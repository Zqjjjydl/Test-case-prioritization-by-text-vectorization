/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static java.lang.annotation.ElementType.FIELD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.CURLY; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.LARRY; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.MOE; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.SHEMP; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Collection; import java.util.Map; import org.junit.Before; import org.junit.Test; /** * @version $Id$ */ public class AnnotationUtilsTest { @TestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, nest = @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object.class, types = { Object.class } ), nests = { @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object[].class, types = { Object[].class } ) }, shortValue = 0, shortValues = { 0 }, stooge = SHEMP, stooges = { MOE, LARRY, CURLY }, string = "", strings = { "" }, type = Object.class, types = { Object.class } ) public Object dummy1; @TestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, nest = @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object.class, types = { Object.class } ), nests = { @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object[].class, types = { Object[].class } ) }, shortValue = 0, shortValues = { 0 }, stooge = SHEMP, stooges = { MOE, LARRY, CURLY }, string = "", strings = { "" }, type = Object.class, types = { Object.class } ) public Object dummy2; @TestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, nest = @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object.class, types = { Object.class } ), nests = { @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object[].class, types = { Object[].class } ), //add a second NestAnnotation to break equality: @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object[].class, types = { Object[].class } ) }, shortValue = 0, shortValues = { 0 }, stooge = SHEMP, stooges = { MOE, LARRY, CURLY }, string = "", strings = { "" }, type = Object.class, types = { Object.class } ) public Object dummy3; @NestAnnotation( booleanValue = false, booleanValues = { false }, byteValue = 0, byteValues = { 0 }, charValue = 0, charValues = { 0 }, doubleValue = 0, doubleValues = { 0 }, floatValue = 0, floatValues = { 0 }, intValue = 0, intValues = { 0 }, longValue = 0, longValues = { 0 }, shortValue = 0, shortValues = { 0 }, stooge = CURLY, stooges = { MOE, LARRY, SHEMP }, string = "", strings = { "" }, type = Object[].class, types = { Object[].class } ) public Object dummy4; @Target(FIELD) @Retention(RUNTIME) public @interface TestAnnotation { String string(); String[] strings(); Class<?> type(); Class<?>[] types(); byte byteValue(); byte[] byteValues(); short shortValue(); short[] shortValues(); int intValue(); int[] intValues(); char charValue(); char[] charValues(); long longValue(); long[] longValues(); float floatValue(); float[] floatValues(); double doubleValue(); double[] doubleValues(); boolean booleanValue(); boolean[] booleanValues(); Stooge stooge(); Stooge[] stooges(); NestAnnotation nest(); NestAnnotation[] nests(); } public @interface NestAnnotation { String string(); String[] strings(); Class<?> type(); Class<?>[] types(); byte byteValue(); byte[] byteValues(); short shortValue(); short[] shortValues(); int intValue(); int[] intValues(); char charValue(); char[] charValues(); long longValue(); long[] longValues(); float floatValue(); float[] floatValues(); double doubleValue(); double[] doubleValues(); boolean booleanValue(); boolean[] booleanValues(); Stooge stooge(); Stooge[] stooges(); } public static enum Stooge { MOE, LARRY, CURLY, JOE, SHEMP; } private Field field1; private Field field2; private Field field3; private Field field4; @Before public void setup() throws Exception { field1 = getClass().getDeclaredField("dummy1"); field2 = getClass().getDeclaredField("dummy2"); field3 = getClass().getDeclaredField("dummy3"); field4 = getClass().getDeclaredField("dummy4"); } @Test public void testEquivalence() { assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class))); assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); } @Test public void testSameInstance() { assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); } @Test public void testNonEquivalentAnnotationsOfSameType() { assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class))); assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); } @Test public void testAnnotationsOfDifferingTypes() { assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field4.getAnnotation(NestAnnotation.class))); assertFalse(AnnotationUtils.equals(field4.getAnnotation(NestAnnotation.class), field1.getAnnotation(TestAnnotation.class))); } @Test public void testOneArgNull() { assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null)); assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class))); } @Test public void testBothArgsNull() { assertTrue(AnnotationUtils.equals(null, null)); } @Test public void testIsValidAnnotationMemberType() { for (final Class<?> type : new Class[] { byte.class, short.class, int.class, char.class, long.class, float.class, double.class, boolean.class, String.class, Class.class, NestAnnotation.class, TestAnnotation.class, Stooge.class, ElementType.class }) { assertTrue(AnnotationUtils.isValidAnnotationMemberType(type)); assertTrue(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0) .getClass())); } for (final Class<?> type : new Class[] { Object.class, Map.class, Collection.class }) { assertFalse(AnnotationUtils.isValidAnnotationMemberType(type)); assertFalse(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0) .getClass())); } } @Test(timeout = 666000) public void testGeneratedAnnotationEquivalentToRealAnnotation() throws Exception { final Test real = getClass().getDeclaredMethod( "testGeneratedAnnotationEquivalentToRealAnnotation").getAnnotation(Test.class); final InvocationHandler generatedTestInvocationHandler = new InvocationHandler() { @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { if ("equals".equals(method.getName()) && method.getParameterTypes().length == 1) { return Boolean.valueOf(proxy == args[0]); } if ("hashCode".equals(method.getName()) && method.getParameterTypes().length == 0) { return Integer.valueOf(System.identityHashCode(proxy)); } if ("toString".equals(method.getName()) && method.getParameterTypes().length == 0) { return "Test proxy"; } return method.invoke(real, args); } }; final Test generated = (Test) Proxy.newProxyInstance(Thread.currentThread() .getContextClassLoader(), new Class[] { Test.class }, generatedTestInvocationHandler); assertTrue(real.equals(generated)); assertFalse(generated.equals(real)); assertTrue(AnnotationUtils.equals(generated, real)); assertTrue(AnnotationUtils.equals(real, generated)); final Test generated2 = (Test) Proxy.newProxyInstance(Thread.currentThread() .getContextClassLoader(), new Class[] { Test.class }, generatedTestInvocationHandler); assertFalse(generated.equals(generated2)); assertFalse(generated2.equals(generated)); assertTrue(AnnotationUtils.equals(generated, generated2)); assertTrue(AnnotationUtils.equals(generated2, generated)); } @Test(timeout = 666000) public void testHashCode() throws Exception { final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class); assertEquals(test.hashCode(), AnnotationUtils.hashCode(test)); final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class); assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1)); final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class); assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3)); } @Test(timeout = 666000) public void testToString() throws Exception { final Test testAnno = getClass().getDeclaredMethod("testToString") .getAnnotation(Test.class); final String toString = AnnotationUtils.toString(testAnno); assertTrue(toString.startsWith("@org.junit.Test(")); assertTrue(toString.endsWith(")")); assertTrue(toString.contains("expected=class org.junit.Test$None")); assertTrue(toString.contains("timeout=666000")); assertTrue(toString.contains(", ")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.util.Arrays; import org.junit.Test; /** * Tests ArrayUtils add methods. * * @version $Id$ */ public class ArrayUtilsAddTest { @Test public void testJira567(){ Number[] n; // Valid array construction n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); assertEquals(2,n.length); assertEquals(Number.class,n.getClass().getComponentType()); try { // Invalid - can't store Long in Integer array n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}); fail("Should have generated IllegalArgumentException"); } catch (final IllegalArgumentException expected) { } } @Test public void testAddObjectArrayBoolean() { boolean[] newArray; newArray = ArrayUtils.add((boolean[])null, false); assertTrue(Arrays.equals(new boolean[]{false}, newArray)); assertEquals(Boolean.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((boolean[])null, true); assertTrue(Arrays.equals(new boolean[]{true}, newArray)); assertEquals(Boolean.TYPE, newArray.getClass().getComponentType()); final boolean[] array1 = new boolean[]{true, false, true}; newArray = ArrayUtils.add(array1, false); assertTrue(Arrays.equals(new boolean[]{true, false, true, false}, newArray)); assertEquals(Boolean.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayByte() { byte[] newArray; newArray = ArrayUtils.add((byte[])null, (byte)0); assertTrue(Arrays.equals(new byte[]{0}, newArray)); assertEquals(Byte.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((byte[])null, (byte)1); assertTrue(Arrays.equals(new byte[]{1}, newArray)); assertEquals(Byte.TYPE, newArray.getClass().getComponentType()); final byte[] array1 = new byte[]{1, 2, 3}; newArray = ArrayUtils.add(array1, (byte)0); assertTrue(Arrays.equals(new byte[]{1, 2, 3, 0}, newArray)); assertEquals(Byte.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, (byte)4); assertTrue(Arrays.equals(new byte[]{1, 2, 3, 4}, newArray)); assertEquals(Byte.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayChar() { char[] newArray; newArray = ArrayUtils.add((char[])null, (char)0); assertTrue(Arrays.equals(new char[]{0}, newArray)); assertEquals(Character.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((char[])null, (char)1); assertTrue(Arrays.equals(new char[]{1}, newArray)); assertEquals(Character.TYPE, newArray.getClass().getComponentType()); final char[] array1 = new char[]{1, 2, 3}; newArray = ArrayUtils.add(array1, (char)0); assertTrue(Arrays.equals(new char[]{1, 2, 3, 0}, newArray)); assertEquals(Character.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, (char)4); assertTrue(Arrays.equals(new char[]{1, 2, 3, 4}, newArray)); assertEquals(Character.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayDouble() { double[] newArray; newArray = ArrayUtils.add((double[])null, 0); assertTrue(Arrays.equals(new double[]{0}, newArray)); assertEquals(Double.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((double[])null, 1); assertTrue(Arrays.equals(new double[]{1}, newArray)); assertEquals(Double.TYPE, newArray.getClass().getComponentType()); final double[] array1 = new double[]{1, 2, 3}; newArray = ArrayUtils.add(array1, 0); assertTrue(Arrays.equals(new double[]{1, 2, 3, 0}, newArray)); assertEquals(Double.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, 4); assertTrue(Arrays.equals(new double[]{1, 2, 3, 4}, newArray)); assertEquals(Double.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayFloat() { float[] newArray; newArray = ArrayUtils.add((float[])null, 0); assertTrue(Arrays.equals(new float[]{0}, newArray)); assertEquals(Float.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((float[])null, 1); assertTrue(Arrays.equals(new float[]{1}, newArray)); assertEquals(Float.TYPE, newArray.getClass().getComponentType()); final float[] array1 = new float[]{1, 2, 3}; newArray = ArrayUtils.add(array1, 0); assertTrue(Arrays.equals(new float[]{1, 2, 3, 0}, newArray)); assertEquals(Float.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, 4); assertTrue(Arrays.equals(new float[]{1, 2, 3, 4}, newArray)); assertEquals(Float.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayInt() { int[] newArray; newArray = ArrayUtils.add((int[])null, 0); assertTrue(Arrays.equals(new int[]{0}, newArray)); assertEquals(Integer.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((int[])null, 1); assertTrue(Arrays.equals(new int[]{1}, newArray)); assertEquals(Integer.TYPE, newArray.getClass().getComponentType()); final int[] array1 = new int[]{1, 2, 3}; newArray = ArrayUtils.add(array1, 0); assertTrue(Arrays.equals(new int[]{1, 2, 3, 0}, newArray)); assertEquals(Integer.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, 4); assertTrue(Arrays.equals(new int[]{1, 2, 3, 4}, newArray)); assertEquals(Integer.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayLong() { long[] newArray; newArray = ArrayUtils.add((long[])null, 0); assertTrue(Arrays.equals(new long[]{0}, newArray)); assertEquals(Long.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((long[])null, 1); assertTrue(Arrays.equals(new long[]{1}, newArray)); assertEquals(Long.TYPE, newArray.getClass().getComponentType()); final long[] array1 = new long[]{1, 2, 3}; newArray = ArrayUtils.add(array1, 0); assertTrue(Arrays.equals(new long[]{1, 2, 3, 0}, newArray)); assertEquals(Long.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, 4); assertTrue(Arrays.equals(new long[]{1, 2, 3, 4}, newArray)); assertEquals(Long.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayShort() { short[] newArray; newArray = ArrayUtils.add((short[])null, (short)0); assertTrue(Arrays.equals(new short[]{0}, newArray)); assertEquals(Short.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add((short[])null, (short)1); assertTrue(Arrays.equals(new short[]{1}, newArray)); assertEquals(Short.TYPE, newArray.getClass().getComponentType()); final short[] array1 = new short[]{1, 2, 3}; newArray = ArrayUtils.add(array1, (short)0); assertTrue(Arrays.equals(new short[]{1, 2, 3, 0}, newArray)); assertEquals(Short.TYPE, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(array1, (short)4); assertTrue(Arrays.equals(new short[]{1, 2, 3, 4}, newArray)); assertEquals(Short.TYPE, newArray.getClass().getComponentType()); } @Test public void testAddObjectArrayObject() { Object[] newArray; //show that not casting is okay newArray = ArrayUtils.add((Object[])null, "a"); assertTrue(Arrays.equals(new String[]{"a"}, newArray)); assertTrue(Arrays.equals(new Object[]{"a"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); //show that not casting to Object[] is okay and will assume String based on "a" final String[] newStringArray = ArrayUtils.add(null, "a"); assertTrue(Arrays.equals(new String[]{"a"}, newStringArray)); assertTrue(Arrays.equals(new Object[]{"a"}, newStringArray)); assertEquals(String.class, newStringArray.getClass().getComponentType()); final String[] stringArray1 = new String[]{"a", "b", "c"}; newArray = ArrayUtils.add(stringArray1, null); assertTrue(Arrays.equals(new String[]{"a", "b", "c", null}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(stringArray1, "d"); assertTrue(Arrays.equals(new String[]{"a", "b", "c", "d"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); Number[] numberArray1 = new Number[]{Integer.valueOf(1), Double.valueOf(2)}; newArray = ArrayUtils.add(numberArray1, Float.valueOf(3)); assertTrue(Arrays.equals(new Number[]{Integer.valueOf(1), Double.valueOf(2), Float.valueOf(3)}, newArray)); assertEquals(Number.class, newArray.getClass().getComponentType()); numberArray1 = null; newArray = ArrayUtils.add(numberArray1, Float.valueOf(3)); assertTrue(Arrays.equals(new Float[]{Float.valueOf(3)}, newArray)); assertEquals(Float.class, newArray.getClass().getComponentType()); } @Test public void testLANG571(){ final String[] stringArray=null; final String aString=null; try { @SuppressWarnings("unused") final String[] sa = ArrayUtils.add(stringArray, aString); fail("Should have caused IllegalArgumentException"); } catch (final IllegalArgumentException iae){ //expected } try { @SuppressWarnings("unused") final String[] sa = ArrayUtils.add(stringArray, 0, aString); fail("Should have caused IllegalArgumentException"); } catch (final IllegalArgumentException iae){ //expected } } @Test public void testAddObjectArrayToObjectArray() { assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null)); Object[] newArray; final String[] stringArray1 = new String[]{"a", "b", "c"}; final String[] stringArray2 = new String[]{"1", "2", "3"}; newArray = ArrayUtils.addAll(stringArray1, (String[]) null); assertNotSame(stringArray1, newArray); assertTrue(Arrays.equals(stringArray1, newArray)); assertTrue(Arrays.equals(new String[]{"a", "b", "c"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.addAll(null, stringArray2); assertNotSame(stringArray2, newArray); assertTrue(Arrays.equals(stringArray2, newArray)); assertTrue(Arrays.equals(new String[]{"1", "2", "3"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.addAll(stringArray1, stringArray2); assertTrue(Arrays.equals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null); assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); assertTrue(Arrays.equals(new String[]{}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY); assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); assertTrue(Arrays.equals(new String[]{}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY); assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray)); assertTrue(Arrays.equals(new String[]{}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); final String[] stringArrayNull = new String []{null}; newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull); assertTrue(Arrays.equals(new String[]{null, null}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); // boolean assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) ); assertTrue( Arrays.equals( new boolean[] { false, true }, ArrayUtils.addAll( null, new boolean[] { false, true } ) ) ); assertTrue( Arrays.equals( new boolean[] { true, false }, ArrayUtils.addAll( new boolean[] { true, false }, null ) ) ); // char assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) ); assertTrue( Arrays.equals( new char[] { 'c', 'd' }, ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) ); assertTrue( Arrays.equals( new char[] { 'a', 'b' }, ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) ); // byte assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) ); assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) ); assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) ); // short assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) ); assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) ); assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) ); // int assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) ); assertTrue( Arrays.equals( new int[] { -1000, -1 }, ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) ); assertTrue( Arrays.equals( new int[] { 1, 1000 }, ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) ); // long assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) ); assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) ); assertTrue( Arrays.equals( new long[] { 1L, -1L }, ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) ); // float assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) ); assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) ); assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) ); // double assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) ); assertTrue( Arrays.equals( new double[] { 0, 9.99 }, ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) ); assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) ); } @Test public void testAddObjectAtIndex() { Object[] newArray; newArray = ArrayUtils.add((Object[])null, 0, "a"); assertTrue(Arrays.equals(new String[]{"a"}, newArray)); assertTrue(Arrays.equals(new Object[]{"a"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); final String[] stringArray1 = new String[]{"a", "b", "c"}; newArray = ArrayUtils.add(stringArray1, 0, null); assertTrue(Arrays.equals(new String[]{null, "a", "b", "c"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(stringArray1, 1, null); assertTrue(Arrays.equals(new String[]{"a", null, "b", "c"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(stringArray1, 3, null); assertTrue(Arrays.equals(new String[]{"a", "b", "c", null}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); newArray = ArrayUtils.add(stringArray1, 3, "d"); assertTrue(Arrays.equals(new String[]{"a", "b", "c", "d"}, newArray)); assertEquals(String.class, newArray.getClass().getComponentType()); assertEquals(String.class, newArray.getClass().getComponentType()); final Object[] o = new Object[] {"1", "2", "4"}; final Object[] result = ArrayUtils.add(o, 2, "3"); final Object[] result2 = ArrayUtils.add(o, 3, "5"); assertNotNull(result); assertEquals(4, result.length); assertEquals("1", result[0]); assertEquals("2", result[1]); assertEquals("3", result[2]); assertEquals("4", result[3]); assertNotNull(result2); assertEquals(4, result2.length); assertEquals("1", result2[0]); assertEquals("2", result2[1]); assertEquals("4", result2[2]); assertEquals("5", result2[3]); // boolean tests boolean[] booleanArray = ArrayUtils.add( null, 0, true ); assertTrue( Arrays.equals( new boolean[] { true }, booleanArray ) ); try { booleanArray = ArrayUtils.add( null, -1, true ); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false); assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) ); booleanArray = ArrayUtils.add( new boolean[] { false }, 1, true); assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) ); booleanArray = ArrayUtils.add( new boolean[] { true, false }, 1, true); assertTrue( Arrays.equals( new boolean[] { true, true, false }, booleanArray ) ); try { booleanArray = ArrayUtils.add( new boolean[] { true, false }, 4, true); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { booleanArray = ArrayUtils.add( new boolean[] { true, false }, -1, true); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // char tests char[] charArray = ArrayUtils.add( (char[]) null, 0, 'a' ); assertTrue( Arrays.equals( new char[] { 'a' }, charArray ) ); try { charArray = ArrayUtils.add( (char[]) null, -1, 'a' ); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b'); assertTrue( Arrays.equals( new char[] { 'b', 'a' }, charArray ) ); charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 0, 'c'); assertTrue( Arrays.equals( new char[] { 'c', 'a', 'b' }, charArray ) ); charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 1, 'k'); assertTrue( Arrays.equals( new char[] { 'a', 'k', 'b' }, charArray ) ); charArray = ArrayUtils.add( new char[] { 'a', 'b', 'c' }, 1, 't'); assertTrue( Arrays.equals( new char[] { 'a', 't', 'b', 'c' }, charArray ) ); try { charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c'); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { charArray = ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c'); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // short tests short[] shortArray = ArrayUtils.add( new short[] { 1 }, 0, (short) 2); assertTrue( Arrays.equals( new short[] { 2, 1 }, shortArray ) ); try { shortArray = ArrayUtils.add( (short[]) null, -1, (short) 2); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10); assertTrue( Arrays.equals( new short[] { 2, 6, 10 }, shortArray ) ); shortArray = ArrayUtils.add( new short[] { 2, 6 }, 0, (short) -4); assertTrue( Arrays.equals( new short[] { -4, 2, 6 }, shortArray ) ); shortArray = ArrayUtils.add( new short[] { 2, 6, 3 }, 2, (short) 1); assertTrue( Arrays.equals( new short[] { 2, 6, 1, 3 }, shortArray ) ); try { shortArray = ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { shortArray = ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // byte tests byte[] byteArray = ArrayUtils.add( new byte[] { 1 }, 0, (byte) 2); assertTrue( Arrays.equals( new byte[] { 2, 1 }, byteArray ) ); try { byteArray = ArrayUtils.add( (byte[]) null, -1, (byte) 2); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3); assertTrue( Arrays.equals( new byte[] { 2, 6, 3 }, byteArray ) ); byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 0, (byte) 1); assertTrue( Arrays.equals( new byte[] { 1, 2, 6 }, byteArray ) ); byteArray = ArrayUtils.add( new byte[] { 2, 6, 3 }, 2, (byte) 1); assertTrue( Arrays.equals( new byte[] { 2, 6, 1, 3 }, byteArray ) ); try { byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { byteArray = ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // int tests int[] intArray = ArrayUtils.add( new int[] { 1 }, 0, 2); assertTrue( Arrays.equals( new int[] { 2, 1 }, intArray ) ); try { intArray = ArrayUtils.add( (int[]) null, -1, 2); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10); assertTrue( Arrays.equals( new int[] { 2, 6, 10 }, intArray ) ); intArray = ArrayUtils.add( new int[] { 2, 6 }, 0, -4); assertTrue( Arrays.equals( new int[] { -4, 2, 6 }, intArray ) ); intArray = ArrayUtils.add( new int[] { 2, 6, 3 }, 2, 1); assertTrue( Arrays.equals( new int[] { 2, 6, 1, 3 }, intArray ) ); try { intArray = ArrayUtils.add( new int[] { 2, 6 }, 4, 10); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { intArray = ArrayUtils.add( new int[] { 2, 6 }, -1, 10); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // long tests long[] longArray = ArrayUtils.add( new long[] { 1L }, 0, 2L); assertTrue( Arrays.equals( new long[] { 2L, 1L }, longArray ) ); try { longArray = ArrayUtils.add( (long[]) null, -1, 2L); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L); assertTrue( Arrays.equals( new long[] { 2L, 6L, 10L }, longArray ) ); longArray = ArrayUtils.add( new long[] { 2L, 6L }, 0, -4L); assertTrue( Arrays.equals( new long[] { -4L, 2L, 6L }, longArray ) ); longArray = ArrayUtils.add( new long[] { 2L, 6L, 3L }, 2, 1L); assertTrue( Arrays.equals( new long[] { 2L, 6L, 1L, 3L }, longArray ) ); try { longArray = ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { longArray = ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // float tests float[] floatArray = ArrayUtils.add( new float[] { 1.1f }, 0, 2.2f); assertTrue( Arrays.equals( new float[] { 2.2f, 1.1f }, floatArray ) ); try { floatArray = ArrayUtils.add( (float[]) null, -1, 2.2f); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f); assertTrue( Arrays.equals( new float[] { 2.3f, 6.4f, 10.5f }, floatArray ) ); floatArray = ArrayUtils.add( new float[] { 2.6f, 6.7f }, 0, -4.8f); assertTrue( Arrays.equals( new float[] { -4.8f, 2.6f, 6.7f }, floatArray ) ); floatArray = ArrayUtils.add( new float[] { 2.9f, 6.0f, 0.3f }, 2, 1.0f); assertTrue( Arrays.equals( new float[] { 2.9f, 6.0f, 1.0f, 0.3f }, floatArray ) ); try { floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } // double tests double[] doubleArray = ArrayUtils.add( new double[] { 1.1 }, 0, 2.2); assertTrue( Arrays.equals( new double[] { 2.2, 1.1 }, doubleArray ) ); try { doubleArray = ArrayUtils.add( (double[]) null, -1, 2.2); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 0", e.getMessage()); } doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5); assertTrue( Arrays.equals( new double[] { 2.3, 6.4, 10.5 }, doubleArray ) ); doubleArray = ArrayUtils.add( new double[] { 2.6, 6.7 }, 0, -4.8); assertTrue( Arrays.equals( new double[] { -4.8, 2.6, 6.7 }, doubleArray ) ); doubleArray = ArrayUtils.add( new double[] { 2.9, 6.0, 0.3 }, 2, 1.0); assertTrue( Arrays.equals( new double[] { 2.9, 6.0, 1.0, 0.3 }, doubleArray ) ); try { doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: 4, Length: 2", e.getMessage()); } try { doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5); } catch(final IndexOutOfBoundsException e) { assertEquals("Index: -1, Length: 2", e.getMessage()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Arrays; import org.junit.Test; /** * Tests ArrayUtils remove and removeElement methods. * * @version $Id$ */ public class ArrayUtilsRemoveMultipleTest { @Test public void testRemoveAllObjectArray() { Object[] array; array = ArrayUtils.removeAll(new Object[] { "a" }, 0); assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b" }, 0, 1); assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c" }, 1, 2); assertArrayEquals(new Object[] { "a" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 1, 2); assertArrayEquals(new Object[] { "a", "d" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 0, 3); assertArrayEquals(new Object[] { "b", "c" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 0, 1, 3); assertArrayEquals(new Object[] { "c" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d", "e" }, 0, 1, 3); assertArrayEquals(new Object[] { "c", "e" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d", "e" }, 0, 2, 4); assertArrayEquals(new Object[] { "b", "d" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 0, 1, 3, 0, 1, 3); assertArrayEquals(new Object[] { "c" }, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 2, 1, 0, 3); assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 2, 0, 1, 3, 0, 2, 1, 3); assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array); assertEquals(Object.class, array.getClass().getComponentType()); } @Test public void testRemoveAllObjectArrayRemoveNone() { final Object[] array1 = new Object[] { "foo", "bar", "baz" }; final Object[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertArrayEquals(array1, array2); assertEquals(Object.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllObjectArrayNegativeIndex() { ArrayUtils.removeAll(new Object[] { "a", "b" }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllObjectArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new Object[] { "a", "b" }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullObjectArray() { ArrayUtils.remove((Object[]) null, 0); } @Test public void testRemoveAllNumberArray() { final Number[] inarray = { Integer.valueOf(1), Long.valueOf(2L), Byte.valueOf((byte) 3) }; assertEquals(3, inarray.length); Number[] outarray; outarray = ArrayUtils.removeAll(inarray, 1); assertArrayEquals(new Number[] { Integer.valueOf(1), Byte.valueOf((byte) 3) }, outarray); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.removeAll(outarray, 1); assertArrayEquals(new Number[] { Integer.valueOf(1) }, outarray); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.removeAll(outarray, 0); assertEquals(0, outarray.length); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.removeAll(inarray, 0, 1); assertArrayEquals(new Number[] { Byte.valueOf((byte) 3) }, outarray); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.removeAll(inarray, 0, 2); assertArrayEquals(new Number[] { Long.valueOf(2L) }, outarray); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.removeAll(inarray, 1, 2); assertArrayEquals(new Number[] { Integer.valueOf(1) }, outarray); assertEquals(Number.class, outarray.getClass().getComponentType()); } @Test public void testRemoveAllBooleanArray() { boolean[] array; array = ArrayUtils.removeAll(new boolean[] { true }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false }, 0); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false }, 1); assertTrue(Arrays.equals(new boolean[] { true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true }, 1); assertTrue(Arrays.equals(new boolean[] { true, true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 0, 1); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 0, 2); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 1, 2); assertTrue(Arrays.equals(new boolean[] { true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 0, 2, 4); assertTrue(Arrays.equals(new boolean[] { false, false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 1, 3); assertTrue(Arrays.equals(new boolean[] { true, true, true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 1, 3, 4); assertTrue(Arrays.equals(new boolean[] { true, true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 0, 2, 4, 6); assertTrue(Arrays.equals(new boolean[] { false, false, false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 1, 3, 5); assertTrue(Arrays.equals(new boolean[] { true, true, true, true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 0, 1, 2); assertTrue(Arrays.equals(new boolean[] { false, true, false, true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllBooleanArrayRemoveNone() { final boolean[] array1 = new boolean[] { true, false }; final boolean[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertTrue(Arrays.equals(array1, array2)); assertEquals(boolean.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllBooleanArrayNegativeIndex() { ArrayUtils.removeAll(new boolean[] { true, false }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllBooleanArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new boolean[] { true, false }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullBooleanArray() { ArrayUtils.removeAll((boolean[]) null, 0); } @Test public void testRemoveAllByteArray() { byte[] array; array = ArrayUtils.removeAll(new byte[] { 1 }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 0); assertTrue(Arrays.equals(new byte[] { 2 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 1); assertTrue(Arrays.equals(new byte[] { 1 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new byte[] { 1, 1 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 0, 1); assertTrue(Arrays.equals(new byte[] { 3 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 1, 2); assertTrue(Arrays.equals(new byte[] { 1 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 0, 2); assertTrue(Arrays.equals(new byte[] { 2 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5 }, 1, 3); assertTrue(Arrays.equals(new byte[] { 1, 3, 5 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5 }, 0, 2, 4); assertTrue(Arrays.equals(new byte[] { 2, 4 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); assertTrue(Arrays.equals(new byte[] { 1, 3, 5, 7 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); assertTrue(Arrays.equals(new byte[] { 2, 4, 6 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllByteArrayRemoveNone() { final byte[] array1 = new byte[] { 1, 2 }; final byte[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertArrayEquals(array1, array2); assertEquals(byte.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllByteArrayNegativeIndex() { ArrayUtils.removeAll(new byte[] { 1, 2 }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllByteArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new byte[] { 1, 2 }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullByteArray() { ArrayUtils.removeAll((byte[]) null, 0); } @Test public void testRemoveAllCharArray() { char[] array; array = ArrayUtils.removeAll(new char[] { 'a' }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 0); assertTrue(Arrays.equals(new char[] { 'b' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 1); assertTrue(Arrays.equals(new char[] { 'a' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 1); assertTrue(Arrays.equals(new char[] { 'a', 'c' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 0, 1); assertTrue(Arrays.equals(new char[] { 'c' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 1, 2); assertTrue(Arrays.equals(new char[] { 'a' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 0, 2); assertTrue(Arrays.equals(new char[] { 'b' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e' }, 1, 3); assertTrue(Arrays.equals(new char[] { 'a', 'c', 'e' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e' }, 0, 2, 4); assertTrue(Arrays.equals(new char[] { 'b', 'd' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g' }, 1, 3, 5); assertTrue(Arrays.equals(new char[] { 'a', 'c', 'e', 'g' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g' }, 0, 2, 4, 6); assertTrue(Arrays.equals(new char[] { 'b', 'd', 'f' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllCharArrayRemoveNone() { final char[] array1 = new char[] { 'a', 'b' }; final char[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertArrayEquals(array1, array2); assertEquals(char.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllCharArrayNegativeIndex() { ArrayUtils.removeAll(new char[] { 'a', 'b' }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllCharArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new char[] { 'a', 'b' }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullCharArray() { ArrayUtils.removeAll((char[]) null, 0); } @Test public void testRemoveAllDoubleArray() { double[] array; array = ArrayUtils.removeAll(new double[] { 1 }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0); assertTrue(Arrays.equals(new double[] { 2 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2 }, 1); assertTrue(Arrays.equals(new double[] { 1 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new double[] { 1, 1 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 1); assertTrue(Arrays.equals(new double[] { 3 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 1, 2); assertTrue(Arrays.equals(new double[] { 1 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 2); assertTrue(Arrays.equals(new double[] { 2 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 1, 3); assertTrue(Arrays.equals(new double[] { 1, 3, 5 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 0, 2, 4); assertTrue(Arrays.equals(new double[] { 2, 4 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); assertTrue(Arrays.equals(new double[] { 1, 3, 5, 7 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); assertTrue(Arrays.equals(new double[] { 2, 4, 6 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllDoubleArrayRemoveNone() { final double[] array1 = new double[] { 1, 2 }; final double[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertTrue(Arrays.equals(array1, array2)); assertEquals(double.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllDoubleArrayNegativeIndex() { ArrayUtils.removeAll(new double[] { 1, 2 }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllDoubleArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new double[] { 1, 2 }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullDoubleArray() { ArrayUtils.removeAll((double[]) null, 0); } @Test public void testRemoveAllFloatArray() { float[] array; array = ArrayUtils.removeAll(new float[] { 1 }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2 }, 0); assertTrue(Arrays.equals(new float[] { 2 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2 }, 1); assertTrue(Arrays.equals(new float[] { 1 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new float[] { 1, 1 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2 }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 0, 1); assertTrue(Arrays.equals(new float[] { 3 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 1, 2); assertTrue(Arrays.equals(new float[] { 1 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 0, 2); assertTrue(Arrays.equals(new float[] { 2 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5 }, 1, 3); assertTrue(Arrays.equals(new float[] { 1, 3, 5 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5 }, 0, 2, 4); assertTrue(Arrays.equals(new float[] { 2, 4 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); assertTrue(Arrays.equals(new float[] { 1, 3, 5, 7 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); assertTrue(Arrays.equals(new float[] { 2, 4, 6 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllFloatArrayRemoveNone() { final float[] array1 = new float[] { 1, 2 }; final float[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertTrue(Arrays.equals(array1, array2)); assertEquals(float.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllFloatArrayNegativeIndex() { ArrayUtils.removeAll(new float[] { 1, 2 }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllFloatArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new float[] { 1, 2 }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullFloatArray() { ArrayUtils.removeAll((float[]) null, 0); } @Test public void testRemoveAllIntArray() { int[] array; array = ArrayUtils.removeAll(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.EMPTY_INT_ARRAY); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); array = ArrayUtils.removeAll(new int[] { 1 }, ArrayUtils.EMPTY_INT_ARRAY); assertTrue(Arrays.equals(new int[] { 1 }, array)); array = ArrayUtils.removeAll(new int[] { 1 }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2 }, 0); assertTrue(Arrays.equals(new int[] { 2 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2 }, 1); assertTrue(Arrays.equals(new int[] { 1 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new int[] { 1, 1 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2 }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 0, 1); assertTrue(Arrays.equals(new int[] { 3 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 1, 2); assertTrue(Arrays.equals(new int[] { 1 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 0, 2); assertTrue(Arrays.equals(new int[] { 2 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5 }, 1, 3); assertTrue(Arrays.equals(new int[] { 1, 3, 5 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5 }, 0, 2, 4); assertTrue(Arrays.equals(new int[] { 2, 4 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); assertTrue(Arrays.equals(new int[] { 1, 3, 5, 7 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); assertTrue(Arrays.equals(new int[] { 2, 4, 6 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllIntArrayRemoveNone() { final int[] array1 = new int[] { 1, 2 }; final int[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertArrayEquals(array1, array2); assertEquals(int.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllIntArrayNegativeIndex() { ArrayUtils.removeAll(new int[] { 1, 2 }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllIntArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new int[] { 1, 2 }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullIntArray() { ArrayUtils.removeAll((int[]) null, 0); } @Test public void testRemoveAllLongArray() { long[] array; array = ArrayUtils.removeAll(new long[] { 1 }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2 }, 0); assertTrue(Arrays.equals(new long[] { 2 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1); assertTrue(Arrays.equals(new long[] { 1 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new long[] { 1, 1 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2 }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 0, 1); assertTrue(Arrays.equals(new long[] { 3 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1, 2); assertTrue(Arrays.equals(new long[] { 1 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 0, 2); assertTrue(Arrays.equals(new long[] { 2 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5 }, 1, 3); assertTrue(Arrays.equals(new long[] { 1, 3, 5 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5 }, 0, 2, 4); assertTrue(Arrays.equals(new long[] { 2, 4 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); assertTrue(Arrays.equals(new long[] { 1, 3, 5, 7 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); assertTrue(Arrays.equals(new long[] { 2, 4, 6 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllLongArrayRemoveNone() { final long[] array1 = new long[] { 1, 2 }; final long[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertArrayEquals(array1, array2); assertEquals(long.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllLongArrayNegativeIndex() { ArrayUtils.removeAll(new long[] { 1, 2 }, -1); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllLongArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new long[] { 1, 2 }, 2); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullLongArray() { ArrayUtils.removeAll((long[]) null, 0); } @Test public void testRemoveAllShortArray() { short[] array; array = ArrayUtils.removeAll(new short[] { 1 }, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2 }, 0); assertTrue(Arrays.equals(new short[] { 2 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2 }, 1); assertTrue(Arrays.equals(new short[] { 1 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new short[] { 1, 1 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2 }, 0, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 0, 1); assertTrue(Arrays.equals(new short[] { 3 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 1, 2); assertTrue(Arrays.equals(new short[] { 1 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 0, 2); assertTrue(Arrays.equals(new short[] { 2 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5 }, 1, 3); assertTrue(Arrays.equals(new short[] { 1, 3, 5 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5 }, 0, 2, 4); assertTrue(Arrays.equals(new short[] { 2, 4 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5); assertTrue(Arrays.equals(new short[] { 1, 3, 5, 7 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6); assertTrue(Arrays.equals(new short[] { 2, 4, 6 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveAllShortArrayRemoveNone() { final short[] array1 = new short[] { 1, 2 }; final short[] array2 = ArrayUtils.removeAll(array1); assertNotSame(array1, array2); assertArrayEquals(array1, array2); assertEquals(short.class, array2.getClass().getComponentType()); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllShortArrayNegativeIndex() { ArrayUtils.removeAll(new short[] { 1, 2 }, -1, 0); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllShortArrayOutOfBoundsIndex() { ArrayUtils.removeAll(new short[] { 1, 2 }, 2, 0); } @Test(expected = IndexOutOfBoundsException.class) public void testRemoveAllNullShortArray() { ArrayUtils.removeAll((short[]) null, 0); } @Test public void testRemoveElementsObjectArray() { Object[] array; array = ArrayUtils.removeElements((Object[]) null, "a"); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a" }, "a"); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a"); assertTrue(Arrays.equals(new Object[] { "b" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements((Object[]) null, "a", "b"); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b"); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b"); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c"); assertTrue(Arrays.equals(new Object[] { "b" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a"); assertTrue(Arrays.equals(new Object[] { "b", "a" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b"); assertTrue(Arrays.equals(new Object[] { "a" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a"); assertTrue(Arrays.equals(new Object[] { "b" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a"); assertTrue(Arrays.equals(new Object[] { "b" }, array)); assertEquals(Object.class, array.getClass().getComponentType()); } @Test public void testRemoveElementBooleanArray() { boolean[] array; array = ArrayUtils.removeElements((boolean[]) null, true); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true }, true); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false }, true); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true); assertTrue(Arrays.equals(new boolean[] { false, true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((boolean[]) null, true, false); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true, false); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true }, true, false); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false }, true, false); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false }, true, true); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, false); assertTrue(Arrays.equals(new boolean[] { true }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true, true, true); assertTrue(Arrays.equals(new boolean[] { false }, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementByteArray() { byte[] array; array = ArrayUtils.removeElements((byte[]) null, (byte) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1); assertTrue(Arrays.equals(new byte[] { 2 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1); assertTrue(Arrays.equals(new byte[] { 2, 1 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1); assertTrue(Arrays.equals(new byte[] { 2 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2); assertTrue(Arrays.equals(new byte[] { 1 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1); assertTrue(Arrays.equals(new byte[] { 2 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1); assertTrue(Arrays.equals(new byte[] { 2 }, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementCharArray() { char[] array; array = ArrayUtils.removeElements((char[]) null, 'a'); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a' }, 'a'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a'); assertTrue(Arrays.equals(new char[] { 'b' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a'); assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((char[]) null, 'a', 'b'); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a' }, 'a', 'b'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'a'); assertTrue(Arrays.equals(new char[] { 'b' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'b'); assertTrue(Arrays.equals(new char[] { 'a' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a'); assertTrue(Arrays.equals(new char[] { 'b' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a', 'a', 'a'); assertTrue(Arrays.equals(new char[] { 'b' }, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); } @Test @SuppressWarnings("cast") public void testRemoveElementDoubleArray() { double[] array; array = ArrayUtils.removeElements((double[]) null, (double) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1); assertTrue(Arrays.equals(new double[] { 2 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1); assertTrue(Arrays.equals(new double[] { 2, 1 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((double[]) null, (double) 1, (double) 2); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1, (double) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1, (double) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 1); assertTrue(Arrays.equals(new double[] { 2 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 2); assertTrue(Arrays.equals(new double[] { 1 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1); assertTrue(Arrays.equals(new double[] { 2 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1, (double) 1, (double) 1); assertTrue(Arrays.equals(new double[] { 2 }, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); } @Test @SuppressWarnings("cast") public void testRemoveElementFloatArray() { float[] array; array = ArrayUtils.removeElements((float[]) null, (float) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1); assertTrue(Arrays.equals(new float[] { 2 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1); assertTrue(Arrays.equals(new float[] { 2, 1 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 1); assertTrue(Arrays.equals(new float[] { 2 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1); assertTrue(Arrays.equals(new float[] { 2 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 2); assertTrue(Arrays.equals(new float[] { 1 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1, (float) 1, (float) 1); assertTrue(Arrays.equals(new float[] { 2 }, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementIntArray() { int[] array; array = ArrayUtils.removeElements((int[]) null, 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1 }, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1); assertTrue(Arrays.equals(new int[] { 2 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1); assertTrue(Arrays.equals(new int[] { 2, 1 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((int[]) null, 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1 }, 1, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 1); assertTrue(Arrays.equals(new int[] { 2 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 2); assertTrue(Arrays.equals(new int[] { 1 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1); assertTrue(Arrays.equals(new int[] { 2 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1, 1, 1); assertTrue(Arrays.equals(new int[] { 2 }, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); } @Test @SuppressWarnings("cast") public void testRemoveElementLongArray() { long[] array; array = ArrayUtils.removeElements((long[]) null, (long) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1); assertTrue(Arrays.equals(new long[] { 2 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1); assertTrue(Arrays.equals(new long[] { 2, 1 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((long[]) null, (long) 1, (long) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1, (long) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1, (long) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 1); assertTrue(Arrays.equals(new long[] { 2 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 1); assertTrue(Arrays.equals(new long[] { 2 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 2); assertTrue(Arrays.equals(new long[] { 1 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 1, (long) 1, (long) 1); assertTrue(Arrays.equals(new long[] { 2 }, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementShortArray() { short[] array; array = ArrayUtils.removeElements((short[]) null, (short) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1); assertTrue(Arrays.equals(new short[] { 2 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1); assertTrue(Arrays.equals(new short[] { 2, 1 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1); assertNull(array); array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 2); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 1); assertTrue(Arrays.equals(new short[] { 2 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1); assertTrue(Arrays.equals(new short[] { 2 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 2); assertTrue(Arrays.equals(new short[] { 1 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1, (short) 1, (short) 1); assertTrue(Arrays.equals(new short[] { 2 }, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.util.Arrays; import org.junit.Test; /** * Tests ArrayUtils remove and removeElement methods. * * @version $Id$ */ public class ArrayUtilsRemoveTest { @Test public void testRemoveObjectArray() { Object[] array; array = ArrayUtils.remove(new Object[] {"a"}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.remove(new Object[] {"a", "b"}, 0); assertTrue(Arrays.equals(new Object[] {"b"}, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.remove(new Object[] {"a", "b"}, 1); assertTrue(Arrays.equals(new Object[] {"a"}, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.remove(new Object[] {"a", "b", "c"}, 1); assertTrue(Arrays.equals(new Object[] {"a", "c"}, array)); assertEquals(Object.class, array.getClass().getComponentType()); try { ArrayUtils.remove(new Object[] {"a", "b"}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new Object[] {"a", "b"}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((Object[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveNumberArray(){ final Number[] inarray = {Integer.valueOf(1),Long.valueOf(2),Byte.valueOf((byte) 3)}; assertEquals(3, inarray.length); Number[] outarray; outarray = ArrayUtils.remove(inarray, 1); assertEquals(2, outarray.length); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.remove(outarray, 1); assertEquals(1, outarray.length); assertEquals(Number.class, outarray.getClass().getComponentType()); outarray = ArrayUtils.remove(outarray, 0); assertEquals(0, outarray.length); assertEquals(Number.class, outarray.getClass().getComponentType()); } @Test public void testRemoveBooleanArray() { boolean[] array; array = ArrayUtils.remove(new boolean[] {true}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new boolean[] {true, false}, 0); assertTrue(Arrays.equals(new boolean[] {false}, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new boolean[] {true, false}, 1); assertTrue(Arrays.equals(new boolean[] {true}, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new boolean[] {true, false, true}, 1); assertTrue(Arrays.equals(new boolean[] {true, true}, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new boolean[] {true, false}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new boolean[] {true, false}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((boolean[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveByteArray() { byte[] array; array = ArrayUtils.remove(new byte[] {1}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new byte[] {1, 2}, 0); assertTrue(Arrays.equals(new byte[] {2}, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new byte[] {1, 2}, 1); assertTrue(Arrays.equals(new byte[] {1}, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new byte[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new byte[] {1, 1}, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new byte[] {1, 2}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new byte[] {1, 2}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((byte[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveCharArray() { char[] array; array = ArrayUtils.remove(new char[] {'a'}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new char[] {'a', 'b'}, 0); assertTrue(Arrays.equals(new char[] {'b'}, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new char[] {'a', 'b'}, 1); assertTrue(Arrays.equals(new char[] {'a'}, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new char[] {'a', 'b', 'c'}, 1); assertTrue(Arrays.equals(new char[] {'a', 'c'}, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new char[] {'a', 'b'}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new char[] {'a', 'b'}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((char[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveDoubleArray() { double[] array; array = ArrayUtils.remove(new double[] {1}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new double[] {1, 2}, 0); assertTrue(Arrays.equals(new double[] {2}, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new double[] {1, 2}, 1); assertTrue(Arrays.equals(new double[] {1}, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new double[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new double[] {1, 1}, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new double[] {1, 2}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new double[] {1, 2}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((double[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveFloatArray() { float[] array; array = ArrayUtils.remove(new float[] {1}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new float[] {1, 2}, 0); assertTrue(Arrays.equals(new float[] {2}, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new float[] {1, 2}, 1); assertTrue(Arrays.equals(new float[] {1}, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new float[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new float[] {1, 1}, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new float[] {1, 2}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new float[] {1, 2}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((float[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveIntArray() { int[] array; array = ArrayUtils.remove(new int[] {1}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new int[] {1, 2}, 0); assertTrue(Arrays.equals(new int[] {2}, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new int[] {1, 2}, 1); assertTrue(Arrays.equals(new int[] {1}, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new int[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new int[] {1, 1}, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new int[] {1, 2}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new int[] {1, 2}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((int[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveLongArray() { long[] array; array = ArrayUtils.remove(new long[] {1}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new long[] {1, 2}, 0); assertTrue(Arrays.equals(new long[] {2}, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new long[] {1, 2}, 1); assertTrue(Arrays.equals(new long[] {1}, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new long[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new long[] {1, 1}, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new long[] {1, 2}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new long[] {1, 2}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((long[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveShortArray() { short[] array; array = ArrayUtils.remove(new short[] {1}, 0); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new short[] {1, 2}, 0); assertTrue(Arrays.equals(new short[] {2}, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new short[] {1, 2}, 1); assertTrue(Arrays.equals(new short[] {1}, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.remove(new short[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new short[] {1, 1}, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); try { ArrayUtils.remove(new short[] {1, 2}, -1); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove(new short[] {1, 2}, 2); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} try { ArrayUtils.remove((short[]) null, 0); fail("IndexOutOfBoundsException expected"); } catch (final IndexOutOfBoundsException e) {} } @Test public void testRemoveElementObjectArray() { Object[] array; array = ArrayUtils.removeElement((Object[]) null, "a"); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, "a"); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new Object[] {"a"}, "a"); assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new Object[] {"a", "b"}, "a"); assertTrue(Arrays.equals(new Object[] {"b"}, array)); assertEquals(Object.class, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new Object[] {"a", "b", "a"}, "a"); assertTrue(Arrays.equals(new Object[] {"b", "a"}, array)); assertEquals(Object.class, array.getClass().getComponentType()); } @Test public void testRemoveElementBooleanArray() { boolean[] array; array = ArrayUtils.removeElement((boolean[]) null, true); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new boolean[] {true}, true); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new boolean[] {true, false}, true); assertTrue(Arrays.equals(new boolean[] {false}, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true); assertTrue(Arrays.equals(new boolean[] {false, true}, array)); assertEquals(Boolean.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementByteArray() { byte[] array; array = ArrayUtils.removeElement((byte[]) null, (byte) 1); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1); assertTrue(Arrays.equals(new byte[] {2}, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1); assertTrue(Arrays.equals(new byte[] {2, 1}, array)); assertEquals(Byte.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementCharArray() { char[] array; array = ArrayUtils.removeElement((char[]) null, 'a'); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_CHAR_ARRAY, 'a'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new char[] {'a'}, 'a'); assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new char[] {'a', 'b'}, 'a'); assertTrue(Arrays.equals(new char[] {'b'}, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new char[] {'a', 'b', 'a'}, 'a'); assertTrue(Arrays.equals(new char[] {'b', 'a'}, array)); assertEquals(Character.TYPE, array.getClass().getComponentType()); } @Test @SuppressWarnings("cast") public void testRemoveElementDoubleArray() { double[] array; array = ArrayUtils.removeElement((double[]) null, (double) 1); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new double[] {1}, (double) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new double[] {1, 2}, (double) 1); assertTrue(Arrays.equals(new double[] {2}, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new double[] {1, 2, 1}, (double) 1); assertTrue(Arrays.equals(new double[] {2, 1}, array)); assertEquals(Double.TYPE, array.getClass().getComponentType()); } @Test @SuppressWarnings("cast") public void testRemoveElementFloatArray() { float[] array; array = ArrayUtils.removeElement((float[]) null, (float) 1); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new float[] {1}, (float) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new float[] {1, 2}, (float) 1); assertTrue(Arrays.equals(new float[] {2}, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new float[] {1, 2, 1}, (float) 1); assertTrue(Arrays.equals(new float[] {2, 1}, array)); assertEquals(Float.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementIntArray() { int[] array; array = ArrayUtils.removeElement((int[]) null, 1); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new int[] {1}, 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new int[] {1, 2}, 1); assertTrue(Arrays.equals(new int[] {2}, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1); assertTrue(Arrays.equals(new int[] {2, 1}, array)); assertEquals(Integer.TYPE, array.getClass().getComponentType()); } @Test @SuppressWarnings("cast") public void testRemoveElementLongArray() { long[] array; array = ArrayUtils.removeElement((long[]) null, (long) 1); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new long[] {1}, (long) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new long[] {1, 2}, (long) 1); assertTrue(Arrays.equals(new long[] {2}, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new long[] {1, 2, 1}, (long) 1); assertTrue(Arrays.equals(new long[] {2, 1}, array)); assertEquals(Long.TYPE, array.getClass().getComponentType()); } @Test public void testRemoveElementShortArray() { short[] array; array = ArrayUtils.removeElement((short[]) null, (short) 1); assertNull(array); array = ArrayUtils.removeElement(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new short[] {1}, (short) 1); assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new short[] {1, 2}, (short) 1); assertTrue(Arrays.equals(new short[] {2}, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); array = ArrayUtils.removeElement(new short[] {1, 2, 1}, (short) 1); assertTrue(Arrays.equals(new short[] {2, 1}, array)); assertEquals(Short.TYPE, array.getClass().getComponentType()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Date; import java.util.Map; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.ArrayUtils}. * * @version $Id$ */ public class ArrayUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new ArrayUtils()); final Constructor<?>[] cons = ArrayUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(ArrayUtils.class.getModifiers())); assertFalse(Modifier.isFinal(ArrayUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testToString() { assertEquals("{}", ArrayUtils.toString(null)); assertEquals("{}", ArrayUtils.toString(new Object[0])); assertEquals("{}", ArrayUtils.toString(new String[0])); assertEquals("{<null>}", ArrayUtils.toString(new String[] {null})); assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"})); assertEquals("<empty>", ArrayUtils.toString(null, "<empty>")); assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>")); assertEquals("{}", ArrayUtils.toString(new String[0], "<empty>")); assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>")); assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>")); } //----------------------------------------------------------------------- @Test public void testHashCode() { final long[][] array1 = new long[][] {{2,5}, {4,5}}; final long[][] array2 = new long[][] {{2,5}, {4,6}}; assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1)); assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2)); final Object[] array3 = new Object[] {new String(new char[] {'A', 'B'})}; final Object[] array4 = new Object[] {"AB"}; assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3)); assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array4)); final Object[] arrayA = new Object[] {new boolean[] {true, false}, new int[] {6, 7}}; final Object[] arrayB = new Object[] {new boolean[] {true, false}, new int[] {6, 7}}; assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA)); } //----------------------------------------------------------------------- private void assertIsEquals(final Object array1, final Object array2, final Object array3) { assertTrue(ArrayUtils.isEquals(array1, array1)); assertTrue(ArrayUtils.isEquals(array2, array2)); assertTrue(ArrayUtils.isEquals(array3, array3)); assertFalse(ArrayUtils.isEquals(array1, array2)); assertFalse(ArrayUtils.isEquals(array2, array1)); assertFalse(ArrayUtils.isEquals(array1, array3)); assertFalse(ArrayUtils.isEquals(array3, array1)); assertFalse(ArrayUtils.isEquals(array1, array2)); assertFalse(ArrayUtils.isEquals(array2, array1)); } @Test public void testIsEquals() { final long[][] larray1 = new long[][]{{2, 5}, {4, 5}}; final long[][] larray2 = new long[][]{{2, 5}, {4, 6}}; final long[] larray3 = new long[]{2, 5}; this.assertIsEquals(larray1, larray2, larray3); final int[][] iarray1 = new int[][]{{2, 5}, {4, 5}}; final int[][] iarray2 = new int[][]{{2, 5}, {4, 6}}; final int[] iarray3 = new int[]{2, 5}; this.assertIsEquals(iarray1, iarray2, iarray3); final short[][] sarray1 = new short[][]{{2, 5}, {4, 5}}; final short[][] sarray2 = new short[][]{{2, 5}, {4, 6}}; final short[] sarray3 = new short[]{2, 5}; this.assertIsEquals(sarray1, sarray2, sarray3); final float[][] farray1 = new float[][]{{2, 5}, {4, 5}}; final float[][] farray2 = new float[][]{{2, 5}, {4, 6}}; final float[] farray3 = new float[]{2, 5}; this.assertIsEquals(farray1, farray2, farray3); final double[][] darray1 = new double[][]{{2, 5}, {4, 5}}; final double[][] darray2 = new double[][]{{2, 5}, {4, 6}}; final double[] darray3 = new double[]{2, 5}; this.assertIsEquals(darray1, darray2, darray3); final byte[][] byteArray1 = new byte[][]{{2, 5}, {4, 5}}; final byte[][] byteArray2 = new byte[][]{{2, 5}, {4, 6}}; final byte[] byteArray3 = new byte[]{2, 5}; this.assertIsEquals(byteArray1, byteArray2, byteArray3); final char[][] charArray1 = new char[][]{{2, 5}, {4, 5}}; final char[][] charArray2 = new char[][]{{2, 5}, {4, 6}}; final char[] charArray3 = new char[]{2, 5}; this.assertIsEquals(charArray1, charArray2, charArray3); final boolean[][] barray1 = new boolean[][]{{true, false}, {true, true}}; final boolean[][] barray2 = new boolean[][]{{true, false}, {true, false}}; final boolean[] barray3 = new boolean[]{false, true}; this.assertIsEquals(barray1, barray2, barray3); final Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})}; final Object[] array4 = new Object[]{"AB"}; assertTrue(ArrayUtils.isEquals(array3, array3)); assertTrue(ArrayUtils.isEquals(array3, array4)); assertTrue(ArrayUtils.isEquals(null, null)); assertFalse(ArrayUtils.isEquals(null, array4)); } //----------------------------------------------------------------------- /** * Tests generic array creation with parameters of same type. */ @Test public void testArrayCreation() { final String[] array = ArrayUtils.toArray("foo", "bar"); assertEquals(2, array.length); assertEquals("foo", array[0]); assertEquals("bar", array[1]); } /** * Tests generic array creation with general return type. */ @Test public void testArrayCreationWithGeneralReturnType() { final Object obj = ArrayUtils.toArray("foo", "bar"); assertTrue(obj instanceof String[]); } /** * Tests generic array creation with parameters of common base type. */ @Test public void testArrayCreationWithDifferentTypes() { final Number[] array = ArrayUtils.<Number>toArray(Integer.valueOf(42), Double.valueOf(Math.PI)); assertEquals(2, array.length); assertEquals(Integer.valueOf(42), array[0]); assertEquals(Double.valueOf(Math.PI), array[1]); } /** * Tests generic array creation with generic type. */ @Test public void testIndirectArrayCreation() { final String[] array = toArrayPropagatingType("foo", "bar"); assertEquals(2, array.length); assertEquals("foo", array[0]); assertEquals("bar", array[1]); } /** * Tests generic empty array creation with generic type. */ @Test public void testEmptyArrayCreation() { final String[] array = ArrayUtils.<String>toArray(); assertEquals(0, array.length); } /** * Tests indirect generic empty array creation with generic type. */ @Test public void testIndirectEmptyArrayCreation() { final String[] array = ArrayUtilsTest.<String>toArrayPropagatingType(); assertEquals(0, array.length); } private static <T> T[] toArrayPropagatingType(final T... items) { return ArrayUtils.toArray(items); } //----------------------------------------------------------------------- @Test public void testToMap() { Map<?, ?> map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}}); assertEquals("bar", map.get("foo")); assertEquals("world", map.get("hello")); assertEquals(null, ArrayUtils.toMap(null)); try { ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}}); fail("exception expected"); } catch (final IllegalArgumentException ex) {} try { ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"}); fail("exception expected"); } catch (final IllegalArgumentException ex) {} try { ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null}); fail("exception expected"); } catch (final IllegalArgumentException ex) {} map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() { @Override public Object getKey() { return "foo"; } @Override public Object getValue() { return "bar"; } @Override public Object setValue(final Object value) { throw new UnsupportedOperationException(); } @Override public boolean equals(final Object o) { throw new UnsupportedOperationException(); } @Override public int hashCode() { throw new UnsupportedOperationException(); } }}); assertEquals("bar", map.get("foo")); } //----------------------------------------------------------------------- @Test public void testClone() { assertArrayEquals(null, ArrayUtils.clone((Object[]) null)); Object[] original1 = new Object[0]; Object[] cloned1 = ArrayUtils.clone(original1); assertTrue(Arrays.equals(original1, cloned1)); assertTrue(original1 != cloned1); final StringBuffer buf = new StringBuffer("pick"); original1 = new Object[] {buf, "a", new String[] {"stick"}}; cloned1 = ArrayUtils.clone(original1); assertTrue(Arrays.equals(original1, cloned1)); assertTrue(original1 != cloned1); assertSame(original1[0], cloned1[0]); assertSame(original1[1], cloned1[1]); assertSame(original1[2], cloned1[2]); } @Test public void testCloneBoolean() { assertEquals(null, ArrayUtils.clone((boolean[]) null)); final boolean[] original = new boolean[] {true, false}; final boolean[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneLong() { assertEquals(null, ArrayUtils.clone((long[]) null)); final long[] original = new long[] {0L, 1L}; final long[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneInt() { assertEquals(null, ArrayUtils.clone((int[]) null)); final int[] original = new int[] {5, 8}; final int[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneShort() { assertEquals(null, ArrayUtils.clone((short[]) null)); final short[] original = new short[] {1, 4}; final short[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneChar() { assertEquals(null, ArrayUtils.clone((char[]) null)); final char[] original = new char[] {'a', '4'}; final char[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneByte() { assertEquals(null, ArrayUtils.clone((byte[]) null)); final byte[] original = new byte[] {1, 6}; final byte[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneDouble() { assertEquals(null, ArrayUtils.clone((double[]) null)); final double[] original = new double[] {2.4d, 5.7d}; final double[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } @Test public void testCloneFloat() { assertEquals(null, ArrayUtils.clone((float[]) null)); final float[] original = new float[] {2.6f, 6.4f}; final float[] cloned = ArrayUtils.clone(original); assertTrue(Arrays.equals(original, cloned)); assertTrue(original != cloned); } //----------------------------------------------------------------------- @Test public void testNullToEmptyBoolean() { // Test null handling assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.nullToEmpty((boolean[]) null)); // Test valid array handling final boolean[] original = new boolean[] {true, false}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final boolean[] empty = new boolean[]{}; final boolean[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyLong() { // Test null handling assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.nullToEmpty((long[]) null)); // Test valid array handling final long[] original = new long[] {1L, 2L}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final long[] empty = new long[]{}; final long[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyInt() { // Test null handling assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.nullToEmpty((int[]) null)); // Test valid array handling final int[] original = new int[] {1, 2}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final int[] empty = new int[]{}; final int[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_INT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyShort() { // Test null handling assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.nullToEmpty((short[]) null)); // Test valid array handling final short[] original = new short[] {1, 2}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final short[] empty = new short[]{}; final short[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyChar() { // Test null handling assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.nullToEmpty((char[]) null)); // Test valid array handling final char[] original = new char[] {'a', 'b'}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final char[] empty = new char[]{}; final char[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyByte() { // Test null handling assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.nullToEmpty((byte[]) null)); // Test valid array handling final byte[] original = new byte[] {0x0F, 0x0E}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final byte[] empty = new byte[]{}; final byte[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyDouble() { // Test null handling assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.nullToEmpty((double[]) null)); // Test valid array handling final double[] original = new double[] {1L, 2L}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final double[] empty = new double[]{}; final double[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyFloat() { // Test null handling assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.nullToEmpty((float[]) null)); // Test valid array handling final float[] original = new float[] {2.6f, 3.8f}; assertEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final float[] empty = new float[]{}; final float[] result = ArrayUtils.nullToEmpty(empty); assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Object[]) null)); // Test valid array handling final Object[] original = new Object[] {Boolean.TRUE, Boolean.FALSE}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Object[] empty = new Object[]{}; final Object[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyString() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.nullToEmpty((String[]) null)); // Test valid array handling final String[] original = new String[] {"abc", "def"}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final String[] empty = new String[]{}; final String[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyBooleanObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Boolean[]) null)); // Test valid array handling final Boolean[] original = new Boolean[] {Boolean.TRUE, Boolean.FALSE}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Boolean[] empty = new Boolean[]{}; final Boolean[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyLongObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null)); // Test valid array handling @SuppressWarnings("boxing") final Long[] original = new Long[] {1L, 2L}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Long[] empty = new Long[]{}; final Long[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyIntObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Integer[]) null)); // Test valid array handling final Integer[] original = new Integer[] {1, 2}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Integer[] empty = new Integer[]{}; final Integer[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyShortObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null)); // Test valid array handling @SuppressWarnings("boxing") final Short[] original = new Short[] {1, 2}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Short[] empty = new Short[]{}; final Short[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyCharObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Character[]) null)); // Test valid array handling final Character[] original = new Character[] {'a', 'b'}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Character[] empty = new Character[]{}; final Character[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyByteObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null)); // Test valid array handling final Byte[] original = new Byte[] {0x0F, 0x0E}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Byte[] empty = new Byte[]{}; final Byte[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyDoubleObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Double[]) null)); // Test valid array handling final Double[] original = new Double[] {1D, 2D}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Double[] empty = new Double[]{}; final Double[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, result); assertTrue(empty != result); } @Test public void testNullToEmptyFloatObject() { // Test null handling assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null)); // Test valid array handling final Float[] original = new Float[] {2.6f, 3.8f}; assertArrayEquals(original, ArrayUtils.nullToEmpty(original)); // Test empty array handling final Float[] empty = new Float[]{}; final Float[] result = ArrayUtils.nullToEmpty(empty); assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result); assertTrue(empty != result); } //----------------------------------------------------------------------- @Test public void testSubarrayObject() { final Object[] nullArray = null; final Object[] objectArray = { "a", "b", "c", "d", "e", "f"}; assertEquals("0 start, mid end", "abcd", StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4))); assertEquals("0 start, length end", "abcdef", StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length))); assertEquals("mid start, mid end", "bcd", StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4))); assertEquals("mid start, length end", "bcdef", StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", "", StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2))); assertEquals("start > end", "", StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2))); assertEquals("start == end", "", StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3))); assertEquals("start undershoot, normal end", "abcd", StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4))); assertEquals("start overshoot, any end", "", StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4))); assertEquals("normal start, end overshoot", "cdef", StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33))); assertEquals("start undershoot, end overshoot", "abcdef", StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12))); // array type tests final Date[] dateArray = { new java.sql.Date(new Date().getTime()), new Date(), new Date(), new Date(), new Date() }; assertSame("Object type", Object.class, ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType()); assertSame("java.util.Date type", java.util.Date.class, ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); assertNotSame("java.sql.Date type", java.sql.Date.class, ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType()); try { @SuppressWarnings("unused") final java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3); fail("Invalid downcast"); } catch (final ClassCastException e) {} } @Test public void testSubarrayLong() { final long[] nullArray = null; final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 }; final long[] leftSubarray = { 999910, 999911, 999912, 999913 }; final long[] midSubarray = { 999911, 999912, 999913, 999914 }; final long[] rightSubarray = { 999912, 999913, 999914, 999915 }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("long type", long.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrayInt() { final int[] nullArray = null; final int[] array = { 10, 11, 12, 13, 14, 15 }; final int[] leftSubarray = { 10, 11, 12, 13 }; final int[] midSubarray = { 11, 12, 13, 14 }; final int[] rightSubarray = { 12, 13, 14, 15 }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("int type", int.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrayShort() { final short[] nullArray = null; final short[] array = { 10, 11, 12, 13, 14, 15 }; final short[] leftSubarray = { 10, 11, 12, 13 }; final short[] midSubarray = { 11, 12, 13, 14 }; final short[] rightSubarray = { 12, 13, 14, 15 }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("short type", short.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrChar() { final char[] nullArray = null; final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' }; final char[] leftSubarray = { 'a', 'b', 'c', 'd', }; final char[] midSubarray = { 'b', 'c', 'd', 'e', }; final char[] rightSubarray = { 'c', 'd', 'e', 'f', }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("char type", char.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrayByte() { final byte[] nullArray = null; final byte[] array = { 10, 11, 12, 13, 14, 15 }; final byte[] leftSubarray = { 10, 11, 12, 13 }; final byte[] midSubarray = { 11, 12, 13, 14 }; final byte[] rightSubarray = { 12, 13, 14, 15 }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("byte type", byte.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrayDouble() { final double[] nullArray = null; final double[] array = { 10.123, 11.234, 12.345, 13.456, 14.567, 15.678 }; final double[] leftSubarray = { 10.123, 11.234, 12.345, 13.456, }; final double[] midSubarray = { 11.234, 12.345, 13.456, 14.567, }; final double[] rightSubarray = { 12.345, 13.456, 14.567, 15.678 }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("double type", double.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrayFloat() { final float[] nullArray = null; final float[] array = { 10, 11, 12, 13, 14, 15 }; final float[] leftSubarray = { 10, 11, 12, 13 }; final float[] midSubarray = { 11, 12, 13, 14 }; final float[] rightSubarray = { 12, 13, 14, 15 }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("float type", float.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } @Test public void testSubarrayBoolean() { final boolean[] nullArray = null; final boolean[] array = { true, true, false, true, false, true }; final boolean[] leftSubarray = { true, true, false, true }; final boolean[] midSubarray = { true, false, true, false }; final boolean[] rightSubarray = { false, true, false, true }; assertTrue("0 start, mid end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4))); assertTrue("0 start, length end", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length))); assertTrue("mid start, mid end", ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5))); assertTrue("mid start, length end", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length))); assertNull("null input", ArrayUtils.subarray(nullArray, 0, 3)); assertEquals("empty array", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); assertEquals("start > end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 4, 2)); assertEquals("start == end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertTrue("start undershoot, normal end", ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4))); assertEquals("start overshoot, any end", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 33, 4)); assertTrue("normal start, end overshoot", ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33))); assertTrue("start undershoot, end overshoot", ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12))); // empty-return tests assertSame("empty array, object test", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2)); assertSame("start > end, object test", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 4, 1)); assertSame("start == end, object test", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 3, 3)); assertSame("start overshoot, any end, object test", ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 8733, 4)); // array type tests assertSame("boolean type", boolean.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType()); } //----------------------------------------------------------------------- @Test public void testSameLength() { final Object[] nullArray = null; final Object[] emptyArray = new Object[0]; final Object[] oneArray = new Object[] {"pick"}; final Object[] twoArray = new Object[] {"pick", "stick"}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthBoolean() { final boolean[] nullArray = null; final boolean[] emptyArray = new boolean[0]; final boolean[] oneArray = new boolean[] {true}; final boolean[] twoArray = new boolean[] {true, false}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthLong() { final long[] nullArray = null; final long[] emptyArray = new long[0]; final long[] oneArray = new long[] {0L}; final long[] twoArray = new long[] {0L, 76L}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthInt() { final int[] nullArray = null; final int[] emptyArray = new int[0]; final int[] oneArray = new int[] {4}; final int[] twoArray = new int[] {5, 7}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthShort() { final short[] nullArray = null; final short[] emptyArray = new short[0]; final short[] oneArray = new short[] {4}; final short[] twoArray = new short[] {6, 8}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthChar() { final char[] nullArray = null; final char[] emptyArray = new char[0]; final char[] oneArray = new char[] {'f'}; final char[] twoArray = new char[] {'d', 't'}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthByte() { final byte[] nullArray = null; final byte[] emptyArray = new byte[0]; final byte[] oneArray = new byte[] {3}; final byte[] twoArray = new byte[] {4, 6}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthDouble() { final double[] nullArray = null; final double[] emptyArray = new double[0]; final double[] oneArray = new double[] {1.3d}; final double[] twoArray = new double[] {4.5d, 6.3d}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } @Test public void testSameLengthFloat() { final float[] nullArray = null; final float[] emptyArray = new float[0]; final float[] oneArray = new float[] {2.5f}; final float[] twoArray = new float[] {6.4f, 5.8f}; assertTrue(ArrayUtils.isSameLength(nullArray, nullArray)); assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(nullArray, oneArray)); assertFalse(ArrayUtils.isSameLength(nullArray, twoArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray)); assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray)); assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray)); assertFalse(ArrayUtils.isSameLength(oneArray, nullArray)); assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray)); assertTrue(ArrayUtils.isSameLength(oneArray, oneArray)); assertFalse(ArrayUtils.isSameLength(oneArray, twoArray)); assertFalse(ArrayUtils.isSameLength(twoArray, nullArray)); assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray)); assertFalse(ArrayUtils.isSameLength(twoArray, oneArray)); assertTrue(ArrayUtils.isSameLength(twoArray, twoArray)); } //----------------------------------------------------------------------- @Test public void testSameType() { try { ArrayUtils.isSameType(null, null); fail(); } catch (final IllegalArgumentException ex) {} try { ArrayUtils.isSameType(null, new Object[0]); fail(); } catch (final IllegalArgumentException ex) {} try { ArrayUtils.isSameType(new Object[0], null); fail(); } catch (final IllegalArgumentException ex) {} assertTrue(ArrayUtils.isSameType(new Object[0], new Object[0])); assertFalse(ArrayUtils.isSameType(new String[0], new Object[0])); assertTrue(ArrayUtils.isSameType(new String[0][0], new String[0][0])); assertFalse(ArrayUtils.isSameType(new String[0], new String[0][0])); assertFalse(ArrayUtils.isSameType(new String[0][0], new String[0])); } //----------------------------------------------------------------------- @Test public void testReverse() { final StringBuffer str1 = new StringBuffer("pick"); final String str2 = "a"; final String[] str3 = new String[] {"stick"}; final String str4 = "up"; Object[] array = new Object[] {str1, str2, str3}; ArrayUtils.reverse(array); assertEquals(array[0], str3); assertEquals(array[1], str2); assertEquals(array[2], str1); array = new Object[] {str1, str2, str3, str4}; ArrayUtils.reverse(array); assertEquals(array[0], str4); assertEquals(array[1], str3); assertEquals(array[2], str2); assertEquals(array[3], str1); array = null; ArrayUtils.reverse(array); assertArrayEquals(null, array); } @Test public void testReverseLong() { long[] array = new long[] {1L, 2L, 3L}; ArrayUtils.reverse(array); assertEquals(array[0], 3L); assertEquals(array[1], 2L); assertEquals(array[2], 1L); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseInt() { int[] array = new int[] {1, 2, 3}; ArrayUtils.reverse(array); assertEquals(array[0], 3); assertEquals(array[1], 2); assertEquals(array[2], 1); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseShort() { short[] array = new short[] {1, 2, 3}; ArrayUtils.reverse(array); assertEquals(array[0], 3); assertEquals(array[1], 2); assertEquals(array[2], 1); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseChar() { char[] array = new char[] {'a', 'f', 'C'}; ArrayUtils.reverse(array); assertEquals(array[0], 'C'); assertEquals(array[1], 'f'); assertEquals(array[2], 'a'); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseByte() { byte[] array = new byte[] {2, 3, 4}; ArrayUtils.reverse(array); assertEquals(array[0], 4); assertEquals(array[1], 3); assertEquals(array[2], 2); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseDouble() { double[] array = new double[] {0.3d, 0.4d, 0.5d}; ArrayUtils.reverse(array); assertEquals(array[0], 0.5d, 0.0d); assertEquals(array[1], 0.4d, 0.0d); assertEquals(array[2], 0.3d, 0.0d); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseFloat() { float[] array = new float[] {0.3f, 0.4f, 0.5f}; ArrayUtils.reverse(array); assertEquals(array[0], 0.5f, 0.0f); assertEquals(array[1], 0.4f, 0.0f); assertEquals(array[2], 0.3f, 0.0f); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } @Test public void testReverseBoolean() { boolean[] array = new boolean[] {false, false, true}; ArrayUtils.reverse(array); assertTrue(array[0]); assertFalse(array[1]); assertFalse(array[2]); array = null; ArrayUtils.reverse(array); assertEquals(null, array); } //----------------------------------------------------------------------- @Test public void testIndexOf() { final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; assertEquals(-1, ArrayUtils.indexOf(null, null)); assertEquals(-1, ArrayUtils.indexOf(null, "0")); assertEquals(-1, ArrayUtils.indexOf(new Object[0], "0")); assertEquals(0, ArrayUtils.indexOf(array, "0")); assertEquals(1, ArrayUtils.indexOf(array, "1")); assertEquals(2, ArrayUtils.indexOf(array, "2")); assertEquals(3, ArrayUtils.indexOf(array, "3")); assertEquals(4, ArrayUtils.indexOf(array, null)); assertEquals(-1, ArrayUtils.indexOf(array, "notInArray")); } @Test public void testIndexOfWithStartIndex() { final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; assertEquals(-1, ArrayUtils.indexOf(null, null, 2)); assertEquals(-1, ArrayUtils.indexOf(new Object[0], "0", 0)); assertEquals(-1, ArrayUtils.indexOf(null, "0", 2)); assertEquals(5, ArrayUtils.indexOf(array, "0", 2)); assertEquals(-1, ArrayUtils.indexOf(array, "1", 2)); assertEquals(2, ArrayUtils.indexOf(array, "2", 2)); assertEquals(3, ArrayUtils.indexOf(array, "3", 2)); assertEquals(4, ArrayUtils.indexOf(array, null, 2)); assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 2)); assertEquals(4, ArrayUtils.indexOf(array, null, -1)); assertEquals(-1, ArrayUtils.indexOf(array, null, 8)); assertEquals(-1, ArrayUtils.indexOf(array, "0", 8)); } @Test public void testLastIndexOf() { final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; assertEquals(-1, ArrayUtils.lastIndexOf(null, null)); assertEquals(-1, ArrayUtils.lastIndexOf(null, "0")); assertEquals(5, ArrayUtils.lastIndexOf(array, "0")); assertEquals(1, ArrayUtils.lastIndexOf(array, "1")); assertEquals(2, ArrayUtils.lastIndexOf(array, "2")); assertEquals(3, ArrayUtils.lastIndexOf(array, "3")); assertEquals(4, ArrayUtils.lastIndexOf(array, null)); assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray")); } @Test public void testLastIndexOfWithStartIndex() { final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(null, "0", 2)); assertEquals(0, ArrayUtils.lastIndexOf(array, "0", 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, "1", 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, "2", 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", -1)); assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5)); assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray", 5)); assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1)); assertEquals(5, ArrayUtils.lastIndexOf(array, "0", 88)); } @Test public void testContains() { final Object[] array = new Object[] { "0", "1", "2", "3", null, "0" }; assertFalse(ArrayUtils.contains(null, null)); assertFalse(ArrayUtils.contains(null, "1")); assertTrue(ArrayUtils.contains(array, "0")); assertTrue(ArrayUtils.contains(array, "1")); assertTrue(ArrayUtils.contains(array, "2")); assertTrue(ArrayUtils.contains(array, "3")); assertTrue(ArrayUtils.contains(array, null)); assertFalse(ArrayUtils.contains(array, "notInArray")); } //----------------------------------------------------------------------- @Test public void testIndexOfLong() { long[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, 0)); array = new long[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, 0)); assertEquals(1, ArrayUtils.indexOf(array, 1)); assertEquals(2, ArrayUtils.indexOf(array, 2)); assertEquals(3, ArrayUtils.indexOf(array, 3)); assertEquals(-1, ArrayUtils.indexOf(array, 99)); } @Test public void testIndexOfLongWithStartIndex() { long[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, 0, 2)); array = new long[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.indexOf(array, 0, 2)); assertEquals(-1, ArrayUtils.indexOf(array, 1, 2)); assertEquals(2, ArrayUtils.indexOf(array, 2, 2)); assertEquals(3, ArrayUtils.indexOf(array, 3, 2)); assertEquals(3, ArrayUtils.indexOf(array, 3, -1)); assertEquals(-1, ArrayUtils.indexOf(array, 99, 0)); assertEquals(-1, ArrayUtils.indexOf(array, 0, 6)); } @Test public void testLastIndexOfLong() { long[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, 0)); array = new long[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, 0)); assertEquals(1, ArrayUtils.lastIndexOf(array, 1)); assertEquals(2, ArrayUtils.lastIndexOf(array, 2)); assertEquals(3, ArrayUtils.lastIndexOf(array, 3)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 99)); } @Test public void testLastIndexOfLongWithStartIndex() { long[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2)); array = new long[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4)); assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88)); } @Test public void testContainsLong() { long[] array = null; assertFalse(ArrayUtils.contains(array, 1)); array = new long[] { 0, 1, 2, 3, 0 }; assertTrue(ArrayUtils.contains(array, 0)); assertTrue(ArrayUtils.contains(array, 1)); assertTrue(ArrayUtils.contains(array, 2)); assertTrue(ArrayUtils.contains(array, 3)); assertFalse(ArrayUtils.contains(array, 99)); } //----------------------------------------------------------------------- @Test public void testIndexOfInt() { int[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, 0)); array = new int[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, 0)); assertEquals(1, ArrayUtils.indexOf(array, 1)); assertEquals(2, ArrayUtils.indexOf(array, 2)); assertEquals(3, ArrayUtils.indexOf(array, 3)); assertEquals(-1, ArrayUtils.indexOf(array, 99)); } @Test public void testIndexOfIntWithStartIndex() { int[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, 0, 2)); array = new int[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.indexOf(array, 0, 2)); assertEquals(-1, ArrayUtils.indexOf(array, 1, 2)); assertEquals(2, ArrayUtils.indexOf(array, 2, 2)); assertEquals(3, ArrayUtils.indexOf(array, 3, 2)); assertEquals(3, ArrayUtils.indexOf(array, 3, -1)); assertEquals(-1, ArrayUtils.indexOf(array, 99, 0)); assertEquals(-1, ArrayUtils.indexOf(array, 0, 6)); } @Test public void testLastIndexOfInt() { int[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, 0)); array = new int[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, 0)); assertEquals(1, ArrayUtils.lastIndexOf(array, 1)); assertEquals(2, ArrayUtils.lastIndexOf(array, 2)); assertEquals(3, ArrayUtils.lastIndexOf(array, 3)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 99)); } @Test public void testLastIndexOfIntWithStartIndex() { int[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2)); array = new int[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 99)); assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88)); } @Test public void testContainsInt() { int[] array = null; assertFalse(ArrayUtils.contains(array, 1)); array = new int[] { 0, 1, 2, 3, 0 }; assertTrue(ArrayUtils.contains(array, 0)); assertTrue(ArrayUtils.contains(array, 1)); assertTrue(ArrayUtils.contains(array, 2)); assertTrue(ArrayUtils.contains(array, 3)); assertFalse(ArrayUtils.contains(array, 99)); } //----------------------------------------------------------------------- @Test public void testIndexOfShort() { short[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (short) 0)); array = new short[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, (short) 0)); assertEquals(1, ArrayUtils.indexOf(array, (short) 1)); assertEquals(2, ArrayUtils.indexOf(array, (short) 2)); assertEquals(3, ArrayUtils.indexOf(array, (short) 3)); assertEquals(-1, ArrayUtils.indexOf(array, (short) 99)); } @Test public void testIndexOfShortWithStartIndex() { short[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 2)); array = new short[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.indexOf(array, (short) 0, 2)); assertEquals(-1, ArrayUtils.indexOf(array, (short) 1, 2)); assertEquals(2, ArrayUtils.indexOf(array, (short) 2, 2)); assertEquals(3, ArrayUtils.indexOf(array, (short) 3, 2)); assertEquals(3, ArrayUtils.indexOf(array, (short) 3, -1)); assertEquals(-1, ArrayUtils.indexOf(array, (short) 99, 0)); assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 6)); } @Test public void testLastIndexOfShort() { short[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0)); array = new short[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0)); assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1)); assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2)); assertEquals(3, ArrayUtils.lastIndexOf(array, (short) 3)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); } @Test public void testLastIndexOfShortWithStartIndex() { short[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2)); array = new short[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99)); assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88)); } @Test public void testContainsShort() { short[] array = null; assertFalse(ArrayUtils.contains(array, (short) 1)); array = new short[] { 0, 1, 2, 3, 0 }; assertTrue(ArrayUtils.contains(array, (short) 0)); assertTrue(ArrayUtils.contains(array, (short) 1)); assertTrue(ArrayUtils.contains(array, (short) 2)); assertTrue(ArrayUtils.contains(array, (short) 3)); assertFalse(ArrayUtils.contains(array, (short) 99)); } //----------------------------------------------------------------------- @Test public void testIndexOfChar() { char[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, 'a')); array = new char[] { 'a', 'b', 'c', 'd', 'a' }; assertEquals(0, ArrayUtils.indexOf(array, 'a')); assertEquals(1, ArrayUtils.indexOf(array, 'b')); assertEquals(2, ArrayUtils.indexOf(array, 'c')); assertEquals(3, ArrayUtils.indexOf(array, 'd')); assertEquals(-1, ArrayUtils.indexOf(array, 'e')); } @Test public void testIndexOfCharWithStartIndex() { char[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2)); array = new char[] { 'a', 'b', 'c', 'd', 'a' }; assertEquals(4, ArrayUtils.indexOf(array, 'a', 2)); assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2)); assertEquals(2, ArrayUtils.indexOf(array, 'c', 2)); assertEquals(3, ArrayUtils.indexOf(array, 'd', 2)); assertEquals(3, ArrayUtils.indexOf(array, 'd', -1)); assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0)); assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6)); } @Test public void testLastIndexOfChar() { char[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a')); array = new char[] { 'a', 'b', 'c', 'd', 'a' }; assertEquals(4, ArrayUtils.lastIndexOf(array, 'a')); assertEquals(1, ArrayUtils.lastIndexOf(array, 'b')); assertEquals(2, ArrayUtils.lastIndexOf(array, 'c')); assertEquals(3, ArrayUtils.lastIndexOf(array, 'd')); assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e')); } @Test public void testLastIndexOfCharWithStartIndex() { char[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2)); array = new char[] { 'a', 'b', 'c', 'd', 'a' }; assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e')); assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88)); } @Test public void testContainsChar() { char[] array = null; assertFalse(ArrayUtils.contains(array, 'b')); array = new char[] { 'a', 'b', 'c', 'd', 'a' }; assertTrue(ArrayUtils.contains(array, 'a')); assertTrue(ArrayUtils.contains(array, 'b')); assertTrue(ArrayUtils.contains(array, 'c')); assertTrue(ArrayUtils.contains(array, 'd')); assertFalse(ArrayUtils.contains(array, 'e')); } //----------------------------------------------------------------------- @Test public void testIndexOfByte() { byte[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0)); array = new byte[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, (byte) 0)); assertEquals(1, ArrayUtils.indexOf(array, (byte) 1)); assertEquals(2, ArrayUtils.indexOf(array, (byte) 2)); assertEquals(3, ArrayUtils.indexOf(array, (byte) 3)); assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99)); } @Test public void testIndexOfByteWithStartIndex() { byte[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2)); array = new byte[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 2)); assertEquals(-1, ArrayUtils.indexOf(array, (byte) 1, 2)); assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2)); assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, 2)); assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, -1)); assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99, 0)); assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 6)); } @Test public void testLastIndexOfByte() { byte[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0)); array = new byte[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0)); assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1)); assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2)); assertEquals(3, ArrayUtils.lastIndexOf(array, (byte) 3)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99)); } @Test public void testLastIndexOfByteWithStartIndex() { byte[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0, 2)); array = new byte[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.lastIndexOf(array, (byte) 0, 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1, 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99)); assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0, 88)); } @Test public void testContainsByte() { byte[] array = null; assertFalse(ArrayUtils.contains(array, (byte) 1)); array = new byte[] { 0, 1, 2, 3, 0 }; assertTrue(ArrayUtils.contains(array, (byte) 0)); assertTrue(ArrayUtils.contains(array, (byte) 1)); assertTrue(ArrayUtils.contains(array, (byte) 2)); assertTrue(ArrayUtils.contains(array, (byte) 3)); assertFalse(ArrayUtils.contains(array, (byte) 99)); } //----------------------------------------------------------------------- @SuppressWarnings("cast") @Test public void testIndexOfDouble() { double[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0)); array = new double[0]; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, (double) 0)); assertEquals(1, ArrayUtils.indexOf(array, (double) 1)); assertEquals(2, ArrayUtils.indexOf(array, (double) 2)); assertEquals(3, ArrayUtils.indexOf(array, (double) 3)); assertEquals(3, ArrayUtils.indexOf(array, (double) 3, -1)); assertEquals(-1, ArrayUtils.indexOf(array, (double) 99)); } @SuppressWarnings("cast") @Test public void testIndexOfDoubleTolerance() { double[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0)); array = new double[0]; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, (double) 0, (double) 0.3)); assertEquals(2, ArrayUtils.indexOf(array, (double) 2.2, (double) 0.35)); assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, (double) 2.0)); assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, (double) 0.0001)); } @SuppressWarnings("cast") @Test public void testIndexOfDoubleWithStartIndex() { double[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2)); array = new double[0]; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 2)); assertEquals(-1, ArrayUtils.indexOf(array, (double) 1, 2)); assertEquals(2, ArrayUtils.indexOf(array, (double) 2, 2)); assertEquals(3, ArrayUtils.indexOf(array, (double) 3, 2)); assertEquals(-1, ArrayUtils.indexOf(array, (double) 99, 0)); assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 6)); } @SuppressWarnings("cast") @Test public void testIndexOfDoubleWithStartIndexTolerance() { double[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0)); array = new double[0]; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 99, (double) 0.3)); assertEquals(0, ArrayUtils.indexOf(array, (double) 0, 0, (double) 0.3)); assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 3, (double) 0.3)); assertEquals(2, ArrayUtils.indexOf(array, (double) 2.2, 0, (double) 0.35)); assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, 0, (double) 2.0)); assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, 0, (double) 0.0001)); assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, -1, (double) 2.0)); assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, -300, (double) 0.0001)); } @SuppressWarnings("cast") @Test public void testLastIndexOfDouble() { double[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0)); array = new double[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0)); assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1)); assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2)); assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 3)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99)); } @SuppressWarnings("cast") @Test public void testLastIndexOfDoubleTolerance() { double[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0)); array = new double[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0.3)); assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2.2, (double) 0.35)); assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 4.15, (double) 2.0)); assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1.00001324, (double) 0.0001)); } @SuppressWarnings("cast") @Test public void testLastIndexOfDoubleWithStartIndex() { double[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2)); array = new double[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1, 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99)); assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 88)); } @SuppressWarnings("cast") @Test public void testLastIndexOfDoubleWithStartIndexTolerance() { double[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0)); array = new double[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0)); array = new double[] { (double) 3 }; assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 1, 0, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 99, (double) 0.3)); assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 3, (double) 0.3)); assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2.2, 3, (double) 0.35)); assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 4.15, array.length, (double) 2.0)); assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1.00001324, array.length, (double) 0.0001)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 4.15, -200, (double) 2.0)); } @SuppressWarnings("cast") @Test public void testContainsDouble() { double[] array = null; assertFalse(ArrayUtils.contains(array, (double) 1)); array = new double[] { 0, 1, 2, 3, 0 }; assertTrue(ArrayUtils.contains(array, (double) 0)); assertTrue(ArrayUtils.contains(array, (double) 1)); assertTrue(ArrayUtils.contains(array, (double) 2)); assertTrue(ArrayUtils.contains(array, (double) 3)); assertFalse(ArrayUtils.contains(array, (double) 99)); } @SuppressWarnings("cast") @Test public void testContainsDoubleTolerance() { double[] array = null; assertFalse(ArrayUtils.contains(array, (double) 1, (double) 0)); array = new double[] { 0, 1, 2, 3, 0 }; assertFalse(ArrayUtils.contains(array, (double) 4.0, (double) 0.33)); assertFalse(ArrayUtils.contains(array, (double) 2.5, (double) 0.49)); assertTrue(ArrayUtils.contains(array, (double) 2.5, (double) 0.50)); assertTrue(ArrayUtils.contains(array, (double) 2.5, (double) 0.51)); } //----------------------------------------------------------------------- @SuppressWarnings("cast") @Test public void testIndexOfFloat() { float[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (float) 0)); array = new float[0]; assertEquals(-1, ArrayUtils.indexOf(array, (float) 0)); array = new float[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.indexOf(array, (float) 0)); assertEquals(1, ArrayUtils.indexOf(array, (float) 1)); assertEquals(2, ArrayUtils.indexOf(array, (float) 2)); assertEquals(3, ArrayUtils.indexOf(array, (float) 3)); assertEquals(-1, ArrayUtils.indexOf(array, (float) 99)); } @SuppressWarnings("cast") @Test public void testIndexOfFloatWithStartIndex() { float[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2)); array = new float[0]; assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2)); array = new float[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.indexOf(array, (float) 0, 2)); assertEquals(-1, ArrayUtils.indexOf(array, (float) 1, 2)); assertEquals(2, ArrayUtils.indexOf(array, (float) 2, 2)); assertEquals(3, ArrayUtils.indexOf(array, (float) 3, 2)); assertEquals(3, ArrayUtils.indexOf(array, (float) 3, -1)); assertEquals(-1, ArrayUtils.indexOf(array, (float) 99, 0)); assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 6)); } @SuppressWarnings("cast") @Test public void testLastIndexOfFloat() { float[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0)); array = new float[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0)); array = new float[] { 0, 1, 2, 3, 0 }; assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0)); assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1)); assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2)); assertEquals(3, ArrayUtils.lastIndexOf(array, (float) 3)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99)); } @SuppressWarnings("cast") @Test public void testLastIndexOfFloatWithStartIndex() { float[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2)); array = new float[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2)); array = new float[] { 0, 1, 2, 3, 0 }; assertEquals(0, ArrayUtils.lastIndexOf(array, (float) 0, 2)); assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1, 2)); assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, -1)); assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99)); assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0, 88)); } @SuppressWarnings("cast") @Test public void testContainsFloat() { float[] array = null; assertFalse(ArrayUtils.contains(array, (float) 1)); array = new float[] { 0, 1, 2, 3, 0 }; assertTrue(ArrayUtils.contains(array, (float) 0)); assertTrue(ArrayUtils.contains(array, (float) 1)); assertTrue(ArrayUtils.contains(array, (float) 2)); assertTrue(ArrayUtils.contains(array, (float) 3)); assertFalse(ArrayUtils.contains(array, (float) 99)); } //----------------------------------------------------------------------- @Test public void testIndexOfBoolean() { boolean[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, true)); array = new boolean[0]; assertEquals(-1, ArrayUtils.indexOf(array, true)); array = new boolean[] { true, false, true }; assertEquals(0, ArrayUtils.indexOf(array, true)); assertEquals(1, ArrayUtils.indexOf(array, false)); array = new boolean[] { true, true }; assertEquals(-1, ArrayUtils.indexOf(array, false)); } @Test public void testIndexOfBooleanWithStartIndex() { boolean[] array = null; assertEquals(-1, ArrayUtils.indexOf(array, true, 2)); array = new boolean[0]; assertEquals(-1, ArrayUtils.indexOf(array, true, 2)); array = new boolean[] { true, false, true }; assertEquals(2, ArrayUtils.indexOf(array, true, 1)); assertEquals(-1, ArrayUtils.indexOf(array, false, 2)); assertEquals(1, ArrayUtils.indexOf(array, false, 0)); assertEquals(1, ArrayUtils.indexOf(array, false, -1)); array = new boolean[] { true, true }; assertEquals(-1, ArrayUtils.indexOf(array, false, 0)); assertEquals(-1, ArrayUtils.indexOf(array, false, -1)); } @Test public void testLastIndexOfBoolean() { boolean[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, true)); array = new boolean[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, true)); array = new boolean[] { true, false, true }; assertEquals(2, ArrayUtils.lastIndexOf(array, true)); assertEquals(1, ArrayUtils.lastIndexOf(array, false)); array = new boolean[] { true, true }; assertEquals(-1, ArrayUtils.lastIndexOf(array, false)); } @Test public void testLastIndexOfBooleanWithStartIndex() { boolean[] array = null; assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); array = new boolean[0]; assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2)); array = new boolean[] { true, false, true }; assertEquals(2, ArrayUtils.lastIndexOf(array, true, 2)); assertEquals(0, ArrayUtils.lastIndexOf(array, true, 1)); assertEquals(1, ArrayUtils.lastIndexOf(array, false, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1)); array = new boolean[] { true, true }; assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 2)); assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1)); } @Test public void testContainsBoolean() { boolean[] array = null; assertFalse(ArrayUtils.contains(array, true)); array = new boolean[] { true, false, true }; assertTrue(ArrayUtils.contains(array, true)); assertTrue(ArrayUtils.contains(array, false)); array = new boolean[] { true, true }; assertTrue(ArrayUtils.contains(array, true)); assertFalse(ArrayUtils.contains(array, false)); } // testToPrimitive/Object for boolean // ----------------------------------------------------------------------- @Test public void testToPrimitive_boolean() { final Boolean[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0])); assertTrue(Arrays.equals( new boolean[] {true, false, true}, ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE})) ); try { ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_boolean_boolean() { assertEquals(null, ArrayUtils.toPrimitive(null, false)); assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false)); assertTrue(Arrays.equals( new boolean[] {true, false, true}, ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false)) ); assertTrue(Arrays.equals( new boolean[] {true, false, false}, ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false)) ); assertTrue(Arrays.equals( new boolean[] {true, true, false}, ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true)) ); } @Test public void testToObject_boolean() { final boolean[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.toObject(new boolean[0])); assertTrue(Arrays.equals( new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, ArrayUtils.toObject(new boolean[] {true, false, true})) ); } // testToPrimitive/Object for byte // ----------------------------------------------------------------------- @Test public void testToPrimitive_char() { final Character[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0])); assertTrue(Arrays.equals( new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), new Character(Character.MAX_VALUE), new Character('0')})) ); try { ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_char_char() { final Character[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b, Character.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0], (char)0)); assertTrue(Arrays.equals( new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), new Character(Character.MAX_VALUE), new Character('0')}, Character.MIN_VALUE)) ); assertTrue(Arrays.equals( new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'}, ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null, new Character('0')}, Character.MAX_VALUE)) ); } @Test public void testToObject_char() { final char[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, ArrayUtils.toObject(new char[0])); assertTrue(Arrays.equals( new Character[] {new Character(Character.MIN_VALUE), new Character(Character.MAX_VALUE), new Character('0')}, ArrayUtils.toObject(new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'} )) ); } // testToPrimitive/Object for byte // ----------------------------------------------------------------------- @Test public void testToPrimitive_byte() { final Byte[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0])); assertTrue(Arrays.equals( new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)})) ); try { ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_byte_byte() { final Byte[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b, Byte.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0], (byte)1)); assertTrue(Arrays.equals( new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, Byte.MIN_VALUE)) ); assertTrue(Arrays.equals( new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999}, ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null, Byte.valueOf((byte)9999999)}, Byte.MAX_VALUE)) ); } @Test public void testToObject_byte() { final byte[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.toObject(new byte[0])); assertTrue(Arrays.equals( new Byte[] {Byte.valueOf(Byte.MIN_VALUE), Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999})) ); } // testToPrimitive/Object for short // ----------------------------------------------------------------------- @Test public void testToPrimitive_short() { final Short[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0])); assertTrue(Arrays.equals( new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)})) ); try { ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_short_short() { final Short[] s = null; assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0], Short.MIN_VALUE)); assertTrue(Arrays.equals( new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)}, Short.MIN_VALUE)) ); assertTrue(Arrays.equals( new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999}, ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null, Short.valueOf((short)9999999)}, Short.MAX_VALUE)) ); } @Test public void testToObject_short() { final short[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.toObject(new short[0])); assertTrue(Arrays.equals( new Short[] {Short.valueOf(Short.MIN_VALUE), Short.valueOf(Short.MAX_VALUE), Short.valueOf((short)9999999)}, ArrayUtils.toObject(new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999})) ); } // testToPrimitive/Object for int // ----------------------------------------------------------------------- @Test public void testToPrimitive_int() { final Integer[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0])); assertTrue(Arrays.equals( new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)})) ); try { ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_int_int() { final Long[] l = null; assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0], 1)); assertTrue(Arrays.equals( new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1))); assertTrue(Arrays.equals( new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null, Integer.valueOf(9999999)}, Integer.MAX_VALUE)) ); } @Test public void testToPrimitive_intNull() { final Integer[] iArray = null; assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE)); } @Test public void testToObject_int() { final int[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame( ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, ArrayUtils.toObject(new int[0])); assertTrue( Arrays.equals( new Integer[] { Integer.valueOf(Integer.MIN_VALUE), Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)}, ArrayUtils.toObject( new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 }))); } // testToPrimitive/Object for long // ----------------------------------------------------------------------- @Test public void testToPrimitive_long() { final Long[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0])); assertTrue(Arrays.equals( new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)})) ); try { ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_long_long() { final Long[] l = null; assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.toPrimitive(new Long[0], 1)); assertTrue(Arrays.equals( new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)},1))); assertTrue(Arrays.equals( new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null, Long.valueOf(9999999)}, Long.MAX_VALUE)) ); } @Test public void testToObject_long() { final long[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame( ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.toObject(new long[0])); assertTrue( Arrays.equals( new Long[] { Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)}, ArrayUtils.toObject( new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 }))); } // testToPrimitive/Object for float // ----------------------------------------------------------------------- @Test public void testToPrimitive_float() { final Float[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.toPrimitive(new Float[0])); assertTrue(Arrays.equals( new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)})) ); try { ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_float_float() { final Float[] l = null; assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.toPrimitive(new Float[0], 1)); assertTrue(Arrays.equals( new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)},1))); assertTrue(Arrays.equals( new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null, Float.valueOf(9999999)}, Float.MAX_VALUE)) ); } @Test public void testToObject_float() { final float[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame( ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.toObject(new float[0])); assertTrue( Arrays.equals( new Float[] { Float.valueOf(Float.MIN_VALUE), Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}, ArrayUtils.toObject( new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 }))); } // testToPrimitive/Object for double // ----------------------------------------------------------------------- @Test public void testToPrimitive_double() { final Double[] b = null; assertEquals(null, ArrayUtils.toPrimitive(b)); assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0])); assertTrue(Arrays.equals( new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)})) ); try { ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null}); fail(); } catch (final NullPointerException ex) {} } @Test public void testToPrimitive_double_double() { final Double[] l = null; assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE)); assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.toPrimitive(new Double[0], 1)); assertTrue(Arrays.equals( new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)},1))); assertTrue(Arrays.equals( new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE), null, Double.valueOf(9999999)}, Double.MAX_VALUE)) ); } @Test public void testToObject_double() { final double[] b = null; assertArrayEquals(null, ArrayUtils.toObject(b)); assertSame( ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, ArrayUtils.toObject(new double[0])); assertTrue( Arrays.equals( new Double[] { Double.valueOf(Double.MIN_VALUE), Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)}, ArrayUtils.toObject( new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 }))); } //----------------------------------------------------------------------- /** * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}. */ @Test public void testIsEmptyObject() { final Object[] emptyArray = new Object[] {}; final Object[] notEmptyArray = new Object[] { new String("Value") }; assertTrue(ArrayUtils.isEmpty((Object[])null)); assertTrue(ArrayUtils.isEmpty(emptyArray)); assertFalse(ArrayUtils.isEmpty(notEmptyArray)); } /** * Tests for {@link ArrayUtils#isEmpty(long[])}, * {@link ArrayUtils#isEmpty(int[])}, * {@link ArrayUtils#isEmpty(short[])}, * {@link ArrayUtils#isEmpty(char[])}, * {@link ArrayUtils#isEmpty(byte[])}, * {@link ArrayUtils#isEmpty(double[])}, * {@link ArrayUtils#isEmpty(float[])} and * {@link ArrayUtils#isEmpty(boolean[])}. */ @Test public void testIsEmptyPrimitives() { final long[] emptyLongArray = new long[] {}; final long[] notEmptyLongArray = new long[] { 1L }; assertTrue(ArrayUtils.isEmpty((long[])null)); assertTrue(ArrayUtils.isEmpty(emptyLongArray)); assertFalse(ArrayUtils.isEmpty(notEmptyLongArray)); final int[] emptyIntArray = new int[] {}; final int[] notEmptyIntArray = new int[] { 1 }; assertTrue(ArrayUtils.isEmpty((int[])null)); assertTrue(ArrayUtils.isEmpty(emptyIntArray)); assertFalse(ArrayUtils.isEmpty(notEmptyIntArray)); final short[] emptyShortArray = new short[] {}; final short[] notEmptyShortArray = new short[] { 1 }; assertTrue(ArrayUtils.isEmpty((short[])null)); assertTrue(ArrayUtils.isEmpty(emptyShortArray)); assertFalse(ArrayUtils.isEmpty(notEmptyShortArray)); final char[] emptyCharArray = new char[] {}; final char[] notEmptyCharArray = new char[] { 1 }; assertTrue(ArrayUtils.isEmpty((char[])null)); assertTrue(ArrayUtils.isEmpty(emptyCharArray)); assertFalse(ArrayUtils.isEmpty(notEmptyCharArray)); final byte[] emptyByteArray = new byte[] {}; final byte[] notEmptyByteArray = new byte[] { 1 }; assertTrue(ArrayUtils.isEmpty((byte[])null)); assertTrue(ArrayUtils.isEmpty(emptyByteArray)); assertFalse(ArrayUtils.isEmpty(notEmptyByteArray)); final double[] emptyDoubleArray = new double[] {}; final double[] notEmptyDoubleArray = new double[] { 1.0 }; assertTrue(ArrayUtils.isEmpty((double[])null)); assertTrue(ArrayUtils.isEmpty(emptyDoubleArray)); assertFalse(ArrayUtils.isEmpty(notEmptyDoubleArray)); final float[] emptyFloatArray = new float[] {}; final float[] notEmptyFloatArray = new float[] { 1.0F }; assertTrue(ArrayUtils.isEmpty((float[])null)); assertTrue(ArrayUtils.isEmpty(emptyFloatArray)); assertFalse(ArrayUtils.isEmpty(notEmptyFloatArray)); final boolean[] emptyBooleanArray = new boolean[] {}; final boolean[] notEmptyBooleanArray = new boolean[] { true }; assertTrue(ArrayUtils.isEmpty((boolean[])null)); assertTrue(ArrayUtils.isEmpty(emptyBooleanArray)); assertFalse(ArrayUtils.isEmpty(notEmptyBooleanArray)); } /** * Test for {@link ArrayUtils#isNotEmpty(java.lang.Object[])}. */ @Test public void testIsNotEmptyObject() { final Object[] emptyArray = new Object[] {}; final Object[] notEmptyArray = new Object[] { new String("Value") }; assertFalse(ArrayUtils.isNotEmpty((Object[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyArray)); } /** * Tests for {@link ArrayUtils#isNotEmpty(long[])}, * {@link ArrayUtils#isNotEmpty(int[])}, * {@link ArrayUtils#isNotEmpty(short[])}, * {@link ArrayUtils#isNotEmpty(char[])}, * {@link ArrayUtils#isNotEmpty(byte[])}, * {@link ArrayUtils#isNotEmpty(double[])}, * {@link ArrayUtils#isNotEmpty(float[])} and * {@link ArrayUtils#isNotEmpty(boolean[])}. */ @Test public void testIsNotEmptyPrimitives() { final long[] emptyLongArray = new long[] {}; final long[] notEmptyLongArray = new long[] { 1L }; assertFalse(ArrayUtils.isNotEmpty((long[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyLongArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyLongArray)); final int[] emptyIntArray = new int[] {}; final int[] notEmptyIntArray = new int[] { 1 }; assertFalse(ArrayUtils.isNotEmpty((int[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyIntArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyIntArray)); final short[] emptyShortArray = new short[] {}; final short[] notEmptyShortArray = new short[] { 1 }; assertFalse(ArrayUtils.isNotEmpty((short[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyShortArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyShortArray)); final char[] emptyCharArray = new char[] {}; final char[] notEmptyCharArray = new char[] { 1 }; assertFalse(ArrayUtils.isNotEmpty((char[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyCharArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyCharArray)); final byte[] emptyByteArray = new byte[] {}; final byte[] notEmptyByteArray = new byte[] { 1 }; assertFalse(ArrayUtils.isNotEmpty((byte[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyByteArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyByteArray)); final double[] emptyDoubleArray = new double[] {}; final double[] notEmptyDoubleArray = new double[] { 1.0 }; assertFalse(ArrayUtils.isNotEmpty((double[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyDoubleArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyDoubleArray)); final float[] emptyFloatArray = new float[] {}; final float[] notEmptyFloatArray = new float[] { 1.0F }; assertFalse(ArrayUtils.isNotEmpty((float[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyFloatArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyFloatArray)); final boolean[] emptyBooleanArray = new boolean[] {}; final boolean[] notEmptyBooleanArray = new boolean[] { true }; assertFalse(ArrayUtils.isNotEmpty((boolean[])null)); assertFalse(ArrayUtils.isNotEmpty(emptyBooleanArray)); assertTrue(ArrayUtils.isNotEmpty(notEmptyBooleanArray)); } // ------------------------------------------------------------------------ @Test public void testGetLength() { assertEquals(0, ArrayUtils.getLength(null)); final Object[] emptyObjectArray = new Object[0]; final Object[] notEmptyObjectArray = new Object[] {"aValue"}; assertEquals(0, ArrayUtils.getLength((Object[]) null)); assertEquals(0, ArrayUtils.getLength(emptyObjectArray)); assertEquals(1, ArrayUtils.getLength(notEmptyObjectArray)); final int[] emptyIntArray = new int[] {}; final int[] notEmptyIntArray = new int[] { 1 }; assertEquals(0, ArrayUtils.getLength((int[]) null)); assertEquals(0, ArrayUtils.getLength(emptyIntArray)); assertEquals(1, ArrayUtils.getLength(notEmptyIntArray)); final short[] emptyShortArray = new short[] {}; final short[] notEmptyShortArray = new short[] { 1 }; assertEquals(0, ArrayUtils.getLength((short[]) null)); assertEquals(0, ArrayUtils.getLength(emptyShortArray)); assertEquals(1, ArrayUtils.getLength(notEmptyShortArray)); final char[] emptyCharArray = new char[] {}; final char[] notEmptyCharArray = new char[] { 1 }; assertEquals(0, ArrayUtils.getLength((char[]) null)); assertEquals(0, ArrayUtils.getLength(emptyCharArray)); assertEquals(1, ArrayUtils.getLength(notEmptyCharArray)); final byte[] emptyByteArray = new byte[] {}; final byte[] notEmptyByteArray = new byte[] { 1 }; assertEquals(0, ArrayUtils.getLength((byte[]) null)); assertEquals(0, ArrayUtils.getLength(emptyByteArray)); assertEquals(1, ArrayUtils.getLength(notEmptyByteArray)); final double[] emptyDoubleArray = new double[] {}; final double[] notEmptyDoubleArray = new double[] { 1.0 }; assertEquals(0, ArrayUtils.getLength((double[]) null)); assertEquals(0, ArrayUtils.getLength(emptyDoubleArray)); assertEquals(1, ArrayUtils.getLength(notEmptyDoubleArray)); final float[] emptyFloatArray = new float[] {}; final float[] notEmptyFloatArray = new float[] { 1.0F }; assertEquals(0, ArrayUtils.getLength((float[]) null)); assertEquals(0, ArrayUtils.getLength(emptyFloatArray)); assertEquals(1, ArrayUtils.getLength(notEmptyFloatArray)); final boolean[] emptyBooleanArray = new boolean[] {}; final boolean[] notEmptyBooleanArray = new boolean[] { true }; assertEquals(0, ArrayUtils.getLength((boolean[]) null)); assertEquals(0, ArrayUtils.getLength(emptyBooleanArray)); assertEquals(1, ArrayUtils.getLength(notEmptyBooleanArray)); try { ArrayUtils.getLength("notAnArray"); fail("IllegalArgumentException should have been thrown"); } catch (final IllegalArgumentException e) {} } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import org.junit.Test; /** * Class to test BitField functionality * * @version $Id$ */ public class BitFieldTest { private static final BitField bf_multi = new BitField(0x3F80); private static final BitField bf_single = new BitField(0x4000); private static final BitField bf_zero = new BitField(0); /** * test the getValue() method */ @Test public void testGetValue() { assertEquals(bf_multi.getValue(-1), 127); assertEquals(bf_multi.getValue(0), 0); assertEquals(bf_single.getValue(-1), 1); assertEquals(bf_single.getValue(0), 0); assertEquals(bf_zero.getValue(-1), 0); assertEquals(bf_zero.getValue(0), 0); } /** * test the getShortValue() method */ @Test public void testGetShortValue() { assertEquals(bf_multi.getShortValue((short) - 1), (short) 127); assertEquals(bf_multi.getShortValue((short) 0), (short) 0); assertEquals(bf_single.getShortValue((short) - 1), (short) 1); assertEquals(bf_single.getShortValue((short) 0), (short) 0); assertEquals(bf_zero.getShortValue((short) -1), (short) 0); assertEquals(bf_zero.getShortValue((short) 0), (short) 0); } /** * test the getRawValue() method */ @Test public void testGetRawValue() { assertEquals(bf_multi.getRawValue(-1), 0x3F80); assertEquals(bf_multi.getRawValue(0), 0); assertEquals(bf_single.getRawValue(-1), 0x4000); assertEquals(bf_single.getRawValue(0), 0); assertEquals(bf_zero.getRawValue(-1), 0); assertEquals(bf_zero.getRawValue(0), 0); } /** * test the getShortRawValue() method */ @Test public void testGetShortRawValue() { assertEquals(bf_multi.getShortRawValue((short) - 1), (short) 0x3F80); assertEquals(bf_multi.getShortRawValue((short) 0), (short) 0); assertEquals(bf_single.getShortRawValue((short) - 1), (short) 0x4000); assertEquals(bf_single.getShortRawValue((short) 0), (short) 0); assertEquals(bf_zero.getShortRawValue((short) -1), (short) 0); assertEquals(bf_zero.getShortRawValue((short) 0), (short) 0); } /** * test the isSet() method */ @Test public void testIsSet() { assertTrue(!bf_multi.isSet(0)); assertTrue(!bf_zero.isSet(0)); for (int j = 0x80; j <= 0x3F80; j += 0x80) { assertTrue(bf_multi.isSet(j)); } for (int j = 0x80; j <= 0x3F80; j += 0x80) { assertTrue(!bf_zero.isSet(j)); } assertTrue(!bf_single.isSet(0)); assertTrue(bf_single.isSet(0x4000)); } /** * test the isAllSet() method */ @Test public void testIsAllSet() { for (int j = 0; j < 0x3F80; j += 0x80) { assertTrue(!bf_multi.isAllSet(j)); assertTrue(bf_zero.isAllSet(j)); } assertTrue(bf_multi.isAllSet(0x3F80)); assertTrue(!bf_single.isAllSet(0)); assertTrue(bf_single.isAllSet(0x4000)); } /** * test the setValue() method */ @Test public void testSetValue() { for (int j = 0; j < 128; j++) { assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j); assertEquals(bf_multi.setValue(0, j), j << 7); } for (int j = 0; j < 128; j++) { assertEquals(bf_zero.getValue(bf_zero.setValue(0, j)), 0); assertEquals(bf_zero.setValue(0, j), 0); } // verify that excess bits are stripped off assertEquals(bf_multi.setValue(0x3f80, 128), 0); for (int j = 0; j < 2; j++) { assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j); assertEquals(bf_single.setValue(0, j), j << 14); } // verify that excess bits are stripped off assertEquals(bf_single.setValue(0x4000, 2), 0); } /** * test the setShortValue() method */ @Test public void testSetShortValue() { for (int j = 0; j < 128; j++) { assertEquals(bf_multi.getShortValue(bf_multi.setShortValue((short) 0, (short) j)), (short) j); assertEquals(bf_multi.setShortValue((short) 0, (short) j), (short) (j << 7)); } for (int j = 0; j < 128; j++) { assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0); assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) 0); } // verify that excess bits are stripped off assertEquals(bf_multi.setShortValue((short) 0x3f80, (short) 128), (short) 0); for (int j = 0; j < 2; j++) { assertEquals(bf_single.getShortValue(bf_single.setShortValue((short) 0, (short) j)), (short) j); assertEquals(bf_single.setShortValue((short) 0, (short) j), (short) (j << 14)); } // verify that excess bits are stripped off assertEquals(bf_single.setShortValue((short) 0x4000, (short) 2), (short) 0); } @Test public void testByte() { assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true)); assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true)); assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true)); assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true)); assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true)); assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true)); assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true)); assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true)); assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true)); assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false)); assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false)); assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false)); assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false)); assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false)); assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false)); assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false)); assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false)); assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false)); assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false)); final byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false); assertFalse(new BitField(0x40).isSet(clearedBit)); } /** * test the clear() method */ @Test public void testClear() { assertEquals(bf_multi.clear(-1), 0xFFFFC07F); assertEquals(bf_single.clear(-1), 0xFFFFBFFF); assertEquals(bf_zero.clear(-1), 0xFFFFFFFF); } /** * test the clearShort() method */ @Test public void testClearShort() { assertEquals(bf_multi.clearShort((short) - 1), (short) 0xC07F); assertEquals(bf_single.clearShort((short) - 1), (short) 0xBFFF); assertEquals(bf_zero.clearShort((short) -1), (short) 0xFFFF); } /** * test the set() method */ @Test public void testSet() { assertEquals(bf_multi.set(0), 0x3F80); assertEquals(bf_single.set(0), 0x4000); assertEquals(bf_zero.set(0), 0); } /** * test the setShort() method */ @Test public void testSetShort() { assertEquals(bf_multi.setShort((short) 0), (short) 0x3F80); assertEquals(bf_single.setShort((short) 0), (short) 0x4000); assertEquals(bf_zero.setShort((short) 0), (short) 0); } /** * test the setBoolean() method */ @Test public void testSetBoolean() { assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true)); assertEquals(bf_single.set(0), bf_single.setBoolean(0, true)); assertEquals(bf_zero.set(0), bf_zero.setBoolean(0, true)); assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false)); assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false)); assertEquals(bf_zero.clear(-1), bf_zero.setBoolean(-1, false)); } /** * test the setShortBoolean() method */ @Test public void testSetShortBoolean() { assertEquals(bf_multi.setShort((short) 0), bf_multi.setShortBoolean((short) 0, true)); assertEquals(bf_single.setShort((short) 0), bf_single.setShortBoolean((short) 0, true)); assertEquals(bf_zero.setShort((short) 0), bf_zero.setShortBoolean((short) 0, true)); assertEquals(bf_multi.clearShort((short) - 1), bf_multi.setShortBoolean((short) - 1, false)); assertEquals(bf_single.clearShort((short) - 1), bf_single.setShortBoolean((short) - 1, false)); assertEquals(bf_zero.clearShort((short) -1), bf_zero.setShortBoolean((short) -1, false)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.BooleanUtils}. * * @version $Id$ */ public class BooleanUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new BooleanUtils()); final Constructor<?>[] cons = BooleanUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(BooleanUtils.class.getModifiers())); assertFalse(Modifier.isFinal(BooleanUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void test_negate_Boolean() { assertSame(null, BooleanUtils.negate(null)); assertSame(Boolean.TRUE, BooleanUtils.negate(Boolean.FALSE)); assertSame(Boolean.FALSE, BooleanUtils.negate(Boolean.TRUE)); } //----------------------------------------------------------------------- @Test public void test_isTrue_Boolean() { assertTrue(BooleanUtils.isTrue(Boolean.TRUE)); assertFalse(BooleanUtils.isTrue(Boolean.FALSE)); assertFalse(BooleanUtils.isTrue((Boolean) null)); } @Test public void test_isNotTrue_Boolean() { assertFalse(BooleanUtils.isNotTrue(Boolean.TRUE)); assertTrue(BooleanUtils.isNotTrue(Boolean.FALSE)); assertTrue(BooleanUtils.isNotTrue((Boolean) null)); } //----------------------------------------------------------------------- @Test public void test_isFalse_Boolean() { assertFalse(BooleanUtils.isFalse(Boolean.TRUE)); assertTrue(BooleanUtils.isFalse(Boolean.FALSE)); assertFalse(BooleanUtils.isFalse((Boolean) null)); } @Test public void test_isNotFalse_Boolean() { assertTrue(BooleanUtils.isNotFalse(Boolean.TRUE)); assertFalse(BooleanUtils.isNotFalse(Boolean.FALSE)); assertTrue(BooleanUtils.isNotFalse((Boolean) null)); } //----------------------------------------------------------------------- @Test public void test_toBoolean_Boolean() { assertTrue(BooleanUtils.toBoolean(Boolean.TRUE)); assertFalse(BooleanUtils.toBoolean(Boolean.FALSE)); assertFalse(BooleanUtils.toBoolean((Boolean) null)); } @Test public void test_toBooleanDefaultIfNull_Boolean_boolean() { assertTrue(BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true)); assertTrue(BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false)); assertFalse(BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true)); assertFalse(BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false)); assertTrue(BooleanUtils.toBooleanDefaultIfNull((Boolean) null, true)); assertFalse(BooleanUtils.toBooleanDefaultIfNull((Boolean) null, false)); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void test_toBoolean_int() { assertTrue(BooleanUtils.toBoolean(1)); assertTrue(BooleanUtils.toBoolean(-1)); assertFalse(BooleanUtils.toBoolean(0)); } @Test public void test_toBooleanObject_int() { assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1)); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(-1)); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0)); } @Test public void test_toBooleanObject_Integer() { assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(1))); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(-1))); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(Integer.valueOf(0))); assertEquals(null, BooleanUtils.toBooleanObject((Integer) null)); } //----------------------------------------------------------------------- @Test public void test_toBoolean_int_int_int() { assertTrue(BooleanUtils.toBoolean(6, 6, 7)); assertFalse(BooleanUtils.toBoolean(7, 6, 7)); } @Test(expected = IllegalArgumentException.class) public void test_toBoolean_int_int_int_noMatch() { BooleanUtils.toBoolean(8, 6, 7); } @Test public void test_toBoolean_Integer_Integer_Integer() { final Integer six = Integer.valueOf(6); final Integer seven = Integer.valueOf(7); assertTrue(BooleanUtils.toBoolean((Integer) null, null, seven)); assertFalse(BooleanUtils.toBoolean((Integer) null, six, null)); assertTrue(BooleanUtils.toBoolean(Integer.valueOf(6), six, seven)); assertFalse(BooleanUtils.toBoolean(Integer.valueOf(7), six, seven)); } @Test(expected = IllegalArgumentException.class) public void test_toBoolean_Integer_Integer_Integer_nullValue() { BooleanUtils.toBoolean(null, Integer.valueOf(6), Integer.valueOf(7)); } @Test(expected = IllegalArgumentException.class) public void test_toBoolean_Integer_Integer_Integer_noMatch() { BooleanUtils.toBoolean(Integer.valueOf(8), Integer.valueOf(6), Integer.valueOf(7)); } //----------------------------------------------------------------------- @Test public void test_toBooleanObject_int_int_int() { assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(6, 6, 7, 8)); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(7, 6, 7, 8)); assertEquals(null, BooleanUtils.toBooleanObject(8, 6, 7, 8)); } @Test(expected = IllegalArgumentException.class) public void test_toBooleanObject_int_int_int_noMatch() { BooleanUtils.toBooleanObject(9, 6, 7, 8); } @Test public void test_toBooleanObject_Integer_Integer_Integer_Integer() { final Integer six = Integer.valueOf(6); final Integer seven = Integer.valueOf(7); final Integer eight = Integer.valueOf(8); assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((Integer) null, null, seven, eight)); assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((Integer) null, six, null, eight)); assertSame(null, BooleanUtils.toBooleanObject((Integer) null, six, seven, null)); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(6), six, seven, eight)); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(Integer.valueOf(7), six, seven, eight)); assertEquals(null, BooleanUtils.toBooleanObject(Integer.valueOf(8), six, seven, eight)); } @Test(expected = IllegalArgumentException.class) public void test_toBooleanObject_Integer_Integer_Integer_Integer_nullValue() { BooleanUtils.toBooleanObject(null, Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8)); } @Test(expected = IllegalArgumentException.class) public void test_toBooleanObject_Integer_Integer_Integer_Integer_noMatch() { BooleanUtils.toBooleanObject(Integer.valueOf(9), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8)); } //----------------------------------------------------------------------- @Test public void test_toInteger_boolean() { assertEquals(1, BooleanUtils.toInteger(true)); assertEquals(0, BooleanUtils.toInteger(false)); } @Test public void test_toIntegerObject_boolean() { assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(true)); assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(false)); } @Test public void test_toIntegerObject_Boolean() { assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(Boolean.TRUE)); assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(Boolean.FALSE)); assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null)); } //----------------------------------------------------------------------- @Test public void test_toInteger_boolean_int_int() { assertEquals(6, BooleanUtils.toInteger(true, 6, 7)); assertEquals(7, BooleanUtils.toInteger(false, 6, 7)); } @Test public void test_toInteger_Boolean_int_int_int() { assertEquals(6, BooleanUtils.toInteger(Boolean.TRUE, 6, 7, 8)); assertEquals(7, BooleanUtils.toInteger(Boolean.FALSE, 6, 7, 8)); assertEquals(8, BooleanUtils.toInteger(null, 6, 7, 8)); } @Test public void test_toIntegerObject_boolean_Integer_Integer() { final Integer six = Integer.valueOf(6); final Integer seven = Integer.valueOf(7); assertEquals(six, BooleanUtils.toIntegerObject(true, six, seven)); assertEquals(seven, BooleanUtils.toIntegerObject(false, six, seven)); } @Test public void test_toIntegerObject_Boolean_Integer_Integer_Integer() { final Integer six = Integer.valueOf(6); final Integer seven = Integer.valueOf(7); final Integer eight = Integer.valueOf(8); assertEquals(six, BooleanUtils.toIntegerObject(Boolean.TRUE, six, seven, eight)); assertEquals(seven, BooleanUtils.toIntegerObject(Boolean.FALSE, six, seven, eight)); assertEquals(eight, BooleanUtils.toIntegerObject((Boolean) null, six, seven, eight)); assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null, six, seven, null)); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void test_toBooleanObject_String() { assertEquals(null, BooleanUtils.toBooleanObject((String) null)); assertEquals(null, BooleanUtils.toBooleanObject("")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF")); assertEquals(null, BooleanUtils.toBooleanObject("oof")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("YES")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("y")); // yes assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y")); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("t")); // true assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("T")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("f")); // false assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("F")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("n")); // No assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N")); assertEquals(null, BooleanUtils.toBooleanObject("z")); assertEquals(null, BooleanUtils.toBooleanObject("ab")); assertEquals(null, BooleanUtils.toBooleanObject("yoo")); } @Test public void test_toBooleanObject_String_String_String_String() { assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((String) null, null, "N", "U")); assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((String) null, "Y", null, "U")); assertSame(null, BooleanUtils.toBooleanObject((String) null, "Y", "N", null)); assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y", "Y", "N", "U")); assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N", "Y", "N", "U")); assertEquals(null, BooleanUtils.toBooleanObject("U", "Y", "N", "U")); } @Test(expected = IllegalArgumentException.class) public void test_toBooleanObject_String_String_String_String_nullValue() { BooleanUtils.toBooleanObject((String) null, "Y", "N", "U"); } @Test(expected = IllegalArgumentException.class) public void test_toBooleanObject_String_String_String_String_noMatch() { BooleanUtils.toBooleanObject("X", "Y", "N", "U"); } //----------------------------------------------------------------------- @Test public void test_toBoolean_String() { assertFalse(BooleanUtils.toBoolean((String) null)); assertFalse(BooleanUtils.toBoolean("")); assertFalse(BooleanUtils.toBoolean("off")); assertFalse(BooleanUtils.toBoolean("oof")); assertFalse(BooleanUtils.toBoolean("yep")); assertFalse(BooleanUtils.toBoolean("trux")); assertFalse(BooleanUtils.toBoolean("false")); assertFalse(BooleanUtils.toBoolean("a")); assertTrue(BooleanUtils.toBoolean("true")); // interned handled differently assertTrue(BooleanUtils.toBoolean(new StringBuffer("tr").append("ue").toString())); assertTrue(BooleanUtils.toBoolean("truE")); assertTrue(BooleanUtils.toBoolean("trUe")); assertTrue(BooleanUtils.toBoolean("trUE")); assertTrue(BooleanUtils.toBoolean("tRue")); assertTrue(BooleanUtils.toBoolean("tRuE")); assertTrue(BooleanUtils.toBoolean("tRUe")); assertTrue(BooleanUtils.toBoolean("tRUE")); assertTrue(BooleanUtils.toBoolean("TRUE")); assertTrue(BooleanUtils.toBoolean("TRUe")); assertTrue(BooleanUtils.toBoolean("TRuE")); assertTrue(BooleanUtils.toBoolean("TRue")); assertTrue(BooleanUtils.toBoolean("TrUE")); assertTrue(BooleanUtils.toBoolean("TrUe")); assertTrue(BooleanUtils.toBoolean("TruE")); assertTrue(BooleanUtils.toBoolean("True")); assertTrue(BooleanUtils.toBoolean("on")); assertTrue(BooleanUtils.toBoolean("oN")); assertTrue(BooleanUtils.toBoolean("On")); assertTrue(BooleanUtils.toBoolean("ON")); assertTrue(BooleanUtils.toBoolean("yes")); assertTrue(BooleanUtils.toBoolean("yeS")); assertTrue(BooleanUtils.toBoolean("yEs")); assertTrue(BooleanUtils.toBoolean("yES")); assertTrue(BooleanUtils.toBoolean("Yes")); assertTrue(BooleanUtils.toBoolean("YeS")); assertTrue(BooleanUtils.toBoolean("YEs")); assertTrue(BooleanUtils.toBoolean("YES")); assertFalse(BooleanUtils.toBoolean("yes?")); assertFalse(BooleanUtils.toBoolean("tru")); assertFalse(BooleanUtils.toBoolean("no")); assertFalse(BooleanUtils.toBoolean("off")); assertFalse(BooleanUtils.toBoolean("yoo")); } @Test public void test_toBoolean_String_String_String() { assertTrue(BooleanUtils.toBoolean((String) null, null, "N")); assertFalse(BooleanUtils.toBoolean((String) null, "Y", null)); assertTrue(BooleanUtils.toBoolean("Y", "Y", "N")); assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("N"))); assertFalse(BooleanUtils.toBoolean("N", "Y", "N")); assertFalse(BooleanUtils.toBoolean("N", new String("Y"), new String("N"))); assertTrue(BooleanUtils.toBoolean((String) null, null, null)); assertTrue(BooleanUtils.toBoolean("Y", "Y", "Y")); assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("Y"))); } @Test(expected = IllegalArgumentException.class) public void test_toBoolean_String_String_String_nullValue() { BooleanUtils.toBoolean(null, "Y", "N"); } @Test(expected = IllegalArgumentException.class) public void test_toBoolean_String_String_String_noMatch() { BooleanUtils.toBoolean("X", "Y", "N"); } //----------------------------------------------------------------------- @Test public void test_toStringTrueFalse_Boolean() { assertEquals(null, BooleanUtils.toStringTrueFalse((Boolean) null)); assertEquals("true", BooleanUtils.toStringTrueFalse(Boolean.TRUE)); assertEquals("false", BooleanUtils.toStringTrueFalse(Boolean.FALSE)); } @Test public void test_toStringOnOff_Boolean() { assertEquals(null, BooleanUtils.toStringOnOff((Boolean) null)); assertEquals("on", BooleanUtils.toStringOnOff(Boolean.TRUE)); assertEquals("off", BooleanUtils.toStringOnOff(Boolean.FALSE)); } @Test public void test_toStringYesNo_Boolean() { assertEquals(null, BooleanUtils.toStringYesNo((Boolean) null)); assertEquals("yes", BooleanUtils.toStringYesNo(Boolean.TRUE)); assertEquals("no", BooleanUtils.toStringYesNo(Boolean.FALSE)); } @Test public void test_toString_Boolean_String_String_String() { assertEquals("U", BooleanUtils.toString((Boolean) null, "Y", "N", "U")); assertEquals("Y", BooleanUtils.toString(Boolean.TRUE, "Y", "N", "U")); assertEquals("N", BooleanUtils.toString(Boolean.FALSE, "Y", "N", "U")); } //----------------------------------------------------------------------- @Test public void test_toStringTrueFalse_boolean() { assertEquals("true", BooleanUtils.toStringTrueFalse(true)); assertEquals("false", BooleanUtils.toStringTrueFalse(false)); } @Test public void test_toStringOnOff_boolean() { assertEquals("on", BooleanUtils.toStringOnOff(true)); assertEquals("off", BooleanUtils.toStringOnOff(false)); } @Test public void test_toStringYesNo_boolean() { assertEquals("yes", BooleanUtils.toStringYesNo(true)); assertEquals("no", BooleanUtils.toStringYesNo(false)); } @Test public void test_toString_boolean_String_String_String() { assertEquals("Y", BooleanUtils.toString(true, "Y", "N")); assertEquals("N", BooleanUtils.toString(false, "Y", "N")); } // testXor // ----------------------------------------------------------------------- @Test(expected = IllegalArgumentException.class) public void testXor_primitive_nullInput() { BooleanUtils.xor((boolean[]) null); } @Test(expected = IllegalArgumentException.class) public void testXor_primitive_emptyInput() { BooleanUtils.xor(new boolean[] {}); } @Test public void testXor_primitive_validInput_2items() { assertTrue( "True result for (true, true)", ! BooleanUtils.xor(new boolean[] { true, true })); assertTrue( "True result for (false, false)", ! BooleanUtils.xor(new boolean[] { false, false })); assertTrue( "False result for (true, false)", BooleanUtils.xor(new boolean[] { true, false })); assertTrue( "False result for (false, true)", BooleanUtils.xor(new boolean[] { false, true })); } @Test public void testXor_primitive_validInput_3items() { assertTrue( "False result for (false, false, true)", BooleanUtils.xor(new boolean[] { false, false, true })); assertTrue( "False result for (false, true, false)", BooleanUtils.xor(new boolean[] { false, true, false })); assertTrue( "False result for (true, false, false)", BooleanUtils.xor(new boolean[] { true, false, false })); assertTrue( "True result for (true, true, true)", ! BooleanUtils.xor(new boolean[] { true, true, true })); assertTrue( "True result for (false, false)", ! BooleanUtils.xor(new boolean[] { false, false, false })); assertTrue( "True result for (true, true, false)", ! BooleanUtils.xor(new boolean[] { true, true, false })); assertTrue( "True result for (true, false, true)", ! BooleanUtils.xor(new boolean[] { true, false, true })); assertTrue( "False result for (false, true, true)", ! BooleanUtils.xor(new boolean[] { false, true, true })); } @Test(expected = IllegalArgumentException.class) public void testXor_object_nullInput() { BooleanUtils.xor((Boolean[]) null); } @Test(expected = IllegalArgumentException.class) public void testXor_object_emptyInput() { BooleanUtils.xor(new Boolean[] {}); } @Test(expected = IllegalArgumentException.class) public void testXor_object_nullElementInput() { BooleanUtils.xor(new Boolean[] {null}); } @Test public void testXor_object_validInput_2items() { assertTrue( "True result for (true, true)", ! BooleanUtils .xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, false)", ! BooleanUtils .xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, false)", BooleanUtils .xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (false, true)", BooleanUtils .xor(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) .booleanValue()); } @Test public void testXor_object_validInput_3items() { assertTrue( "False result for (false, false, true)", BooleanUtils .xor( new Boolean[] { Boolean.FALSE, Boolean.FALSE, Boolean.TRUE }) .booleanValue()); assertTrue( "False result for (false, true, false)", BooleanUtils .xor( new Boolean[] { Boolean.FALSE, Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, false, false)", BooleanUtils .xor( new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, true, true)", ! BooleanUtils .xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, false)", ! BooleanUtils.xor( new Boolean[] { Boolean.FALSE, Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, true, false)", ! BooleanUtils.xor( new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, false, true)", ! BooleanUtils.xor( new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.TRUE }) .booleanValue()); assertTrue( "False result for (false, true, true)", ! BooleanUtils.xor( new Boolean[] { Boolean.FALSE, Boolean.TRUE, Boolean.TRUE }) .booleanValue()); } // testAnd // ----------------------------------------------------------------------- @Test(expected = IllegalArgumentException.class) public void testAnd_primitive_nullInput() { BooleanUtils.and((boolean[]) null); } @Test(expected = IllegalArgumentException.class) public void testAnd_primitive_emptyInput() { BooleanUtils.and(new boolean[] {}); } @Test public void testAnd_primitive_validInput_2items() { assertTrue( "False result for (true, true)", BooleanUtils.and(new boolean[] { true, true })); assertTrue( "True result for (false, false)", ! BooleanUtils.and(new boolean[] { false, false })); assertTrue( "True result for (true, false)", ! BooleanUtils.and(new boolean[] { true, false })); assertTrue( "True result for (false, true)", ! BooleanUtils.and(new boolean[] { false, true })); } @Test public void testAnd_primitive_validInput_3items() { assertTrue( "True result for (false, false, true)", ! BooleanUtils.and(new boolean[] { false, false, true })); assertTrue( "True result for (false, true, false)", ! BooleanUtils.and(new boolean[] { false, true, false })); assertTrue( "True result for (true, false, false)", ! BooleanUtils.and(new boolean[] { true, false, false })); assertTrue( "False result for (true, true, true)", BooleanUtils.and(new boolean[] { true, true, true })); assertTrue( "True result for (false, false)", ! BooleanUtils.and(new boolean[] { false, false, false })); assertTrue( "True result for (true, true, false)", ! BooleanUtils.and(new boolean[] { true, true, false })); assertTrue( "True result for (true, false, true)", ! BooleanUtils.and(new boolean[] { true, false, true })); assertTrue( "True result for (false, true, true)", ! BooleanUtils.and(new boolean[] { false, true, true })); } @Test(expected = IllegalArgumentException.class) public void testAnd_object_nullInput() { BooleanUtils.and((Boolean[]) null); } @Test(expected = IllegalArgumentException.class) public void testAnd_object_emptyInput() { BooleanUtils.and(new Boolean[] {}); } @Test(expected = IllegalArgumentException.class) public void testAnd_object_nullElementInput() { BooleanUtils.and(new Boolean[] {null}); } @Test public void testAnd_object_validInput_2items() { assertTrue( "False result for (true, true)", BooleanUtils .and(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, false)", ! BooleanUtils .and(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, false)", ! BooleanUtils .and(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (false, true)", ! BooleanUtils .and(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) .booleanValue()); } @Test public void testAnd_object_validInput_3items() { assertTrue( "True result for (false, false, true)", ! BooleanUtils .and( new Boolean[] { Boolean.FALSE, Boolean.FALSE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, true, false)", ! BooleanUtils .and( new Boolean[] { Boolean.FALSE, Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, false, false)", ! BooleanUtils .and( new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, true, true)", BooleanUtils .and(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, false)", ! BooleanUtils.and( new Boolean[] { Boolean.FALSE, Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, true, false)", ! BooleanUtils.and( new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "True result for (true, false, true)", ! BooleanUtils.and( new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, true, true)", ! BooleanUtils.and( new Boolean[] { Boolean.FALSE, Boolean.TRUE, Boolean.TRUE }) .booleanValue()); } // testOr // ----------------------------------------------------------------------- @Test(expected = IllegalArgumentException.class) public void testOr_primitive_nullInput() { BooleanUtils.or((boolean[]) null); } @Test(expected = IllegalArgumentException.class) public void testOr_primitive_emptyInput() { BooleanUtils.or(new boolean[] {}); } @Test public void testOr_primitive_validInput_2items() { assertTrue( "False result for (true, true)", BooleanUtils.or(new boolean[] { true, true })); assertTrue( "True result for (false, false)", ! BooleanUtils.or(new boolean[] { false, false })); assertTrue( "False result for (true, false)", BooleanUtils.or(new boolean[] { true, false })); assertTrue( "False result for (false, true)", BooleanUtils.or(new boolean[] { false, true })); } @Test public void testOr_primitive_validInput_3items() { assertTrue( "False result for (false, false, true)", BooleanUtils.or(new boolean[] { false, false, true })); assertTrue( "False result for (false, true, false)", BooleanUtils.or(new boolean[] { false, true, false })); assertTrue( "False result for (true, false, false)", BooleanUtils.or(new boolean[] { true, false, false })); assertTrue( "False result for (true, true, true)", BooleanUtils.or(new boolean[] { true, true, true })); assertTrue( "True result for (false, false)", ! BooleanUtils.or(new boolean[] { false, false, false })); assertTrue( "False result for (true, true, false)", BooleanUtils.or(new boolean[] { true, true, false })); assertTrue( "False result for (true, false, true)", BooleanUtils.or(new boolean[] { true, false, true })); assertTrue( "False result for (false, true, true)", BooleanUtils.or(new boolean[] { false, true, true })); } @Test(expected = IllegalArgumentException.class) public void testOr_object_nullInput() { BooleanUtils.or((Boolean[]) null); } @Test(expected = IllegalArgumentException.class) public void testOr_object_emptyInput() { BooleanUtils.or(new Boolean[] {}); } @Test(expected = IllegalArgumentException.class) public void testOr_object_nullElementInput() { BooleanUtils.or(new Boolean[] {null}); } @Test public void testOr_object_validInput_2items() { assertTrue( "False result for (true, true)", BooleanUtils .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, false)", ! BooleanUtils .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, false)", BooleanUtils .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (false, true)", BooleanUtils .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE }) .booleanValue()); } @Test public void testOr_object_validInput_3items() { assertTrue( "False result for (false, false, true)", BooleanUtils .or( new Boolean[] { Boolean.FALSE, Boolean.FALSE, Boolean.TRUE }) .booleanValue()); assertTrue( "False result for (false, true, false)", BooleanUtils .or( new Boolean[] { Boolean.FALSE, Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, false, false)", BooleanUtils .or( new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, true, true)", BooleanUtils .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE }) .booleanValue()); assertTrue( "True result for (false, false)", ! BooleanUtils.or( new Boolean[] { Boolean.FALSE, Boolean.FALSE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, true, false)", BooleanUtils.or( new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.FALSE }) .booleanValue()); assertTrue( "False result for (true, false, true)", BooleanUtils.or( new Boolean[] { Boolean.TRUE, Boolean.FALSE, Boolean.TRUE }) .booleanValue()); assertTrue( "False result for (false, true, true)", BooleanUtils.or( new Boolean[] { Boolean.FALSE, Boolean.TRUE, Boolean.TRUE }) .booleanValue()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.apache.commons.lang3.JavaVersion.JAVA_1_1; import static org.apache.commons.lang3.JavaVersion.JAVA_1_2; import static org.apache.commons.lang3.JavaVersion.JAVA_1_3; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import org.junit.Test; /** * Tests CharEncoding. * * @see CharEncoding * @version $Id$ */ public class CharEncodingTest { private void assertSupportedEncoding(final String name) { assertTrue("Encoding should be supported: " + name, CharEncoding.isSupported(name)); } /** * The class can be instantiated. */ @Test public void testConstructor() { new CharEncoding(); } @Test public void testMustBeSupportedJava1_3_1() { if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) { this.assertSupportedEncoding(CharEncoding.ISO_8859_1); this.assertSupportedEncoding(CharEncoding.US_ASCII); this.assertSupportedEncoding(CharEncoding.UTF_16); this.assertSupportedEncoding(CharEncoding.UTF_16BE); this.assertSupportedEncoding(CharEncoding.UTF_16LE); this.assertSupportedEncoding(CharEncoding.UTF_8); } else { this.warn("Java 1.3 tests not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); } } @Test public void testSupported() { assertTrue(CharEncoding.isSupported("UTF8")); assertTrue(CharEncoding.isSupported("UTF-8")); assertTrue(CharEncoding.isSupported("ASCII")); } @Test public void testNotSupported() { assertFalse(CharEncoding.isSupported(null)); assertFalse(CharEncoding.isSupported("")); assertFalse(CharEncoding.isSupported(" ")); assertFalse(CharEncoding.isSupported("\t\r\n")); assertFalse(CharEncoding.isSupported("DOESNOTEXIST")); assertFalse(CharEncoding.isSupported("this is not a valid encoding name")); } @Test public void testWorksOnJava1_1_8() { // // In this test, I simply deleted the encodings from the 1.3.1 list. // The Javadoc do not specify which encodings are required. // if (SystemUtils.isJavaVersionAtLeast(JAVA_1_1)) { this.assertSupportedEncoding(CharEncoding.ISO_8859_1); this.assertSupportedEncoding(CharEncoding.US_ASCII); this.assertSupportedEncoding(CharEncoding.UTF_8); } else { this.warn("Java 1.1 tests not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); } } @Test public void testWorksOnJava1_2_2() { // // In this test, I simply deleted the encodings from the 1.3.1 list. // The Javadoc do not specify which encodings are required. // if (SystemUtils.isJavaVersionAtLeast(JAVA_1_2)) { this.assertSupportedEncoding(CharEncoding.ISO_8859_1); this.assertSupportedEncoding(CharEncoding.US_ASCII); this.assertSupportedEncoding(CharEncoding.UTF_8); } else { this.warn("Java 1.2 tests not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); } } void warn(final String msg) { System.err.println(msg); } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Modifier; import java.util.Iterator; import java.util.NoSuchElementException; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.CharRange}. * * @version $Id$ */ public class CharRangeTest { //----------------------------------------------------------------------- @Test public void testClass() { // class changed to non-public in 3.0 assertFalse(Modifier.isPublic(CharRange.class.getModifiers())); assertTrue(Modifier.isFinal(CharRange.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testConstructorAccessors_is() { final CharRange rangea = CharRange.is('a'); assertEquals('a', rangea.getStart()); assertEquals('a', rangea.getEnd()); assertFalse(rangea.isNegated()); assertEquals("a", rangea.toString()); } @Test public void testConstructorAccessors_isNot() { final CharRange rangea = CharRange.isNot('a'); assertEquals('a', rangea.getStart()); assertEquals('a', rangea.getEnd()); assertTrue(rangea.isNegated()); assertEquals("^a", rangea.toString()); } @Test public void testConstructorAccessors_isIn_Same() { final CharRange rangea = CharRange.isIn('a', 'a'); assertEquals('a', rangea.getStart()); assertEquals('a', rangea.getEnd()); assertFalse(rangea.isNegated()); assertEquals("a", rangea.toString()); } @Test public void testConstructorAccessors_isIn_Normal() { final CharRange rangea = CharRange.isIn('a', 'e'); assertEquals('a', rangea.getStart()); assertEquals('e', rangea.getEnd()); assertFalse(rangea.isNegated()); assertEquals("a-e", rangea.toString()); } @Test public void testConstructorAccessors_isIn_Reversed() { final CharRange rangea = CharRange.isIn('e', 'a'); assertEquals('a', rangea.getStart()); assertEquals('e', rangea.getEnd()); assertFalse(rangea.isNegated()); assertEquals("a-e", rangea.toString()); } @Test public void testConstructorAccessors_isNotIn_Same() { final CharRange rangea = CharRange.isNotIn('a', 'a'); assertEquals('a', rangea.getStart()); assertEquals('a', rangea.getEnd()); assertTrue(rangea.isNegated()); assertEquals("^a", rangea.toString()); } @Test public void testConstructorAccessors_isNotIn_Normal() { final CharRange rangea = CharRange.isNotIn('a', 'e'); assertEquals('a', rangea.getStart()); assertEquals('e', rangea.getEnd()); assertTrue(rangea.isNegated()); assertEquals("^a-e", rangea.toString()); } @Test public void testConstructorAccessors_isNotIn_Reversed() { final CharRange rangea = CharRange.isNotIn('e', 'a'); assertEquals('a', rangea.getStart()); assertEquals('e', rangea.getEnd()); assertTrue(rangea.isNegated()); assertEquals("^a-e", rangea.toString()); } //----------------------------------------------------------------------- @Test public void testEquals_Object() { final CharRange rangea = CharRange.is('a'); final CharRange rangeae = CharRange.isIn('a', 'e'); final CharRange rangenotbf = CharRange.isIn('b', 'f'); assertFalse(rangea.equals(null)); assertTrue(rangea.equals(rangea)); assertTrue(rangea.equals(CharRange.is('a'))); assertTrue(rangeae.equals(rangeae)); assertTrue(rangeae.equals(CharRange.isIn('a', 'e'))); assertTrue(rangenotbf.equals(rangenotbf)); assertTrue(rangenotbf.equals(CharRange.isIn('b', 'f'))); assertFalse(rangea.equals(rangeae)); assertFalse(rangea.equals(rangenotbf)); assertFalse(rangeae.equals(rangea)); assertFalse(rangeae.equals(rangenotbf)); assertFalse(rangenotbf.equals(rangea)); assertFalse(rangenotbf.equals(rangeae)); } @Test public void testHashCode() { final CharRange rangea = CharRange.is('a'); final CharRange rangeae = CharRange.isIn('a', 'e'); final CharRange rangenotbf = CharRange.isIn('b', 'f'); assertTrue(rangea.hashCode() == rangea.hashCode()); assertTrue(rangea.hashCode() == CharRange.is('a').hashCode()); assertTrue(rangeae.hashCode() == rangeae.hashCode()); assertTrue(rangeae.hashCode() == CharRange.isIn('a', 'e').hashCode()); assertTrue(rangenotbf.hashCode() == rangenotbf.hashCode()); assertTrue(rangenotbf.hashCode() == CharRange.isIn('b', 'f').hashCode()); assertFalse(rangea.hashCode() == rangeae.hashCode()); assertFalse(rangea.hashCode() == rangenotbf.hashCode()); assertFalse(rangeae.hashCode() == rangea.hashCode()); assertFalse(rangeae.hashCode() == rangenotbf.hashCode()); assertFalse(rangenotbf.hashCode() == rangea.hashCode()); assertFalse(rangenotbf.hashCode() == rangeae.hashCode()); } //----------------------------------------------------------------------- @Test public void testContains_Char() { CharRange range = CharRange.is('c'); assertFalse(range.contains('b')); assertTrue(range.contains('c')); assertFalse(range.contains('d')); assertFalse(range.contains('e')); range = CharRange.isIn('c', 'd'); assertFalse(range.contains('b')); assertTrue(range.contains('c')); assertTrue(range.contains('d')); assertFalse(range.contains('e')); range = CharRange.isIn('d', 'c'); assertFalse(range.contains('b')); assertTrue(range.contains('c')); assertTrue(range.contains('d')); assertFalse(range.contains('e')); range = CharRange.isNotIn('c', 'd'); assertTrue(range.contains('b')); assertFalse(range.contains('c')); assertFalse(range.contains('d')); assertTrue(range.contains('e')); assertTrue(range.contains((char) 0)); assertTrue(range.contains(Character.MAX_VALUE)); } //----------------------------------------------------------------------- @Test public void testContains_Charrange() { final CharRange a = CharRange.is('a'); final CharRange b = CharRange.is('b'); final CharRange c = CharRange.is('c'); final CharRange c2 = CharRange.is('c'); final CharRange d = CharRange.is('d'); final CharRange e = CharRange.is('e'); final CharRange cd = CharRange.isIn('c', 'd'); final CharRange bd = CharRange.isIn('b', 'd'); final CharRange bc = CharRange.isIn('b', 'c'); final CharRange ab = CharRange.isIn('a', 'b'); final CharRange de = CharRange.isIn('d', 'e'); final CharRange ef = CharRange.isIn('e', 'f'); final CharRange ae = CharRange.isIn('a', 'e'); // normal/normal assertFalse(c.contains(b)); assertTrue(c.contains(c)); assertTrue(c.contains(c2)); assertFalse(c.contains(d)); assertFalse(c.contains(cd)); assertFalse(c.contains(bd)); assertFalse(c.contains(bc)); assertFalse(c.contains(ab)); assertFalse(c.contains(de)); assertTrue(cd.contains(c)); assertTrue(bd.contains(c)); assertTrue(bc.contains(c)); assertFalse(ab.contains(c)); assertFalse(de.contains(c)); assertTrue(ae.contains(b)); assertTrue(ae.contains(ab)); assertTrue(ae.contains(bc)); assertTrue(ae.contains(cd)); assertTrue(ae.contains(de)); final CharRange notb = CharRange.isNot('b'); final CharRange notc = CharRange.isNot('c'); final CharRange notd = CharRange.isNot('d'); final CharRange notab = CharRange.isNotIn('a', 'b'); final CharRange notbc = CharRange.isNotIn('b', 'c'); final CharRange notbd = CharRange.isNotIn('b', 'd'); final CharRange notcd = CharRange.isNotIn('c', 'd'); final CharRange notde = CharRange.isNotIn('d', 'e'); final CharRange notae = CharRange.isNotIn('a', 'e'); final CharRange all = CharRange.isIn((char) 0, Character.MAX_VALUE); final CharRange allbutfirst = CharRange.isIn((char) 1, Character.MAX_VALUE); // normal/negated assertFalse(c.contains(notc)); assertFalse(c.contains(notbd)); assertTrue(all.contains(notc)); assertTrue(all.contains(notbd)); assertFalse(allbutfirst.contains(notc)); assertFalse(allbutfirst.contains(notbd)); // negated/normal assertTrue(notc.contains(a)); assertTrue(notc.contains(b)); assertFalse(notc.contains(c)); assertTrue(notc.contains(d)); assertTrue(notc.contains(e)); assertTrue(notc.contains(ab)); assertFalse(notc.contains(bc)); assertFalse(notc.contains(bd)); assertFalse(notc.contains(cd)); assertTrue(notc.contains(de)); assertFalse(notc.contains(ae)); assertFalse(notc.contains(all)); assertFalse(notc.contains(allbutfirst)); assertTrue(notbd.contains(a)); assertFalse(notbd.contains(b)); assertFalse(notbd.contains(c)); assertFalse(notbd.contains(d)); assertTrue(notbd.contains(e)); assertTrue(notcd.contains(ab)); assertFalse(notcd.contains(bc)); assertFalse(notcd.contains(bd)); assertFalse(notcd.contains(cd)); assertFalse(notcd.contains(de)); assertFalse(notcd.contains(ae)); assertTrue(notcd.contains(ef)); assertFalse(notcd.contains(all)); assertFalse(notcd.contains(allbutfirst)); // negated/negated assertFalse(notc.contains(notb)); assertTrue(notc.contains(notc)); assertFalse(notc.contains(notd)); assertFalse(notc.contains(notab)); assertTrue(notc.contains(notbc)); assertTrue(notc.contains(notbd)); assertTrue(notc.contains(notcd)); assertFalse(notc.contains(notde)); assertFalse(notbd.contains(notb)); assertFalse(notbd.contains(notc)); assertFalse(notbd.contains(notd)); assertFalse(notbd.contains(notab)); assertFalse(notbd.contains(notbc)); assertTrue(notbd.contains(notbd)); assertFalse(notbd.contains(notcd)); assertFalse(notbd.contains(notde)); assertTrue(notbd.contains(notae)); } @Test public void testContainsNullArg() { final CharRange range = CharRange.is('a'); try { @SuppressWarnings("unused") final boolean contains = range.contains(null); } catch(final IllegalArgumentException e) { assertEquals("The Range must not be null", e.getMessage()); } } @Test public void testIterator() { final CharRange a = CharRange.is('a'); final CharRange ad = CharRange.isIn('a', 'd'); final CharRange nota = CharRange.isNot('a'); final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE); final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE); final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1)); final Iterator<Character> aIt = a.iterator(); assertNotNull(aIt); assertTrue(aIt.hasNext()); assertEquals(Character.valueOf('a'), aIt.next()); assertFalse(aIt.hasNext()); final Iterator<Character> adIt = ad.iterator(); assertNotNull(adIt); assertTrue(adIt.hasNext()); assertEquals(Character.valueOf('a'), adIt.next()); assertEquals(Character.valueOf('b'), adIt.next()); assertEquals(Character.valueOf('c'), adIt.next()); assertEquals(Character.valueOf('d'), adIt.next()); assertFalse(adIt.hasNext()); final Iterator<Character> notaIt = nota.iterator(); assertNotNull(notaIt); assertTrue(notaIt.hasNext()); while (notaIt.hasNext()) { final Character c = notaIt.next(); assertFalse('a' == c.charValue()); } final Iterator<Character> emptySetIt = emptySet.iterator(); assertNotNull(emptySetIt); assertFalse(emptySetIt.hasNext()); try { emptySetIt.next(); fail("Should throw NoSuchElementException"); } catch (final NoSuchElementException e) { assertTrue(true); } final Iterator<Character> notFirstIt = notFirst.iterator(); assertNotNull(notFirstIt); assertTrue(notFirstIt.hasNext()); assertEquals(Character.valueOf((char) 0), notFirstIt.next()); assertFalse(notFirstIt.hasNext()); try { notFirstIt.next(); fail("Should throw NoSuchElementException"); } catch (final NoSuchElementException e) { assertTrue(true); } final Iterator<Character> notLastIt = notLast.iterator(); assertNotNull(notLastIt); assertTrue(notLastIt.hasNext()); assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next()); assertFalse(notLastIt.hasNext()); try { notLastIt.next(); fail("Should throw NoSuchElementException"); } catch (final NoSuchElementException e) { assertTrue(true); } } //----------------------------------------------------------------------- @Test public void testSerialization() { CharRange range = CharRange.is('a'); assertEquals(range, SerializationUtils.clone(range)); range = CharRange.isIn('a', 'e'); assertEquals(range, SerializationUtils.clone(range)); range = CharRange.isNotIn('a', 'e'); assertEquals(range, SerializationUtils.clone(range)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import org.junit.Assert; import org.junit.Test; /** * Tests CharSequenceUtils * * @version $Id: CharSequenceUtilsTest.java 1066341 2011-02-02 06:21:53Z bayard $ */ public class CharSequenceUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new CharSequenceUtils()); final Constructor<?>[] cons = CharSequenceUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(CharSequenceUtils.class.getModifiers())); assertFalse(Modifier.isFinal(CharSequenceUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testSubSequence() { // // null input // Assert.assertEquals(null, CharSequenceUtils.subSequence(null, -1)); Assert.assertEquals(null, CharSequenceUtils.subSequence(null, 0)); Assert.assertEquals(null, CharSequenceUtils.subSequence(null, 1)); // // non-null input // Assert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(StringUtils.EMPTY, 0)); Assert.assertEquals("012", CharSequenceUtils.subSequence("012", 0)); Assert.assertEquals("12", CharSequenceUtils.subSequence("012", 1)); Assert.assertEquals("2", CharSequenceUtils.subSequence("012", 2)); Assert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence("012", 3)); // // Exception expected // try { Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, -1)); Assert.fail("Expected " + IndexOutOfBoundsException.class.getName()); } catch (final IndexOutOfBoundsException e) { // Expected } try { Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, 1)); Assert.fail("Expected " + IndexOutOfBoundsException.class.getName()); } catch (final IndexOutOfBoundsException e) { // Expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import java.lang.reflect.Modifier; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.CharSet}. * * @version $Id$ */ public class CharSetTest { //----------------------------------------------------------------------- @Test public void testClass() { assertTrue(Modifier.isPublic(CharSet.class.getModifiers())); assertFalse(Modifier.isFinal(CharSet.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testGetInstance() { assertSame(CharSet.EMPTY, CharSet.getInstance( (String) null)); assertSame(CharSet.EMPTY, CharSet.getInstance("")); assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance("a-zA-Z")); assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance("A-Za-z")); assertSame(CharSet.ASCII_ALPHA_LOWER, CharSet.getInstance("a-z")); assertSame(CharSet.ASCII_ALPHA_UPPER, CharSet.getInstance("A-Z")); assertSame(CharSet.ASCII_NUMERIC, CharSet.getInstance("0-9")); } //----------------------------------------------------------------------- @Test public void testGetInstance_Stringarray() { assertEquals(null, CharSet.getInstance((String[]) null)); assertEquals("[]", CharSet.getInstance(new String[0]).toString()); assertEquals("[]", CharSet.getInstance(new String[] {null}).toString()); assertEquals("[a-e]", CharSet.getInstance(new String[] {"a-e"}).toString()); } //----------------------------------------------------------------------- @Test public void testConstructor_String_simple() { CharSet set; CharRange[] array; set = CharSet.getInstance((String) null); array = set.getCharRanges(); assertEquals("[]", set.toString()); assertEquals(0, array.length); set = CharSet.getInstance(""); array = set.getCharRanges(); assertEquals("[]", set.toString()); assertEquals(0, array.length); set = CharSet.getInstance("a"); array = set.getCharRanges(); assertEquals("[a]", set.toString()); assertEquals(1, array.length); assertEquals("a", array[0].toString()); set = CharSet.getInstance("^a"); array = set.getCharRanges(); assertEquals("[^a]", set.toString()); assertEquals(1, array.length); assertEquals("^a", array[0].toString()); set = CharSet.getInstance("a-e"); array = set.getCharRanges(); assertEquals("[a-e]", set.toString()); assertEquals(1, array.length); assertEquals("a-e", array[0].toString()); set = CharSet.getInstance("^a-e"); array = set.getCharRanges(); assertEquals("[^a-e]", set.toString()); assertEquals(1, array.length); assertEquals("^a-e", array[0].toString()); } @Test public void testConstructor_String_combo() { CharSet set; CharRange[] array; set = CharSet.getInstance("abc"); array = set.getCharRanges(); assertEquals(3, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); assertTrue(ArrayUtils.contains(array, CharRange.is('b'))); assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); set = CharSet.getInstance("a-ce-f"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', 'c'))); assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f'))); set = CharSet.getInstance("ae-f"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f'))); set = CharSet.getInstance("e-fa"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f'))); set = CharSet.getInstance("ae-fm-pz"); array = set.getCharRanges(); assertEquals(4, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f'))); assertTrue(ArrayUtils.contains(array, CharRange.isIn('m', 'p'))); assertTrue(ArrayUtils.contains(array, CharRange.is('z'))); } @Test public void testConstructor_String_comboNegated() { CharSet set; CharRange[] array; set = CharSet.getInstance("^abc"); array = set.getCharRanges(); assertEquals(3, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('a'))); assertTrue(ArrayUtils.contains(array, CharRange.is('b'))); assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); set = CharSet.getInstance("b^ac"); array = set.getCharRanges(); assertEquals(3, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('b'))); assertTrue(ArrayUtils.contains(array, CharRange.isNot('a'))); assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); set = CharSet.getInstance("db^ac"); array = set.getCharRanges(); assertEquals(4, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('d'))); assertTrue(ArrayUtils.contains(array, CharRange.is('b'))); assertTrue(ArrayUtils.contains(array, CharRange.isNot('a'))); assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); set = CharSet.getInstance("^b^a"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('b'))); assertTrue(ArrayUtils.contains(array, CharRange.isNot('a'))); set = CharSet.getInstance("b^a-c^z"); array = set.getCharRanges(); assertEquals(3, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('a', 'c'))); assertTrue(ArrayUtils.contains(array, CharRange.isNot('z'))); assertTrue(ArrayUtils.contains(array, CharRange.is('b'))); } @Test public void testConstructor_String_oddDash() { CharSet set; CharRange[] array; set = CharSet.getInstance("-"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); set = CharSet.getInstance("--"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); set = CharSet.getInstance("---"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); set = CharSet.getInstance("----"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); set = CharSet.getInstance("-a"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); set = CharSet.getInstance("a-"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); set = CharSet.getInstance("a--"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', '-'))); set = CharSet.getInstance("--a"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('-', 'a'))); } @Test public void testConstructor_String_oddNegate() { CharSet set; CharRange[] array; set = CharSet.getInstance("^"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('^'))); // "^" set = CharSet.getInstance("^^"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^" set = CharSet.getInstance("^^^"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^" assertTrue(ArrayUtils.contains(array, CharRange.is('^'))); // "^" set = CharSet.getInstance("^^^^"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^" x2 set = CharSet.getInstance("a^"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); // "a" assertTrue(ArrayUtils.contains(array, CharRange.is('^'))); // "^" set = CharSet.getInstance("^a-"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('a'))); // "^a" assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); // "-" set = CharSet.getInstance("^^-c"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('^', 'c'))); // "^^-c" set = CharSet.getInstance("^c-^"); array = set.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('c', '^'))); // "^c-^" set = CharSet.getInstance("^c-^d"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('c', '^'))); // "^c-^" assertTrue(ArrayUtils.contains(array, CharRange.is('d'))); // "d" set = CharSet.getInstance("^^-"); array = set.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^" assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); // "-" } @Test public void testConstructor_String_oddCombinations() { CharSet set; CharRange[] array = null; set = CharSet.getInstance("a-^c"); array = set.getCharRanges(); assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', '^'))); // "a-^" assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); // "c" assertFalse(set.contains('b')); assertTrue(set.contains('^')); assertTrue(set.contains('_')); // between ^ and a assertTrue(set.contains('c')); set = CharSet.getInstance("^a-^c"); array = set.getCharRanges(); assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('a', '^'))); // "^a-^" assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); // "c" assertTrue(set.contains('b')); assertFalse(set.contains('^')); assertFalse(set.contains('_')); // between ^ and a set = CharSet.getInstance("a- ^-- "); //contains everything array = set.getCharRanges(); assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', ' '))); // "a- " assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('-', ' '))); // "^-- " assertTrue(set.contains('#')); assertTrue(set.contains('^')); assertTrue(set.contains('a')); assertTrue(set.contains('*')); assertTrue(set.contains('A')); set = CharSet.getInstance("^-b"); array = set.getCharRanges(); assertTrue(ArrayUtils.contains(array, CharRange.isIn('^','b'))); // "^-b" assertTrue(set.contains('b')); assertTrue(set.contains('_')); // between ^ and a assertFalse(set.contains('A')); assertTrue(set.contains('^')); set = CharSet.getInstance("b-^"); array = set.getCharRanges(); assertTrue(ArrayUtils.contains(array, CharRange.isIn('^','b'))); // "b-^" assertTrue(set.contains('b')); assertTrue(set.contains('^')); assertTrue(set.contains('a')); // between ^ and b assertFalse(set.contains('c')); } //----------------------------------------------------------------------- @Test public void testEquals_Object() { final CharSet abc = CharSet.getInstance("abc"); final CharSet abc2 = CharSet.getInstance("abc"); final CharSet atoc = CharSet.getInstance("a-c"); final CharSet atoc2 = CharSet.getInstance("a-c"); final CharSet notatoc = CharSet.getInstance("^a-c"); final CharSet notatoc2 = CharSet.getInstance("^a-c"); assertFalse(abc.equals(null)); assertTrue(abc.equals(abc)); assertTrue(abc.equals(abc2)); assertFalse(abc.equals(atoc)); assertFalse(abc.equals(notatoc)); assertFalse(atoc.equals(abc)); assertTrue(atoc.equals(atoc)); assertTrue(atoc.equals(atoc2)); assertFalse(atoc.equals(notatoc)); assertFalse(notatoc.equals(abc)); assertFalse(notatoc.equals(atoc)); assertTrue(notatoc.equals(notatoc)); assertTrue(notatoc.equals(notatoc2)); } @Test public void testHashCode() { final CharSet abc = CharSet.getInstance("abc"); final CharSet abc2 = CharSet.getInstance("abc"); final CharSet atoc = CharSet.getInstance("a-c"); final CharSet atoc2 = CharSet.getInstance("a-c"); final CharSet notatoc = CharSet.getInstance("^a-c"); final CharSet notatoc2 = CharSet.getInstance("^a-c"); assertEquals(abc.hashCode(), abc.hashCode()); assertEquals(abc.hashCode(), abc2.hashCode()); assertEquals(atoc.hashCode(), atoc.hashCode()); assertEquals(atoc.hashCode(), atoc2.hashCode()); assertEquals(notatoc.hashCode(), notatoc.hashCode()); assertEquals(notatoc.hashCode(), notatoc2.hashCode()); } //----------------------------------------------------------------------- @Test public void testContains_Char() { final CharSet btod = CharSet.getInstance("b-d"); final CharSet dtob = CharSet.getInstance("d-b"); final CharSet bcd = CharSet.getInstance("bcd"); final CharSet bd = CharSet.getInstance("bd"); final CharSet notbtod = CharSet.getInstance("^b-d"); assertFalse(btod.contains('a')); assertTrue(btod.contains('b')); assertTrue(btod.contains('c')); assertTrue(btod.contains('d')); assertFalse(btod.contains('e')); assertFalse(bcd.contains('a')); assertTrue(bcd.contains('b')); assertTrue(bcd.contains('c')); assertTrue(bcd.contains('d')); assertFalse(bcd.contains('e')); assertFalse(bd.contains('a')); assertTrue(bd.contains('b')); assertFalse(bd.contains('c')); assertTrue(bd.contains('d')); assertFalse(bd.contains('e')); assertTrue(notbtod.contains('a')); assertFalse(notbtod.contains('b')); assertFalse(notbtod.contains('c')); assertFalse(notbtod.contains('d')); assertTrue(notbtod.contains('e')); assertFalse(dtob.contains('a')); assertTrue(dtob.contains('b')); assertTrue(dtob.contains('c')); assertTrue(dtob.contains('d')); assertFalse(dtob.contains('e')); final CharRange[] array = dtob.getCharRanges(); assertEquals("[b-d]", dtob.toString()); assertEquals(1, array.length); } //----------------------------------------------------------------------- @Test public void testSerialization() { CharSet set = CharSet.getInstance("a"); assertEquals(set, SerializationUtils.clone(set)); set = CharSet.getInstance("a-e"); assertEquals(set, SerializationUtils.clone(set)); set = CharSet.getInstance("be-f^a-z"); assertEquals(set, SerializationUtils.clone(set)); } //----------------------------------------------------------------------- @Test public void testStatics() { CharRange[] array; array = CharSet.EMPTY.getCharRanges(); assertEquals(0, array.length); array = CharSet.ASCII_ALPHA.getCharRanges(); assertEquals(2, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', 'z'))); assertTrue(ArrayUtils.contains(array, CharRange.isIn('A', 'Z'))); array = CharSet.ASCII_ALPHA_LOWER.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', 'z'))); array = CharSet.ASCII_ALPHA_UPPER.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('A', 'Z'))); array = CharSet.ASCII_NUMERIC.getCharRanges(); assertEquals(1, array.length); assertTrue(ArrayUtils.contains(array, CharRange.isIn('0', '9'))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.CharSetUtils}. * * @version $Id$ */ public class CharSetUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new CharSetUtils()); final Constructor<?>[] cons = CharSetUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(CharSetUtils.class.getModifiers())); assertFalse(Modifier.isFinal(CharSetUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testSqueeze_StringString() { assertEquals(null, CharSetUtils.squeeze(null, (String) null)); assertEquals(null, CharSetUtils.squeeze(null, "")); assertEquals("", CharSetUtils.squeeze("", (String) null)); assertEquals("", CharSetUtils.squeeze("", "")); assertEquals("", CharSetUtils.squeeze("", "a-e")); assertEquals("hello", CharSetUtils.squeeze("hello", (String) null)); assertEquals("hello", CharSetUtils.squeeze("hello", "")); assertEquals("hello", CharSetUtils.squeeze("hello", "a-e")); assertEquals("helo", CharSetUtils.squeeze("hello", "l-p")); assertEquals("heloo", CharSetUtils.squeeze("helloo", "l")); assertEquals("hello", CharSetUtils.squeeze("helloo", "^l")); } @Test public void testSqueeze_StringStringarray() { assertEquals(null, CharSetUtils.squeeze(null, (String[]) null)); assertEquals(null, CharSetUtils.squeeze(null, new String[0])); assertEquals(null, CharSetUtils.squeeze(null, new String[] {null})); assertEquals(null, CharSetUtils.squeeze(null, new String[] {"el"})); assertEquals("", CharSetUtils.squeeze("", (String[]) null)); assertEquals("", CharSetUtils.squeeze("", new String[0])); assertEquals("", CharSetUtils.squeeze("", new String[] {null})); assertEquals("", CharSetUtils.squeeze("", new String[] {"a-e"})); assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null)); assertEquals("hello", CharSetUtils.squeeze("hello", new String[0])); assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {null})); assertEquals("hello", CharSetUtils.squeeze("hello", new String[] {"a-e"})); assertEquals("helo", CharSetUtils.squeeze("hello", new String[] { "el" })); assertEquals("hello", CharSetUtils.squeeze("hello", new String[] { "e" })); assertEquals("fofof", CharSetUtils.squeeze("fooffooff", new String[] { "of" })); assertEquals("fof", CharSetUtils.squeeze("fooooff", new String[] { "fo" })); } //----------------------------------------------------------------------- @Test public void testContainsAny_StringString() { assertFalse(CharSetUtils.containsAny(null, (String) null)); assertFalse(CharSetUtils.containsAny(null, "")); assertFalse(CharSetUtils.containsAny("", (String) null)); assertFalse(CharSetUtils.containsAny("", "")); assertFalse(CharSetUtils.containsAny("", "a-e")); assertFalse(CharSetUtils.containsAny("hello", (String) null)); assertFalse(CharSetUtils.containsAny("hello", "")); assertTrue(CharSetUtils.containsAny("hello", "a-e")); assertTrue(CharSetUtils.containsAny("hello", "l-p")); } @Test public void testContainsAny_StringStringarray() { assertFalse(CharSetUtils.containsAny(null, (String[]) null)); assertFalse(CharSetUtils.containsAny(null, new String[0])); assertFalse(CharSetUtils.containsAny(null, new String[] {null})); assertFalse(CharSetUtils.containsAny(null, new String[] {"a-e"})); assertFalse(CharSetUtils.containsAny("", (String[]) null)); assertFalse(CharSetUtils.containsAny("", new String[0])); assertFalse(CharSetUtils.containsAny("", new String[] {null})); assertFalse(CharSetUtils.containsAny("", new String[] {"a-e"})); assertFalse(CharSetUtils.containsAny("hello", (String[]) null)); assertFalse(CharSetUtils.containsAny("hello", new String[0])); assertFalse(CharSetUtils.containsAny("hello", new String[] {null})); assertTrue(CharSetUtils.containsAny("hello", new String[] {"a-e"})); assertTrue(CharSetUtils.containsAny("hello", new String[] { "el" })); assertFalse(CharSetUtils.containsAny("hello", new String[] { "x" })); assertTrue(CharSetUtils.containsAny("hello", new String[] { "e-i" })); assertTrue(CharSetUtils.containsAny("hello", new String[] { "a-z" })); assertFalse(CharSetUtils.containsAny("hello", new String[] { "" })); } //----------------------------------------------------------------------- @Test public void testCount_StringString() { assertEquals(0, CharSetUtils.count(null, (String) null)); assertEquals(0, CharSetUtils.count(null, "")); assertEquals(0, CharSetUtils.count("", (String) null)); assertEquals(0, CharSetUtils.count("", "")); assertEquals(0, CharSetUtils.count("", "a-e")); assertEquals(0, CharSetUtils.count("hello", (String) null)); assertEquals(0, CharSetUtils.count("hello", "")); assertEquals(1, CharSetUtils.count("hello", "a-e")); assertEquals(3, CharSetUtils.count("hello", "l-p")); } @Test public void testCount_StringStringarray() { assertEquals(0, CharSetUtils.count(null, (String[]) null)); assertEquals(0, CharSetUtils.count(null, new String[0])); assertEquals(0, CharSetUtils.count(null, new String[] {null})); assertEquals(0, CharSetUtils.count(null, new String[] {"a-e"})); assertEquals(0, CharSetUtils.count("", (String[]) null)); assertEquals(0, CharSetUtils.count("", new String[0])); assertEquals(0, CharSetUtils.count("", new String[] {null})); assertEquals(0, CharSetUtils.count("", new String[] {"a-e"})); assertEquals(0, CharSetUtils.count("hello", (String[]) null)); assertEquals(0, CharSetUtils.count("hello", new String[0])); assertEquals(0, CharSetUtils.count("hello", new String[] {null})); assertEquals(1, CharSetUtils.count("hello", new String[] {"a-e"})); assertEquals(3, CharSetUtils.count("hello", new String[] { "el" })); assertEquals(0, CharSetUtils.count("hello", new String[] { "x" })); assertEquals(2, CharSetUtils.count("hello", new String[] { "e-i" })); assertEquals(5, CharSetUtils.count("hello", new String[] { "a-z" })); assertEquals(0, CharSetUtils.count("hello", new String[] { "" })); } //----------------------------------------------------------------------- @Test public void testKeep_StringString() { assertEquals(null, CharSetUtils.keep(null, (String) null)); assertEquals(null, CharSetUtils.keep(null, "")); assertEquals("", CharSetUtils.keep("", (String) null)); assertEquals("", CharSetUtils.keep("", "")); assertEquals("", CharSetUtils.keep("", "a-e")); assertEquals("", CharSetUtils.keep("hello", (String) null)); assertEquals("", CharSetUtils.keep("hello", "")); assertEquals("", CharSetUtils.keep("hello", "xyz")); assertEquals("hello", CharSetUtils.keep("hello", "a-z")); assertEquals("hello", CharSetUtils.keep("hello", "oleh")); assertEquals("ell", CharSetUtils.keep("hello", "el")); } @Test public void testKeep_StringStringarray() { assertEquals(null, CharSetUtils.keep(null, (String[]) null)); assertEquals(null, CharSetUtils.keep(null, new String[0])); assertEquals(null, CharSetUtils.keep(null, new String[] {null})); assertEquals(null, CharSetUtils.keep(null, new String[] {"a-e"})); assertEquals("", CharSetUtils.keep("", (String[]) null)); assertEquals("", CharSetUtils.keep("", new String[0])); assertEquals("", CharSetUtils.keep("", new String[] {null})); assertEquals("", CharSetUtils.keep("", new String[] {"a-e"})); assertEquals("", CharSetUtils.keep("hello", (String[]) null)); assertEquals("", CharSetUtils.keep("hello", new String[0])); assertEquals("", CharSetUtils.keep("hello", new String[] {null})); assertEquals("e", CharSetUtils.keep("hello", new String[] {"a-e"})); assertEquals("e", CharSetUtils.keep("hello", new String[] { "a-e" })); assertEquals("ell", CharSetUtils.keep("hello", new String[] { "el" })); assertEquals("hello", CharSetUtils.keep("hello", new String[] { "elho" })); assertEquals("hello", CharSetUtils.keep("hello", new String[] { "a-z" })); assertEquals("----", CharSetUtils.keep("----", new String[] { "-" })); assertEquals("ll", CharSetUtils.keep("hello", new String[] { "l" })); } //----------------------------------------------------------------------- @Test public void testDelete_StringString() { assertEquals(null, CharSetUtils.delete(null, (String) null)); assertEquals(null, CharSetUtils.delete(null, "")); assertEquals("", CharSetUtils.delete("", (String) null)); assertEquals("", CharSetUtils.delete("", "")); assertEquals("", CharSetUtils.delete("", "a-e")); assertEquals("hello", CharSetUtils.delete("hello", (String) null)); assertEquals("hello", CharSetUtils.delete("hello", "")); assertEquals("hllo", CharSetUtils.delete("hello", "a-e")); assertEquals("he", CharSetUtils.delete("hello", "l-p")); assertEquals("hello", CharSetUtils.delete("hello", "z")); } @Test public void testDelete_StringStringarray() { assertEquals(null, CharSetUtils.delete(null, (String[]) null)); assertEquals(null, CharSetUtils.delete(null, new String[0])); assertEquals(null, CharSetUtils.delete(null, new String[] {null})); assertEquals(null, CharSetUtils.delete(null, new String[] {"el"})); assertEquals("", CharSetUtils.delete("", (String[]) null)); assertEquals("", CharSetUtils.delete("", new String[0])); assertEquals("", CharSetUtils.delete("", new String[] {null})); assertEquals("", CharSetUtils.delete("", new String[] {"a-e"})); assertEquals("hello", CharSetUtils.delete("hello", (String[]) null)); assertEquals("hello", CharSetUtils.delete("hello", new String[0])); assertEquals("hello", CharSetUtils.delete("hello", new String[] {null})); assertEquals("hello", CharSetUtils.delete("hello", new String[] {"xyz"})); assertEquals("ho", CharSetUtils.delete("hello", new String[] { "el" })); assertEquals("", CharSetUtils.delete("hello", new String[] { "elho" })); assertEquals("hello", CharSetUtils.delete("hello", new String[] { "" })); assertEquals("hello", CharSetUtils.delete("hello", "")); assertEquals("", CharSetUtils.delete("hello", new String[] { "a-z" })); assertEquals("", CharSetUtils.delete("----", new String[] { "-" })); assertEquals("heo", CharSetUtils.delete("hello", new String[] { "l" })); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.CharUtils}. * * @version $Id$ */ public class CharUtilsTest { private static final Character CHARACTER_A = new Character('A'); private static final Character CHARACTER_B = new Character('B'); private static final char CHAR_COPY = '\u00a9'; @Test public void testConstructor() { assertNotNull(new CharUtils()); final Constructor<?>[] cons = CharUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(BooleanUtils.class.getModifiers())); assertFalse(Modifier.isFinal(BooleanUtils.class.getModifiers())); } @SuppressWarnings("deprecation") // intentional test of deprecated method @Test public void testToCharacterObject_char() { assertEquals(new Character('a'), CharUtils.toCharacterObject('a')); assertSame(CharUtils.toCharacterObject('a'), CharUtils.toCharacterObject('a')); for (int i = 0; i < 128; i++) { final Character ch = CharUtils.toCharacterObject((char) i); final Character ch2 = CharUtils.toCharacterObject((char) i); assertSame(ch, ch2); assertEquals(i, ch.charValue()); } for (int i = 128; i < 196; i++) { final Character ch = CharUtils.toCharacterObject((char) i); final Character ch2 = CharUtils.toCharacterObject((char) i); assertEquals(ch, ch2); assertTrue(ch != ch2); assertEquals(i, ch.charValue()); assertEquals(i, ch2.charValue()); } assertSame(CharUtils.toCharacterObject("a"), CharUtils.toCharacterObject('a')); } @Test public void testToCharacterObject_String() { assertEquals(null, CharUtils.toCharacterObject(null)); assertEquals(null, CharUtils.toCharacterObject("")); assertEquals(new Character('a'), CharUtils.toCharacterObject("a")); assertEquals(new Character('a'), CharUtils.toCharacterObject("abc")); assertSame(CharUtils.toCharacterObject("a"), CharUtils.toCharacterObject("a")); } @Test public void testToChar_Character() { assertEquals('A', CharUtils.toChar(CHARACTER_A)); assertEquals('B', CharUtils.toChar(CHARACTER_B)); try { CharUtils.toChar((Character) null); } catch (final IllegalArgumentException ex) {} } @Test public void testToChar_Character_char() { assertEquals('A', CharUtils.toChar(CHARACTER_A, 'X')); assertEquals('B', CharUtils.toChar(CHARACTER_B, 'X')); assertEquals('X', CharUtils.toChar((Character) null, 'X')); } @Test public void testToChar_String() { assertEquals('A', CharUtils.toChar("A")); assertEquals('B', CharUtils.toChar("BA")); try { CharUtils.toChar((String) null); } catch (final IllegalArgumentException ex) {} try { CharUtils.toChar(""); } catch (final IllegalArgumentException ex) {} } @Test public void testToChar_String_char() { assertEquals('A', CharUtils.toChar("A", 'X')); assertEquals('B', CharUtils.toChar("BA", 'X')); assertEquals('X', CharUtils.toChar("", 'X')); assertEquals('X', CharUtils.toChar((String) null, 'X')); } @Test public void testToIntValue_char() { assertEquals(0, CharUtils.toIntValue('0')); assertEquals(1, CharUtils.toIntValue('1')); assertEquals(2, CharUtils.toIntValue('2')); assertEquals(3, CharUtils.toIntValue('3')); assertEquals(4, CharUtils.toIntValue('4')); assertEquals(5, CharUtils.toIntValue('5')); assertEquals(6, CharUtils.toIntValue('6')); assertEquals(7, CharUtils.toIntValue('7')); assertEquals(8, CharUtils.toIntValue('8')); assertEquals(9, CharUtils.toIntValue('9')); try { CharUtils.toIntValue('a'); } catch (final IllegalArgumentException ex) {} } @Test public void testToIntValue_char_int() { assertEquals(0, CharUtils.toIntValue('0', -1)); assertEquals(3, CharUtils.toIntValue('3', -1)); assertEquals(-1, CharUtils.toIntValue('a', -1)); } @Test public void testToIntValue_Character() { assertEquals(0, CharUtils.toIntValue(new Character('0'))); assertEquals(3, CharUtils.toIntValue(new Character('3'))); try { CharUtils.toIntValue(null); } catch (final IllegalArgumentException ex) {} try { CharUtils.toIntValue(CHARACTER_A); } catch (final IllegalArgumentException ex) {} } @Test public void testToIntValue_Character_int() { assertEquals(0, CharUtils.toIntValue(new Character('0'), -1)); assertEquals(3, CharUtils.toIntValue(new Character('3'), -1)); assertEquals(-1, CharUtils.toIntValue(new Character('A'), -1)); assertEquals(-1, CharUtils.toIntValue(null, -1)); } @Test public void testToString_char() { assertEquals("a", CharUtils.toString('a')); assertSame(CharUtils.toString('a'), CharUtils.toString('a')); for (int i = 0; i < 128; i++) { final String str = CharUtils.toString((char) i); final String str2 = CharUtils.toString((char) i); assertSame(str, str2); assertEquals(1, str.length()); assertEquals(i, str.charAt(0)); } for (int i = 128; i < 196; i++) { final String str = CharUtils.toString((char) i); final String str2 = CharUtils.toString((char) i); assertEquals(str, str2); assertTrue(str != str2); assertEquals(1, str.length()); assertEquals(i, str.charAt(0)); assertEquals(1, str2.length()); assertEquals(i, str2.charAt(0)); } } @Test public void testToString_Character() { assertEquals(null, CharUtils.toString(null)); assertEquals("A", CharUtils.toString(CHARACTER_A)); assertSame(CharUtils.toString(CHARACTER_A), CharUtils.toString(CHARACTER_A)); } @Test public void testToUnicodeEscaped_char() { assertEquals("\\u0041", CharUtils.unicodeEscaped('A')); for (int i = 0; i < 196; i++) { final String str = CharUtils.unicodeEscaped((char) i); assertEquals(6, str.length()); final int val = Integer.parseInt(str.substring(2), 16); assertEquals(i, val); } assertEquals("\\u0999", CharUtils.unicodeEscaped((char) 0x999)); assertEquals("\\u1001", CharUtils.unicodeEscaped((char) 0x1001)); } @Test public void testToUnicodeEscaped_Character() { assertEquals(null, CharUtils.unicodeEscaped(null)); assertEquals("\\u0041", CharUtils.unicodeEscaped(CHARACTER_A)); } @Test public void testIsAscii_char() { assertTrue(CharUtils.isAscii('a')); assertTrue(CharUtils.isAscii('A')); assertTrue(CharUtils.isAscii('3')); assertTrue(CharUtils.isAscii('-')); assertTrue(CharUtils.isAscii('\n')); assertFalse(CharUtils.isAscii(CHAR_COPY)); for (int i = 0; i < 128; i++) { if (i < 128) { assertTrue(CharUtils.isAscii((char) i)); } else { assertFalse(CharUtils.isAscii((char) i)); } } } @Test public void testIsAsciiPrintable_char() { assertTrue(CharUtils.isAsciiPrintable('a')); assertTrue(CharUtils.isAsciiPrintable('A')); assertTrue(CharUtils.isAsciiPrintable('3')); assertTrue(CharUtils.isAsciiPrintable('-')); assertFalse(CharUtils.isAsciiPrintable('\n')); assertFalse(CharUtils.isAscii(CHAR_COPY)); for (int i = 0; i < 196; i++) { if (i >= 32 && i <= 126) { assertTrue(CharUtils.isAsciiPrintable((char) i)); } else { assertFalse(CharUtils.isAsciiPrintable((char) i)); } } } @Test public void testIsAsciiControl_char() { assertFalse(CharUtils.isAsciiControl('a')); assertFalse(CharUtils.isAsciiControl('A')); assertFalse(CharUtils.isAsciiControl('3')); assertFalse(CharUtils.isAsciiControl('-')); assertTrue(CharUtils.isAsciiControl('\n')); assertFalse(CharUtils.isAsciiControl(CHAR_COPY)); for (int i = 0; i < 196; i++) { if (i < 32 || i == 127) { assertTrue(CharUtils.isAsciiControl((char) i)); } else { assertFalse(CharUtils.isAsciiControl((char) i)); } } } @Test public void testIsAsciiAlpha_char() { assertTrue(CharUtils.isAsciiAlpha('a')); assertTrue(CharUtils.isAsciiAlpha('A')); assertFalse(CharUtils.isAsciiAlpha('3')); assertFalse(CharUtils.isAsciiAlpha('-')); assertFalse(CharUtils.isAsciiAlpha('\n')); assertFalse(CharUtils.isAsciiAlpha(CHAR_COPY)); for (int i = 0; i < 196; i++) { if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z')) { assertTrue(CharUtils.isAsciiAlpha((char) i)); } else { assertFalse(CharUtils.isAsciiAlpha((char) i)); } } } @Test public void testIsAsciiAlphaUpper_char() { assertFalse(CharUtils.isAsciiAlphaUpper('a')); assertTrue(CharUtils.isAsciiAlphaUpper('A')); assertFalse(CharUtils.isAsciiAlphaUpper('3')); assertFalse(CharUtils.isAsciiAlphaUpper('-')); assertFalse(CharUtils.isAsciiAlphaUpper('\n')); assertFalse(CharUtils.isAsciiAlphaUpper(CHAR_COPY)); for (int i = 0; i < 196; i++) { if (i >= 'A' && i <= 'Z') { assertTrue(CharUtils.isAsciiAlphaUpper((char) i)); } else { assertFalse(CharUtils.isAsciiAlphaUpper((char) i)); } } } @Test public void testIsAsciiAlphaLower_char() { assertTrue(CharUtils.isAsciiAlphaLower('a')); assertFalse(CharUtils.isAsciiAlphaLower('A')); assertFalse(CharUtils.isAsciiAlphaLower('3')); assertFalse(CharUtils.isAsciiAlphaLower('-')); assertFalse(CharUtils.isAsciiAlphaLower('\n')); assertFalse(CharUtils.isAsciiAlphaLower(CHAR_COPY)); for (int i = 0; i < 196; i++) { if (i >= 'a' && i <= 'z') { assertTrue(CharUtils.isAsciiAlphaLower((char) i)); } else { assertFalse(CharUtils.isAsciiAlphaLower((char) i)); } } } @Test public void testIsAsciiNumeric_char() { assertFalse(CharUtils.isAsciiNumeric('a')); assertFalse(CharUtils.isAsciiNumeric('A')); assertTrue(CharUtils.isAsciiNumeric('3')); assertFalse(CharUtils.isAsciiNumeric('-')); assertFalse(CharUtils.isAsciiNumeric('\n')); assertFalse(CharUtils.isAsciiNumeric(CHAR_COPY)); for (int i = 0; i < 196; i++) { if (i >= '0' && i <= '9') { assertTrue(CharUtils.isAsciiNumeric((char) i)); } else { assertFalse(CharUtils.isAsciiNumeric((char) i)); } } } @Test public void testIsAsciiAlphanumeric_char() { assertTrue(CharUtils.isAsciiAlphanumeric('a')); assertTrue(CharUtils.isAsciiAlphanumeric('A')); assertTrue(CharUtils.isAsciiAlphanumeric('3')); assertFalse(CharUtils.isAsciiAlphanumeric('-')); assertFalse(CharUtils.isAsciiAlphanumeric('\n')); assertFalse(CharUtils.isAsciiAlphanumeric(CHAR_COPY)); for (int i = 0; i < 196; i++) { if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z') || (i >= '0' && i <= '9')) { assertTrue(CharUtils.isAsciiAlphanumeric((char) i)); } else { assertFalse(CharUtils.isAsciiAlphanumeric((char) i)); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.apache.commons.lang3.JavaVersion.JAVA_1_5; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.ClassUtils}. * * @version $Id$ */ @SuppressWarnings("boxing") // JUnit4 does not support primitive equality testing apart from long public class ClassUtilsTest { private static class Inner { private class DeeplyNested{} } //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new ClassUtils()); final Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(ClassUtils.class.getModifiers())); assertFalse(Modifier.isFinal(ClassUtils.class.getModifiers())); } // ------------------------------------------------------------------------- @Test public void test_getShortClassName_Object() { assertEquals("ClassUtils", ClassUtils.getShortClassName(new ClassUtils(), "<null>")); assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(new Inner(), "<null>")); assertEquals("String", ClassUtils.getShortClassName("hello", "<null>")); assertEquals("<null>", ClassUtils.getShortClassName(null, "<null>")); // Inner types class Named extends Object {} assertEquals("ClassUtilsTest.1", ClassUtils.getShortClassName(new Object(){}, "<null>")); assertEquals("ClassUtilsTest.1Named", ClassUtils.getShortClassName(new Named(), "<null>")); assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(new Inner(), "<null>")); } @Test public void test_getShortClassName_Class() { assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class)); assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class)); assertEquals("", ClassUtils.getShortClassName((Class<?>) null)); // LANG-535 assertEquals("String[]", ClassUtils.getShortClassName(String[].class)); assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class)); // Primitives assertEquals("boolean", ClassUtils.getShortClassName(boolean.class)); assertEquals("byte", ClassUtils.getShortClassName(byte.class)); assertEquals("char", ClassUtils.getShortClassName(char.class)); assertEquals("short", ClassUtils.getShortClassName(short.class)); assertEquals("int", ClassUtils.getShortClassName(int.class)); assertEquals("long", ClassUtils.getShortClassName(long.class)); assertEquals("float", ClassUtils.getShortClassName(float.class)); assertEquals("double", ClassUtils.getShortClassName(double.class)); // Primitive Arrays assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class)); assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class)); assertEquals("char[]", ClassUtils.getShortClassName(char[].class)); assertEquals("short[]", ClassUtils.getShortClassName(short[].class)); assertEquals("int[]", ClassUtils.getShortClassName(int[].class)); assertEquals("long[]", ClassUtils.getShortClassName(long[].class)); assertEquals("float[]", ClassUtils.getShortClassName(float[].class)); assertEquals("double[]", ClassUtils.getShortClassName(double[].class)); // Arrays of arrays of ... assertEquals("String[][]", ClassUtils.getShortClassName(String[][].class)); assertEquals("String[][][]", ClassUtils.getShortClassName(String[][][].class)); assertEquals("String[][][][]", ClassUtils.getShortClassName(String[][][][].class)); // Inner types class Named extends Object {} assertEquals("ClassUtilsTest.2", ClassUtils.getShortClassName(new Object(){}.getClass())); assertEquals("ClassUtilsTest.2Named", ClassUtils.getShortClassName(Named.class)); assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(Inner.class)); } @Test public void test_getShortClassName_String() { assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class.getName())); assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class.getName())); assertEquals("", ClassUtils.getShortClassName((String) null)); assertEquals("", ClassUtils.getShortClassName("")); } @Test public void test_getSimpleName_Class() { assertEquals("ClassUtils", ClassUtils.getSimpleName(ClassUtils.class)); assertEquals("Entry", ClassUtils.getSimpleName(Map.Entry.class)); assertEquals("", ClassUtils.getSimpleName((Class<?>) null)); // LANG-535 assertEquals("String[]", ClassUtils.getSimpleName(String[].class)); assertEquals("Entry[]", ClassUtils.getSimpleName(Map.Entry[].class)); // Primitives assertEquals("boolean", ClassUtils.getSimpleName(boolean.class)); assertEquals("byte", ClassUtils.getSimpleName(byte.class)); assertEquals("char", ClassUtils.getSimpleName(char.class)); assertEquals("short", ClassUtils.getSimpleName(short.class)); assertEquals("int", ClassUtils.getSimpleName(int.class)); assertEquals("long", ClassUtils.getSimpleName(long.class)); assertEquals("float", ClassUtils.getSimpleName(float.class)); assertEquals("double", ClassUtils.getSimpleName(double.class)); // Primitive Arrays assertEquals("boolean[]", ClassUtils.getSimpleName(boolean[].class)); assertEquals("byte[]", ClassUtils.getSimpleName(byte[].class)); assertEquals("char[]", ClassUtils.getSimpleName(char[].class)); assertEquals("short[]", ClassUtils.getSimpleName(short[].class)); assertEquals("int[]", ClassUtils.getSimpleName(int[].class)); assertEquals("long[]", ClassUtils.getSimpleName(long[].class)); assertEquals("float[]", ClassUtils.getSimpleName(float[].class)); assertEquals("double[]", ClassUtils.getSimpleName(double[].class)); // Arrays of arrays of ... assertEquals("String[][]", ClassUtils.getSimpleName(String[][].class)); assertEquals("String[][][]", ClassUtils.getSimpleName(String[][][].class)); assertEquals("String[][][][]", ClassUtils.getSimpleName(String[][][][].class)); // On-the-fly types class Named extends Object {} assertEquals("", ClassUtils.getSimpleName(new Object(){}.getClass())); assertEquals("Named", ClassUtils.getSimpleName(Named.class)); } @Test public void test_getSimpleName_Object() { assertEquals("ClassUtils", ClassUtils.getSimpleName(new ClassUtils(), "<null>")); assertEquals("Inner", ClassUtils.getSimpleName(new Inner(), "<null>")); assertEquals("String", ClassUtils.getSimpleName("hello", "<null>")); assertEquals("<null>", ClassUtils.getSimpleName(null, "<null>")); } // ------------------------------------------------------------------------- @Test public void test_getPackageName_Object() { assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new ClassUtils(), "<null>")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new Inner(), "<null>")); assertEquals("<null>", ClassUtils.getPackageName(null, "<null>")); } @Test public void test_getPackageName_Class() { assertEquals("java.lang", ClassUtils.getPackageName(String.class)); assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class)); assertEquals("", ClassUtils.getPackageName((Class<?>)null)); // LANG-535 assertEquals("java.lang", ClassUtils.getPackageName(String[].class)); // Primitive Arrays assertEquals("", ClassUtils.getPackageName(boolean[].class)); assertEquals("", ClassUtils.getPackageName(byte[].class)); assertEquals("", ClassUtils.getPackageName(char[].class)); assertEquals("", ClassUtils.getPackageName(short[].class)); assertEquals("", ClassUtils.getPackageName(int[].class)); assertEquals("", ClassUtils.getPackageName(long[].class)); assertEquals("", ClassUtils.getPackageName(float[].class)); assertEquals("", ClassUtils.getPackageName(double[].class)); // Arrays of arrays of ... assertEquals("java.lang", ClassUtils.getPackageName(String[][].class)); assertEquals("java.lang", ClassUtils.getPackageName(String[][][].class)); assertEquals("java.lang", ClassUtils.getPackageName(String[][][][].class)); // On-the-fly types class Named extends Object {} assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new Object(){}.getClass())); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Named.class)); } @Test public void test_getPackageName_String() { assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class.getName())); assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class.getName())); assertEquals("", ClassUtils.getPackageName((String)null)); assertEquals("", ClassUtils.getPackageName("")); } // ------------------------------------------------------------------------- @Test public void test_getAllSuperclasses_Class() { final List<?> list = ClassUtils.getAllSuperclasses(CY.class); assertEquals(2, list.size()); assertEquals(CX.class, list.get(0)); assertEquals(Object.class, list.get(1)); assertEquals(null, ClassUtils.getAllSuperclasses(null)); } @Test public void test_getAllInterfaces_Class() { final List<?> list = ClassUtils.getAllInterfaces(CY.class); assertEquals(6, list.size()); assertEquals(IB.class, list.get(0)); assertEquals(IC.class, list.get(1)); assertEquals(ID.class, list.get(2)); assertEquals(IE.class, list.get(3)); assertEquals(IF.class, list.get(4)); assertEquals(IA.class, list.get(5)); assertEquals(null, ClassUtils.getAllInterfaces(null)); } private static interface IA { } private static interface IB { } private static interface IC extends ID, IE { } private static interface ID { } private static interface IE extends IF { } private static interface IF { } private static class CX implements IB, IA, IE { } private static class CY extends CX implements IB, IC { } // ------------------------------------------------------------------------- @Test public void test_convertClassNamesToClasses_List() { final List<String> list = new ArrayList<String>(); List<Class<?>> result = ClassUtils.convertClassNamesToClasses(list); assertEquals(0, result.size()); list.add("java.lang.String"); list.add("java.lang.xxx"); list.add("java.lang.Object"); result = ClassUtils.convertClassNamesToClasses(list); assertEquals(3, result.size()); assertEquals(String.class, result.get(0)); assertEquals(null, result.get(1)); assertEquals(Object.class, result.get(2)); @SuppressWarnings("unchecked") // test what happens when non-generic code adds wrong type of element final List<Object> olist = (List<Object>)(List<?>)list; olist.add(new Object()); try { ClassUtils.convertClassNamesToClasses(list); fail("Should not have been able to convert list"); } catch (final ClassCastException expected) {} assertEquals(null, ClassUtils.convertClassNamesToClasses(null)); } @Test public void test_convertClassesToClassNames_List() { final List<Class<?>> list = new ArrayList<Class<?>>(); List<String> result = ClassUtils.convertClassesToClassNames(list); assertEquals(0, result.size()); list.add(String.class); list.add(null); list.add(Object.class); result = ClassUtils.convertClassesToClassNames(list); assertEquals(3, result.size()); assertEquals("java.lang.String", result.get(0)); assertEquals(null, result.get(1)); assertEquals("java.lang.Object", result.get(2)); @SuppressWarnings("unchecked") // test what happens when non-generic code adds wrong type of element final List<Object> olist = (List<Object>)(List<?>)list; olist.add(new Object()); try { ClassUtils.convertClassesToClassNames(list); fail("Should not have been able to convert list"); } catch (final ClassCastException expected) {} assertEquals(null, ClassUtils.convertClassesToClassNames(null)); } // ------------------------------------------------------------------------- @Test public void test_isInnerClass_Class() { assertTrue(ClassUtils.isInnerClass(Inner.class)); assertTrue(ClassUtils.isInnerClass(Map.Entry.class)); assertTrue(ClassUtils.isInnerClass(new Cloneable() { }.getClass())); assertFalse(ClassUtils.isInnerClass(this.getClass())); assertFalse(ClassUtils.isInnerClass(String.class)); assertFalse(ClassUtils.isInnerClass(null)); } // ------------------------------------------------------------------------- @Test public void test_isAssignable_ClassArray_ClassArray() throws Exception { final Class<?>[] array2 = new Class[] {Object.class, Object.class}; final Class<?>[] array1 = new Class[] {Object.class}; final Class<?>[] array1s = new Class[] {String.class}; final Class<?>[] array0 = new Class[] {}; final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; assertFalse(ClassUtils.isAssignable(array1, array2)); assertFalse(ClassUtils.isAssignable(null, array2)); assertTrue(ClassUtils.isAssignable(null, array0)); assertTrue(ClassUtils.isAssignable(array0, array0)); // assertTrue(ClassUtils.isAssignable(array0, null)); assertTrue(ClassUtils.isAssignable(array0, (Class<?>[]) null)); // explicit cast to avoid warning assertTrue(ClassUtils.isAssignable((Class[]) null, (Class[]) null)); assertFalse(ClassUtils.isAssignable(array1, array1s)); assertTrue(ClassUtils.isAssignable(array1s, array1s)); assertTrue(ClassUtils.isAssignable(array1s, array1)); final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); assertEquals(autoboxing, ClassUtils.isAssignable(arrayPrimitives, arrayWrappers)); assertEquals(autoboxing, ClassUtils.isAssignable(arrayWrappers, arrayPrimitives)); assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1)); assertFalse(ClassUtils.isAssignable(arrayWrappers, array1)); assertEquals(autoboxing, ClassUtils.isAssignable(arrayPrimitives, array2)); assertTrue(ClassUtils.isAssignable(arrayWrappers, array2)); } @Test public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception { final Class<?>[] array2 = new Class[] {Object.class, Object.class}; final Class<?>[] array1 = new Class[] {Object.class}; final Class<?>[] array1s = new Class[] {String.class}; final Class<?>[] array0 = new Class[] {}; final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; assertFalse(ClassUtils.isAssignable(array1, array2, true)); assertFalse(ClassUtils.isAssignable(null, array2, true)); assertTrue(ClassUtils.isAssignable(null, array0, true)); assertTrue(ClassUtils.isAssignable(array0, array0, true)); assertTrue(ClassUtils.isAssignable(array0, null, true)); assertTrue(ClassUtils.isAssignable((Class[]) null, (Class[]) null, true)); assertFalse(ClassUtils.isAssignable(array1, array1s, true)); assertTrue(ClassUtils.isAssignable(array1s, array1s, true)); assertTrue(ClassUtils.isAssignable(array1s, array1, true)); assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true)); assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true)); assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true)); assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true)); assertTrue(ClassUtils.isAssignable(arrayPrimitives, array2, true)); assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true)); } @Test public void test_isAssignable_ClassArray_ClassArray_NoAutoboxing() throws Exception { final Class<?>[] array2 = new Class[] {Object.class, Object.class}; final Class<?>[] array1 = new Class[] {Object.class}; final Class<?>[] array1s = new Class[] {String.class}; final Class<?>[] array0 = new Class[] {}; final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE }; final Class<?>[] arrayWrappers = { Integer.class, Boolean.class }; assertFalse(ClassUtils.isAssignable(array1, array2, false)); assertFalse(ClassUtils.isAssignable(null, array2, false)); assertTrue(ClassUtils.isAssignable(null, array0, false)); assertTrue(ClassUtils.isAssignable(array0, array0, false)); assertTrue(ClassUtils.isAssignable(array0, null, false)); assertTrue(ClassUtils.isAssignable((Class[]) null, (Class[]) null, false)); assertFalse(ClassUtils.isAssignable(array1, array1s, false)); assertTrue(ClassUtils.isAssignable(array1s, array1s, false)); assertTrue(ClassUtils.isAssignable(array1s, array1, false)); assertFalse(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, false)); assertFalse(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, false)); assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, false)); assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, false)); assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, false)); assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, false)); } @Test public void test_isAssignable() throws Exception { assertFalse(ClassUtils.isAssignable((Class<?>) null, null)); assertFalse(ClassUtils.isAssignable(String.class, null)); assertTrue(ClassUtils.isAssignable(null, Object.class)); assertTrue(ClassUtils.isAssignable(null, Integer.class)); assertFalse(ClassUtils.isAssignable(null, Integer.TYPE)); assertTrue(ClassUtils.isAssignable(String.class, Object.class)); assertTrue(ClassUtils.isAssignable(String.class, String.class)); assertFalse(ClassUtils.isAssignable(Object.class, String.class)); final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); assertEquals(autoboxing, ClassUtils.isAssignable(Integer.TYPE, Integer.class)); assertEquals(autoboxing, ClassUtils.isAssignable(Integer.TYPE, Object.class)); assertEquals(autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); assertEquals(autoboxing, ClassUtils.isAssignable(Integer.class, Object.class)); assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE)); assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class)); assertEquals(autoboxing, ClassUtils.isAssignable(Boolean.TYPE, Boolean.class)); assertEquals(autoboxing, ClassUtils.isAssignable(Boolean.TYPE, Object.class)); assertEquals(autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); assertEquals(autoboxing, ClassUtils.isAssignable(Boolean.class, Object.class)); assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE)); assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class)); } @Test public void test_isAssignable_Autoboxing() throws Exception { assertFalse(ClassUtils.isAssignable((Class<?>) null, null, true)); assertFalse(ClassUtils.isAssignable(String.class, null, true)); assertTrue(ClassUtils.isAssignable(null, Object.class, true)); assertTrue(ClassUtils.isAssignable(null, Integer.class, true)); assertFalse(ClassUtils.isAssignable(null, Integer.TYPE, true)); assertTrue(ClassUtils.isAssignable(String.class, Object.class, true)); assertTrue(ClassUtils.isAssignable(String.class, String.class, true)); assertFalse(ClassUtils.isAssignable(Object.class, String.class, true)); assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.class, true)); assertTrue(ClassUtils.isAssignable(Integer.TYPE, Object.class, true)); assertTrue(ClassUtils.isAssignable(Integer.class, Integer.TYPE, true)); assertTrue(ClassUtils.isAssignable(Integer.class, Object.class, true)); assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE, true)); assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class, true)); assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class, true)); assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, true)); assertTrue(ClassUtils.isAssignable(Boolean.class, Object.class, true)); assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE, true)); assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class, true)); } @Test public void test_isAssignable_NoAutoboxing() throws Exception { assertFalse(ClassUtils.isAssignable((Class<?>) null, null, false)); assertFalse(ClassUtils.isAssignable(String.class, null, false)); assertTrue(ClassUtils.isAssignable(null, Object.class, false)); assertTrue(ClassUtils.isAssignable(null, Integer.class, false)); assertFalse(ClassUtils.isAssignable(null, Integer.TYPE, false)); assertTrue(ClassUtils.isAssignable(String.class, Object.class, false)); assertTrue(ClassUtils.isAssignable(String.class, String.class, false)); assertFalse(ClassUtils.isAssignable(Object.class, String.class, false)); assertFalse(ClassUtils.isAssignable(Integer.TYPE, Integer.class, false)); assertFalse(ClassUtils.isAssignable(Integer.TYPE, Object.class, false)); assertFalse(ClassUtils.isAssignable(Integer.class, Integer.TYPE, false)); assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE, false)); assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class, false)); assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class, false)); assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Object.class, false)); assertFalse(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, false)); assertTrue(ClassUtils.isAssignable(Boolean.class, Object.class, false)); assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE, false)); assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class, false)); } @Test public void test_isAssignable_Widening() throws Exception { // test byte conversions assertFalse("byte -> char", ClassUtils.isAssignable(Byte.TYPE, Character.TYPE)); assertTrue("byte -> byte", ClassUtils.isAssignable(Byte.TYPE, Byte.TYPE)); assertTrue("byte -> short", ClassUtils.isAssignable(Byte.TYPE, Short.TYPE)); assertTrue("byte -> int", ClassUtils.isAssignable(Byte.TYPE, Integer.TYPE)); assertTrue("byte -> long", ClassUtils.isAssignable(Byte.TYPE, Long.TYPE)); assertTrue("byte -> float", ClassUtils.isAssignable(Byte.TYPE, Float.TYPE)); assertTrue("byte -> double", ClassUtils.isAssignable(Byte.TYPE, Double.TYPE)); assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.TYPE, Boolean.TYPE)); // test short conversions assertFalse("short -> char", ClassUtils.isAssignable(Short.TYPE, Character.TYPE)); assertFalse("short -> byte", ClassUtils.isAssignable(Short.TYPE, Byte.TYPE)); assertTrue("short -> short", ClassUtils.isAssignable(Short.TYPE, Short.TYPE)); assertTrue("short -> int", ClassUtils.isAssignable(Short.TYPE, Integer.TYPE)); assertTrue("short -> long", ClassUtils.isAssignable(Short.TYPE, Long.TYPE)); assertTrue("short -> float", ClassUtils.isAssignable(Short.TYPE, Float.TYPE)); assertTrue("short -> double", ClassUtils.isAssignable(Short.TYPE, Double.TYPE)); assertFalse("short -> boolean", ClassUtils.isAssignable(Short.TYPE, Boolean.TYPE)); // test char conversions assertTrue("char -> char", ClassUtils.isAssignable(Character.TYPE, Character.TYPE)); assertFalse("char -> byte", ClassUtils.isAssignable(Character.TYPE, Byte.TYPE)); assertFalse("char -> short", ClassUtils.isAssignable(Character.TYPE, Short.TYPE)); assertTrue("char -> int", ClassUtils.isAssignable(Character.TYPE, Integer.TYPE)); assertTrue("char -> long", ClassUtils.isAssignable(Character.TYPE, Long.TYPE)); assertTrue("char -> float", ClassUtils.isAssignable(Character.TYPE, Float.TYPE)); assertTrue("char -> double", ClassUtils.isAssignable(Character.TYPE, Double.TYPE)); assertFalse("char -> boolean", ClassUtils.isAssignable(Character.TYPE, Boolean.TYPE)); // test int conversions assertFalse("int -> char", ClassUtils.isAssignable(Integer.TYPE, Character.TYPE)); assertFalse("int -> byte", ClassUtils.isAssignable(Integer.TYPE, Byte.TYPE)); assertFalse("int -> short", ClassUtils.isAssignable(Integer.TYPE, Short.TYPE)); assertTrue("int -> int", ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE)); assertTrue("int -> long", ClassUtils.isAssignable(Integer.TYPE, Long.TYPE)); assertTrue("int -> float", ClassUtils.isAssignable(Integer.TYPE, Float.TYPE)); assertTrue("int -> double", ClassUtils.isAssignable(Integer.TYPE, Double.TYPE)); assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.TYPE, Boolean.TYPE)); // test long conversions assertFalse("long -> char", ClassUtils.isAssignable(Long.TYPE, Character.TYPE)); assertFalse("long -> byte", ClassUtils.isAssignable(Long.TYPE, Byte.TYPE)); assertFalse("long -> short", ClassUtils.isAssignable(Long.TYPE, Short.TYPE)); assertFalse("long -> int", ClassUtils.isAssignable(Long.TYPE, Integer.TYPE)); assertTrue("long -> long", ClassUtils.isAssignable(Long.TYPE, Long.TYPE)); assertTrue("long -> float", ClassUtils.isAssignable(Long.TYPE, Float.TYPE)); assertTrue("long -> double", ClassUtils.isAssignable(Long.TYPE, Double.TYPE)); assertFalse("long -> boolean", ClassUtils.isAssignable(Long.TYPE, Boolean.TYPE)); // test float conversions assertFalse("float -> char", ClassUtils.isAssignable(Float.TYPE, Character.TYPE)); assertFalse("float -> byte", ClassUtils.isAssignable(Float.TYPE, Byte.TYPE)); assertFalse("float -> short", ClassUtils.isAssignable(Float.TYPE, Short.TYPE)); assertFalse("float -> int", ClassUtils.isAssignable(Float.TYPE, Integer.TYPE)); assertFalse("float -> long", ClassUtils.isAssignable(Float.TYPE, Long.TYPE)); assertTrue("float -> float", ClassUtils.isAssignable(Float.TYPE, Float.TYPE)); assertTrue("float -> double", ClassUtils.isAssignable(Float.TYPE, Double.TYPE)); assertFalse("float -> boolean", ClassUtils.isAssignable(Float.TYPE, Boolean.TYPE)); // test double conversions assertFalse("double -> char", ClassUtils.isAssignable(Double.TYPE, Character.TYPE)); assertFalse("double -> byte", ClassUtils.isAssignable(Double.TYPE, Byte.TYPE)); assertFalse("double -> short", ClassUtils.isAssignable(Double.TYPE, Short.TYPE)); assertFalse("double -> int", ClassUtils.isAssignable(Double.TYPE, Integer.TYPE)); assertFalse("double -> long", ClassUtils.isAssignable(Double.TYPE, Long.TYPE)); assertFalse("double -> float", ClassUtils.isAssignable(Double.TYPE, Float.TYPE)); assertTrue("double -> double", ClassUtils.isAssignable(Double.TYPE, Double.TYPE)); assertFalse("double -> boolean", ClassUtils.isAssignable(Double.TYPE, Boolean.TYPE)); // test boolean conversions assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.TYPE, Character.TYPE)); assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.TYPE, Byte.TYPE)); assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.TYPE, Short.TYPE)); assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.TYPE, Integer.TYPE)); assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.TYPE, Long.TYPE)); assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.TYPE, Float.TYPE)); assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.TYPE, Double.TYPE)); assertTrue("boolean -> boolean", ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE)); } @Test public void test_isAssignable_DefaultUnboxing_Widening() throws Exception { final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5); // test byte conversions assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE)); assertEquals("byte -> byte", autoboxing, ClassUtils.isAssignable(Byte.class, Byte.TYPE)); assertEquals("byte -> short", autoboxing, ClassUtils.isAssignable(Byte.class, Short.TYPE)); assertEquals("byte -> int", autoboxing, ClassUtils.isAssignable(Byte.class, Integer.TYPE)); assertEquals("byte -> long", autoboxing, ClassUtils.isAssignable(Byte.class, Long.TYPE)); assertEquals("byte -> float", autoboxing, ClassUtils.isAssignable(Byte.class, Float.TYPE)); assertEquals("byte -> double", autoboxing, ClassUtils.isAssignable(Byte.class, Double.TYPE)); assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE)); // test short conversions assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE)); assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE)); assertEquals("short -> short", autoboxing, ClassUtils.isAssignable(Short.class, Short.TYPE)); assertEquals("short -> int", autoboxing, ClassUtils.isAssignable(Short.class, Integer.TYPE)); assertEquals("short -> long", autoboxing, ClassUtils.isAssignable(Short.class, Long.TYPE)); assertEquals("short -> float", autoboxing, ClassUtils.isAssignable(Short.class, Float.TYPE)); assertEquals("short -> double", autoboxing, ClassUtils.isAssignable(Short.class, Double.TYPE)); assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE)); // test char conversions assertEquals("char -> char", autoboxing, ClassUtils.isAssignable(Character.class, Character.TYPE)); assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE)); assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE)); assertEquals("char -> int", autoboxing, ClassUtils.isAssignable(Character.class, Integer.TYPE)); assertEquals("char -> long", autoboxing, ClassUtils.isAssignable(Character.class, Long.TYPE)); assertEquals("char -> float", autoboxing, ClassUtils.isAssignable(Character.class, Float.TYPE)); assertEquals("char -> double", autoboxing, ClassUtils.isAssignable(Character.class, Double.TYPE)); assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE)); // test int conversions assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE)); assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE)); assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE)); assertEquals("int -> int", autoboxing, ClassUtils.isAssignable(Integer.class, Integer.TYPE)); assertEquals("int -> long", autoboxing, ClassUtils.isAssignable(Integer.class, Long.TYPE)); assertEquals("int -> float", autoboxing, ClassUtils.isAssignable(Integer.class, Float.TYPE)); assertEquals("int -> double", autoboxing, ClassUtils.isAssignable(Integer.class, Double.TYPE)); assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE)); // test long conversions assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE)); assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE)); assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE)); assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE)); assertEquals("long -> long", autoboxing, ClassUtils.isAssignable(Long.class, Long.TYPE)); assertEquals("long -> float", autoboxing, ClassUtils.isAssignable(Long.class, Float.TYPE)); assertEquals("long -> double", autoboxing, ClassUtils.isAssignable(Long.class, Double.TYPE)); assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE)); // test float conversions assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE)); assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE)); assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE)); assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE)); assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE)); assertEquals("float -> float", autoboxing, ClassUtils.isAssignable(Float.class, Float.TYPE)); assertEquals("float -> double", autoboxing, ClassUtils.isAssignable(Float.class, Double.TYPE)); assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE)); // test double conversions assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE)); assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE)); assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE)); assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE)); assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE)); assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE)); assertEquals("double -> double", autoboxing, ClassUtils.isAssignable(Double.class, Double.TYPE)); assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE)); // test boolean conversions assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE)); assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE)); assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE)); assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE)); assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE)); assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE)); assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE)); assertEquals("boolean -> boolean", autoboxing, ClassUtils.isAssignable(Boolean.class, Boolean.TYPE)); } @Test public void test_isAssignable_Unboxing_Widening() throws Exception { // test byte conversions assertFalse("byte -> char", ClassUtils.isAssignable(Byte.class, Character.TYPE, true)); assertTrue("byte -> byte", ClassUtils.isAssignable(Byte.class, Byte.TYPE, true)); assertTrue("byte -> short", ClassUtils.isAssignable(Byte.class, Short.TYPE, true)); assertTrue("byte -> int", ClassUtils.isAssignable(Byte.class, Integer.TYPE, true)); assertTrue("byte -> long", ClassUtils.isAssignable(Byte.class, Long.TYPE, true)); assertTrue("byte -> float", ClassUtils.isAssignable(Byte.class, Float.TYPE, true)); assertTrue("byte -> double", ClassUtils.isAssignable(Byte.class, Double.TYPE, true)); assertFalse("byte -> boolean", ClassUtils.isAssignable(Byte.class, Boolean.TYPE, true)); // test short conversions assertFalse("short -> char", ClassUtils.isAssignable(Short.class, Character.TYPE, true)); assertFalse("short -> byte", ClassUtils.isAssignable(Short.class, Byte.TYPE, true)); assertTrue("short -> short", ClassUtils.isAssignable(Short.class, Short.TYPE, true)); assertTrue("short -> int", ClassUtils.isAssignable(Short.class, Integer.TYPE, true)); assertTrue("short -> long", ClassUtils.isAssignable(Short.class, Long.TYPE, true)); assertTrue("short -> float", ClassUtils.isAssignable(Short.class, Float.TYPE, true)); assertTrue("short -> double", ClassUtils.isAssignable(Short.class, Double.TYPE, true)); assertFalse("short -> boolean", ClassUtils.isAssignable(Short.class, Boolean.TYPE, true)); // test char conversions assertTrue("char -> char", ClassUtils.isAssignable(Character.class, Character.TYPE, true)); assertFalse("char -> byte", ClassUtils.isAssignable(Character.class, Byte.TYPE, true)); assertFalse("char -> short", ClassUtils.isAssignable(Character.class, Short.TYPE, true)); assertTrue("char -> int", ClassUtils.isAssignable(Character.class, Integer.TYPE, true)); assertTrue("char -> long", ClassUtils.isAssignable(Character.class, Long.TYPE, true)); assertTrue("char -> float", ClassUtils.isAssignable(Character.class, Float.TYPE, true)); assertTrue("char -> double", ClassUtils.isAssignable(Character.class, Double.TYPE, true)); assertFalse("char -> boolean", ClassUtils.isAssignable(Character.class, Boolean.TYPE, true)); // test int conversions assertFalse("int -> char", ClassUtils.isAssignable(Integer.class, Character.TYPE, true)); assertFalse("int -> byte", ClassUtils.isAssignable(Integer.class, Byte.TYPE, true)); assertFalse("int -> short", ClassUtils.isAssignable(Integer.class, Short.TYPE, true)); assertTrue("int -> int", ClassUtils.isAssignable(Integer.class, Integer.TYPE, true)); assertTrue("int -> long", ClassUtils.isAssignable(Integer.class, Long.TYPE, true)); assertTrue("int -> float", ClassUtils.isAssignable(Integer.class, Float.TYPE, true)); assertTrue("int -> double", ClassUtils.isAssignable(Integer.class, Double.TYPE, true)); assertFalse("int -> boolean", ClassUtils.isAssignable(Integer.class, Boolean.TYPE, true)); // test long conversions assertFalse("long -> char", ClassUtils.isAssignable(Long.class, Character.TYPE, true)); assertFalse("long -> byte", ClassUtils.isAssignable(Long.class, Byte.TYPE, true)); assertFalse("long -> short", ClassUtils.isAssignable(Long.class, Short.TYPE, true)); assertFalse("long -> int", ClassUtils.isAssignable(Long.class, Integer.TYPE, true)); assertTrue("long -> long", ClassUtils.isAssignable(Long.class, Long.TYPE, true)); assertTrue("long -> float", ClassUtils.isAssignable(Long.class, Float.TYPE, true)); assertTrue("long -> double", ClassUtils.isAssignable(Long.class, Double.TYPE, true)); assertFalse("long -> boolean", ClassUtils.isAssignable(Long.class, Boolean.TYPE, true)); // test float conversions assertFalse("float -> char", ClassUtils.isAssignable(Float.class, Character.TYPE, true)); assertFalse("float -> byte", ClassUtils.isAssignable(Float.class, Byte.TYPE, true)); assertFalse("float -> short", ClassUtils.isAssignable(Float.class, Short.TYPE, true)); assertFalse("float -> int", ClassUtils.isAssignable(Float.class, Integer.TYPE, true)); assertFalse("float -> long", ClassUtils.isAssignable(Float.class, Long.TYPE, true)); assertTrue("float -> float", ClassUtils.isAssignable(Float.class, Float.TYPE, true)); assertTrue("float -> double", ClassUtils.isAssignable(Float.class, Double.TYPE, true)); assertFalse("float -> boolean", ClassUtils.isAssignable(Float.class, Boolean.TYPE, true)); // test double conversions assertFalse("double -> char", ClassUtils.isAssignable(Double.class, Character.TYPE, true)); assertFalse("double -> byte", ClassUtils.isAssignable(Double.class, Byte.TYPE, true)); assertFalse("double -> short", ClassUtils.isAssignable(Double.class, Short.TYPE, true)); assertFalse("double -> int", ClassUtils.isAssignable(Double.class, Integer.TYPE, true)); assertFalse("double -> long", ClassUtils.isAssignable(Double.class, Long.TYPE, true)); assertFalse("double -> float", ClassUtils.isAssignable(Double.class, Float.TYPE, true)); assertTrue("double -> double", ClassUtils.isAssignable(Double.class, Double.TYPE, true)); assertFalse("double -> boolean", ClassUtils.isAssignable(Double.class, Boolean.TYPE, true)); // test boolean conversions assertFalse("boolean -> char", ClassUtils.isAssignable(Boolean.class, Character.TYPE, true)); assertFalse("boolean -> byte", ClassUtils.isAssignable(Boolean.class, Byte.TYPE, true)); assertFalse("boolean -> short", ClassUtils.isAssignable(Boolean.class, Short.TYPE, true)); assertFalse("boolean -> int", ClassUtils.isAssignable(Boolean.class, Integer.TYPE, true)); assertFalse("boolean -> long", ClassUtils.isAssignable(Boolean.class, Long.TYPE, true)); assertFalse("boolean -> float", ClassUtils.isAssignable(Boolean.class, Float.TYPE, true)); assertFalse("boolean -> double", ClassUtils.isAssignable(Boolean.class, Double.TYPE, true)); assertTrue("boolean -> boolean", ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, true)); } @Test public void testIsPrimitiveOrWrapper() { // test primitive wrapper classes assertTrue("Boolean.class", ClassUtils.isPrimitiveOrWrapper(Boolean.class)); assertTrue("Byte.class", ClassUtils.isPrimitiveOrWrapper(Byte.class)); assertTrue("Character.class", ClassUtils.isPrimitiveOrWrapper(Character.class)); assertTrue("Short.class", ClassUtils.isPrimitiveOrWrapper(Short.class)); assertTrue("Integer.class", ClassUtils.isPrimitiveOrWrapper(Integer.class)); assertTrue("Long.class", ClassUtils.isPrimitiveOrWrapper(Long.class)); assertTrue("Double.class", ClassUtils.isPrimitiveOrWrapper(Double.class)); assertTrue("Float.class", ClassUtils.isPrimitiveOrWrapper(Float.class)); // test primitive classes assertTrue("boolean", ClassUtils.isPrimitiveOrWrapper(Boolean.TYPE)); assertTrue("byte", ClassUtils.isPrimitiveOrWrapper(Byte.TYPE)); assertTrue("char", ClassUtils.isPrimitiveOrWrapper(Character.TYPE)); assertTrue("short", ClassUtils.isPrimitiveOrWrapper(Short.TYPE)); assertTrue("int", ClassUtils.isPrimitiveOrWrapper(Integer.TYPE)); assertTrue("long", ClassUtils.isPrimitiveOrWrapper(Long.TYPE)); assertTrue("double", ClassUtils.isPrimitiveOrWrapper(Double.TYPE)); assertTrue("float", ClassUtils.isPrimitiveOrWrapper(Float.TYPE)); assertTrue("Void.TYPE", ClassUtils.isPrimitiveOrWrapper(Void.TYPE)); // others assertFalse("null", ClassUtils.isPrimitiveOrWrapper(null)); assertFalse("Void.class", ClassUtils.isPrimitiveOrWrapper(Void.class)); assertFalse("String.class", ClassUtils.isPrimitiveOrWrapper(String.class)); assertFalse("this.getClass()", ClassUtils.isPrimitiveOrWrapper(this.getClass())); } @Test public void testIsPrimitiveWrapper() { // test primitive wrapper classes assertTrue("Boolean.class", ClassUtils.isPrimitiveWrapper(Boolean.class)); assertTrue("Byte.class", ClassUtils.isPrimitiveWrapper(Byte.class)); assertTrue("Character.class", ClassUtils.isPrimitiveWrapper(Character.class)); assertTrue("Short.class", ClassUtils.isPrimitiveWrapper(Short.class)); assertTrue("Integer.class", ClassUtils.isPrimitiveWrapper(Integer.class)); assertTrue("Long.class", ClassUtils.isPrimitiveWrapper(Long.class)); assertTrue("Double.class", ClassUtils.isPrimitiveWrapper(Double.class)); assertTrue("Float.class", ClassUtils.isPrimitiveWrapper(Float.class)); // test primitive classes assertFalse("boolean", ClassUtils.isPrimitiveWrapper(Boolean.TYPE)); assertFalse("byte", ClassUtils.isPrimitiveWrapper(Byte.TYPE)); assertFalse("char", ClassUtils.isPrimitiveWrapper(Character.TYPE)); assertFalse("short", ClassUtils.isPrimitiveWrapper(Short.TYPE)); assertFalse("int", ClassUtils.isPrimitiveWrapper(Integer.TYPE)); assertFalse("long", ClassUtils.isPrimitiveWrapper(Long.TYPE)); assertFalse("double", ClassUtils.isPrimitiveWrapper(Double.TYPE)); assertFalse("float", ClassUtils.isPrimitiveWrapper(Float.TYPE)); // others assertFalse("null", ClassUtils.isPrimitiveWrapper(null)); assertFalse("Void.class", ClassUtils.isPrimitiveWrapper(Void.class)); assertFalse("Void.TYPE", ClassUtils.isPrimitiveWrapper(Void.TYPE)); assertFalse("String.class", ClassUtils.isPrimitiveWrapper(String.class)); assertFalse("this.getClass()", ClassUtils.isPrimitiveWrapper(this.getClass())); } @Test public void testPrimitiveToWrapper() { // test primitive classes assertEquals("boolean -> Boolean.class", Boolean.class, ClassUtils.primitiveToWrapper(Boolean.TYPE)); assertEquals("byte -> Byte.class", Byte.class, ClassUtils.primitiveToWrapper(Byte.TYPE)); assertEquals("char -> Character.class", Character.class, ClassUtils.primitiveToWrapper(Character.TYPE)); assertEquals("short -> Short.class", Short.class, ClassUtils.primitiveToWrapper(Short.TYPE)); assertEquals("int -> Integer.class", Integer.class, ClassUtils.primitiveToWrapper(Integer.TYPE)); assertEquals("long -> Long.class", Long.class, ClassUtils.primitiveToWrapper(Long.TYPE)); assertEquals("double -> Double.class", Double.class, ClassUtils.primitiveToWrapper(Double.TYPE)); assertEquals("float -> Float.class", Float.class, ClassUtils.primitiveToWrapper(Float.TYPE)); // test a few other classes assertEquals("String.class -> String.class", String.class, ClassUtils.primitiveToWrapper(String.class)); assertEquals("ClassUtils.class -> ClassUtils.class", org.apache.commons.lang3.ClassUtils.class, ClassUtils.primitiveToWrapper(org.apache.commons.lang3.ClassUtils.class)); assertEquals("Void.TYPE -> Void.TYPE", Void.TYPE, ClassUtils.primitiveToWrapper(Void.TYPE)); // test null assertNull("null -> null", ClassUtils.primitiveToWrapper(null)); } @Test public void testPrimitivesToWrappers() { // test null // assertNull("null -> null", ClassUtils.primitivesToWrappers(null)); // generates warning assertNull("null -> null", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent cast to avoid warning // Other possible casts for null assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers())); final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null} assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); // test empty array is returned unchanged // TODO this is not documented assertArrayEquals("empty -> empty", ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers(ArrayUtils.EMPTY_CLASS_ARRAY)); // test an array of various classes final Class<?>[] primitives = new Class[] { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Double.TYPE, Float.TYPE, String.class, ClassUtils.class }; final Class<?>[] wrappers= ClassUtils.primitivesToWrappers(primitives); for (int i=0; i < primitives.length; i++) { // test each returned wrapper final Class<?> primitive = primitives[i]; final Class<?> expectedWrapper = ClassUtils.primitiveToWrapper(primitive); assertEquals(primitive + " -> " + expectedWrapper, expectedWrapper, wrappers[i]); } // test an array of no primitive classes final Class<?>[] noPrimitives = new Class[] { String.class, ClassUtils.class, Void.TYPE }; // This used to return the exact same array, but no longer does. assertNotSame("unmodified", noPrimitives, ClassUtils.primitivesToWrappers(noPrimitives)); } @Test public void testWrapperToPrimitive() { // an array with classes to convert final Class<?>[] primitives = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }; for (final Class<?> primitive : primitives) { final Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitive); assertFalse("Still primitive", wrapperCls.isPrimitive()); assertEquals(wrapperCls + " -> " + primitive, primitive, ClassUtils.wrapperToPrimitive(wrapperCls)); } } @Test public void testWrapperToPrimitiveNoWrapper() { assertNull("Wrong result for non wrapper class", ClassUtils.wrapperToPrimitive(String.class)); } @Test public void testWrapperToPrimitiveNull() { assertNull("Wrong result for null class", ClassUtils.wrapperToPrimitive(null)); } @Test public void testWrappersToPrimitives() { // an array with classes to test final Class<?>[] classes = { Boolean.class, Byte.class, Character.class, Short.class, Integer.class, Long.class, Float.class, Double.class, String.class, ClassUtils.class, null }; final Class<?>[] primitives = ClassUtils.wrappersToPrimitives(classes); // now test the result assertEquals("Wrong length of result array", classes.length, primitives.length); for (int i = 0; i < classes.length; i++) { final Class<?> expectedPrimitive = ClassUtils.wrapperToPrimitive(classes[i]); assertEquals(classes[i] + " -> " + expectedPrimitive, expectedPrimitive, primitives[i]); } } @Test public void testWrappersToPrimitivesNull() { // assertNull("Wrong result for null input", ClassUtils.wrappersToPrimitives(null)); // generates warning assertNull("Wrong result for null input", ClassUtils.wrappersToPrimitives((Class<?>[]) null)); // equivalent cast // Other possible casts for null assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.wrappersToPrimitives())); final Class<?>[] castNull = ClassUtils.wrappersToPrimitives((Class<?>)null); // == new Class<?>[]{null} assertTrue("(Class<?>)null -> [null]", Arrays.equals(new Class<?>[]{null}, castNull)); } @Test public void testWrappersToPrimitivesEmpty() { final Class<?>[] empty = new Class[0]; assertArrayEquals("Wrong result for empty input", empty, ClassUtils.wrappersToPrimitives(empty)); } @Test public void testGetClassClassNotFound() throws Exception { assertGetClassThrowsClassNotFound( "bool" ); assertGetClassThrowsClassNotFound( "bool[]" ); assertGetClassThrowsClassNotFound( "integer[]" ); } @Test public void testGetClassInvalidArguments() throws Exception { assertGetClassThrowsNullPointerException( null ); assertGetClassThrowsClassNotFound( "[][][]" ); assertGetClassThrowsClassNotFound( "[[]" ); assertGetClassThrowsClassNotFound( "[" ); assertGetClassThrowsClassNotFound( "java.lang.String][" ); assertGetClassThrowsClassNotFound( ".hello.world" ); assertGetClassThrowsClassNotFound( "hello..world" ); } @Test public void testWithInterleavingWhitespace() throws ClassNotFoundException { assertEquals( int[].class, ClassUtils.getClass( " int [ ] " ) ); assertEquals( long[].class, ClassUtils.getClass( "\rlong\t[\n]\r" ) ); assertEquals( short[].class, ClassUtils.getClass( "\tshort \t\t[]" ) ); assertEquals( byte[].class, ClassUtils.getClass( "byte[\t\t\n\r] " ) ); } @Test public void testGetInnerClass() throws ClassNotFoundException { assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested" ) ); assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested" ) ); assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested" ) ); assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested" ) ); } @Test public void testGetClassByNormalNameArrays() throws ClassNotFoundException { assertEquals( int[].class, ClassUtils.getClass( "int[]" ) ); assertEquals( long[].class, ClassUtils.getClass( "long[]" ) ); assertEquals( short[].class, ClassUtils.getClass( "short[]" ) ); assertEquals( byte[].class, ClassUtils.getClass( "byte[]" ) ); assertEquals( char[].class, ClassUtils.getClass( "char[]" ) ); assertEquals( float[].class, ClassUtils.getClass( "float[]" ) ); assertEquals( double[].class, ClassUtils.getClass( "double[]" ) ); assertEquals( boolean[].class, ClassUtils.getClass( "boolean[]" ) ); assertEquals( String[].class, ClassUtils.getClass( "java.lang.String[]" ) ); assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "java.util.Map.Entry[]" ) ); assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "java.util.Map$Entry[]" ) ); assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "[Ljava.util.Map.Entry;" ) ); assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "[Ljava.util.Map$Entry;" ) ); } @Test public void testGetClassByNormalNameArrays2D() throws ClassNotFoundException { assertEquals( int[][].class, ClassUtils.getClass( "int[][]" ) ); assertEquals( long[][].class, ClassUtils.getClass( "long[][]" ) ); assertEquals( short[][].class, ClassUtils.getClass( "short[][]" ) ); assertEquals( byte[][].class, ClassUtils.getClass( "byte[][]" ) ); assertEquals( char[][].class, ClassUtils.getClass( "char[][]" ) ); assertEquals( float[][].class, ClassUtils.getClass( "float[][]" ) ); assertEquals( double[][].class, ClassUtils.getClass( "double[][]" ) ); assertEquals( boolean[][].class, ClassUtils.getClass( "boolean[][]" ) ); assertEquals( String[][].class, ClassUtils.getClass( "java.lang.String[][]" ) ); } @Test public void testGetClassWithArrayClasses2D() throws Exception { assertGetClassReturnsClass( String[][].class ); assertGetClassReturnsClass( int[][].class ); assertGetClassReturnsClass( long[][].class ); assertGetClassReturnsClass( short[][].class ); assertGetClassReturnsClass( byte[][].class ); assertGetClassReturnsClass( char[][].class ); assertGetClassReturnsClass( float[][].class ); assertGetClassReturnsClass( double[][].class ); assertGetClassReturnsClass( boolean[][].class ); } @Test public void testGetClassWithArrayClasses() throws Exception { assertGetClassReturnsClass( String[].class ); assertGetClassReturnsClass( int[].class ); assertGetClassReturnsClass( long[].class ); assertGetClassReturnsClass( short[].class ); assertGetClassReturnsClass( byte[].class ); assertGetClassReturnsClass( char[].class ); assertGetClassReturnsClass( float[].class ); assertGetClassReturnsClass( double[].class ); assertGetClassReturnsClass( boolean[].class ); } @Test public void testGetClassRawPrimitives() throws ClassNotFoundException { assertEquals( int.class, ClassUtils.getClass( "int" ) ); assertEquals( long.class, ClassUtils.getClass( "long" ) ); assertEquals( short.class, ClassUtils.getClass( "short" ) ); assertEquals( byte.class, ClassUtils.getClass( "byte" ) ); assertEquals( char.class, ClassUtils.getClass( "char" ) ); assertEquals( float.class, ClassUtils.getClass( "float" ) ); assertEquals( double.class, ClassUtils.getClass( "double" ) ); assertEquals( boolean.class, ClassUtils.getClass( "boolean" ) ); } private void assertGetClassReturnsClass( final Class<?> c ) throws Exception { assertEquals( c, ClassUtils.getClass( c.getName() ) ); } private void assertGetClassThrowsException( final String className, final Class<?> exceptionType ) throws Exception { try { ClassUtils.getClass( className ); fail( "ClassUtils.getClass() should fail with an exception of type " + exceptionType.getName() + " when given class name \"" + className + "\"." ); } catch( final Exception e ) { assertTrue( exceptionType.isAssignableFrom( e.getClass() ) ); } } private void assertGetClassThrowsNullPointerException( final String className ) throws Exception { assertGetClassThrowsException( className, NullPointerException.class ); } private void assertGetClassThrowsClassNotFound( final String className ) throws Exception { assertGetClassThrowsException( className, ClassNotFoundException.class ); } // Show the Java bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957 // We may have to delete this if a JDK fixes the bug. @Test public void testShowJavaBug() throws Exception { // Tests with Collections$UnmodifiableSet final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); final Method isEmptyMethod = set.getClass().getMethod("isEmpty", new Class[0]); try { isEmptyMethod.invoke(set, new Object[0]); fail("Failed to throw IllegalAccessException as expected"); } catch(final IllegalAccessException iae) { // expected } } @Test public void testGetPublicMethod() throws Exception { // Tests with Collections$UnmodifiableSet final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>()); final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty", new Class[0]); assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers())); try { isEmptyMethod.invoke(set, new Object[0]); } catch(final java.lang.IllegalAccessException iae) { fail("Should not have thrown IllegalAccessException"); } // Tests with a public Class final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString", new Class[0]); assertEquals(Object.class.getMethod("toString", new Class[0]), toStringMethod); } @Test public void testToClass_object() { // assertNull(ClassUtils.toClass(null)); // generates warning assertNull(ClassUtils.toClass((Object[]) null)); // equivalent explicit cast // Additional varargs tests assertTrue("empty -> empty", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass())); final Class<?>[] castNull = ClassUtils.toClass((Object) null); // == new Object[]{null} assertTrue("(Object)null -> [null]", Arrays.equals(new Object[]{null}, castNull)); assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY)); assertTrue(Arrays.equals(new Class[] { String.class, Integer.class, Double.class }, ClassUtils.toClass(new Object[] { "Test", Integer.valueOf(1), Double.valueOf(99d) }))); assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class }, ClassUtils.toClass(new Object[] { "Test", null, Double.valueOf(99d) }))); } @Test public void test_getShortCanonicalName_Object() { assertEquals("<null>", ClassUtils.getShortCanonicalName(null, "<null>")); assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(new ClassUtils(), "<null>")); assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName(new ClassUtils[0], "<null>")); assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName(new ClassUtils[0][0], "<null>")); assertEquals("int[]", ClassUtils.getShortCanonicalName(new int[0], "<null>")); assertEquals("int[][]", ClassUtils.getShortCanonicalName(new int[0][0], "<null>")); // Inner types class Named extends Object {} assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName(new Object(){}, "<null>")); assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName(new Named(), "<null>")); assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(new Inner(), "<null>")); } @Test public void test_getShortCanonicalName_Class() { assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(ClassUtils.class)); assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName(ClassUtils[].class)); assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName(ClassUtils[][].class)); assertEquals("int[]", ClassUtils.getShortCanonicalName(int[].class)); assertEquals("int[][]", ClassUtils.getShortCanonicalName(int[][].class)); // Inner types class Named extends Object {} assertEquals("ClassUtilsTest.7", ClassUtils.getShortCanonicalName(new Object(){}.getClass())); assertEquals("ClassUtilsTest.6Named", ClassUtils.getShortCanonicalName(Named.class)); assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(Inner.class)); } @Test public void test_getShortCanonicalName_String() { assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils")); assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]")); assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); assertEquals("int[]", ClassUtils.getShortCanonicalName("[I")); assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I")); assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]")); assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]")); // Inner types assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); } @Test public void test_getPackageCanonicalName_Object() { assertEquals("<null>", ClassUtils.getPackageCanonicalName(null, "<null>")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils(), "<null>")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils[0], "<null>")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils[0][0], "<null>")); assertEquals("", ClassUtils.getPackageCanonicalName(new int[0], "<null>")); assertEquals("", ClassUtils.getPackageCanonicalName(new int[0][0], "<null>")); // Inner types class Named extends Object {} assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Object(){}, "<null>")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Named(), "<null>")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Inner(), "<null>")); } @Test public void test_getPackageCanonicalName_Class() { assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(ClassUtils.class)); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(ClassUtils[].class)); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(ClassUtils[][].class)); assertEquals("", ClassUtils.getPackageCanonicalName(int[].class)); assertEquals("", ClassUtils.getPackageCanonicalName(int[][].class)); // Inner types class Named extends Object {} assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Object(){}.getClass())); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(Named.class)); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(Inner.class)); } @Test public void test_getPackageCanonicalName_String() { assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtils")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtils[]")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtils[][]")); assertEquals("", ClassUtils.getPackageCanonicalName("[I")); assertEquals("", ClassUtils.getPackageCanonicalName("[[I")); assertEquals("", ClassUtils.getPackageCanonicalName("int[]")); assertEquals("", ClassUtils.getPackageCanonicalName("int[][]")); // Inner types assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named")); assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner")); } }
/******************************************************************************* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. *******************************************************************************/ package org.apache.commons.lang3; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import java.util.UUID; import org.junit.Test; /** * Unit tests {@link Conversion}. * * @version $Id$ */ public class ConversionTest { /** * Tests {@link Conversion#hexDigitToInt(char)}. */ @Test public void testHexDigitToInt() { assertEquals(0, Conversion.hexDigitToInt('0')); assertEquals(1, Conversion.hexDigitToInt('1')); assertEquals(2, Conversion.hexDigitToInt('2')); assertEquals(3, Conversion.hexDigitToInt('3')); assertEquals(4, Conversion.hexDigitToInt('4')); assertEquals(5, Conversion.hexDigitToInt('5')); assertEquals(6, Conversion.hexDigitToInt('6')); assertEquals(7, Conversion.hexDigitToInt('7')); assertEquals(8, Conversion.hexDigitToInt('8')); assertEquals(9, Conversion.hexDigitToInt('9')); assertEquals(10, Conversion.hexDigitToInt('A')); assertEquals(10, Conversion.hexDigitToInt('a')); assertEquals(11, Conversion.hexDigitToInt('B')); assertEquals(11, Conversion.hexDigitToInt('b')); assertEquals(12, Conversion.hexDigitToInt('C')); assertEquals(12, Conversion.hexDigitToInt('c')); assertEquals(13, Conversion.hexDigitToInt('D')); assertEquals(13, Conversion.hexDigitToInt('d')); assertEquals(14, Conversion.hexDigitToInt('E')); assertEquals(14, Conversion.hexDigitToInt('e')); assertEquals(15, Conversion.hexDigitToInt('F')); assertEquals(15, Conversion.hexDigitToInt('f')); try { Conversion.hexDigitToInt('G'); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#hexDigitMsb0ToInt(char)}. */ @Test public void testHexDigitMsb0ToInt() { assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0')); assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1')); assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2')); assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3')); assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4')); assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5')); assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6')); assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7')); assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8')); assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9')); assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A')); assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a')); assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B')); assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b')); assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C')); assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c')); assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D')); assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d')); assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E')); assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e')); assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F')); assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f')); try { Conversion.hexDigitMsb0ToInt('G'); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#hexDigitToBinary(char)}. */ @Test public void testHexDigitToBinary() { assertBinaryEquals( new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0')); assertBinaryEquals( new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1')); assertBinaryEquals( new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2')); assertBinaryEquals( new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3')); assertBinaryEquals( new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4')); assertBinaryEquals( new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5')); assertBinaryEquals( new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6')); assertBinaryEquals( new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7')); assertBinaryEquals( new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8')); assertBinaryEquals( new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9')); assertBinaryEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A')); assertBinaryEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a')); assertBinaryEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B')); assertBinaryEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b')); assertBinaryEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C')); assertBinaryEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c')); assertBinaryEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D')); assertBinaryEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d')); assertBinaryEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E')); assertBinaryEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e')); assertBinaryEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F')); assertBinaryEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f')); try { Conversion.hexDigitToBinary('G'); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}. */ @Test public void testHexDigitMsb0ToBinary() { assertBinaryEquals( new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0')); assertBinaryEquals( new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1')); assertBinaryEquals( new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2')); assertBinaryEquals( new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3')); assertBinaryEquals( new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4')); assertBinaryEquals( new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5')); assertBinaryEquals( new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6')); assertBinaryEquals( new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7')); assertBinaryEquals( new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8')); assertBinaryEquals( new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9')); assertBinaryEquals( new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A')); assertBinaryEquals( new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a')); assertBinaryEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B')); assertBinaryEquals( new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b')); assertBinaryEquals( new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C')); assertBinaryEquals( new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c')); assertBinaryEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D')); assertBinaryEquals( new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d')); assertBinaryEquals( new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E')); assertBinaryEquals( new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e')); assertBinaryEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F')); assertBinaryEquals( new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f')); try { Conversion.hexDigitMsb0ToBinary('G'); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#binaryToHexDigit(boolean[])}. */ @Test public void testBinaryToHexDigit() { assertEquals( '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false})); assertEquals('1', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false})); assertEquals('2', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false})); assertEquals('3', Conversion.binaryToHexDigit(new boolean[]{true, true, false, false})); assertEquals('4', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false})); assertEquals('5', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false})); assertEquals('6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false})); assertEquals('7', Conversion.binaryToHexDigit(new boolean[]{true, true, true, false})); assertEquals('8', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true})); assertEquals('9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true})); assertEquals('a', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true})); assertEquals('b', Conversion.binaryToHexDigit(new boolean[]{true, true, false, true})); assertEquals('c', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true})); assertEquals('d', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true})); assertEquals('e', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true})); assertEquals('f', Conversion.binaryToHexDigit(new boolean[]{true, true, true, true})); assertEquals('1', Conversion.binaryToHexDigit(new boolean[]{true})); assertEquals( 'f', Conversion.binaryToHexDigit(new boolean[]{true, true, true, true, true})); try { Conversion.binaryToHexDigit(new boolean[]{}); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#binaryBeMsb0ToHexDigit(boolean[], int)}. */ @Test public void testBinaryToHexDigit_2args() { final boolean[] shortArray = new boolean[]{false, true, true}; assertEquals('6', Conversion.binaryToHexDigit(shortArray, 0)); assertEquals('3', Conversion.binaryToHexDigit(shortArray, 1)); assertEquals('1', Conversion.binaryToHexDigit(shortArray, 2)); final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true}; assertEquals('5', Conversion.binaryToHexDigit(longArray, 0)); assertEquals('2', Conversion.binaryToHexDigit(longArray, 1)); assertEquals('9', Conversion.binaryToHexDigit(longArray, 2)); assertEquals('c', Conversion.binaryToHexDigit(longArray, 3)); assertEquals('6', Conversion.binaryToHexDigit(longArray, 4)); assertEquals('3', Conversion.binaryToHexDigit(longArray, 5)); assertEquals('1', Conversion.binaryToHexDigit(longArray, 6)); } /** * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[])}. */ @Test public void testBinaryToHexDigitMsb0_bits() { assertEquals( '0', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false})); assertEquals( '1', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true})); assertEquals( '2', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false})); assertEquals( '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true})); assertEquals( '4', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false})); assertEquals( '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, true})); assertEquals( '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false})); assertEquals( '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true})); assertEquals( '8', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false})); assertEquals( '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true})); assertEquals( 'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false})); assertEquals( 'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, true})); assertEquals( 'c', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, false, false})); assertEquals( 'd', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, false, true})); assertEquals( 'e', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, true, false})); assertEquals( 'f', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, true, true})); try { Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{}); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[], int)}. */ @Test public void testBinaryToHexDigitMsb0_4bits_2args() { // boolean[] shortArray = new boolean[]{true,true,false}; // assertEquals('6', Conversion.BinaryToHexDigitMsb0(shortArray,0)); // assertEquals('3', Conversion.BinaryToHexDigitMsb0(shortArray,1)); // assertEquals('1', Conversion.BinaryToHexDigitMsb0(shortArray,2)); final boolean[] shortArray = new boolean[]{true, true, false, true}; assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(shortArray, 0)); final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true}; assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(longArray, 0)); assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(longArray, 1)); assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(longArray, 2)); assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(longArray, 3)); // assertEquals('6', Conversion.BinaryToHexDigitMsb0(longArray,4)); // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray,5)); // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray,6)); final boolean[] maxLengthArray = new boolean[]{ true, false, true, false, false, true, true, true}; assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 0)); assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 1)); assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 2)); assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 3)); assertEquals('7', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 4)); // assertEquals('7', Conversion.BinaryToHexDigitMsb0(longArray,5)); // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray,6)); // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray,7)); final boolean[] javaDocCheck = new boolean[]{ true, false, false, true, true, false, true, false}; assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(javaDocCheck, 3)); } /** * Tests {@link Conversion#binaryToHexDigit(boolean[])}. */ @Test public void testBinaryBeMsb0ToHexDigit() { assertEquals( '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false})); assertEquals( '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true})); assertEquals( '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false})); assertEquals( '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true})); assertEquals( '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false})); assertEquals( '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true})); assertEquals( '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false})); assertEquals( '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true})); assertEquals( '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false})); assertEquals( '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true})); assertEquals( 'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false})); assertEquals( 'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true})); assertEquals( 'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false})); assertEquals( 'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true})); assertEquals( 'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false})); assertEquals( 'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true})); assertEquals( '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false})); try { Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}. */ @Test public void testBinaryBeMsb0ToHexDigit_2args() { assertEquals( '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false}, 2)); final boolean[] shortArray = new boolean[]{true, true, false}; assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(shortArray, 0)); assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray, 1)); assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray, 2)); final boolean[] shortArray2 = new boolean[]{true, true, true, false, false, true, false, true}; assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 0)); assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 1)); assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 2)); assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 3)); assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 4)); assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 5)); assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 6)); assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 7)); final boolean[] multiBytesArray = new boolean[]{ true, true, false, false, true, false, true, false, true, true, true, false, false, true, false, true}; assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 0)); assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 1)); assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 2)); assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 3)); assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 4)); assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 5)); assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 6)); assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 7)); assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 8)); assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 9)); assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 10)); assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 11)); assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 12)); assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 13)); assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 14)); assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 15)); } /** * Tests {@link Conversion#intToHexDigit(int)}. */ @Test public void testIntToHexDigit() { assertEquals('0', Conversion.intToHexDigit(0)); assertEquals('1', Conversion.intToHexDigit(1)); assertEquals('2', Conversion.intToHexDigit(2)); assertEquals('3', Conversion.intToHexDigit(3)); assertEquals('4', Conversion.intToHexDigit(4)); assertEquals('5', Conversion.intToHexDigit(5)); assertEquals('6', Conversion.intToHexDigit(6)); assertEquals('7', Conversion.intToHexDigit(7)); assertEquals('8', Conversion.intToHexDigit(8)); assertEquals('9', Conversion.intToHexDigit(9)); assertEquals('a', Conversion.intToHexDigit(10)); assertEquals('b', Conversion.intToHexDigit(11)); assertEquals('c', Conversion.intToHexDigit(12)); assertEquals('d', Conversion.intToHexDigit(13)); assertEquals('e', Conversion.intToHexDigit(14)); assertEquals('f', Conversion.intToHexDigit(15)); try { Conversion.intToHexDigit(16); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } /** * Tests {@link Conversion#intToHexDigitMsb0(int)}. */ @Test public void testIntToHexDigitMsb0() { assertEquals('0', Conversion.intToHexDigitMsb0(0)); assertEquals('8', Conversion.intToHexDigitMsb0(1)); assertEquals('4', Conversion.intToHexDigitMsb0(2)); assertEquals('c', Conversion.intToHexDigitMsb0(3)); assertEquals('2', Conversion.intToHexDigitMsb0(4)); assertEquals('a', Conversion.intToHexDigitMsb0(5)); assertEquals('6', Conversion.intToHexDigitMsb0(6)); assertEquals('e', Conversion.intToHexDigitMsb0(7)); assertEquals('1', Conversion.intToHexDigitMsb0(8)); assertEquals('9', Conversion.intToHexDigitMsb0(9)); assertEquals('5', Conversion.intToHexDigitMsb0(10)); assertEquals('d', Conversion.intToHexDigitMsb0(11)); assertEquals('3', Conversion.intToHexDigitMsb0(12)); assertEquals('b', Conversion.intToHexDigitMsb0(13)); assertEquals('7', Conversion.intToHexDigitMsb0(14)); assertEquals('f', Conversion.intToHexDigitMsb0(15)); try { Conversion.intToHexDigitMsb0(16); fail("Thrown " + IllegalArgumentException.class.getName() + " expected"); } catch (final IllegalArgumentException e) { // OK } } static String dbgPrint(final boolean[] src) { final StringBuilder sb = new StringBuilder(); for (final boolean e : src) { if (e) { sb.append("1,"); } else { sb.append("0,"); } } final String out = sb.toString(); return out.substring(0, out.length() - 1); } // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2 static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) { assertEquals(expected.length, actual.length); for (int i = 0; i < expected.length; i++ ) { try { assertEquals(expected[i], actual[i]); } catch (final Throwable e) { final String msg = "Mismatch at index " + i + " between:\n" + dbgPrint(expected) + " and\n" + dbgPrint(actual); fail(msg + "\n" + e.getMessage()); } } } /** * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}. */ @Test public void testIntArrayToLong() { final int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000}; assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0)); assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0)); assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1)); assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2)); assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1)); assertEquals( 0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); assertEquals( 0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1)); // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2)); } /** * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}. */ @Test public void testShortArrayToLong() { final short[] src = new short[]{ (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0)); assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1)); assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2)); assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4)); assertEquals( 0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); assertEquals( 0x123456CDF1BCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); assertEquals( 0x123478003456DEF0L, Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2)); } /** * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}. */ @Test public void testByteArrayToLong() { final byte[] src = new byte[]{ (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, (byte)0x56, (byte)0x78}; assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0)); assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1)); assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4)); assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4)); assertEquals( 0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0)); assertEquals( 0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1)); assertEquals( 0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2)); } /** * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}. */ @Test public void testShortArrayToInt() { final short[] src = new short[]{ (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800}; assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0)); assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1)); assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2)); assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2)); assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0)); assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1)); // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2)); } /** * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}. */ @Test public void testByteArrayToInt() { final byte[] src = new byte[]{ (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, (byte)0x56, (byte)0x78}; assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0)); assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1)); assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4)); assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4)); assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0)); assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1)); // assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4)); } /** * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}. */ @Test public void testByteArrayToShort() { final byte[] src = new byte[]{ (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34, (byte)0x56, (byte)0x78}; assertEquals((short)0x0000, Conversion.byteArrayToShort(src, 0, (short)0, 0, 0)); assertEquals((short)0x00CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 1)); assertEquals((short)0xF1CD, Conversion.byteArrayToShort(src, 0, (short)0, 0, 2)); assertEquals((short)0xF0F1, Conversion.byteArrayToShort(src, 1, (short)0, 0, 2)); assertEquals((short)0x1234, Conversion.byteArrayToShort(src, 0, (short)0x1234, 0, 0)); assertEquals((short)0xCD34, Conversion.byteArrayToShort(src, 0, (short)0x1234, 8, 1)); // assertEquals((short)0x5678,Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8, // 2)); } /** * Tests {@link Conversion#hexToLong(String, int, long, int, int)}. */ @Test public void testHexToLong() { final String src = "CDF1F0C10F12345678"; assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0)); assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1)); assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8)); assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8)); assertEquals( 0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); assertEquals( 0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3)); } /** * Tests {@link Conversion#hexToInt(String, int, int, int, int)}. */ @Test public void testHexToInt() { final String src = "CDF1F0C10F12345678"; assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0)); assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1)); assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8)); assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8)); assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0)); assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3)); } /** * Tests {@link Conversion#hexToShort(String, int, short, int, int)}. */ @Test public void testHexToShort() { final String src = "CDF1F0C10F12345678"; assertEquals((short)0x0000, Conversion.hexToShort(src, 0, (short)0, 0, 0)); assertEquals((short)0x000C, Conversion.hexToShort(src, 0, (short)0, 0, 1)); assertEquals((short)0x1FDC, Conversion.hexToShort(src, 0, (short)0, 0, 4)); assertEquals((short)0xF1FD, Conversion.hexToShort(src, 1, (short)0, 0, 4)); assertEquals((short)0x1234, Conversion.hexToShort(src, 0, (short)0x1234, 0, 0)); assertEquals((short)0x8764, Conversion.hexToShort(src, 15, (short)0x1234, 4, 3)); } /** * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}. */ @Test public void testHexToByte() { final String src = "CDF1F0C10F12345678"; assertEquals((byte)0x00, Conversion.hexToByte(src, 0, (byte)0, 0, 0)); assertEquals((byte)0x0C, Conversion.hexToByte(src, 0, (byte)0, 0, 1)); assertEquals((byte)0xDC, Conversion.hexToByte(src, 0, (byte)0, 0, 2)); assertEquals((byte)0xFD, Conversion.hexToByte(src, 1, (byte)0, 0, 2)); assertEquals((byte)0x34, Conversion.hexToByte(src, 0, (byte)0x34, 0, 0)); assertEquals((byte)0x84, Conversion.hexToByte(src, 17, (byte)0x34, 4, 1)); } /** * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}. */ @Test public void testBinaryToLong() { final boolean[] src = new boolean[]{ false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true}; // conversion of "CDF1F0C10F12345678" by HexToBinary assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0)); assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4)); assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4)); assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4)); assertEquals( 0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0)); assertEquals( 0x1234567876BCDEF0L, Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4)); } /** * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}. */ @Test public void testBinaryToInt() { final boolean[] src = new boolean[]{ false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true}; // conversion of "CDF1F0C10F12345678" by HexToBinary assertEquals(0x00000000, Conversion.binaryToInt(src, 0 * 4, 0, 0, 0 * 4)); assertEquals(0x0000000C, Conversion.binaryToInt(src, 0 * 4, 0, 0, 1 * 4)); assertEquals(0x1C0F1FDC, Conversion.binaryToInt(src, 0 * 4, 0, 0, 8 * 4)); assertEquals(0x01C0F1FD, Conversion.binaryToInt(src, 1 * 4, 0, 0, 8 * 4)); assertEquals(0x12345679, Conversion.binaryToInt(src, 0 * 4, 0x12345679, 0, 0 * 4)); assertEquals(0x87645679, Conversion.binaryToInt(src, 15 * 4, 0x12345679, 20, 3 * 4)); } /** * Tests {@link Conversion#binaryToShort(boolean[], int, short, int, int)}. */ @Test public void testBinaryToShort() { final boolean[] src = new boolean[]{ false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true}; // conversion of "CDF1F0C10F12345678" by HexToBinary assertEquals((short)0x0000, Conversion.binaryToShort(src, 0 * 4, (short)0, 0, 0 * 4)); assertEquals((short)0x000C, Conversion.binaryToShort(src, 0 * 4, (short)0, 0, 1 * 4)); assertEquals((short)0x1FDC, Conversion.binaryToShort(src, 0 * 4, (short)0, 0, 4 * 4)); assertEquals((short)0xF1FD, Conversion.binaryToShort(src, 1 * 4, (short)0, 0, 4 * 4)); assertEquals( (short)0x1234, Conversion.binaryToShort(src, 0 * 4, (short)0x1234, 0, 0 * 4)); assertEquals( (short)0x8764, Conversion.binaryToShort(src, 15 * 4, (short)0x1234, 4, 3 * 4)); } /** * Tests {@link Conversion#binaryToByte(boolean[], int, byte, int, int)}. */ @Test public void testBinaryToByte() { final boolean[] src = new boolean[]{ false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true}; // conversion of "CDF1F0C10F12345678" by HexToBinary assertEquals((byte)0x00, Conversion.binaryToByte(src, 0 * 4, (byte)0, 0, 0 * 4)); assertEquals((byte)0x0C, Conversion.binaryToByte(src, 0 * 4, (byte)0, 0, 1 * 4)); assertEquals((byte)0xDC, Conversion.binaryToByte(src, 0 * 4, (byte)0, 0, 2 * 4)); assertEquals((byte)0xFD, Conversion.binaryToByte(src, 1 * 4, (byte)0, 0, 2 * 4)); assertEquals((byte)0x34, Conversion.binaryToByte(src, 0 * 4, (byte)0x34, 0, 0 * 4)); assertEquals((byte)0x84, Conversion.binaryToByte(src, 17 * 4, (byte)0x34, 4, 1 * 4)); } /** * Tests {@link Conversion#longToIntArray(long, int, int[], int, int)}. */ @Test public void testLongToIntArray() { assertArrayEquals( new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 0, 0)); assertArrayEquals( new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[]{}, 0, 0)); assertArrayEquals( new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 100, 0)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0)); assertArrayEquals( new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1)); assertArrayEquals( new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 2)); // assertArrayEquals(new // int[]{0x90ABCDEF,0x12345678,0x90ABCDEF,0x12345678},Conversion.longToIntArray(0x1234567890ABCDEFL, // 0,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion // assertArrayEquals(new // int[]{0xFFFFFFFF,0x90ABCDEF,0x12345678,0x90ABCDEF},Conversion.longToIntArray(0x1234567890ABCDEFL, // 0,new int[]{-1,-1,-1,-1},1,3)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678}, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 2)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 3, 1)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF}, Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[]{-1, -1, -1, -1}, 2, 1)); // assertArrayEquals(new // int[]{0x4855E6F7,0x091A2B3C,0x4855E6F7,0x091A2B3C},Conversion.longToIntArray(0x1234567890ABCDEFL, // 1,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion assertArrayEquals( new int[]{0x091A2B3C}, Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[]{0}, 0, 1)); } /** * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}. */ @Test public void testLongToShortArray() { assertArrayEquals( new short[]{}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[]{}, 0, 0)); assertArrayEquals( new short[]{}, Conversion.longToShortArray(0x0000000000000000L, 100, new short[]{}, 0, 0)); assertArrayEquals( new short[]{}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[]{}, 100, 0)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 0)); assertArrayEquals( new short[]{(short)0xCDEF, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 1)); assertArrayEquals( new short[]{(short)0xCDEF, (short)0x90AB, (short)0xFFFF, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 2)); assertArrayEquals( new short[]{(short)0xCDEF, (short)0x90AB, (short)0x5678, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 3)); assertArrayEquals( new short[]{(short)0xCDEF, (short)0x90AB, (short)0x5678, (short)0x1234}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 4)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xCDEF, (short)0x90AB, (short)0x5678}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 1, 3)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xCDEF, (short)0x90AB}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 2, 2)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xCDEF, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0xCDEF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 3, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xE6F7, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 1, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xF37B, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 2, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x79BD, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 3, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xBCDE, (short)0xFFFF}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 4, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xE6F7, (short)0x4855, (short)0x2B3C, (short)0x091A}, Conversion.longToShortArray( 0x1234567890ABCDEFL, 1, new short[]{-1, -1, -1, -1}, 0, 4)); assertArrayEquals( new short[]{(short)0x2B3C}, Conversion.longToShortArray(0x1234567890ABCDEFL, 33, new short[]{0}, 0, 1)); } /** * Tests {@link Conversion#intToShortArray(int, int, short[], int, int)}. */ @Test public void testIntToShortArray() { assertArrayEquals( new short[]{}, Conversion.intToShortArray(0x00000000, 0, new short[]{}, 0, 0)); assertArrayEquals( new short[]{}, Conversion.intToShortArray(0x00000000, 100, new short[]{}, 0, 0)); assertArrayEquals( new short[]{}, Conversion.intToShortArray(0x00000000, 0, new short[]{}, 100, 0)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 0)); assertArrayEquals( new short[]{(short)0x5678, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 1)); assertArrayEquals( new short[]{(short)0x5678, (short)0x1234, (short)0xFFFF, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 2)); // assertArrayEquals(new // short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0xFFFF},Conversion.intToShortArray(0x12345678, // 0,new short[]{-1,-1,-1,-1},0,3));//rejected by assertion // assertArrayEquals(new // short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0x1234},Conversion.intToShortArray(0x12345678, // 0,new short[]{-1,-1,-1,-1},0,4)); // assertArrayEquals(new // short[]{(short)0xFFFF,(short)0x5678,(short)0x1234,(short)0x5678},Conversion.intToShortArray(0x12345678, // 0,new short[]{-1,-1,-1,-1},1,3)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x5678, (short)0x1234}, Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 2, 2)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x5678, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0x5678}, Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 3, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x2B3C, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 1, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x159E, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 2, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x8ACF, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 3, new short[]{-1, -1, -1, -1}, 2, 1)); assertArrayEquals( new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x4567, (short)0xFFFF}, Conversion.intToShortArray(0x12345678, 4, new short[]{-1, -1, -1, -1}, 2, 1)); // assertArrayEquals(new // short[]{(short)0xE6F7,(short)0x4855,(short)0x2B3C,(short)0x091A},Conversion.intToShortArray(0x12345678, // 1,new short[]{-1,-1,-1,-1},0,4));//rejected by assertion // assertArrayEquals(new // short[]{(short)0x2B3C},Conversion.intToShortArray(0x12345678,33,new // short[]{0},0,1));//rejected by assertion assertArrayEquals( new short[]{(short)0x091A}, Conversion.intToShortArray(0x12345678, 17, new short[]{0}, 0, 1)); } /** * Tests {@link Conversion#longToByteArray(long, int, byte[], int, int)}. */ @Test public void testLongToByteArray() { assertArrayEquals( new byte[]{}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[]{}, 0, 0)); assertArrayEquals( new byte[]{}, Conversion.longToByteArray(0x0000000000000000L, 100, new byte[]{}, 0, 0)); assertArrayEquals( new byte[]{}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[]{}, 100, 0)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 0)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 2)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 4)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0x78, (byte)0x56, (byte)0x34, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 7)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0x78, (byte)0x56, (byte)0x34, (byte)0x12, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 8)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 1)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 2)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0x78, (byte)0x56, (byte)0x34, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 7)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0x78, (byte)0x56, (byte)0x34, (byte)0x12}, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8)); assertArrayEquals( new byte[]{ (byte)0xF7, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 1, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0x7B, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 2, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x6F, (byte)0x5E, (byte)0x85, (byte)0xC4, (byte)0xB3, (byte)0xA2, (byte)0x91, (byte)0x00}, Conversion.longToByteArray(0x1234567890ABCDEFL, 5, new byte[]{ -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8)); // assertArrayEquals(new // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xC4,(byte)0xB3,(byte)0xA2,(byte)0x91,(byte)0x00,(byte)0x00},Conversion.longToByteArray(0x1234567890ABCDEFL,13,new // byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,8));//rejected by assertion assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x5E, (byte)0x85, (byte)0xC4, (byte)0xB3, (byte)0xA2, (byte)0x91, (byte)0x00, (byte)0xFF}, Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new byte[]{ -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 7)); } /** * Tests {@link Conversion#intToByteArray(int, int, byte[], int, int)}. */ @Test public void testIntToByteArray() { assertArrayEquals( new byte[]{}, Conversion.intToByteArray(0x00000000, 0, new byte[]{}, 0, 0)); assertArrayEquals( new byte[]{}, Conversion.intToByteArray(0x00000000, 100, new byte[]{}, 0, 0)); assertArrayEquals( new byte[]{}, Conversion.intToByteArray(0x00000000, 0, new byte[]{}, 100, 0)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 0)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 2)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 4)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 1)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 2)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4)); assertArrayEquals( new byte[]{ (byte)0xF7, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 1, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0x7B, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 2, new byte[]{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x6F, (byte)0x5E, (byte)0x85, (byte)0xFC, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 5, new byte[]{ -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4)); // assertArrayEquals(new // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xFC,(byte)0x00,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.intToByteArray(0x90ABCDEF,13,new // byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,4));//rejected by assertion assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x5E, (byte)0x85, (byte)0xFC, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.intToByteArray(0x90ABCDEF, 13, new byte[]{ -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 3)); } /** * Tests {@link Conversion#shortToByteArray(short, int, byte[], int, int)}. */ @Test public void testShortToByteArray() { assertArrayEquals( new byte[]{}, Conversion.shortToByteArray((short)0x0000, 0, new byte[]{}, 0, 0)); assertArrayEquals( new byte[]{}, Conversion.shortToByteArray((short)0x0000, 100, new byte[]{}, 0, 0)); assertArrayEquals( new byte[]{}, Conversion.shortToByteArray((short)0x0000, 0, new byte[]{}, 100, 0)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 0, 0)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 0, 2)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 3, 1)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 0, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 3, 2)); assertArrayEquals( new byte[]{ (byte)0xF7, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 1, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0x7B, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 2, new byte[]{ -1, -1, -1, -1, -1, -1, -1}, 0, 1)); assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x6F, (byte)0xFE, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 5, new byte[]{ -1, 0, -1, -1, -1, -1, -1}, 3, 2)); // assertArrayEquals(new // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.shortToByteArray((short)0xCDEF,13,new // byte[]{-1, 0,-1,-1,-1,-1,-1},3,2));//rejected by assertion assertArrayEquals( new byte[]{ (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0xFE, (byte)0xFF, (byte)0xFF, (byte)0xFF}, Conversion.shortToByteArray((short)0xCDEF, 13, new byte[]{ -1, 0, -1, -1, -1, -1, -1}, 3, 1)); } /** * Tests {@link Conversion#longToHex(long, int, String, int, int)}. */ @Test public void testLongToHex() { assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 0, 0)); assertEquals("", Conversion.longToHex(0x0000000000000000L, 100, "", 0, 0)); assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 100, 0)); assertEquals( "ffffffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 0)); assertEquals( "3fffffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "feffffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 2)); assertEquals( "fedcffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 4)); assertEquals( "fedcba098765432fffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 15)); assertEquals( "fedcba0987654321ffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 16)); assertEquals( "fff3ffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 3, 1)); assertEquals( "ffffefffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 2)); assertEquals( "ffffedcfffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 4)); assertEquals( "ffffedcba098765432ffffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 15)); assertEquals( "ffffedcba0987654321fffff", Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 16)); assertEquals( "7fffffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 1, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "bfffffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 2, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "fffdb975121fca86420fffff", Conversion.longToHex(0x1234567890ABCDEFL, 3, "ffffffffffffffffffffffff", 3, 16)); // assertEquals("ffffffffffffffffffffffff",Conversion.longToHex(0x1234567890ABCDEFL,4,"ffffffffffffffffffffffff",3,16));//rejected // by assertion assertEquals( "fffedcba0987654321ffffff", Conversion.longToHex(0x1234567890ABCDEFL, 4, "ffffffffffffffffffffffff", 3, 15)); assertEquals( "fedcba0987654321", Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 0, 16)); try { Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 1, 8); fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); } catch (final StringIndexOutOfBoundsException e) { // OK } } /** * Tests {@link Conversion#intToHex(int, int, String, int, int)}. */ @Test public void testIntToHex() { assertEquals("", Conversion.intToHex(0x00000000, 0, "", 0, 0)); assertEquals("", Conversion.intToHex(0x00000000, 100, "", 0, 0)); assertEquals("", Conversion.intToHex(0x00000000, 0, "", 100, 0)); assertEquals( "ffffffffffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); assertEquals( "3fffffffffffffffffffffff", Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "feffffffffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); assertEquals( "fedcffffffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); assertEquals( "fedcba0fffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 7)); assertEquals( "fedcba09ffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 8)); assertEquals( "fff3ffffffffffffffffffff", Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); assertEquals( "ffffefffffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); assertEquals( "ffffedcfffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 4)); assertEquals( "ffffedcba0ffffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 7)); assertEquals( "ffffedcba09fffffffffffff", Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 8)); assertEquals( "7fffffffffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "bfffffffffffffffffffffff", Conversion.intToHex(0x90ABCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "fffdb97512ffffffffffffff", Conversion.intToHex(0x90ABCDEF, 3, "ffffffffffffffffffffffff", 3, 8)); // assertEquals("ffffffffffffffffffffffff",Conversion.intToHex(0x90ABCDEF, // 4,"ffffffffffffffffffffffff",3,8));//rejected by assertion assertEquals( "fffedcba09ffffffffffffff", Conversion.intToHex(0x90ABCDEF, 4, "ffffffffffffffffffffffff", 3, 7)); assertEquals("fedcba09", Conversion.intToHex(0x90ABCDEF, 0, "", 0, 8)); try { Conversion.intToHex(0x90ABCDEF, 0, "", 1, 8); fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); } catch (final StringIndexOutOfBoundsException e) { // OK } } /** * Tests {@link Conversion#shortToHex(short, int, String, int, int)}. */ @Test public void testShortToHex() { assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 0, 0)); assertEquals("", Conversion.shortToHex((short)0x0000, 100, "", 0, 0)); assertEquals("", Conversion.shortToHex((short)0x0000, 0, "", 100, 0)); assertEquals( "ffffffffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0)); assertEquals( "3fffffffffffffffffffffff", Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "feffffffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2)); assertEquals( "fedfffffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3)); assertEquals( "fedcffffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4)); assertEquals( "fff3ffffffffffffffffffff", Conversion.shortToHex((short)0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1)); assertEquals( "ffffefffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2)); assertEquals( "7fffffffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "bfffffffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1)); assertEquals( "fffdb9ffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4)); // assertEquals("ffffffffffffffffffffffff",Conversion.shortToHex((short)0xCDEF, // 4,"ffffffffffffffffffffffff",3,4));//rejected by assertion assertEquals( "fffedcffffffffffffffffff", Conversion.shortToHex((short)0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3)); assertEquals("fedc", Conversion.shortToHex((short)0xCDEF, 0, "", 0, 4)); try { Conversion.shortToHex((short)0xCDEF, 0, "", 1, 4); fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); } catch (final StringIndexOutOfBoundsException e) { // OK } } /** * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}. */ @Test public void testByteToHex() { assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 0, 0)); assertEquals("", Conversion.byteToHex((byte)0x00, 100, "", 0, 0)); assertEquals("", Conversion.byteToHex((byte)0x00, 0, "", 100, 0)); assertEquals("00000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 0)); assertEquals("f0000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 1)); assertEquals("fe000", Conversion.byteToHex((byte)0xEF, 0, "00000", 0, 2)); assertEquals("000f0", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 1)); assertEquals("000fe", Conversion.byteToHex((byte)0xEF, 0, "00000", 3, 2)); assertEquals("70000", Conversion.byteToHex((byte)0xEF, 1, "00000", 0, 1)); assertEquals("b0000", Conversion.byteToHex((byte)0xEF, 2, "00000", 0, 1)); assertEquals("000df", Conversion.byteToHex((byte)0xEF, 3, "00000", 3, 2)); // assertEquals("00000",Conversion.byteToHex((byte)0xEF, 4,"00000",3,2));//rejected by // assertion assertEquals("000e0", Conversion.byteToHex((byte)0xEF, 4, "00000", 3, 1)); assertEquals("fe", Conversion.byteToHex((byte)0xEF, 0, "", 0, 2)); try { Conversion.byteToHex((byte)0xEF, 0, "", 1, 2); fail("Thrown " + StringIndexOutOfBoundsException.class.getName() + " expected"); } catch (final StringIndexOutOfBoundsException e) { // OK } } /** * Tests {@link Conversion#longToBinary(long, int, boolean[], int, int)}. */ @Test public void testLongToBinary() { assertBinaryEquals( new boolean[]{}, Conversion.longToBinary(0x0000000000000000L, 0, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.longToBinary(0x0000000000000000L, 100, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.longToBinary(0x0000000000000000L, 0, new boolean[]{}, 100, 0)); assertBinaryEquals( new boolean[69], Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 0)); assertBinaryEquals( new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 1)); assertBinaryEquals( new boolean[]{ true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 2)); assertBinaryEquals( new boolean[]{ true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 3)); assertBinaryEquals( new boolean[]{ true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 63)); assertBinaryEquals( new boolean[]{ true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 64)); assertBinaryEquals( new boolean[]{ false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 2, 1)); assertBinaryEquals( new boolean[]{ false, false, true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 2, 64)); assertBinaryEquals( new boolean[]{ true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 1, new boolean[69], 0, 63)); assertBinaryEquals( new boolean[]{ true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 2, new boolean[69], 0, 62)); // assertBinaryEquals(new boolean[]{false,false,false, true, true, false, true, true, // true, true, false, true, true, false, false, true, true, true, true, false, true, // false, true, false, true, false, false, false, false, true, false, false, true, // false, false, false, true, true, true, true, false, false, true, true, false, true, // false, true, false, false, false, true, false, true, true, false, false, false, true, // false, false, true, false, false, false // ,false,false,false,false},Conversion.longToBinary(0x1234567890ABCDEFL, 2,new // boolean[69], 3, 63));//rejected by assertion assertBinaryEquals( new boolean[]{ false, false, false, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, true, true, true, true, false, false, true, true, false, true, false, true, false, false, false, true, false, true, true, false, false, false, true, false, false, true, false, false, false, false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 2, new boolean[69], 3, 62)); } /** * Tests {@link Conversion#intToBinary(int, int, boolean[], int, int)}. */ @Test public void testIntToBinary() { assertBinaryEquals( new boolean[]{}, Conversion.intToBinary(0x00000000, 0, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.intToBinary(0x00000000, 100, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.intToBinary(0x00000000, 0, new boolean[]{}, 100, 0)); assertBinaryEquals( new boolean[69], Conversion.intToBinary(0x90ABCDEF, 0, new boolean[69], 0, 0)); assertBinaryEquals(new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 1)); assertBinaryEquals(new boolean[]{ true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 2)); assertBinaryEquals(new boolean[]{ true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 3)); assertBinaryEquals( new boolean[]{ true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 31)); assertBinaryEquals( new boolean[]{ true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 32)); assertBinaryEquals(new boolean[]{ false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 2, 1)); assertBinaryEquals( new boolean[]{ false, false, true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 2, 32)); assertBinaryEquals( new boolean[]{ true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 1, new boolean[37], 0, 31)); assertBinaryEquals( new boolean[]{ true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37], 0, 30)); // assertBinaryEquals(new boolean[]{false, false, false, true, true, false, true, // true, // true, true, false, true, true, false, false, true, true, true, true, false, true, // false, true, false, true, false, false, false, false, true, false, false, false, // false, false, false, false},Conversion.intToBinary(0x90ABCDEF, 2,new boolean[37], // 3,31));//rejected by assertion assertBinaryEquals( new boolean[]{ false, false, false, true, true, false, true, true, true, true, false, true, true, false, false, true, true, true, true, false, true, false, true, false, true, false, false, false, false, true, false, false, true, false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37], 3, 30)); } /** * Tests {@link Conversion#shortToBinary(short, int, boolean[], int, int)}. */ @Test public void testShortToBinary() { assertBinaryEquals( new boolean[]{}, Conversion.shortToBinary((short)0x0000, 0, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.shortToBinary((short)0x0000, 100, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.shortToBinary((short)0x0000, 0, new boolean[]{}, 100, 0)); assertBinaryEquals( new boolean[69], Conversion.shortToBinary((short)0xCDEF, 0, new boolean[69], 0, 0)); assertBinaryEquals( new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 1)); assertBinaryEquals( new boolean[]{ true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 2)); assertBinaryEquals( new boolean[]{ true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 3)); assertBinaryEquals( new boolean[]{ true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 15)); assertBinaryEquals( new boolean[]{ true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 0, 16)); assertBinaryEquals( new boolean[]{ false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 2, 1)); assertBinaryEquals( new boolean[]{ false, false, true, true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 0, new boolean[21], 2, 16)); assertBinaryEquals( new boolean[]{ true, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 1, new boolean[21], 0, 15)); assertBinaryEquals( new boolean[]{ true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 2, new boolean[21], 0, 14)); // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true, // true, true, false, true, true, false, false, true, false, false, false, false, // false},Conversion.shortToBinary((short)0xCDEF, 2,new boolean[21], // 3,15));//rejected by // assertion assertBinaryEquals( new boolean[]{ false, false, false, true, true, false, true, true, true, true, false, true, true, false, false, true, true, false, false, false, false}, Conversion.shortToBinary((short)0xCDEF, 2, new boolean[21], 3, 14)); } /** * Tests {@link Conversion#byteToBinary(byte, int, boolean[], int, int)}. */ @Test public void testByteToBinary() { assertBinaryEquals( new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.byteToBinary((byte)0x00, 100, new boolean[]{}, 0, 0)); assertBinaryEquals( new boolean[]{}, Conversion.byteToBinary((byte)0x00, 0, new boolean[]{}, 100, 0)); assertBinaryEquals( new boolean[69], Conversion.byteToBinary((byte)0xEF, 0, new boolean[69], 0, 0)); assertBinaryEquals(new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 1)); assertBinaryEquals(new boolean[]{ true, false, false, false, false, false, false, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 2)); assertBinaryEquals(new boolean[]{ true, false, true, false, false, false, false, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 3)); assertBinaryEquals(new boolean[]{ true, false, true, false, true, false, false, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 7)); assertBinaryEquals(new boolean[]{ true, false, true, false, true, false, false, true, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 0, 8)); assertBinaryEquals(new boolean[]{ false, false, true, false, false, false, false, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 2, 1)); assertBinaryEquals(new boolean[]{ false, false, true, false, true, false, true, false, false, true, false, false, false}, Conversion.byteToBinary((byte)0x95, 0, new boolean[13], 2, 8)); assertBinaryEquals(new boolean[]{ false, true, false, true, false, false, true, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 1, new boolean[13], 0, 7)); assertBinaryEquals(new boolean[]{ true, false, true, false, false, true, false, false, false, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 2, new boolean[13], 0, 6)); // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true, // false, false, false, false, false},Conversion.byteToBinary((byte)0x95, 2,new // boolean[13], 3, 7));//rejected by assertion assertBinaryEquals(new boolean[]{ false, false, false, true, false, true, false, false, true, false, false, false, false}, Conversion.byteToBinary((byte)0x95, 2, new boolean[13], 3, 6)); } /** * Tests {@link Conversion#uuidToByteArray(UUID, byte[], int, int)}. */ @Test public void testUuidToByteArray() { assertArrayEquals(new byte[]{ (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff}, Conversion.uuidToByteArray(new UUID( 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), new byte[16], 0, 16)); assertArrayEquals(new byte[]{ (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55, (byte)0x66, (byte)0x77}, Conversion.uuidToByteArray(new UUID( 0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 0, 16)); assertArrayEquals(new byte[]{ (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00}, Conversion.uuidToByteArray(new UUID( 0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 4, 8)); assertArrayEquals(new byte[]{ (byte)0x00, (byte)0x00, (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x00, (byte)0x00}, Conversion.uuidToByteArray(new UUID( 0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 2, 12)); } /** * Tests {@link Conversion#byteArrayToUuid(byte[], int)}. */ @Test public void testByteArrayToUuid() { assertEquals( new UUID(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), Conversion.byteArrayToUuid(new byte[]{ (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff}, 0)); assertEquals( new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), Conversion.byteArrayToUuid(new byte[]{ (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55, (byte)0x66, (byte)0x77}, 0)); assertEquals( new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L), Conversion.byteArrayToUuid(new byte[]{ 0, 0, (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55, (byte)0x66, (byte)0x77}, 2)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import java.util.ArrayList; import java.util.Arrays; import java.util.EnumSet; import java.util.List; import java.util.Map; import org.junit.Assert; import org.junit.Test; /** * * @version $Id$ */ public class EnumUtilsTest { @Test public void testConstructable() { // enforce public constructor new EnumUtils(); } @Test public void test_getEnumMap() { final Map<String, Traffic> test = EnumUtils.getEnumMap(Traffic.class); assertEquals( "getEnumMap not created correctly", "{RED=RED, AMBER=AMBER, GREEN=GREEN}", test.toString()); assertEquals(3, test.size()); assertTrue(test.containsKey("RED")); assertEquals(Traffic.RED, test.get("RED")); assertTrue(test.containsKey("AMBER")); assertEquals(Traffic.AMBER, test.get("AMBER")); assertTrue(test.containsKey("GREEN")); assertEquals(Traffic.GREEN, test.get("GREEN")); assertFalse(test.containsKey("PURPLE")); } @Test public void test_getEnumList() { final List<Traffic> test = EnumUtils.getEnumList(Traffic.class); assertEquals(3, test.size()); assertEquals(Traffic.RED, test.get(0)); assertEquals(Traffic.AMBER, test.get(1)); assertEquals(Traffic.GREEN, test.get(2)); } @Test public void test_isEnum() { assertTrue(EnumUtils.isValidEnum(Traffic.class, "RED")); assertTrue(EnumUtils.isValidEnum(Traffic.class, "AMBER")); assertTrue(EnumUtils.isValidEnum(Traffic.class, "GREEN")); assertFalse(EnumUtils.isValidEnum(Traffic.class, "PURPLE")); assertFalse(EnumUtils.isValidEnum(Traffic.class, null)); } @Test(expected=NullPointerException.class) public void test_isEnum_nullClass() { EnumUtils.isValidEnum((Class<Traffic>) null, "PURPLE"); } @Test public void test_getEnum() { assertEquals(Traffic.RED, EnumUtils.getEnum(Traffic.class, "RED")); assertEquals(Traffic.AMBER, EnumUtils.getEnum(Traffic.class, "AMBER")); assertEquals(Traffic.GREEN, EnumUtils.getEnum(Traffic.class, "GREEN")); assertEquals(null, EnumUtils.getEnum(Traffic.class, "PURPLE")); assertEquals(null, EnumUtils.getEnum(Traffic.class, null)); } @Test(expected=NullPointerException.class) public void test_getEnum_nullClass() { EnumUtils.getEnum((Class<Traffic>) null, "PURPLE"); } @Test(expected=NullPointerException.class) public void test_generateBitVector_nullClass() { EnumUtils.generateBitVector(null, EnumSet.of(Traffic.RED)); } @Test(expected=NullPointerException.class) public void test_generateBitVectors_nullClass() { EnumUtils.generateBitVectors(null, EnumSet.of(Traffic.RED)); } @Test(expected=NullPointerException.class) public void test_generateBitVector_nullIterable() { EnumUtils.generateBitVector(Traffic.class, (Iterable<Traffic>) null); } @Test(expected=NullPointerException.class) public void test_generateBitVectors_nullIterable() { EnumUtils.generateBitVectors(null, (Iterable<Traffic>) null); } @Test(expected=IllegalArgumentException.class) public void test_generateBitVector_nullElement() { EnumUtils.generateBitVector(Traffic.class, Arrays.asList(Traffic.RED, null)); } @Test(expected=IllegalArgumentException.class) public void test_generateBitVectors_nullElement() { EnumUtils.generateBitVectors(Traffic.class, Arrays.asList(Traffic.RED, null)); } @Test(expected=NullPointerException.class) public void test_generateBitVector_nullClassWithArray() { EnumUtils.generateBitVector(null, Traffic.RED); } @Test(expected=NullPointerException.class) public void test_generateBitVectors_nullClassWithArray() { EnumUtils.generateBitVectors(null, Traffic.RED); } @Test(expected=NullPointerException.class) public void test_generateBitVector_nullArray() { EnumUtils.generateBitVector(Traffic.class, (Traffic[]) null); } @Test(expected=NullPointerException.class) public void test_generateBitVectors_nullArray() { EnumUtils.generateBitVectors(Traffic.class, (Traffic[]) null); } @Test(expected=IllegalArgumentException.class) public void test_generateBitVector_nullArrayElement() { EnumUtils.generateBitVector(Traffic.class, Traffic.RED, null); } @Test(expected=IllegalArgumentException.class) public void test_generateBitVectors_nullArrayElement() { EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, null); } @Test(expected=IllegalArgumentException.class) public void test_generateBitVector_longClass() { EnumUtils.generateBitVector(TooMany.class, EnumSet.of(TooMany.A1)); } @Test(expected=IllegalArgumentException.class) public void test_generateBitVector_longClassWithArray() { EnumUtils.generateBitVector(TooMany.class, TooMany.A1); } @SuppressWarnings("unchecked") @Test(expected=IllegalArgumentException.class) public void test_generateBitVector_nonEnumClass() { @SuppressWarnings("rawtypes") final Class rawType = Object.class; @SuppressWarnings("rawtypes") final List rawList = new ArrayList(); EnumUtils.generateBitVector(rawType, rawList); } @SuppressWarnings("unchecked") @Test(expected=IllegalArgumentException.class) public void test_generateBitVectors_nonEnumClass() { @SuppressWarnings("rawtypes") final Class rawType = Object.class; @SuppressWarnings("rawtypes") final List rawList = new ArrayList(); EnumUtils.generateBitVectors(rawType, rawList); } @SuppressWarnings("unchecked") @Test(expected=IllegalArgumentException.class) public void test_generateBitVector_nonEnumClassWithArray() { @SuppressWarnings("rawtypes") final Class rawType = Object.class; EnumUtils.generateBitVector(rawType); } @SuppressWarnings("unchecked") @Test(expected=IllegalArgumentException.class) public void test_generateBitVectors_nonEnumClassWithArray() { @SuppressWarnings("rawtypes") final Class rawType = Object.class; EnumUtils.generateBitVectors(rawType); } @Test public void test_generateBitVector() { assertEquals(0L, EnumUtils.generateBitVector(Traffic.class, EnumSet.noneOf(Traffic.class))); assertEquals(1L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED))); assertEquals(2L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER))); assertEquals(4L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.GREEN))); assertEquals(3L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER))); assertEquals(5L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN))); assertEquals(6L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN))); assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN))); } @Test public void test_generateBitVectors() { assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.noneOf(Traffic.class)), 0L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED)), 1L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.AMBER)), 2L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.GREEN)), 4L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)), 3L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)), 5L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)), 6L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)), 7L); } @Test public void test_generateBitVectorFromArray() { assertEquals(0L, EnumUtils.generateBitVector(Traffic.class)); assertEquals(1L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED)); assertEquals(2L, EnumUtils.generateBitVector(Traffic.class, Traffic.AMBER)); assertEquals(4L, EnumUtils.generateBitVector(Traffic.class, Traffic.GREEN)); assertEquals(3L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER)); assertEquals(5L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.GREEN)); assertEquals(6L, EnumUtils.generateBitVector(Traffic.class, Traffic.AMBER, Traffic.GREEN)); assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN)); //gracefully handles duplicates: assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN)); } @Test public void test_generateBitVectorsFromArray() { assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class), 0L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED), 1L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER), 2L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.GREEN), 4L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER), 3L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.GREEN), 5L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN), 6L); assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN), 7L); //gracefully handles duplicates: assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L); } private void assertArrayEquals(final long[] actual, final long... expected) { Assert.assertArrayEquals(expected, actual); } @Test(expected=NullPointerException.class) public void test_processBitVector_nullClass() { final Class<Traffic> empty = null; EnumUtils.processBitVector(empty, 0L); } @Test(expected=NullPointerException.class) public void test_processBitVectors_nullClass() { final Class<Traffic> empty = null; EnumUtils.processBitVectors(empty, 0L); } @Test public void test_processBitVector() { assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVector(Traffic.class, 0L)); assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVector(Traffic.class, 1L)); assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVector(Traffic.class, 2L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVector(Traffic.class, 3L)); assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 4L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 5L)); assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 6L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 7L)); } @Test public void test_processBitVectors() { assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 0L)); assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 1L)); assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 2L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 3L)); assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 4L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 5L)); assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 6L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 7L)); assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 0L, 0L)); assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 0L, 1L)); assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 0L, 2L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 0L, 3L)); assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 4L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 5L)); assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 6L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 7L)); // demonstrate tolerance of irrelevant high-order digits: assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 666L, 0L)); assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 666L, 1L)); assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 666L, 2L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 666L, 3L)); assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 4L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 5L)); assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 6L)); assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 7L)); } @Test(expected=IllegalArgumentException.class) public void test_processBitVector_longClass() { EnumUtils.processBitVector(TooMany.class, 0L); } public void test_processBitVectors_longClass() { assertEquals(EnumSet.noneOf(TooMany.class), EnumUtils.processBitVectors(TooMany.class, 0L)); assertEquals(EnumSet.of(TooMany.A), EnumUtils.processBitVectors(TooMany.class, 1L)); assertEquals(EnumSet.of(TooMany.B), EnumUtils.processBitVectors(TooMany.class, 2L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B), EnumUtils.processBitVectors(TooMany.class, 3L)); assertEquals(EnumSet.of(TooMany.C), EnumUtils.processBitVectors(TooMany.class, 4L)); assertEquals(EnumSet.of(TooMany.A, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 5L)); assertEquals(EnumSet.of(TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 6L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 7L)); assertEquals(EnumSet.noneOf(TooMany.class), EnumUtils.processBitVectors(TooMany.class, 0L, 0L)); assertEquals(EnumSet.of(TooMany.A), EnumUtils.processBitVectors(TooMany.class, 0L, 1L)); assertEquals(EnumSet.of(TooMany.B), EnumUtils.processBitVectors(TooMany.class, 0L, 2L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B), EnumUtils.processBitVectors(TooMany.class, 0L, 3L)); assertEquals(EnumSet.of(TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 4L)); assertEquals(EnumSet.of(TooMany.A, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 5L)); assertEquals(EnumSet.of(TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 6L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 7L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 7L)); assertEquals(EnumSet.of(TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 0L)); assertEquals(EnumSet.of(TooMany.A, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 1L)); assertEquals(EnumSet.of(TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 2L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 3L)); assertEquals(EnumSet.of(TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 4L)); assertEquals(EnumSet.of(TooMany.A, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 5L)); assertEquals(EnumSet.of(TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 6L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 7L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 7L)); // demonstrate tolerance of irrelevant high-order digits: assertEquals(EnumSet.of(TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 0L)); assertEquals(EnumSet.of(TooMany.A, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 1L)); assertEquals(EnumSet.of(TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 2L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 3L)); assertEquals(EnumSet.of(TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 4L)); assertEquals(EnumSet.of(TooMany.A, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 5L)); assertEquals(EnumSet.of(TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 6L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 7L)); assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 7L)); } } enum Traffic { RED, AMBER, GREEN } enum TooMany { A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z, A1,B1,C1,D1,E1,F1,G1,H1,I1,J1,K1,L1,M1,N1,O1,P1,Q1,R1,S1,T1,U1,V1,W1,X1,Y1,Z1, A2,B2,C2,D2,E2,F2,G2,H2,I2,J2,K2,L2,M2; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import java.util.BitSet; import java.util.HashSet; import org.junit.Assert; import org.junit.Test; /** * Test to show whether using BitSet for removeAll() methods is faster than using HashSet. */ public class HashSetvBitSetTest { private static final int LOOPS = 2000; // number of times to invoke methods private static final int LOOPS2 = 10000; @Test public void testTimes() { timeHashSet(10); // warmup timeBitSet(10); // warmup long timeDiff = printTimes(0); timeDiff += printTimes(5); timeDiff += printTimes(10); timeDiff += printTimes(200); timeDiff += printTimes(50); timeDiff += printTimes(100); timeDiff += printTimes(1000); timeDiff += printTimes(2000); Assert.assertTrue(timeDiff <= 0); } /** * @return bitSet - HashSet */ private long printTimes(final int count) { final long hashSet = timeHashSet(count); final long bitSet = timeBitSet(count); // If percent is less than 100, then bitset is faster System.out.println("Ratio="+(bitSet*100/hashSet)+"% count="+count+" hash="+hashSet+" bits="+bitSet); return bitSet - hashSet; } private static long timeHashSet(final int count) { int [] result = new int[0]; final long start = System.nanoTime(); for (int i = 0; i < LOOPS; i++) { result = testHashSet(count); } final long elapsed = System.nanoTime() - start; Assert.assertEquals(count, result.length); return elapsed; } private static long timeBitSet(final int count) { int [] result = new int[0]; final long start = System.nanoTime(); for (int i = 0; i < LOOPS; i++) { result = testBitSet(count); } final long elapsed = System.nanoTime() - start; Assert.assertEquals(count, result.length); return elapsed; } @SuppressWarnings("boxing") private static int[] testHashSet(final int count) { final HashSet<Integer> toRemove = new HashSet<Integer>(); int found = 0; for (int i = 0; i < count; i++) { toRemove.add(found++); } return extractIndices(toRemove); } private static int[] testBitSet(final int count) { final BitSet toRemove = new BitSet(); int found = 0; for (int i = 0; i < count; i++) { toRemove.set(found++); } return extractIndices(toRemove); } private static int[] extractIndices(final HashSet<Integer> coll) { final int[] result = new int[coll.size()]; int i = 0; for (final Integer index : coll) { result[i++] = index.intValue(); } return result; } private static int[] extractIndices(final BitSet coll) { final int[] result = new int[coll.cardinality()]; int i = 0; int j=0; while((j=coll.nextSetBit(j)) != -1) { result[i++] = j++; } return result; } @Test public void testTimesExtractOrBitset() { final BitSet toRemove = new BitSet(); final int[] array = new int[100]; toRemove.set(10, 20); timeBitSetRemoveAll(array, toRemove); // warmup timeExtractRemoveAll(array, toRemove); // warmup long timeDiff = printTimes(100,1); timeDiff += printTimes(100,10); timeDiff += printTimes(100,50); timeDiff += printTimes(100,100); timeDiff += printTimes(1000,10); timeDiff += printTimes(1000,100); timeDiff += printTimes(1000,500); timeDiff += printTimes(1000,1000); Assert.assertTrue(timeDiff <= 0); } private long printTimes(final int arraySize, final int bitSetSize) { final int[] array = new int[arraySize]; final BitSet remove = new BitSet(); for (int i = 0; i < bitSetSize; i++) { remove.set(i); } final long bitSet = timeBitSetRemoveAll(array, remove ); final long extract = timeExtractRemoveAll(array, remove); // If percent is less than 100, then direct use of bitset is faster System.out.println("Ratio="+(bitSet*100/extract)+"% array="+array.length+" count="+remove.cardinality()+" extract="+extract+" bitset="+bitSet); return bitSet - extract; } private long timeBitSetRemoveAll(final int[] array, final BitSet toRemove) { int[] output = new int[0]; final long start = System.nanoTime(); for(int i = 0; i < LOOPS2; i++){ output = (int[]) ArrayUtils.removeAll(array, toRemove); } final long end = System.nanoTime(); Assert.assertEquals(array.length-toRemove.cardinality(), output.length); return end - start; } private long timeExtractRemoveAll(final int[] array, final BitSet toRemove) { int[] output = new int[0]; final long start = System.nanoTime(); for(int i = 0; i < LOOPS2; i++){ final int[] extractIndices = extractIndices(toRemove); output = (int[]) ArrayUtils.removeAll((Object)array, extractIndices); } final long end = System.nanoTime(); Assert.assertEquals(array.length-toRemove.cardinality(), output.length); return end - start; } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3; import org.junit.Test; import static org.junit.Assert.*; import static org.apache.commons.lang3.JavaVersion.JAVA_0_9; import static org.apache.commons.lang3.JavaVersion.JAVA_1_1; import static org.apache.commons.lang3.JavaVersion.JAVA_1_2; import static org.apache.commons.lang3.JavaVersion.JAVA_1_3; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import static org.apache.commons.lang3.JavaVersion.JAVA_1_5; import static org.apache.commons.lang3.JavaVersion.JAVA_1_6; import static org.apache.commons.lang3.JavaVersion.JAVA_1_7; import static org.apache.commons.lang3.JavaVersion.JAVA_1_8; import static org.apache.commons.lang3.JavaVersion.get; import static org.apache.commons.lang3.JavaVersion.getJavaVersion; /** * Unit tests {@link org.apache.commons.lang3.JavaVersion}. * * @version $Id: JavaVersionTest.java 918366 2010-03-03 08:56:22Z bayard $ */ public class JavaVersionTest { @Test public void testGetJavaVersion() { assertEquals("0.9 failed", JAVA_0_9, get("0.9")); assertEquals("1.1 failed", JAVA_1_1, get("1.1")); assertEquals("1.2 failed", JAVA_1_2, get("1.2")); assertEquals("1.3 failed", JAVA_1_3, get("1.3")); assertEquals("1.4 failed", JAVA_1_4, get("1.4")); assertEquals("1.5 failed", JAVA_1_5, get("1.5")); assertEquals("1.6 failed", JAVA_1_6, get("1.6")); assertEquals("1.7 failed", JAVA_1_7, get("1.7")); assertEquals("1.8 failed", JAVA_1_8, get("1.8")); assertNull("1.9 unexpectedly worked", get("1.9")); assertEquals("Wrapper method failed", get("1.5"), getJavaVersion("1.5")); } @Test public void testAtLeast() { assertFalse("1.2 at least 1.5 passed", JAVA_1_2.atLeast(JAVA_1_5)); assertTrue("1.5 at least 1.2 failed", JAVA_1_5.atLeast(JAVA_1_2)); assertFalse("1.6 at least 1.7 passed", JAVA_1_6.atLeast(JAVA_1_7)); assertTrue("0.9 at least 1.5 failed", JAVA_0_9.atLeast(JAVA_1_5)); assertFalse("0.9 at least 1.6 passed", JAVA_0_9.atLeast(JAVA_1_6)); } @Test public void testToString() { assertEquals("1.2", JAVA_1_2.toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Locale; import java.util.Set; import org.junit.Before; import org.junit.Test; /** * Unit tests for {@link LocaleUtils}. * * @version $Id$ */ public class LocaleUtilsTest { private static final Locale LOCALE_EN = new Locale("en", ""); private static final Locale LOCALE_EN_US = new Locale("en", "US"); private static final Locale LOCALE_EN_US_ZZZZ = new Locale("en", "US", "ZZZZ"); private static final Locale LOCALE_FR = new Locale("fr", ""); private static final Locale LOCALE_FR_CA = new Locale("fr", "CA"); private static final Locale LOCALE_QQ = new Locale("qq", ""); private static final Locale LOCALE_QQ_ZZ = new Locale("qq", "ZZ"); @Before public void setUp() throws Exception { // Testing #LANG-304. Must be called before availableLocaleSet is called. LocaleUtils.isAvailableLocale(Locale.getDefault()); } //----------------------------------------------------------------------- /** * Test that constructors are public, and work, etc. */ @Test public void testConstructor() { assertNotNull(new LocaleUtils()); final Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(LocaleUtils.class.getModifiers())); assertFalse(Modifier.isFinal(LocaleUtils.class.getModifiers())); } //----------------------------------------------------------------------- /** * Pass in a valid language, test toLocale. * * @param language the language string */ private void assertValidToLocale(final String language) { final Locale locale = LocaleUtils.toLocale(language); assertNotNull("valid locale", locale); assertEquals(language, locale.getLanguage()); //country and variant are empty assertTrue(locale.getCountry() == null || locale.getCountry().isEmpty()); assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty()); } /** * Pass in a valid language, test toLocale. * * @param localeString to pass to toLocale() * @param language of the resulting Locale * @param country of the resulting Locale */ private void assertValidToLocale(final String localeString, final String language, final String country) { final Locale locale = LocaleUtils.toLocale(localeString); assertNotNull("valid locale", locale); assertEquals(language, locale.getLanguage()); assertEquals(country, locale.getCountry()); //variant is empty assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty()); } /** * Pass in a valid language, test toLocale. * * @param localeString to pass to toLocale() * @param language of the resulting Locale * @param country of the resulting Locale * @param variant of the resulting Locale */ private void assertValidToLocale( final String localeString, final String language, final String country, final String variant) { final Locale locale = LocaleUtils.toLocale(localeString); assertNotNull("valid locale", locale); assertEquals(language, locale.getLanguage()); assertEquals(country, locale.getCountry()); assertEquals(variant, locale.getVariant()); } /** * Test toLocale() method. */ @Test public void testToLocale_1Part() { assertEquals(null, LocaleUtils.toLocale((String) null)); assertValidToLocale("us"); assertValidToLocale("fr"); assertValidToLocale("de"); assertValidToLocale("zh"); // Valid format but lang doesnt exist, should make instance anyway assertValidToLocale("qq"); try { LocaleUtils.toLocale("Us"); fail("Should fail if not lowercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("US"); fail("Should fail if not lowercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("uS"); fail("Should fail if not lowercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("u#"); fail("Should fail if not lowercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("u"); fail("Must be 2 chars if less than 5"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("uuu"); fail("Must be 2 chars if less than 5"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("uu_U"); fail("Must be 2 chars if less than 5"); } catch (final IllegalArgumentException iae) {} } /** * Test toLocale() method. */ @Test public void testToLocale_2Part() { assertValidToLocale("us_EN", "us", "EN"); //valid though doesnt exist assertValidToLocale("us_ZH", "us", "ZH"); try { LocaleUtils.toLocale("us-EN"); fail("Should fail as not underscore"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("us_En"); fail("Should fail second part not uppercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("us_en"); fail("Should fail second part not uppercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("us_eN"); fail("Should fail second part not uppercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("uS_EN"); fail("Should fail first part not lowercase"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("us_E3"); fail("Should fail second part not uppercase"); } catch (final IllegalArgumentException iae) {} } /** * Test toLocale() method. */ @Test public void testToLocale_3Part() { assertValidToLocale("us_EN_A", "us", "EN", "A"); // this isn't pretty, but was caused by a jdk bug it seems // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525 if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { assertValidToLocale("us_EN_a", "us", "EN", "a"); assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF"); } else { assertValidToLocale("us_EN_a", "us", "EN", "A"); assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF"); } try { LocaleUtils.toLocale("us_EN-a"); fail("Should fail as not underscore"); } catch (final IllegalArgumentException iae) {} try { LocaleUtils.toLocale("uu_UU_"); fail("Must be 3, 5 or 7+ in length"); } catch (final IllegalArgumentException iae) {} } //----------------------------------------------------------------------- /** * Helper method for local lookups. * * @param locale the input locale * @param defaultLocale the input default locale * @param expected expected results */ private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) { final List<Locale> localeList = defaultLocale == null ? LocaleUtils.localeLookupList(locale) : LocaleUtils.localeLookupList(locale, defaultLocale); assertEquals(expected.length, localeList.size()); assertEquals(Arrays.asList(expected), localeList); assertUnmodifiableCollection(localeList); } //----------------------------------------------------------------------- /** * Test localeLookupList() method. */ @Test public void testLocaleLookupList_Locale() { assertLocaleLookupList(null, null, new Locale[0]); assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ}); assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN}); assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN}); assertLocaleLookupList(LOCALE_EN_US, null, new Locale[] { LOCALE_EN_US, LOCALE_EN}); assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN}); } /** * Test localeLookupList() method. */ @Test public void testLocaleLookupList_LocaleLocale() { assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, new Locale[]{LOCALE_QQ}); assertLocaleLookupList(LOCALE_EN, LOCALE_EN, new Locale[]{LOCALE_EN}); assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, new Locale[]{ LOCALE_EN_US, LOCALE_EN}); assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ, new Locale[] { LOCALE_EN_US, LOCALE_EN, LOCALE_QQ}); assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ, new Locale[] { LOCALE_EN_US, LOCALE_EN, LOCALE_QQ_ZZ}); assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN}); assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN}); assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN, LOCALE_QQ}); assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ, new Locale[] { LOCALE_EN_US_ZZZZ, LOCALE_EN_US, LOCALE_EN, LOCALE_QQ_ZZ}); assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN, new Locale[] { LOCALE_FR_CA, LOCALE_FR, LOCALE_EN}); } //----------------------------------------------------------------------- /** * Test availableLocaleList() method. */ @Test public void testAvailableLocaleList() { final List<Locale> list = LocaleUtils.availableLocaleList(); final List<Locale> list2 = LocaleUtils.availableLocaleList(); assertNotNull(list); assertSame(list, list2); assertUnmodifiableCollection(list); final Locale[] jdkLocaleArray = Locale.getAvailableLocales(); final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray); assertEquals(jdkLocaleList, list); } //----------------------------------------------------------------------- /** * Test availableLocaleSet() method. */ @Test public void testAvailableLocaleSet() { final Set<Locale> set = LocaleUtils.availableLocaleSet(); final Set<Locale> set2 = LocaleUtils.availableLocaleSet(); assertNotNull(set); assertSame(set, set2); assertUnmodifiableCollection(set); final Locale[] jdkLocaleArray = Locale.getAvailableLocales(); final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray); final Set<Locale> jdkLocaleSet = new HashSet<Locale>(jdkLocaleList); assertEquals(jdkLocaleSet, set); } //----------------------------------------------------------------------- /** * Test availableLocaleSet() method. */ @SuppressWarnings("boxing") // JUnit4 does not support primitive equality testing apart from long @Test public void testIsAvailableLocale() { final Set<Locale> set = LocaleUtils.availableLocaleSet(); assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN)); assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US)); assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ)); assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR)); assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA)); assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ)); assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ)); } //----------------------------------------------------------------------- /** * Make sure the language by country is correct. It checks that * the LocaleUtils.languagesByCountry(country) call contains the * array of languages passed in. It may contain more due to JVM * variations. * * @param country * @param languages array of languages that should be returned */ private void assertLanguageByCountry(final String country, final String[] languages) { final List<Locale> list = LocaleUtils.languagesByCountry(country); final List<Locale> list2 = LocaleUtils.languagesByCountry(country); assertNotNull(list); assertSame(list, list2); //search through langauges for (final String language : languages) { final Iterator<Locale> iterator = list.iterator(); boolean found = false; // see if it was returned by the set while (iterator.hasNext()) { final Locale locale = iterator.next(); // should have an en empty variant assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty()); assertEquals(country, locale.getCountry()); if (language.equals(locale.getLanguage())) { found = true; break; } } if (!found) { fail("Cound not find language: " + language + " for country: " + country); } } assertUnmodifiableCollection(list); } /** * Test languagesByCountry() method. */ @Test public void testLanguagesByCountry() { assertLanguageByCountry(null, new String[0]); assertLanguageByCountry("GB", new String[]{"en"}); assertLanguageByCountry("ZZ", new String[0]); assertLanguageByCountry("CH", new String[]{"fr", "de", "it"}); } //----------------------------------------------------------------------- /** * Make sure the country by language is correct. It checks that * the LocaleUtils.countryByLanguage(language) call contains the * array of countries passed in. It may contain more due to JVM * variations. * * * @param language * @param countries array of countries that should be returned */ private void assertCountriesByLanguage(final String language, final String[] countries) { final List<Locale> list = LocaleUtils.countriesByLanguage(language); final List<Locale> list2 = LocaleUtils.countriesByLanguage(language); assertNotNull(list); assertSame(list, list2); //search through langauges for (final String countrie : countries) { final Iterator<Locale> iterator = list.iterator(); boolean found = false; // see if it was returned by the set while (iterator.hasNext()) { final Locale locale = iterator.next(); // should have an en empty variant assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty()); assertEquals(language, locale.getLanguage()); if (countrie.equals(locale.getCountry())) { found = true; break; } } if (!found) { fail("Cound not find language: " + countrie + " for country: " + language); } } assertUnmodifiableCollection(list); } /** * Test countriesByLanguage() method. */ @Test public void testCountriesByLanguage() { assertCountriesByLanguage(null, new String[0]); assertCountriesByLanguage("de", new String[]{"DE", "CH", "AT", "LU"}); assertCountriesByLanguage("zz", new String[0]); assertCountriesByLanguage("it", new String[]{"IT", "CH"}); } /** * @param coll the collection to check */ private static void assertUnmodifiableCollection(final Collection<?> coll) { try { coll.add(null); fail(); } catch (final UnsupportedOperationException ex) {} } /** * Tests #LANG-328 - only language+variant */ @Test public void testLang328() { assertValidToLocale("fr__P", "fr", "", "P"); assertValidToLocale("fr__POSIX", "fr", "", "POSIX"); } /** * Tests #LANG-865, strings starting with an underscore. */ @Test public void testLang865() { assertValidToLocale("_GB", "", "GB", ""); assertValidToLocale("_GB_P", "", "GB", "P"); assertValidToLocale("_GB_POSIX", "", "GB", "POSIX"); try { LocaleUtils.toLocale("_G"); fail("Must be at least 3 chars if starts with underscore"); } catch (final IllegalArgumentException iae) { } try { LocaleUtils.toLocale("_Gb"); fail("Must be uppercase if starts with underscore"); } catch (final IllegalArgumentException iae) { } try { LocaleUtils.toLocale("_gB"); fail("Must be uppercase if starts with underscore"); } catch (final IllegalArgumentException iae) { } try { LocaleUtils.toLocale("_1B"); fail("Must be letter if starts with underscore"); } catch (final IllegalArgumentException iae) { } try { LocaleUtils.toLocale("_G1"); fail("Must be letter if starts with underscore"); } catch (final IllegalArgumentException iae) { } try { LocaleUtils.toLocale("_GB_"); fail("Must be at least 5 chars if starts with underscore"); } catch (final IllegalArgumentException iae) { } try { LocaleUtils.toLocale("_GBAP"); fail("Must have underscore after the country if starts with underscore and is at least 5 chars"); } catch (final IllegalArgumentException iae) { } } @Test public void testParseAllLocales() { Locale[] locales = Locale.getAvailableLocales(); int failures = 0; for (Locale l : locales) { // Check if it's possible to recreate the Locale using just the standard constructor Locale locale = new Locale(l.getLanguage(), l.getCountry(), l.getVariant()); if (l.equals(locale)) { // it is possible for LocaleUtils.toLocale to handle these Locales String str = l.toString(); // Look for the script/extension suffix int suff = str.indexOf("_#"); if (suff == - 1) { suff = str.indexOf("#"); } if (suff >= 0) { // we have a suffix try { LocaleUtils.toLocale(str); // shouuld cause IAE System.out.println("Should not have parsed: " + str); failures++; continue; // try next Locale } catch (IllegalArgumentException iae) { // expected; try without suffix str = str.substring(0, suff); } } Locale loc = LocaleUtils.toLocale(str); if (!l.equals(loc)) { System.out.println("Failed to parse: " + str); failures++; } } } if (failures > 0) { fail("Failed "+failures+" test(s)"); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Arrays; import java.util.Calendar; import java.util.Comparator; import java.util.Date; import java.util.List; import org.apache.commons.lang3.exception.CloneFailedException; import org.apache.commons.lang3.mutable.MutableObject; import org.apache.commons.lang3.text.StrBuilder; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.ObjectUtils}. * * @version $Id$ */ public class ObjectUtilsTest { private static final String FOO = "foo"; private static final String BAR = "bar"; //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new ObjectUtils()); final Constructor<?>[] cons = ObjectUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(ObjectUtils.class.getModifiers())); assertFalse(Modifier.isFinal(ObjectUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testIsNull() { final Object o = FOO; final Object dflt = BAR; assertSame("dflt was not returned when o was null", dflt, ObjectUtils.defaultIfNull(null, dflt)); assertSame("dflt was returned when o was not null", o, ObjectUtils.defaultIfNull(o, dflt)); } @Test public void testFirstNonNull() { assertEquals(null, ObjectUtils.firstNonNull(null, null)); assertEquals("", ObjectUtils.firstNonNull(null, "")); final String firstNonNullGenerics = ObjectUtils.firstNonNull(null, null, "123", "456"); assertEquals("123", firstNonNullGenerics); assertEquals("123", ObjectUtils.firstNonNull("123", null, "456", null)); assertEquals(null, ObjectUtils.firstNonNull()); assertSame(Boolean.TRUE, ObjectUtils.firstNonNull(Boolean.TRUE)); assertNull(ObjectUtils.firstNonNull()); assertNull(ObjectUtils.firstNonNull(null, null)); // assertSame("123", ObjectUtils.firstNonNull(null, ObjectUtils.NULL, "123", "456")); // assertSame("456", ObjectUtils.firstNonNull(ObjectUtils.NULL, "456", "123", null)); // assertNull(ObjectUtils.firstNonNull(null, null, ObjectUtils.NULL)); assertNull(ObjectUtils.firstNonNull((Object) null)); assertNull(ObjectUtils.firstNonNull((Object[]) null)); } //----------------------------------------------------------------------- @Test public void testEquals() { assertTrue("ObjectUtils.equals(null, null) returned false", ObjectUtils.equals(null, null)); assertTrue("ObjectUtils.equals(\"foo\", null) returned true", !ObjectUtils.equals(FOO, null)); assertTrue("ObjectUtils.equals(null, \"bar\") returned true", !ObjectUtils.equals(null, BAR)); assertTrue("ObjectUtils.equals(\"foo\", \"bar\") returned true", !ObjectUtils.equals(FOO, BAR)); assertTrue("ObjectUtils.equals(\"foo\", \"foo\") returned false", ObjectUtils.equals(FOO, FOO)); } @Test public void testNotEqual() { assertFalse("ObjectUtils.notEqual(null, null) returned false", ObjectUtils.notEqual(null, null)); assertTrue("ObjectUtils.notEqual(\"foo\", null) returned true", ObjectUtils.notEqual(FOO, null)); assertTrue("ObjectUtils.notEqual(null, \"bar\") returned true", ObjectUtils.notEqual(null, BAR)); assertTrue("ObjectUtils.notEqual(\"foo\", \"bar\") returned true", ObjectUtils.notEqual(FOO, BAR)); assertFalse("ObjectUtils.notEqual(\"foo\", \"foo\") returned false", ObjectUtils.notEqual(FOO, FOO)); } @Test public void testHashCode() { assertEquals(0, ObjectUtils.hashCode(null)); assertEquals("a".hashCode(), ObjectUtils.hashCode("a")); } @Test public void testHashCodeMulti_multiple_emptyArray() { final Object[] array = new Object[0]; assertEquals(1, ObjectUtils.hashCodeMulti(array)); } @Test public void testHashCodeMulti_multiple_nullArray() { final Object[] array = null; assertEquals(1, ObjectUtils.hashCodeMulti(array)); } @Test public void testHashCodeMulti_multiple_likeList() { final List<Object> list0 = new ArrayList<Object>(Arrays.asList()); assertEquals(list0.hashCode(), ObjectUtils.hashCodeMulti()); final List<Object> list1 = new ArrayList<Object>(Arrays.asList("a")); assertEquals(list1.hashCode(), ObjectUtils.hashCodeMulti("a")); final List<Object> list2 = new ArrayList<Object>(Arrays.asList("a", "b")); assertEquals(list2.hashCode(), ObjectUtils.hashCodeMulti("a", "b")); final List<Object> list3 = new ArrayList<Object>(Arrays.asList("a", "b", "c")); assertEquals(list3.hashCode(), ObjectUtils.hashCodeMulti("a", "b", "c")); } // /** // * Show that java.util.Date and java.sql.Timestamp are apples and oranges. // * Prompted by an email discussion. // * // * The behavior is different b/w Sun Java 1.3.1_10 and 1.4.2_03. // */ // public void testDateEqualsJava() { // long now = 1076957313284L; // Feb 16, 2004 10:49... PST // java.util.Date date = new java.util.Date(now); // java.sql.Timestamp realTimestamp = new java.sql.Timestamp(now); // java.util.Date timestamp = realTimestamp; // // sanity check 1: // assertEquals(284000000, realTimestamp.getNanos()); // assertEquals(1076957313284L, date.getTime()); // // // // On Sun 1.3.1_10: // //junit.framework.AssertionFailedError: expected:<1076957313284> but was:<1076957313000> // // // //assertEquals(1076957313284L, timestamp.getTime()); // // // //junit.framework.AssertionFailedError: expected:<1076957313284> but was:<1076957313000> // // // //assertEquals(1076957313284L, realTimestamp.getTime()); // // sanity check 2: // assertEquals(date.getDay(), realTimestamp.getDay()); // assertEquals(date.getHours(), realTimestamp.getHours()); // assertEquals(date.getMinutes(), realTimestamp.getMinutes()); // assertEquals(date.getMonth(), realTimestamp.getMonth()); // assertEquals(date.getSeconds(), realTimestamp.getSeconds()); // assertEquals(date.getTimezoneOffset(), realTimestamp.getTimezoneOffset()); // assertEquals(date.getYear(), realTimestamp.getYear()); // // // // Time values are == and equals() on Sun 1.4.2_03 but NOT on Sun 1.3.1_10: // // // //assertFalse("Sanity check failed: date.getTime() == timestamp.getTime()", date.getTime() == timestamp.getTime()); // //assertFalse("Sanity check failed: timestamp.equals(date)", timestamp.equals(date)); // //assertFalse("Sanity check failed: date.equals(timestamp)", date.equals(timestamp)); // // real test: // //assertFalse("java.util.Date and java.sql.Timestamp should be equal", ObjectUtils.equals(date, timestamp)); // } @Test public void testIdentityToStringStringBuffer() { final Integer i = Integer.valueOf(45); final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); final StringBuffer buffer = new StringBuffer(); ObjectUtils.identityToString(buffer, i); assertEquals(expected, buffer.toString()); try { ObjectUtils.identityToString((StringBuffer)null, "tmp"); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } try { ObjectUtils.identityToString(new StringBuffer(), null); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } } @Test public void testIdentityToStringStringBuilder() { assertEquals(null, ObjectUtils.identityToString(null)); assertEquals( "java.lang.String@" + Integer.toHexString(System.identityHashCode(FOO)), ObjectUtils.identityToString(FOO)); final Integer i = Integer.valueOf(90); final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); assertEquals(expected, ObjectUtils.identityToString(i)); final StringBuilder builder = new StringBuilder(); ObjectUtils.identityToString(builder, i); assertEquals(expected, builder.toString()); try { ObjectUtils.identityToString((StringBuilder)null, "tmp"); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } try { ObjectUtils.identityToString(new StringBuilder(), null); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } } @Test public void testIdentityToStringStrBuilder() { final Integer i = Integer.valueOf(102); final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); final StrBuilder builder = new StrBuilder(); ObjectUtils.identityToString(builder, i); assertEquals(expected, builder.toString()); try { ObjectUtils.identityToString((StrBuilder)null, "tmp"); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } try { ObjectUtils.identityToString(new StrBuilder(), null); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } } @Test public void testIdentityToStringAppendable() { final Integer i = Integer.valueOf(121); final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)); try { final Appendable appendable = new StringBuilder(); ObjectUtils.identityToString(appendable, i); assertEquals(expected, appendable.toString()); } catch(IOException ex) { fail("IOException unexpected"); } try { ObjectUtils.identityToString((Appendable)null, "tmp"); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } catch (IOException ex) { } try { ObjectUtils.identityToString((Appendable)(new StringBuilder()), null); fail("NullPointerException expected"); } catch(final NullPointerException npe) { } catch (IOException ex) { } } @Test public void testToString_Object() { assertEquals("", ObjectUtils.toString((Object) null) ); assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE) ); } @Test public void testToString_ObjectString() { assertEquals(BAR, ObjectUtils.toString((Object) null, BAR) ); assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE, BAR) ); } @SuppressWarnings("cast") // 1 OK, because we are checking for code change @Test public void testNull() { assertNotNull(ObjectUtils.NULL); // 1 Check that NULL really is a Null i.e. the definition has not been changed assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null); assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL)); } @Test public void testMax() { final Calendar calendar = Calendar.getInstance(); final Date nonNullComparable1 = calendar.getTime(); final Date nonNullComparable2 = calendar.getTime(); final String[] nullAray = null; calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); final Date minComparable = calendar.getTime(); assertNotSame( nonNullComparable1, nonNullComparable2 ); assertNull(ObjectUtils.max( (String) null ) ); assertNull(ObjectUtils.max( nullAray ) ); assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1 ) ); assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, null ) ); assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1, null ) ); assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, nonNullComparable2 ) ); assertSame( nonNullComparable2, ObjectUtils.max( nonNullComparable2, nonNullComparable1 ) ); assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, minComparable ) ); assertSame( nonNullComparable1, ObjectUtils.max( minComparable, nonNullComparable1 ) ); assertSame( nonNullComparable1, ObjectUtils.max( null, minComparable, null, nonNullComparable1 ) ); assertNull( ObjectUtils.max((String)null, (String)null) ); } @Test public void testMin() { final Calendar calendar = Calendar.getInstance(); final Date nonNullComparable1 = calendar.getTime(); final Date nonNullComparable2 = calendar.getTime(); final String[] nullAray = null; calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 ); final Date minComparable = calendar.getTime(); assertNotSame( nonNullComparable1, nonNullComparable2 ); assertNull(ObjectUtils.min( (String) null ) ); assertNull(ObjectUtils.min( nullAray ) ); assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1 ) ); assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, null ) ); assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1, null ) ); assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, nonNullComparable2 ) ); assertSame( nonNullComparable2, ObjectUtils.min( nonNullComparable2, nonNullComparable1 ) ); assertSame( minComparable, ObjectUtils.min( nonNullComparable1, minComparable ) ); assertSame( minComparable, ObjectUtils.min( minComparable, nonNullComparable1 ) ); assertSame( minComparable, ObjectUtils.min( null, nonNullComparable1, null, minComparable ) ); assertNull( ObjectUtils.min((String)null, (String)null) ); } /** * Tests {@link ObjectUtils#compare(Comparable, Comparable, boolean)}. */ @Test public void testCompare() { final Integer one = Integer.valueOf(1); final Integer two = Integer.valueOf(2); final Integer nullValue = null; assertEquals("Null Null false", 0, ObjectUtils.compare(nullValue, nullValue)); assertEquals("Null Null true", 0, ObjectUtils.compare(nullValue, nullValue, true)); assertEquals("Null one false", -1, ObjectUtils.compare(nullValue, one)); assertEquals("Null one true", 1, ObjectUtils.compare(nullValue, one, true)); assertEquals("one Null false", 1, ObjectUtils.compare(one, nullValue)); assertEquals("one Null true", -1, ObjectUtils.compare(one, nullValue, true)); assertEquals("one two false", -1, ObjectUtils.compare(one, two)); assertEquals("one two true", -1, ObjectUtils.compare(one, two, true)); } @Test public void testMedian() { assertEquals("foo", ObjectUtils.median("foo")); assertEquals("bar", ObjectUtils.median("foo", "bar")); assertEquals("baz", ObjectUtils.median("foo", "bar", "baz")); assertEquals("baz", ObjectUtils.median("foo", "bar", "baz", "blah")); assertEquals("blah", ObjectUtils.median("foo", "bar", "baz", "blah", "wah")); assertEquals(Integer.valueOf(5), ObjectUtils.median(Integer.valueOf(1), Integer.valueOf(5), Integer.valueOf(10))); assertEquals( Integer.valueOf(7), ObjectUtils.median(Integer.valueOf(5), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8), Integer.valueOf(9))); assertEquals(Integer.valueOf(6), ObjectUtils.median(Integer.valueOf(5), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8))); } @Test(expected = NullPointerException.class) public void testMedian_nullItems() { ObjectUtils.median((String[]) null); } @Test(expected = IllegalArgumentException.class) public void testMedian_emptyItems() { ObjectUtils.<String> median(); } @Test public void testComparatorMedian() { final CharSequenceComparator cmp = new CharSequenceComparator(); final NonComparableCharSequence foo = new NonComparableCharSequence("foo"); final NonComparableCharSequence bar = new NonComparableCharSequence("bar"); final NonComparableCharSequence baz = new NonComparableCharSequence("baz"); final NonComparableCharSequence blah = new NonComparableCharSequence("blah"); final NonComparableCharSequence wah = new NonComparableCharSequence("wah"); assertSame(foo, ObjectUtils.median(cmp, foo)); assertSame(bar, ObjectUtils.median(cmp, foo, bar)); assertSame(baz, ObjectUtils.median(cmp, foo, bar, baz)); assertSame(baz, ObjectUtils.median(cmp, foo, bar, baz, blah)); assertSame(blah, ObjectUtils.median(cmp, foo, bar, baz, blah, wah)); } @Test(expected = NullPointerException.class) public void testComparatorMedian_nullComparator() { ObjectUtils.median((Comparator<CharSequence>) null, new NonComparableCharSequence("foo")); } @Test(expected = NullPointerException.class) public void testComparatorMedian_nullItems() { ObjectUtils.median(new CharSequenceComparator(), (CharSequence[]) null); } @Test(expected = IllegalArgumentException.class) public void testComparatorMedian_emptyItems() { ObjectUtils.median(new CharSequenceComparator()); } @SuppressWarnings("unchecked") @Test public void testMode() { assertNull(ObjectUtils.mode((Object[]) null)); assertNull(ObjectUtils.mode()); assertNull(ObjectUtils.mode("foo", "bar", "baz")); assertNull(ObjectUtils.mode("foo", "bar", "baz", "foo", "bar")); assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "foo")); assertEquals(Integer.valueOf(9), ObjectUtils.mode("foo", "bar", "baz", Integer.valueOf(9), Integer.valueOf(10), Integer.valueOf(9))); } /** * Tests {@link ObjectUtils#clone(Object)} with a cloneable object. */ @Test public void testCloneOfCloneable() { final CloneableString string = new CloneableString("apache"); final CloneableString stringClone = ObjectUtils.clone(string); assertEquals("apache", stringClone.getValue()); } /** * Tests {@link ObjectUtils#clone(Object)} with a not cloneable object. */ @Test public void testCloneOfNotCloneable() { final String string = new String("apache"); assertNull(ObjectUtils.clone(string)); } /** * Tests {@link ObjectUtils#clone(Object)} with an uncloneable object. */ @Test(expected = NoSuchMethodException.class) public void testCloneOfUncloneable() throws Throwable { final UncloneableString string = new UncloneableString("apache"); try { ObjectUtils.clone(string); fail("Thrown " + CloneFailedException.class.getName() + " expected"); } catch (final CloneFailedException e) { throw e.getCause(); } } /** * Tests {@link ObjectUtils#clone(Object)} with an object array. */ @Test public void testCloneOfStringArray() { assertTrue(Arrays.deepEquals( new String[]{"string"}, ObjectUtils.clone(new String[]{"string"}))); } /** * Tests {@link ObjectUtils#clone(Object)} with an array of primitives. */ @Test public void testCloneOfPrimitiveArray() { assertTrue(Arrays.equals(new int[]{1}, ObjectUtils.clone(new int[]{1}))); } /** * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object. */ @Test public void testPossibleCloneOfCloneable() { final CloneableString string = new CloneableString("apache"); final CloneableString stringClone = ObjectUtils.cloneIfPossible(string); assertEquals("apache", stringClone.getValue()); } /** * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a not cloneable object. */ @Test public void testPossibleCloneOfNotCloneable() { final String string = new String("apache"); assertSame(string, ObjectUtils.cloneIfPossible(string)); } /** * Tests {@link ObjectUtils#cloneIfPossible(Object)} with an uncloneable object. */ @Test(expected = NoSuchMethodException.class) public void testPossibleCloneOfUncloneable() throws Throwable { final UncloneableString string = new UncloneableString("apache"); try { ObjectUtils.cloneIfPossible(string); fail("Thrown " + CloneFailedException.class.getName() + " expected"); } catch (final CloneFailedException e) { throw e.getCause(); } } @Test public void testConstMethods() { // To truly test the CONST() method, we'd want to look in the // bytecode to see if the literals were folded into the // class, or if the bytecode kept the method call. assertTrue("CONST(boolean)", ObjectUtils.CONST(true)); assertEquals("CONST(byte)", (byte) 3, ObjectUtils.CONST((byte) 3)); assertEquals("CONST(char)", (char) 3, ObjectUtils.CONST((char) 3)); assertEquals("CONST(short)", (short) 3, ObjectUtils.CONST((short) 3)); assertEquals("CONST(int)", 3, ObjectUtils.CONST(3)); assertEquals("CONST(long)", 3l, ObjectUtils.CONST(3l)); assertEquals("CONST(float)", 3f, ObjectUtils.CONST(3f), 0); assertEquals("CONST(double)", 3.0, ObjectUtils.CONST(3.0), 0); assertEquals("CONST(Object)", "abc", ObjectUtils.CONST("abc")); // Make sure documentation examples from Javadoc all work // (this fixed a lot of my bugs when I these!) // // My bugs should be in a software engineering textbook // for "Can you screw this up?" The answer is, yes, // you can even screw this up. (When you == Julius) // . final boolean MAGIC_FLAG = ObjectUtils.CONST(true); final byte MAGIC_BYTE1 = ObjectUtils.CONST((byte) 127); final byte MAGIC_BYTE2 = ObjectUtils.CONST_BYTE(127); final char MAGIC_CHAR = ObjectUtils.CONST('a'); final short MAGIC_SHORT1 = ObjectUtils.CONST((short) 123); final short MAGIC_SHORT2 = ObjectUtils.CONST_SHORT(127); final int MAGIC_INT = ObjectUtils.CONST(123); final long MAGIC_LONG1 = ObjectUtils.CONST(123L); final long MAGIC_LONG2 = ObjectUtils.CONST(3); final float MAGIC_FLOAT = ObjectUtils.CONST(1.0f); final double MAGIC_DOUBLE = ObjectUtils.CONST(1.0); final String MAGIC_STRING = ObjectUtils.CONST("abc"); assertTrue(MAGIC_FLAG); assertEquals(127, MAGIC_BYTE1); assertEquals(127, MAGIC_BYTE2); assertEquals('a', MAGIC_CHAR); assertEquals(123, MAGIC_SHORT1); assertEquals(127, MAGIC_SHORT2); assertEquals(123, MAGIC_INT); assertEquals(123, MAGIC_LONG1); assertEquals(3, MAGIC_LONG2); assertEquals(1.0f, MAGIC_FLOAT, 0.0f); assertEquals(1.0, MAGIC_DOUBLE, 0.0); assertEquals("abc", MAGIC_STRING); try { ObjectUtils.CONST_BYTE(-129); fail("CONST_BYTE(-129): IllegalArgumentException should have been thrown."); } catch (final IllegalArgumentException iae) { } try { ObjectUtils.CONST_BYTE(128); fail("CONST_BYTE(128): IllegalArgumentException should have been thrown."); } catch (final IllegalArgumentException iae) { } try { ObjectUtils.CONST_SHORT(-32769); fail("CONST_SHORT(-32769): IllegalArgumentException should have been thrown."); } catch (final IllegalArgumentException iae) { } try { ObjectUtils.CONST_BYTE(32768); fail("CONST_SHORT(32768): IllegalArgumentException should have been thrown."); } catch (final IllegalArgumentException iae) { } } /** * String that is cloneable. */ static final class CloneableString extends MutableObject<String> implements Cloneable { private static final long serialVersionUID = 1L; CloneableString(final String s) { super(s); } @Override public CloneableString clone() throws CloneNotSupportedException { return (CloneableString)super.clone(); } } /** * String that is not cloneable. */ static final class UncloneableString extends MutableObject<String> implements Cloneable { private static final long serialVersionUID = 1L; UncloneableString(final String s) { super(s); } } static final class NonComparableCharSequence implements CharSequence { final String value; /** * Create a new NonComparableCharSequence instance. * * @param value */ public NonComparableCharSequence(final String value) { super(); Validate.notNull(value); this.value = value; } @Override public char charAt(final int arg0) { return value.charAt(arg0); } @Override public int length() { return value.length(); } @Override public CharSequence subSequence(final int arg0, final int arg1) { return value.subSequence(arg0, arg1); } @Override public String toString() { return value; } } static final class CharSequenceComparator implements Comparator<CharSequence> { @Override public int compare(final CharSequence o1, final CharSequence o2) { return o1.toString().compareTo(o2.toString()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Random; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.RandomStringUtils}. * * @version $Id$ */ public class RandomStringUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new RandomStringUtils()); final Constructor<?>[] cons = RandomStringUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(RandomStringUtils.class.getModifiers())); assertFalse(Modifier.isFinal(RandomStringUtils.class.getModifiers())); } //----------------------------------------------------------------------- /** * Test the implementation */ @Test public void testRandomStringUtils() { String r1 = RandomStringUtils.random(50); assertEquals("random(50) length", 50, r1.length()); String r2 = RandomStringUtils.random(50); assertEquals("random(50) length", 50, r2.length()); assertTrue("!r1.equals(r2)", !r1.equals(r2)); r1 = RandomStringUtils.randomAscii(50); assertEquals("randomAscii(50) length", 50, r1.length()); for(int i = 0; i < r1.length(); i++) { assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127); } r2 = RandomStringUtils.randomAscii(50); assertTrue("!r1.equals(r2)", !r1.equals(r2)); r1 = RandomStringUtils.randomAlphabetic(50); assertEquals("randomAlphabetic(50)", 50, r1.length()); for(int i = 0; i < r1.length(); i++) { assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i))); } r2 = RandomStringUtils.randomAlphabetic(50); assertTrue("!r1.equals(r2)", !r1.equals(r2)); r1 = RandomStringUtils.randomAlphanumeric(50); assertEquals("randomAlphanumeric(50)", 50, r1.length()); for(int i = 0; i < r1.length(); i++) { assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i))); } r2 = RandomStringUtils.randomAlphabetic(50); assertTrue("!r1.equals(r2)", !r1.equals(r2)); r1 = RandomStringUtils.randomNumeric(50); assertEquals("randomNumeric(50)", 50, r1.length()); for(int i = 0; i < r1.length(); i++) { assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i))); } r2 = RandomStringUtils.randomNumeric(50); assertTrue("!r1.equals(r2)", !r1.equals(r2)); String set = "abcdefg"; r1 = RandomStringUtils.random(50, set); assertEquals("random(50, \"abcdefg\")", 50, r1.length()); for(int i = 0; i < r1.length(); i++) { assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); } r2 = RandomStringUtils.random(50, set); assertTrue("!r1.equals(r2)", !r1.equals(r2)); r1 = RandomStringUtils.random(50, (String) null); assertEquals("random(50) length", 50, r1.length()); r2 = RandomStringUtils.random(50, (String) null); assertEquals("random(50) length", 50, r2.length()); assertTrue("!r1.equals(r2)", !r1.equals(r2)); set = "stuvwxyz"; r1 = RandomStringUtils.random(50, set.toCharArray()); assertEquals("random(50, \"stuvwxyz\")", 50, r1.length()); for(int i = 0; i < r1.length(); i++) { assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1); } r2 = RandomStringUtils.random(50, set); assertTrue("!r1.equals(r2)", !r1.equals(r2)); r1 = RandomStringUtils.random(50, (char[]) null); assertEquals("random(50) length", 50, r1.length()); r2 = RandomStringUtils.random(50, (char[]) null); assertEquals("random(50) length", 50, r2.length()); assertTrue("!r1.equals(r2)", !r1.equals(r2)); final long seed = System.currentTimeMillis(); r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed)); assertEquals("r1.equals(r2)", r1, r2); r1 = RandomStringUtils.random(0); assertEquals("random(0).equals(\"\")", "", r1); } @Test public void testLANG805() { final long seed = System.currentTimeMillis(); assertEquals("aaa", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed))); } @Test public void testLANG807() { try { RandomStringUtils.random(3,5,5,false,false); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // distinguish from Random#nextInt message final String msg = ex.getMessage(); assertTrue("Message (" + msg + ") must contain 'start'", msg.contains("start")); assertTrue("Message (" + msg + ") must contain 'end'", msg.contains("end")); } } @Test public void testExceptions() { final char[] DUMMY = new char[]{'a'}; // valid char array try { RandomStringUtils.random(-1); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, true, true); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, DUMMY); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, ""); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, (String)null); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, 'a', 'z', false, false); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY); fail(); } catch (final IllegalArgumentException ex) {} try { RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()); fail(); } catch (final IllegalArgumentException ex) {} } /** * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7 */ @Test public void testRandomAlphaNumeric() {} // Defects4J: flaky method // @Test // public void testRandomAlphaNumeric() { // final char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'}; // final boolean[] found = {false, false, false, false, false, false}; // for (int i = 0; i < 100; i++) { // final String randString = RandomStringUtils.randomAlphanumeric(10); // for (int j = 0; j < testChars.length; j++) { // if (randString.indexOf(testChars[j]) > 0) { // found[j] = true; // } // } // } // for (int i = 0; i < testChars.length; i++) { // if (!found[i]) { // fail("alphanumeric character not generated in 1000 attempts: " // + testChars[i] +" -- repeated failures indicate a problem "); // } // } // } /** * Make sure '0' and '9' are generated by randomNumeric * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46 */ @Test public void testRandomNumeric() {} // Defects4J: flaky method // @Test // public void testRandomNumeric() { // final char[] testChars = {'0','9'}; // final boolean[] found = {false, false}; // for (int i = 0; i < 100; i++) { // final String randString = RandomStringUtils.randomNumeric(10); // for (int j = 0; j < testChars.length; j++) { // if (randString.indexOf(testChars[j]) > 0) { // found[j] = true; // } // } // } // for (int i = 0; i < testChars.length; i++) { // if (!found[i]) { // fail("digit not generated in 1000 attempts: " // + testChars[i] +" -- repeated failures indicate a problem "); // } // } // } /** * Make sure boundary alpha characters are generated by randomAlphabetic * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8 */ @Test public void testRandomAlphabetic() {} // Defects4J: flaky method // @Test // public void testRandomAlphabetic() { // final char[] testChars = {'a', 'z', 'A', 'Z'}; // final boolean[] found = {false, false, false, false}; // for (int i = 0; i < 100; i++) { // final String randString = RandomStringUtils.randomAlphabetic(10); // for (int j = 0; j < testChars.length; j++) { // if (randString.indexOf(testChars[j]) > 0) { // found[j] = true; // } // } // } // for (int i = 0; i < testChars.length; i++) { // if (!found[i]) { // fail("alphanumeric character not generated in 1000 attempts: " // + testChars[i] +" -- repeated failures indicate a problem "); // } // } // } /** * Make sure 32 and 127 are generated by randomNumeric * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5 */ @Test public void testRandomAscii() {} // Defects4J: flaky method // @Test // public void testRandomAscii() { // final char[] testChars = {(char) 32, (char) 126}; // final boolean[] found = {false, false}; // for (int i = 0; i < 100; i++) { // final String randString = RandomStringUtils.randomAscii(10); // for (int j = 0; j < testChars.length; j++) { // if (randString.indexOf(testChars[j]) > 0) { // found[j] = true; // } // } // } // for (int i = 0; i < testChars.length; i++) { // if (!found[i]) { // fail("ascii character not generated in 1000 attempts: " // + (int) testChars[i] + // " -- repeated failures indicate a problem"); // } // } // } /** * Test homogeneity of random strings generated -- * i.e., test that characters show up with expected frequencies * in generated strings. Will fail randomly about 1 in 1000 times. * Repeated failures indicate a problem. */ @Test public void testRandomStringUtilsHomog() {} // Defects4J: flaky method // @Test // public void testRandomStringUtilsHomog() { // final String set = "abc"; // final char[] chars = set.toCharArray(); // String gen = ""; // final int[] counts = {0,0,0}; // final int[] expected = {200,200,200}; // for (int i = 0; i< 100; i++) { // gen = RandomStringUtils.random(6,chars); // for (int j = 0; j < 6; j++) { // switch (gen.charAt(j)) { // case 'a': {counts[0]++; break;} // case 'b': {counts[1]++; break;} // case 'c': {counts[2]++; break;} // default: {fail("generated character not in set");} // } // } // } // // Perform chi-square test with df = 3-1 = 2, testing at .001 level // assertTrue("test homogeneity -- will fail about 1 in 1000 times", // chiSquare(expected,counts) < 13.82); // } /** * Computes Chi-Square statistic given observed and expected counts * @param observed array of observed frequency counts * @param expected array of expected frequency counts */ private double chiSquare(final int[] expected, final int[] observed) { double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { dev = observed[i] - expected[i]; sumSq += dev * dev / expected[i]; } return sumSq; } /** * Checks if the string got by {@link RandomStringUtils#random(int)} * can be converted to UTF-8 and back without loss. * * @see <a href="http://issues.apache.org/jira/browse/LANG-100">LANG-100</a> * * @throws Exception */ @Test public void testLang100() throws Exception { final int size = 5000; final String encoding = "UTF-8"; final String orig = RandomStringUtils.random(size); final byte[] bytes = orig.getBytes(encoding); final String copy = new String(bytes, encoding); // for a verbose compare: for (int i=0; i < orig.length() && i < copy.length(); i++) { final char o = orig.charAt(i); final char c = copy.charAt(i); assertEquals("differs at " + i + "(" + Integer.toHexString(new Character(o).hashCode()) + "," + Integer.toHexString(new Character(c).hashCode()) + ")", o, c); } // compare length also assertEquals(orig.length(), copy.length()); // just to be complete assertEquals(orig, copy); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.util.Comparator; import org.junit.Before; import org.junit.Test; /** * <p> * Tests the methods in the {@link org.apache.commons.lang3.Range} class. * </p> * * @version $Id$ */ @SuppressWarnings("boxing") public class RangeTest { private Range<Byte> byteRange; private Range<Byte> byteRange2; private Range<Byte> byteRange3; private Range<Integer> intRange; private Range<Long> longRange; private Range<Float> floatRange; private Range<Double> doubleRange; @SuppressWarnings("cast") // intRange @Before public void setUp() { byteRange = Range.between((byte) 0, (byte) 5); byteRange2 = Range.between((byte) 0, (byte) 5); byteRange3 = Range.between((byte) 0, (byte) 10); intRange = Range.between((int) 10, (int) 20); longRange = Range.between((long) 10, (long) 20); floatRange = Range.between((float) 10, (float) 20); doubleRange = Range.between((double) 10, (double) 20); } //----------------------------------------------------------------------- @SuppressWarnings({ "rawtypes", "unchecked" }) @Test public void testComparableConstructors() { final Comparable c = new Comparable() { @Override public int compareTo(final Object other) { return 1; } }; final Range r1 = Range.is(c); final Range r2 = Range.between(c, c); assertEquals(true, r1.isNaturalOrdering()); assertEquals(true, r2.isNaturalOrdering()); } @Test public void testIsWithCompare(){ final Comparator<Integer> c = new Comparator<Integer>(){ @Override public int compare(final Integer o1, final Integer o2) { return 0; // all integers are equal } }; Range<Integer> ri = Range.is(10); assertFalse("should not contain null",ri.contains(null)); assertTrue("should contain 10",ri.contains(10)); assertFalse("should not contain 11",ri.contains(11)); ri = Range.is(10,c); assertFalse("should not contain null",ri.contains(null)); assertTrue("should contain 10",ri.contains(10)); assertTrue("should contain 11",ri.contains(11)); } @Test public void testBetweenWithCompare(){ // TODO add tests with a better comparator final Comparator<Integer> c = new Comparator<Integer>(){ @Override public int compare(final Integer o1, final Integer o2) { return 0; // all integers are equal } }; Range<Integer> rb = Range.between(-10,20); assertFalse("should not contain null",rb.contains(null)); assertTrue("should contain 10",rb.contains(10)); assertTrue("should contain -10",rb.contains(-10)); assertFalse("should not contain 21",rb.contains(21)); assertFalse("should not contain -11",rb.contains(-11)); rb = Range.between(-10,20,c); assertFalse("should not contain null",rb.contains(null)); assertTrue("should contain 10",rb.contains(10)); assertTrue("should contain -10",rb.contains(-10)); assertTrue("should contain 21",rb.contains(21)); assertTrue("should contain -11",rb.contains(-11)); } //----------------------------------------------------------------------- @Test public void testRangeOfChars() { final Range<Character> chars = Range.between('a', 'z'); assertTrue(chars.contains('b')); assertFalse(chars.contains('B')); } //----------------------------------------------------------------------- @Test public void testEqualsObject() { assertEquals(byteRange, byteRange); assertEquals(byteRange, byteRange2); assertEquals(byteRange2, byteRange2); assertTrue(byteRange.equals(byteRange)); assertTrue(byteRange2.equals(byteRange2)); assertTrue(byteRange3.equals(byteRange3)); assertFalse(byteRange2.equals(byteRange3)); assertFalse(byteRange2.equals(null)); assertFalse(byteRange2.equals("Ni!")); } @Test public void testHashCode() { assertEquals(byteRange.hashCode(), byteRange2.hashCode()); assertFalse(byteRange.hashCode() == byteRange3.hashCode()); assertEquals(intRange.hashCode(), intRange.hashCode()); assertTrue(intRange.hashCode() != 0); } @Test public void testToString() { assertNotNull(byteRange.toString()); final String str = intRange.toString(); assertEquals("[10..20]", str); assertEquals("[-20..-10]", Range.between(-20, -10).toString()); } @Test public void testToStringFormat() { final String str = intRange.toString("From %1$s to %2$s"); assertEquals("From 10 to 20", str); } //----------------------------------------------------------------------- @Test public void testGetMinimum() { assertEquals(10, (int) intRange.getMinimum()); assertEquals(10L, (long) longRange.getMinimum()); assertEquals(10f, floatRange.getMinimum(), 0.00001f); assertEquals(10d, doubleRange.getMinimum(), 0.00001d); } @Test public void testGetMaximum() { assertEquals(20, (int) intRange.getMaximum()); assertEquals(20L, (long) longRange.getMaximum()); assertEquals(20f, floatRange.getMaximum(), 0.00001f); assertEquals(20d, doubleRange.getMaximum(), 0.00001d); } @Test public void testContains() { assertFalse(intRange.contains(null)); assertFalse(intRange.contains(5)); assertTrue(intRange.contains(10)); assertTrue(intRange.contains(15)); assertTrue(intRange.contains(20)); assertFalse(intRange.contains(25)); } @Test public void testIsAfter() { assertFalse(intRange.isAfter(null)); assertTrue(intRange.isAfter(5)); assertFalse(intRange.isAfter(10)); assertFalse(intRange.isAfter(15)); assertFalse(intRange.isAfter(20)); assertFalse(intRange.isAfter(25)); } @Test public void testIsStartedBy() { assertFalse(intRange.isStartedBy(null)); assertFalse(intRange.isStartedBy(5)); assertTrue(intRange.isStartedBy(10)); assertFalse(intRange.isStartedBy(15)); assertFalse(intRange.isStartedBy(20)); assertFalse(intRange.isStartedBy(25)); } @Test public void testIsEndedBy() { assertFalse(intRange.isEndedBy(null)); assertFalse(intRange.isEndedBy(5)); assertFalse(intRange.isEndedBy(10)); assertFalse(intRange.isEndedBy(15)); assertTrue(intRange.isEndedBy(20)); assertFalse(intRange.isEndedBy(25)); } @Test public void testIsBefore() { assertFalse(intRange.isBefore(null)); assertFalse(intRange.isBefore(5)); assertFalse(intRange.isBefore(10)); assertFalse(intRange.isBefore(15)); assertFalse(intRange.isBefore(20)); assertTrue(intRange.isBefore(25)); } @Test public void testElementCompareTo() { try { intRange.elementCompareTo(null); fail("NullPointerException should have been thrown"); } catch(final NullPointerException npe) { // expected } assertEquals(-1, intRange.elementCompareTo(5)); assertEquals(0, intRange.elementCompareTo(10)); assertEquals(0, intRange.elementCompareTo(15)); assertEquals(0, intRange.elementCompareTo(20)); assertEquals(1, intRange.elementCompareTo(25)); } //----------------------------------------------------------------------- @Test public void testContainsRange() { // null handling assertFalse(intRange.containsRange(null)); // easy inside range assertTrue(intRange.containsRange(Range.between(12, 18))); // outside range on each side assertFalse(intRange.containsRange(Range.between(32, 45))); assertFalse(intRange.containsRange(Range.between(2, 8))); // equals range assertTrue(intRange.containsRange(Range.between(10, 20))); // overlaps assertFalse(intRange.containsRange(Range.between(9, 14))); assertFalse(intRange.containsRange(Range.between(16, 21))); // touches lower boundary assertTrue(intRange.containsRange(Range.between(10, 19))); assertFalse(intRange.containsRange(Range.between(10, 21))); // touches upper boundary assertTrue(intRange.containsRange(Range.between(11, 20))); assertFalse(intRange.containsRange(Range.between(9, 20))); // negative assertFalse(intRange.containsRange(Range.between(-11, -18))); } @Test public void testIsAfterRange() { assertFalse(intRange.isAfterRange(null)); assertTrue(intRange.isAfterRange(Range.between(5, 9))); assertFalse(intRange.isAfterRange(Range.between(5, 10))); assertFalse(intRange.isAfterRange(Range.between(5, 20))); assertFalse(intRange.isAfterRange(Range.between(5, 25))); assertFalse(intRange.isAfterRange(Range.between(15, 25))); assertFalse(intRange.isAfterRange(Range.between(21, 25))); assertFalse(intRange.isAfterRange(Range.between(10, 20))); } @Test public void testIsOverlappedBy() { // null handling assertFalse(intRange.isOverlappedBy(null)); // easy inside range assertTrue(intRange.isOverlappedBy(Range.between(12, 18))); // outside range on each side assertFalse(intRange.isOverlappedBy(Range.between(32, 45))); assertFalse(intRange.isOverlappedBy(Range.between(2, 8))); // equals range assertTrue(intRange.isOverlappedBy(Range.between(10, 20))); // overlaps assertTrue(intRange.isOverlappedBy(Range.between(9, 14))); assertTrue(intRange.isOverlappedBy(Range.between(16, 21))); // touches lower boundary assertTrue(intRange.isOverlappedBy(Range.between(10, 19))); assertTrue(intRange.isOverlappedBy(Range.between(10, 21))); // touches upper boundary assertTrue(intRange.isOverlappedBy(Range.between(11, 20))); assertTrue(intRange.isOverlappedBy(Range.between(9, 20))); // negative assertFalse(intRange.isOverlappedBy(Range.between(-11, -18))); } @Test public void testIsBeforeRange() { assertFalse(intRange.isBeforeRange(null)); assertFalse(intRange.isBeforeRange(Range.between(5, 9))); assertFalse(intRange.isBeforeRange(Range.between(5, 10))); assertFalse(intRange.isBeforeRange(Range.between(5, 20))); assertFalse(intRange.isBeforeRange(Range.between(5, 25))); assertFalse(intRange.isBeforeRange(Range.between(15, 25))); assertTrue(intRange.isBeforeRange(Range.between(21, 25))); assertFalse(intRange.isBeforeRange(Range.between(10, 20))); } @Test public void testIntersectionWith() { assertSame(intRange, intRange.intersectionWith(intRange)); assertSame(byteRange, byteRange.intersectionWith(byteRange)); assertSame(longRange, longRange.intersectionWith(longRange)); assertSame(floatRange, floatRange.intersectionWith(floatRange)); assertSame(doubleRange, doubleRange.intersectionWith(doubleRange)); assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15))); } @Test(expected = IllegalArgumentException.class) public void testIntersectionWithNull() { intRange.intersectionWith(null); } @Test(expected = IllegalArgumentException.class) public void testIntersectionWithNonOverlapping() { intRange.intersectionWith(Range.between(0, 9)); } //----------------------------------------------------------------------- @Test public void testSerializing() { SerializationUtils.clone(intRange); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.io.Serializable; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.HashMap; import org.junit.Assert; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.SerializationUtils}. * * @version $Id$ */ public class SerializationUtilsTest { static final String CLASS_NOT_FOUND_MESSAGE = "ClassNotFoundSerialization.readObject fake exception"; protected static final String SERIALIZE_IO_EXCEPTION_MESSAGE = "Anonymous OutputStream I/O exception"; private String iString; private Integer iInteger; private HashMap<Object, Object> iMap; @Before public void setUp() { iString = "foo"; iInteger = Integer.valueOf(7); iMap = new HashMap<Object, Object>(); iMap.put("FOO", iString); iMap.put("BAR", iInteger); } //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new SerializationUtils()); final Constructor<?>[] cons = SerializationUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(SerializationUtils.class.getModifiers())); assertFalse(Modifier.isFinal(SerializationUtils.class.getModifiers())); } @Test public void testException() { SerializationException serEx; final Exception ex = new Exception(); serEx = new SerializationException(); assertSame(null, serEx.getMessage()); assertSame(null, serEx.getCause()); serEx = new SerializationException("Message"); assertSame("Message", serEx.getMessage()); assertSame(null, serEx.getCause()); serEx = new SerializationException(ex); assertEquals("java.lang.Exception", serEx.getMessage()); assertSame(ex, serEx.getCause()); serEx = new SerializationException("Message", ex); assertSame("Message", serEx.getMessage()); assertSame(ex, serEx.getCause()); } //----------------------------------------------------------------------- @Test public void testSerializeStream() throws Exception { final ByteArrayOutputStream streamTest = new ByteArrayOutputStream(); SerializationUtils.serialize(iMap, streamTest); final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(iMap); oos.flush(); oos.close(); final byte[] testBytes = streamTest.toByteArray(); final byte[] realBytes = streamReal.toByteArray(); assertEquals(testBytes.length, realBytes.length); for (int i = 0; i < realBytes.length; i++) { assertEquals(realBytes[i], testBytes[i]); } } @Test public void testSerializeStreamUnserializable() throws Exception { final ByteArrayOutputStream streamTest = new ByteArrayOutputStream(); try { iMap.put(new Object(), new Object()); SerializationUtils.serialize(iMap, streamTest); } catch (final SerializationException ex) { return; } fail(); } @Test public void testSerializeStreamNullObj() throws Exception { final ByteArrayOutputStream streamTest = new ByteArrayOutputStream(); SerializationUtils.serialize(null, streamTest); final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(null); oos.flush(); oos.close(); final byte[] testBytes = streamTest.toByteArray(); final byte[] realBytes = streamReal.toByteArray(); assertEquals(testBytes.length, realBytes.length); for (int i = 0; i < realBytes.length; i++) { assertEquals(realBytes[i], testBytes[i]); } } @Test public void testSerializeStreamObjNull() throws Exception { try { SerializationUtils.serialize(iMap, null); } catch (final IllegalArgumentException ex) { return; } fail(); } @Test public void testSerializeStreamNullNull() throws Exception { try { SerializationUtils.serialize(null, null); } catch (final IllegalArgumentException ex) { return; } fail(); } @Test public void testSerializeIOException() throws Exception { // forces an IOException when the ObjectOutputStream is created, to test not closing the stream // in the finally block final OutputStream streamTest = new OutputStream() { @Override public void write(final int arg0) throws IOException { throw new IOException(SERIALIZE_IO_EXCEPTION_MESSAGE); } }; try { SerializationUtils.serialize(iMap, streamTest); } catch(final SerializationException e) { assertEquals("java.io.IOException: " + SERIALIZE_IO_EXCEPTION_MESSAGE, e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testDeserializeStream() throws Exception { final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(iMap); oos.flush(); oos.close(); final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray()); final Object test = SerializationUtils.deserialize(inTest); assertNotNull(test); assertTrue(test instanceof HashMap<?, ?>); assertTrue(test != iMap); final HashMap<?, ?> testMap = (HashMap<?, ?>) test; assertEquals(iString, testMap.get("FOO")); assertTrue(iString != testMap.get("FOO")); assertEquals(iInteger, testMap.get("BAR")); assertTrue(iInteger != testMap.get("BAR")); assertEquals(iMap, testMap); } @Test(expected=ClassCastException.class) public void testDeserializeClassCastException() { final String value = "Hello"; final byte[] serialized = SerializationUtils.serialize(value); Assert.assertEquals(value, SerializationUtils.deserialize(serialized)); // Causes ClassCastException in call site, not in SerializationUtils.deserialize @SuppressWarnings("unused") // needed to cause Exception final Integer i = SerializationUtils.deserialize(serialized); } @Test public void testDeserializeStreamOfNull() throws Exception { final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(null); oos.flush(); oos.close(); final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray()); final Object test = SerializationUtils.deserialize(inTest); assertNull(test); } @Test public void testDeserializeStreamNull() throws Exception { try { SerializationUtils.deserialize((InputStream) null); } catch (final IllegalArgumentException ex) { return; } fail(); } @Test public void testDeserializeStreamBadStream() throws Exception { try { SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0])); } catch (final SerializationException ex) { return; } fail(); } @Test public void testDeserializeStreamClassNotFound() throws Exception { final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(new ClassNotFoundSerialization()); oos.flush(); oos.close(); final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray()); try { @SuppressWarnings("unused") final Object test = SerializationUtils.deserialize(inTest); } catch(final SerializationException se) { assertEquals("java.lang.ClassNotFoundException: " + CLASS_NOT_FOUND_MESSAGE, se.getMessage()); } } //----------------------------------------------------------------------- @Test public void testSerializeBytes() throws Exception { final byte[] testBytes = SerializationUtils.serialize(iMap); final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(iMap); oos.flush(); oos.close(); final byte[] realBytes = streamReal.toByteArray(); assertEquals(testBytes.length, realBytes.length); for (int i = 0; i < realBytes.length; i++) { assertEquals(realBytes[i], testBytes[i]); } } @Test public void testSerializeBytesUnserializable() throws Exception { try { iMap.put(new Object(), new Object()); SerializationUtils.serialize(iMap); } catch (final SerializationException ex) { return; } fail(); } @Test public void testSerializeBytesNull() throws Exception { final byte[] testBytes = SerializationUtils.serialize(null); final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(null); oos.flush(); oos.close(); final byte[] realBytes = streamReal.toByteArray(); assertEquals(testBytes.length, realBytes.length); for (int i = 0; i < realBytes.length; i++) { assertEquals(realBytes[i], testBytes[i]); } } //----------------------------------------------------------------------- @Test public void testDeserializeBytes() throws Exception { final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(iMap); oos.flush(); oos.close(); final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); assertNotNull(test); assertTrue(test instanceof HashMap<?, ?>); assertTrue(test != iMap); final HashMap<?, ?> testMap = (HashMap<?, ?>) test; assertEquals(iString, testMap.get("FOO")); assertTrue(iString != testMap.get("FOO")); assertEquals(iInteger, testMap.get("BAR")); assertTrue(iInteger != testMap.get("BAR")); assertEquals(iMap, testMap); } @Test public void testDeserializeBytesOfNull() throws Exception { final ByteArrayOutputStream streamReal = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(streamReal); oos.writeObject(null); oos.flush(); oos.close(); final Object test = SerializationUtils.deserialize(streamReal.toByteArray()); assertNull(test); } @Test public void testDeserializeBytesNull() throws Exception { try { SerializationUtils.deserialize((byte[]) null); } catch (final IllegalArgumentException ex) { return; } fail(); } @Test public void testDeserializeBytesBadStream() throws Exception { try { SerializationUtils.deserialize(new byte[0]); } catch (final SerializationException ex) { return; } fail(); } //----------------------------------------------------------------------- @Test public void testClone() throws Exception { final Object test = SerializationUtils.clone(iMap); assertNotNull(test); assertTrue(test instanceof HashMap<?,?>); assertTrue(test != iMap); final HashMap<?, ?> testMap = (HashMap<?, ?>) test; assertEquals(iString, testMap.get("FOO")); assertTrue(iString != testMap.get("FOO")); assertEquals(iInteger, testMap.get("BAR")); assertTrue(iInteger != testMap.get("BAR")); assertEquals(iMap, testMap); } @Test public void testCloneNull() throws Exception { final Object test = SerializationUtils.clone(null); assertNull(test); } @Test public void testCloneUnserializable() throws Exception { try { iMap.put(new Object(), new Object()); SerializationUtils.clone(iMap); } catch (final SerializationException ex) { return; } fail(); } @Test public void testPrimitiveTypeClassSerialization() { final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class, boolean.class, char.class, void.class }; for (final Class<?> primitiveType : primitiveTypes) { final Class<?> clone = SerializationUtils.clone(primitiveType); assertEquals(primitiveType, clone); } } } @SuppressWarnings("serial") class ClassNotFoundSerialization implements Serializable { private void readObject(final ObjectInputStream in) throws ClassNotFoundException { throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.io.FileInputStream; import java.io.IOException; import java.io.StringWriter; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import org.apache.commons.io.IOUtils; import org.apache.commons.lang3.text.translate.CharSequenceTranslator; import org.apache.commons.lang3.text.translate.NumericEntityEscaper; import org.junit.Test; /** * Unit tests for {@link StringEscapeUtils}. * * @version $Id$ */ public class StringEscapeUtilsTest { private final static String FOO = "foo"; @Test public void testConstructor() { assertNotNull(new StringEscapeUtils()); final Constructor<?>[] cons = StringEscapeUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(StringEscapeUtils.class.getModifiers())); assertFalse(Modifier.isFinal(StringEscapeUtils.class.getModifiers())); } @Test public void testEscapeJava() throws IOException { assertEquals(null, StringEscapeUtils.escapeJava(null)); try { StringEscapeUtils.ESCAPE_JAVA.translate(null, null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } try { StringEscapeUtils.ESCAPE_JAVA.translate("", null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } assertEscapeJava("empty string", "", ""); assertEscapeJava(FOO, FOO); assertEscapeJava("tab", "\\t", "\t"); assertEscapeJava("backslash", "\\\\", "\\"); assertEscapeJava("single quote should not be escaped", "'", "'"); assertEscapeJava("\\\\\\b\\t\\r", "\\\b\t\r"); assertEscapeJava("\\u1234", "\u1234"); assertEscapeJava("\\u0234", "\u0234"); assertEscapeJava("\\u00EF", "\u00ef"); assertEscapeJava("\\u0001", "\u0001"); assertEscapeJava("Should use capitalized Unicode hex", "\\uABCD", "\uabcd"); assertEscapeJava("He didn't say, \\\"stop!\\\"", "He didn't say, \"stop!\""); assertEscapeJava("non-breaking space", "This space is non-breaking:" + "\\u00A0", "This space is non-breaking:\u00a0"); assertEscapeJava("\\uABCD\\u1234\\u012C", "\uABCD\u1234\u012C"); } /** * Tests https://issues.apache.org/jira/browse/LANG-421 */ @Test public void testEscapeJavaWithSlash() { final String input = "String with a slash (/) in it"; final String expected = input; final String actual = StringEscapeUtils.escapeJava(input); /** * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape * in a Java string. */ assertEquals(expected, actual); } private void assertEscapeJava(final String escaped, final String original) throws IOException { assertEscapeJava(null, escaped, original); } private void assertEscapeJava(String message, final String expected, final String original) throws IOException { final String converted = StringEscapeUtils.escapeJava(original); message = "escapeJava(String) failed" + (message == null ? "" : (": " + message)); assertEquals(message, expected, converted); final StringWriter writer = new StringWriter(); StringEscapeUtils.ESCAPE_JAVA.translate(original, writer); assertEquals(expected, writer.toString()); } @Test public void testUnescapeJava() throws IOException { assertEquals(null, StringEscapeUtils.unescapeJava(null)); try { StringEscapeUtils.UNESCAPE_JAVA.translate(null, null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } try { StringEscapeUtils.UNESCAPE_JAVA.translate("", null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } try { StringEscapeUtils.unescapeJava("\\u02-3"); fail(); } catch (final RuntimeException ex) { } assertUnescapeJava("", ""); assertUnescapeJava("test", "test"); assertUnescapeJava("\ntest\b", "\\ntest\\b"); assertUnescapeJava("\u123425foo\ntest\b", "\\u123425foo\\ntest\\b"); assertUnescapeJava("'\foo\teste\r", "\\'\\foo\\teste\\r"); assertUnescapeJava("", "\\"); //foo assertUnescapeJava("lowercase Unicode", "\uABCDx", "\\uabcdx"); assertUnescapeJava("uppercase Unicode", "\uABCDx", "\\uABCDx"); assertUnescapeJava("Unicode as final character", "\uABCD", "\\uabcd"); } private void assertUnescapeJava(final String unescaped, final String original) throws IOException { assertUnescapeJava(null, unescaped, original); } private void assertUnescapeJava(final String message, final String unescaped, final String original) throws IOException { final String expected = unescaped; final String actual = StringEscapeUtils.unescapeJava(original); assertEquals("unescape(String) failed" + (message == null ? "" : (": " + message)) + ": expected '" + StringEscapeUtils.escapeJava(expected) + // we escape this so we can see it in the error message "' actual '" + StringEscapeUtils.escapeJava(actual) + "'", expected, actual); final StringWriter writer = new StringWriter(); StringEscapeUtils.UNESCAPE_JAVA.translate(original, writer); assertEquals(unescaped, writer.toString()); } @Test public void testEscapeEcmaScript() { assertEquals(null, StringEscapeUtils.escapeEcmaScript(null)); try { StringEscapeUtils.ESCAPE_ECMASCRIPT.translate(null, null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } try { StringEscapeUtils.ESCAPE_ECMASCRIPT.translate("", null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } assertEquals("He didn\\'t say, \\\"stop!\\\"", StringEscapeUtils.escapeEcmaScript("He didn't say, \"stop!\"")); assertEquals("document.getElementById(\\\"test\\\").value = \\'<script>alert(\\'aaa\\');<\\/script>\\';", StringEscapeUtils.escapeEcmaScript("document.getElementById(\"test\").value = '<script>alert('aaa');</script>';")); } // HTML and XML //-------------------------------------------------------------- private static final String[][] HTML_ESCAPES = { {"no escaping", "plain text", "plain text"}, {"no escaping", "plain text", "plain text"}, {"empty string", "", ""}, {"null", null, null}, {"ampersand", "bread &amp; butter", "bread & butter"}, {"quotes", "&quot;bread&quot; &amp; butter", "\"bread\" & butter"}, {"final character only", "greater than &gt;", "greater than >"}, {"first character only", "&lt; less than", "< less than"}, {"apostrophe", "Huntington's chorea", "Huntington's chorea"}, {"languages", "English,Fran&ccedil;ais,\u65E5\u672C\u8A9E (nihongo)", "English,Fran\u00E7ais,\u65E5\u672C\u8A9E (nihongo)"}, {"8-bit ascii shouldn't number-escape", "\u0080\u009F", "\u0080\u009F"}, }; @Test public void testEscapeHtml() { for (int i = 0; i < HTML_ESCAPES.length; ++i) { final String message = HTML_ESCAPES[i][0]; final String expected = HTML_ESCAPES[i][1]; final String original = HTML_ESCAPES[i][2]; assertEquals(message, expected, StringEscapeUtils.escapeHtml4(original)); final StringWriter sw = new StringWriter(); try { StringEscapeUtils.ESCAPE_HTML4.translate(original, sw); } catch (final IOException e) { } final String actual = original == null ? null : sw.toString(); assertEquals(message, expected, actual); } } @Test public void testUnescapeHtml4() { for (int i = 0; i < HTML_ESCAPES.length; ++i) { final String message = HTML_ESCAPES[i][0]; final String expected = HTML_ESCAPES[i][2]; final String original = HTML_ESCAPES[i][1]; assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original)); final StringWriter sw = new StringWriter(); try { StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw); } catch (final IOException e) { } final String actual = original == null ? null : sw.toString(); assertEquals(message, expected, actual); } // \u00E7 is a cedilla (c with wiggle under) // note that the test string must be 7-bit-clean (Unicode escaped) or else it will compile incorrectly // on some locales assertEquals("funny chars pass through OK", "Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais")); assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World")); assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World")); assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World")); assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World")); } @Test public void testUnescapeHexCharsHtml() { // Simple easy to grok test assertEquals("hex number unescape", "\u0080\u009F", StringEscapeUtils.unescapeHtml4("&#x80;&#x9F;")); assertEquals("hex number unescape", "\u0080\u009F", StringEscapeUtils.unescapeHtml4("&#X80;&#X9F;")); // Test all Character values: for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) { final Character c1 = new Character(i); final Character c2 = new Character((char)(i+1)); final String expected = c1.toString() + c2.toString(); final String escapedC1 = "&#x" + Integer.toHexString((c1.charValue())) + ";"; final String escapedC2 = "&#x" + Integer.toHexString((c2.charValue())) + ";"; assertEquals("hex number unescape index " + (int)i, expected, StringEscapeUtils.unescapeHtml4(escapedC1 + escapedC2)); } } @Test public void testUnescapeUnknownEntity() throws Exception { assertEquals("&zzzz;", StringEscapeUtils.unescapeHtml4("&zzzz;")); } @Test public void testEscapeHtmlVersions() throws Exception { assertEquals("&Beta;", StringEscapeUtils.escapeHtml4("\u0392")); assertEquals("\u0392", StringEscapeUtils.unescapeHtml4("&Beta;")); // TODO: refine API for escaping/unescaping specific HTML versions } @Test public void testEscapeXml() throws Exception { assertEquals("&lt;abc&gt;", StringEscapeUtils.escapeXml("<abc>")); assertEquals("<abc>", StringEscapeUtils.unescapeXml("&lt;abc&gt;")); assertEquals("XML should not escape >0x7f values", "\u00A1", StringEscapeUtils.escapeXml("\u00A1")); assertEquals("XML should be able to unescape >0x7f values", "\u00A0", StringEscapeUtils.unescapeXml("&#160;")); assertEquals("XML should be able to unescape >0x7f values with one leading 0", "\u00A0", StringEscapeUtils.unescapeXml("&#0160;")); assertEquals("XML should be able to unescape >0x7f values with two leading 0s", "\u00A0", StringEscapeUtils.unescapeXml("&#00160;")); assertEquals("XML should be able to unescape >0x7f values with three leading 0s", "\u00A0", StringEscapeUtils.unescapeXml("&#000160;")); assertEquals("ain't", StringEscapeUtils.unescapeXml("ain&apos;t")); assertEquals("ain&apos;t", StringEscapeUtils.escapeXml("ain't")); assertEquals("", StringEscapeUtils.escapeXml("")); assertEquals(null, StringEscapeUtils.escapeXml(null)); assertEquals(null, StringEscapeUtils.unescapeXml(null)); StringWriter sw = new StringWriter(); try { StringEscapeUtils.ESCAPE_XML.translate("<abc>", sw); } catch (final IOException e) { } assertEquals("XML was escaped incorrectly", "&lt;abc&gt;", sw.toString() ); sw = new StringWriter(); try { StringEscapeUtils.UNESCAPE_XML.translate("&lt;abc&gt;", sw); } catch (final IOException e) { } assertEquals("XML was unescaped incorrectly", "<abc>", sw.toString() ); } /** * Tests Supplementary characters. * <p> * From http://www.w3.org/International/questions/qa-escapes * </p> * <blockquote> * Supplementary characters are those Unicode characters that have code points higher than the characters in * the Basic Multilingual Plane (BMP). In UTF-16 a supplementary character is encoded using two 16-bit surrogate code points from the * BMP. Because of this, some people think that supplementary characters need to be represented using two escapes, but this is incorrect * - you must use the single, code point value for that character. For example, use &#x233B4; rather than &#xD84C;&#xDFB4;. * </blockquote> * @see <a href="http://www.w3.org/International/questions/qa-escapes">Using character escapes in markup and CSS</a> * @see <a href="https://issues.apache.org/jira/browse/LANG-728">LANG-728</a> */ @Test public void testEscapeXmlSupplementaryCharacters() { final CharSequenceTranslator escapeXml = StringEscapeUtils.ESCAPE_XML.with( NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE) ); assertEquals("Supplementary character must be represented using a single escape", "&#144308;", escapeXml.translate("\uD84C\uDFB4")); } @Test public void testEscapeXmlAllCharacters() { // http://www.w3.org/TR/xml/#charsets says: // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character, // excluding the surrogate blocks, FFFE, and FFFF. */ final CharSequenceTranslator escapeXml = StringEscapeUtils.ESCAPE_XML .with(NumericEntityEscaper.below(9), NumericEntityEscaper.between(0xB, 0xC), NumericEntityEscaper.between(0xE, 0x19), NumericEntityEscaper.between(0xD800, 0xDFFF), NumericEntityEscaper.between(0xFFFE, 0xFFFF), NumericEntityEscaper.above(0x110000)); assertEquals("&#0;&#1;&#2;&#3;&#4;&#5;&#6;&#7;&#8;", escapeXml.translate("\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\u0008")); assertEquals("\t", escapeXml.translate("\t")); // 0x9 assertEquals("\n", escapeXml.translate("\n")); // 0xA assertEquals("&#11;&#12;", escapeXml.translate("\u000B\u000C")); assertEquals("\r", escapeXml.translate("\r")); // 0xD assertEquals("Hello World! Ain&apos;t this great?", escapeXml.translate("Hello World! Ain't this great?")); assertEquals("&#14;&#15;&#24;&#25;", escapeXml.translate("\u000E\u000F\u0018\u0019")); } /** * Reverse of the above. * * @see <a href="https://issues.apache.org/jira/browse/LANG-729">LANG-729</a> */ @Test public void testUnescapeXmlSupplementaryCharacters() { assertEquals("Supplementary character must be represented using a single escape", "\uD84C\uDFB4", StringEscapeUtils.unescapeXml("&#144308;") ); } // Tests issue #38569 // http://issues.apache.org/bugzilla/show_bug.cgi?id=38569 @Test public void testStandaloneAmphersand() { assertEquals("<P&O>", StringEscapeUtils.unescapeHtml4("&lt;P&O&gt;")); assertEquals("test & <", StringEscapeUtils.unescapeHtml4("test & &lt;")); assertEquals("<P&O>", StringEscapeUtils.unescapeXml("&lt;P&O&gt;")); assertEquals("test & <", StringEscapeUtils.unescapeXml("test & &lt;")); } @Test public void testLang313() { assertEquals("& &", StringEscapeUtils.unescapeHtml4("& &amp;")); } @Test public void testEscapeCsvString() throws Exception { assertEquals("foo.bar", StringEscapeUtils.escapeCsv("foo.bar")); assertEquals("\"foo,bar\"", StringEscapeUtils.escapeCsv("foo,bar")); assertEquals("\"foo\nbar\"", StringEscapeUtils.escapeCsv("foo\nbar")); assertEquals("\"foo\rbar\"", StringEscapeUtils.escapeCsv("foo\rbar")); assertEquals("\"foo\"\"bar\"", StringEscapeUtils.escapeCsv("foo\"bar")); assertEquals("", StringEscapeUtils.escapeCsv("")); assertEquals(null, StringEscapeUtils.escapeCsv(null)); } @Test public void testEscapeCsvWriter() throws Exception { checkCsvEscapeWriter("foo.bar", "foo.bar"); checkCsvEscapeWriter("\"foo,bar\"", "foo,bar"); checkCsvEscapeWriter("\"foo\nbar\"", "foo\nbar"); checkCsvEscapeWriter("\"foo\rbar\"", "foo\rbar"); checkCsvEscapeWriter("\"foo\"\"bar\"", "foo\"bar"); checkCsvEscapeWriter("", null); checkCsvEscapeWriter("", ""); } private void checkCsvEscapeWriter(final String expected, final String value) { try { final StringWriter writer = new StringWriter(); StringEscapeUtils.ESCAPE_CSV.translate(value, writer); assertEquals(expected, writer.toString()); } catch (final IOException e) { fail("Threw: " + e); } } @Test public void testUnescapeCsvString() throws Exception { assertEquals("foo.bar", StringEscapeUtils.unescapeCsv("foo.bar")); assertEquals("foo,bar", StringEscapeUtils.unescapeCsv("\"foo,bar\"")); assertEquals("foo\nbar", StringEscapeUtils.unescapeCsv("\"foo\nbar\"")); assertEquals("foo\rbar", StringEscapeUtils.unescapeCsv("\"foo\rbar\"")); assertEquals("foo\"bar", StringEscapeUtils.unescapeCsv("\"foo\"\"bar\"")); assertEquals("", StringEscapeUtils.unescapeCsv("")); assertEquals(null, StringEscapeUtils.unescapeCsv(null)); assertEquals("\"foo.bar\"", StringEscapeUtils.unescapeCsv("\"foo.bar\"")); } @Test public void testUnescapeCsvWriter() throws Exception { checkCsvUnescapeWriter("foo.bar", "foo.bar"); checkCsvUnescapeWriter("foo,bar", "\"foo,bar\""); checkCsvUnescapeWriter("foo\nbar", "\"foo\nbar\""); checkCsvUnescapeWriter("foo\rbar", "\"foo\rbar\""); checkCsvUnescapeWriter("foo\"bar", "\"foo\"\"bar\""); checkCsvUnescapeWriter("", null); checkCsvUnescapeWriter("", ""); checkCsvUnescapeWriter("\"foo.bar\"", "\"foo.bar\""); } private void checkCsvUnescapeWriter(final String expected, final String value) { try { final StringWriter writer = new StringWriter(); StringEscapeUtils.UNESCAPE_CSV.translate(value, writer); assertEquals(expected, writer.toString()); } catch (final IOException e) { fail("Threw: " + e); } } /** * Tests // https://issues.apache.org/jira/browse/LANG-480 * * @throws java.io.UnsupportedEncodingException */ @Test public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException { // this is the utf8 representation of the character: // COUNTING ROD UNIT DIGIT THREE // in Unicode // codepoint: U+1D362 final byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 }; final String original = new String(data, "UTF8"); final String escaped = StringEscapeUtils.escapeHtml4( original ); assertEquals( "High Unicode should not have been escaped", original, escaped); final String unescaped = StringEscapeUtils.unescapeHtml4( escaped ); assertEquals( "High Unicode should have been unchanged", original, unescaped); // TODO: I think this should hold, needs further investigation // String unescapedFromEntity = StringEscapeUtils.unescapeHtml4( "&#119650;" ); // assertEquals( "High Unicode should have been unescaped", original, unescapedFromEntity); } /** * Tests https://issues.apache.org/jira/browse/LANG-339 */ @Test public void testEscapeHiragana() { // Some random Japanese Unicode characters final String original = "\u304B\u304C\u3068"; final String escaped = StringEscapeUtils.escapeHtml4(original); assertEquals( "Hiragana character Unicode behaviour should not be being escaped by escapeHtml4", original, escaped); final String unescaped = StringEscapeUtils.unescapeHtml4( escaped ); assertEquals( "Hiragana character Unicode behaviour has changed - expected no unescaping", escaped, unescaped); } /** * Tests https://issues.apache.org/jira/browse/LANG-708 * * @throws IOException * if an I/O error occurs */ @Test public void testLang708() throws IOException { final String input = IOUtils.toString(new FileInputStream("src/test/resources/lang-708-input.txt"), "UTF-8"); final String escaped = StringEscapeUtils.escapeEcmaScript(input); // just the end: assertTrue(escaped, escaped.endsWith("}]")); // a little more: assertTrue(escaped, escaped.endsWith("\"valueCode\\\":\\\"\\\"}]")); } /** * Tests https://issues.apache.org/jira/browse/LANG-720 */ @Test public void testLang720() { final String input = new StringBuilder("\ud842\udfb7").append("A").toString(); final String escaped = StringEscapeUtils.escapeXml(input); assertEquals(input, escaped); } @Test public void testEscapeJson() { assertEquals(null, StringEscapeUtils.escapeJson(null)); try { StringEscapeUtils.ESCAPE_JSON.translate(null, null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } try { StringEscapeUtils.ESCAPE_JSON.translate("", null); fail(); } catch (final IOException ex) { fail(); } catch (final IllegalArgumentException ex) { } assertEquals("He didn't say, \\\"stop!\\\"", StringEscapeUtils.escapeJson("He didn't say, \"stop!\"")); String expected = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/"; String input ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/"; assertEquals(expected, StringEscapeUtils.escapeJson(input)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertThat; import static org.junit.Assert.assertTrue; import java.util.Locale; import org.hamcrest.core.IsNot; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.StringUtils} - Substring methods * * @version $Id$ */ public class StringUtilsEqualsIndexOfTest { private static final String BAR = "bar"; /** * Supplementary character U+20000 * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ private static final String CharU20000 = "\uD840\uDC00"; /** * Supplementary character U+20001 * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ private static final String CharU20001 = "\uD840\uDC01"; /** * Incomplete supplementary character U+20000, high surrogate only. * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ private static final String CharUSuppCharHigh = "\uDC00"; /** * Incomplete supplementary character U+20000, low surrogate only. * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ private static final String CharUSuppCharLow = "\uD840"; private static final String FOO = "foo"; private static final String FOOBAR = "foobar"; private static final String[] FOOBAR_SUB_ARRAY = new String[] {"ob", "ba"}; @Test public void testContains_Char() { assertFalse(StringUtils.contains(null, ' ')); assertFalse(StringUtils.contains("", ' ')); assertFalse(StringUtils.contains("", null)); assertFalse(StringUtils.contains(null, null)); assertTrue(StringUtils.contains("abc", 'a')); assertTrue(StringUtils.contains("abc", 'b')); assertTrue(StringUtils.contains("abc", 'c')); assertFalse(StringUtils.contains("abc", 'z')); } @Test public void testContains_String() { assertFalse(StringUtils.contains(null, null)); assertFalse(StringUtils.contains(null, "")); assertFalse(StringUtils.contains(null, "a")); assertFalse(StringUtils.contains("", null)); assertTrue(StringUtils.contains("", "")); assertFalse(StringUtils.contains("", "a")); assertTrue(StringUtils.contains("abc", "a")); assertTrue(StringUtils.contains("abc", "b")); assertTrue(StringUtils.contains("abc", "c")); assertTrue(StringUtils.contains("abc", "abc")); assertFalse(StringUtils.contains("abc", "z")); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContains_StringWithBadSupplementaryChars() { // Test edge case: 1/2 of a (broken) supplementary char assertFalse(StringUtils.contains(CharUSuppCharHigh, CharU20001)); assertFalse(StringUtils.contains(CharUSuppCharLow, CharU20001)); assertFalse(StringUtils.contains(CharU20001, CharUSuppCharHigh)); assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); assertTrue(StringUtils.contains(CharU20001, CharUSuppCharLow)); assertTrue(StringUtils.contains(CharU20001 + CharUSuppCharLow + "a", "a")); assertTrue(StringUtils.contains(CharU20001 + CharUSuppCharHigh + "a", "a")); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContains_StringWithSupplementaryChars() { assertTrue(StringUtils.contains(CharU20000 + CharU20001, CharU20000)); assertTrue(StringUtils.contains(CharU20000 + CharU20001, CharU20001)); assertTrue(StringUtils.contains(CharU20000, CharU20000)); assertFalse(StringUtils.contains(CharU20000, CharU20001)); } @Test public void testContainsAny_StringCharArray() { assertFalse(StringUtils.containsAny(null, (char[]) null)); assertFalse(StringUtils.containsAny(null, new char[0])); assertFalse(StringUtils.containsAny(null, new char[] { 'a', 'b' })); assertFalse(StringUtils.containsAny("", (char[]) null)); assertFalse(StringUtils.containsAny("", new char[0])); assertFalse(StringUtils.containsAny("", new char[] { 'a', 'b' })); assertFalse(StringUtils.containsAny("zzabyycdxx", (char[]) null)); assertFalse(StringUtils.containsAny("zzabyycdxx", new char[0])); assertTrue(StringUtils.containsAny("zzabyycdxx", new char[] { 'z', 'a' })); assertTrue(StringUtils.containsAny("zzabyycdxx", new char[] { 'b', 'y' })); assertFalse(StringUtils.containsAny("ab", new char[] { 'z' })); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsAny_StringCharArrayWithBadSupplementaryChars() { // Test edge case: 1/2 of a (broken) supplementary char assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray())); assertFalse(StringUtils.containsAny("abc" + CharUSuppCharHigh + "xyz", CharU20001.toCharArray())); assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray())); assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray())); assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray())); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsAny_StringCharArrayWithSupplementaryChars() { assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray())); assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray())); assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray())); assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray())); assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray())); assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray())); // Sanity check: assertEquals(-1, CharU20000.indexOf(CharU20001)); assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); // Test: assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray())); } @Test public void testContainsAny_StringString() { assertFalse(StringUtils.containsAny(null, (String) null)); assertFalse(StringUtils.containsAny(null, "")); assertFalse(StringUtils.containsAny(null, "ab")); assertFalse(StringUtils.containsAny("", (String) null)); assertFalse(StringUtils.containsAny("", "")); assertFalse(StringUtils.containsAny("", "ab")); assertFalse(StringUtils.containsAny("zzabyycdxx", (String) null)); assertFalse(StringUtils.containsAny("zzabyycdxx", "")); assertTrue(StringUtils.containsAny("zzabyycdxx", "za")); assertTrue(StringUtils.containsAny("zzabyycdxx", "by")); assertFalse(StringUtils.containsAny("ab", "z")); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsAny_StringWithBadSupplementaryChars() { // Test edge case: 1/2 of a (broken) supplementary char assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001)); assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001)); assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh)); assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow)); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsAny_StringWithSupplementaryChars() { assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000)); assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001)); assertTrue(StringUtils.containsAny(CharU20000, CharU20000)); // Sanity check: assertEquals(-1, CharU20000.indexOf(CharU20001)); assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); // Test: assertFalse(StringUtils.containsAny(CharU20000, CharU20001)); assertFalse(StringUtils.containsAny(CharU20001, CharU20000)); } @Test public void testContainsIgnoreCase_LocaleIndependence() { final Locale orig = Locale.getDefault(); final Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() }; final String[][] tdata = { { "i", "I" }, { "I", "i" }, { "\u03C2", "\u03C3" }, { "\u03A3", "\u03C2" }, { "\u03A3", "\u03C3" }, }; final String[][] fdata = { { "\u00DF", "SS" }, }; try { for (final Locale locale : locales) { Locale.setDefault(locale); for (int j = 0; j < tdata.length; j++) { assertTrue(Locale.getDefault() + ": " + j + " " + tdata[j][0] + " " + tdata[j][1], StringUtils .containsIgnoreCase(tdata[j][0], tdata[j][1])); } for (int j = 0; j < fdata.length; j++) { assertFalse(Locale.getDefault() + ": " + j + " " + fdata[j][0] + " " + fdata[j][1], StringUtils .containsIgnoreCase(fdata[j][0], fdata[j][1])); } } } finally { Locale.setDefault(orig); } } @Test public void testContainsIgnoreCase_StringString() { assertFalse(StringUtils.containsIgnoreCase(null, null)); // Null tests assertFalse(StringUtils.containsIgnoreCase(null, "")); assertFalse(StringUtils.containsIgnoreCase(null, "a")); assertFalse(StringUtils.containsIgnoreCase(null, "abc")); assertFalse(StringUtils.containsIgnoreCase("", null)); assertFalse(StringUtils.containsIgnoreCase("a", null)); assertFalse(StringUtils.containsIgnoreCase("abc", null)); // Match len = 0 assertTrue(StringUtils.containsIgnoreCase("", "")); assertTrue(StringUtils.containsIgnoreCase("a", "")); assertTrue(StringUtils.containsIgnoreCase("abc", "")); // Match len = 1 assertFalse(StringUtils.containsIgnoreCase("", "a")); assertTrue(StringUtils.containsIgnoreCase("a", "a")); assertTrue(StringUtils.containsIgnoreCase("abc", "a")); assertFalse(StringUtils.containsIgnoreCase("", "A")); assertTrue(StringUtils.containsIgnoreCase("a", "A")); assertTrue(StringUtils.containsIgnoreCase("abc", "A")); // Match len > 1 assertFalse(StringUtils.containsIgnoreCase("", "abc")); assertFalse(StringUtils.containsIgnoreCase("a", "abc")); assertTrue(StringUtils.containsIgnoreCase("xabcz", "abc")); assertFalse(StringUtils.containsIgnoreCase("", "ABC")); assertFalse(StringUtils.containsIgnoreCase("a", "ABC")); assertTrue(StringUtils.containsIgnoreCase("xabcz", "ABC")); } @Test public void testContainsNone_CharArray() { final String str1 = "a"; final String str2 = "b"; final String str3 = "ab."; final char[] chars1= {'b'}; final char[] chars2= {'.'}; final char[] chars3= {'c', 'd'}; final char[] emptyChars = new char[0]; assertTrue(StringUtils.containsNone(null, (char[]) null)); assertTrue(StringUtils.containsNone("", (char[]) null)); assertTrue(StringUtils.containsNone(null, emptyChars)); assertTrue(StringUtils.containsNone(str1, emptyChars)); assertTrue(StringUtils.containsNone("", emptyChars)); assertTrue(StringUtils.containsNone("", chars1)); assertTrue(StringUtils.containsNone(str1, chars1)); assertTrue(StringUtils.containsNone(str1, chars2)); assertTrue(StringUtils.containsNone(str1, chars3)); assertFalse(StringUtils.containsNone(str2, chars1)); assertTrue(StringUtils.containsNone(str2, chars2)); assertTrue(StringUtils.containsNone(str2, chars3)); assertFalse(StringUtils.containsNone(str3, chars1)); assertFalse(StringUtils.containsNone(str3, chars2)); assertTrue(StringUtils.containsNone(str3, chars3)); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsNone_CharArrayWithBadSupplementaryChars() { // Test edge case: 1/2 of a (broken) supplementary char assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray())); assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray())); assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray())); assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray())); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsNone_CharArrayWithSupplementaryChars() { assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000.toCharArray())); assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001.toCharArray())); assertFalse(StringUtils.containsNone(CharU20000, CharU20000.toCharArray())); // Sanity check: assertEquals(-1, CharU20000.indexOf(CharU20001)); assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); // Test: assertTrue(StringUtils.containsNone(CharU20000, CharU20001.toCharArray())); assertTrue(StringUtils.containsNone(CharU20001, CharU20000.toCharArray())); } @Test public void testContainsNone_String() { final String str1 = "a"; final String str2 = "b"; final String str3 = "ab."; final String chars1= "b"; final String chars2= "."; final String chars3= "cd"; assertTrue(StringUtils.containsNone(null, (String) null)); assertTrue(StringUtils.containsNone("", (String) null)); assertTrue(StringUtils.containsNone(null, "")); assertTrue(StringUtils.containsNone(str1, "")); assertTrue(StringUtils.containsNone("", "")); assertTrue(StringUtils.containsNone("", chars1)); assertTrue(StringUtils.containsNone(str1, chars1)); assertTrue(StringUtils.containsNone(str1, chars2)); assertTrue(StringUtils.containsNone(str1, chars3)); assertFalse(StringUtils.containsNone(str2, chars1)); assertTrue(StringUtils.containsNone(str2, chars2)); assertTrue(StringUtils.containsNone(str2, chars3)); assertFalse(StringUtils.containsNone(str3, chars1)); assertFalse(StringUtils.containsNone(str3, chars2)); assertTrue(StringUtils.containsNone(str3, chars3)); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsNone_StringWithBadSupplementaryChars() { // Test edge case: 1/2 of a (broken) supplementary char assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001)); assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001)); assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001)); assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh)); assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh)); assertEquals(0, CharU20001.indexOf(CharUSuppCharLow)); assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow)); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testContainsNone_StringWithSupplementaryChars() { assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000)); assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001)); assertFalse(StringUtils.containsNone(CharU20000, CharU20000)); // Sanity check: assertEquals(-1, CharU20000.indexOf(CharU20001)); assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0))); assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1))); // Test: assertTrue(StringUtils.containsNone(CharU20000, CharU20001)); assertTrue(StringUtils.containsNone(CharU20001, CharU20000)); } @Test public void testContainsOnly_CharArray() { final String str1 = "a"; final String str2 = "b"; final String str3 = "ab"; final char[] chars1= {'b'}; final char[] chars2= {'a'}; final char[] chars3= {'a', 'b'}; final char[] emptyChars = new char[0]; assertFalse(StringUtils.containsOnly(null, (char[]) null)); assertFalse(StringUtils.containsOnly("", (char[]) null)); assertFalse(StringUtils.containsOnly(null, emptyChars)); assertFalse(StringUtils.containsOnly(str1, emptyChars)); assertTrue(StringUtils.containsOnly("", emptyChars)); assertTrue(StringUtils.containsOnly("", chars1)); assertFalse(StringUtils.containsOnly(str1, chars1)); assertTrue(StringUtils.containsOnly(str1, chars2)); assertTrue(StringUtils.containsOnly(str1, chars3)); assertTrue(StringUtils.containsOnly(str2, chars1)); assertFalse(StringUtils.containsOnly(str2, chars2)); assertTrue(StringUtils.containsOnly(str2, chars3)); assertFalse(StringUtils.containsOnly(str3, chars1)); assertFalse(StringUtils.containsOnly(str3, chars2)); assertTrue(StringUtils.containsOnly(str3, chars3)); } @Test public void testContainsOnly_String() { final String str1 = "a"; final String str2 = "b"; final String str3 = "ab"; final String chars1= "b"; final String chars2= "a"; final String chars3= "ab"; assertFalse(StringUtils.containsOnly(null, (String) null)); assertFalse(StringUtils.containsOnly("", (String) null)); assertFalse(StringUtils.containsOnly(null, "")); assertFalse(StringUtils.containsOnly(str1, "")); assertTrue(StringUtils.containsOnly("", "")); assertTrue(StringUtils.containsOnly("", chars1)); assertFalse(StringUtils.containsOnly(str1, chars1)); assertTrue(StringUtils.containsOnly(str1, chars2)); assertTrue(StringUtils.containsOnly(str1, chars3)); assertTrue(StringUtils.containsOnly(str2, chars1)); assertFalse(StringUtils.containsOnly(str2, chars2)); assertTrue(StringUtils.containsOnly(str2, chars3)); assertFalse(StringUtils.containsOnly(str3, chars1)); assertFalse(StringUtils.containsOnly(str3, chars2)); assertTrue(StringUtils.containsOnly(str3, chars3)); } @Test public void testContainsWhitespace() { assertFalse( StringUtils.containsWhitespace("") ); assertTrue( StringUtils.containsWhitespace(" ") ); assertFalse( StringUtils.containsWhitespace("a") ); assertTrue( StringUtils.containsWhitespace("a ") ); assertTrue( StringUtils.containsWhitespace(" a") ); assertTrue( StringUtils.containsWhitespace("a\t") ); assertTrue( StringUtils.containsWhitespace("\n") ); } // The purpose of this class is to test StringUtils#equals(CharSequence, CharSequence) // with a CharSequence implementation whose equals(Object) override requires that the // other object be an instance of CustomCharSequence, even though, as char sequences, // `seq` may equal the other object. private static class CustomCharSequence implements CharSequence { private final CharSequence seq; public CustomCharSequence(final CharSequence seq) { this.seq = seq; } @Override public char charAt(final int index) { return seq.charAt(index); } @Override public int length() { return seq.length(); } @Override public CharSequence subSequence(final int start, final int end) { return new CustomCharSequence(seq.subSequence(start, end)); } @Override public boolean equals(final Object obj) { if (obj == null || !(obj instanceof CustomCharSequence)) { return false; } final CustomCharSequence other = (CustomCharSequence) obj; return seq.equals(other.seq); } @Override public int hashCode() { return seq.hashCode(); } @Override public String toString() { return seq.toString(); } } @Test public void testCustomCharSequence() { assertThat(new CustomCharSequence(FOO), IsNot.<CharSequence>not(FOO)); assertThat(FOO, IsNot.<CharSequence>not(new CustomCharSequence(FOO))); assertEquals(new CustomCharSequence(FOO), new CustomCharSequence(FOO)); } @Test public void testEquals() { final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR; assertTrue(StringUtils.equals(null, null)); assertTrue(StringUtils.equals(fooCs, fooCs)); assertTrue(StringUtils.equals(fooCs, new StringBuilder(FOO))); assertTrue(StringUtils.equals(fooCs, new String(new char[] { 'f', 'o', 'o' }))); assertTrue(StringUtils.equals(fooCs, new CustomCharSequence(FOO))); assertTrue(StringUtils.equals(new CustomCharSequence(FOO), fooCs)); assertFalse(StringUtils.equals(fooCs, new String(new char[] { 'f', 'O', 'O' }))); assertFalse(StringUtils.equals(fooCs, barCs)); assertFalse(StringUtils.equals(fooCs, null)); assertFalse(StringUtils.equals(null, fooCs)); assertFalse(StringUtils.equals(fooCs, foobarCs)); assertFalse(StringUtils.equals(foobarCs, fooCs)); } @Test public void testEqualsOnStrings() { assertTrue(StringUtils.equals(null, null)); assertTrue(StringUtils.equals(FOO, FOO)); assertTrue(StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' }))); assertFalse(StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' }))); assertFalse(StringUtils.equals(FOO, BAR)); assertFalse(StringUtils.equals(FOO, null)); assertFalse(StringUtils.equals(null, FOO)); assertFalse(StringUtils.equals(FOO, FOOBAR)); assertFalse(StringUtils.equals(FOOBAR, FOO)); } @Test public void testEqualsIgnoreCase() { assertTrue(StringUtils.equalsIgnoreCase(null, null)); assertTrue(StringUtils.equalsIgnoreCase(FOO, FOO)); assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' }))); assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' }))); assertFalse(StringUtils.equalsIgnoreCase(FOO, BAR)); assertFalse(StringUtils.equalsIgnoreCase(FOO, null)); assertFalse(StringUtils.equalsIgnoreCase(null, FOO)); assertTrue(StringUtils.equalsIgnoreCase("","")); assertFalse(StringUtils.equalsIgnoreCase("abcd","abcd ")); } //----------------------------------------------------------------------- @Test public void testIndexOf_char() { assertEquals(-1, StringUtils.indexOf(null, ' ')); assertEquals(-1, StringUtils.indexOf("", ' ')); assertEquals(0, StringUtils.indexOf("aabaabaa", 'a')); assertEquals(2, StringUtils.indexOf("aabaabaa", 'b')); assertEquals(2, StringUtils.indexOf(new StringBuilder("aabaabaa"), 'b')); } @Test public void testIndexOf_charInt() { assertEquals(-1, StringUtils.indexOf(null, ' ', 0)); assertEquals(-1, StringUtils.indexOf(null, ' ', -1)); assertEquals(-1, StringUtils.indexOf("", ' ', 0)); assertEquals(-1, StringUtils.indexOf("", ' ', -1)); assertEquals(0, StringUtils.indexOf("aabaabaa", 'a', 0)); assertEquals(2, StringUtils.indexOf("aabaabaa", 'b', 0)); assertEquals(5, StringUtils.indexOf("aabaabaa", 'b', 3)); assertEquals(-1, StringUtils.indexOf("aabaabaa", 'b', 9)); assertEquals(2, StringUtils.indexOf("aabaabaa", 'b', -1)); assertEquals(5, StringUtils.indexOf(new StringBuilder("aabaabaa"), 'b', 3)); } @Test public void testIndexOf_String() { assertEquals(-1, StringUtils.indexOf(null, null)); assertEquals(-1, StringUtils.indexOf("", null)); assertEquals(0, StringUtils.indexOf("", "")); assertEquals(0, StringUtils.indexOf("aabaabaa", "a")); assertEquals(2, StringUtils.indexOf("aabaabaa", "b")); assertEquals(1, StringUtils.indexOf("aabaabaa", "ab")); assertEquals(0, StringUtils.indexOf("aabaabaa", "")); assertEquals(2, StringUtils.indexOf(new StringBuilder("aabaabaa"), "b")); } @Test public void testIndexOf_StringInt() { assertEquals(-1, StringUtils.indexOf(null, null, 0)); assertEquals(-1, StringUtils.indexOf(null, null, -1)); assertEquals(-1, StringUtils.indexOf(null, "", 0)); assertEquals(-1, StringUtils.indexOf(null, "", -1)); assertEquals(-1, StringUtils.indexOf("", null, 0)); assertEquals(-1, StringUtils.indexOf("", null, -1)); assertEquals(0, StringUtils.indexOf("", "", 0)); assertEquals(0, StringUtils.indexOf("", "", -1)); assertEquals(0, StringUtils.indexOf("", "", 9)); assertEquals(0, StringUtils.indexOf("abc", "", 0)); assertEquals(0, StringUtils.indexOf("abc", "", -1)); assertEquals(3, StringUtils.indexOf("abc", "", 9)); assertEquals(3, StringUtils.indexOf("abc", "", 3)); assertEquals(0, StringUtils.indexOf("aabaabaa", "a", 0)); assertEquals(2, StringUtils.indexOf("aabaabaa", "b", 0)); assertEquals(1, StringUtils.indexOf("aabaabaa", "ab", 0)); assertEquals(5, StringUtils.indexOf("aabaabaa", "b", 3)); assertEquals(-1, StringUtils.indexOf("aabaabaa", "b", 9)); assertEquals(2, StringUtils.indexOf("aabaabaa", "b", -1)); assertEquals(2,StringUtils.indexOf("aabaabaa", "", 2)); // Test that startIndex works correctly, i.e. cannot match before startIndex assertEquals(7, StringUtils.indexOf("12345678", "8", 5)); assertEquals(7, StringUtils.indexOf("12345678", "8", 6)); assertEquals(7, StringUtils.indexOf("12345678", "8", 7)); // 7 is last index assertEquals(-1, StringUtils.indexOf("12345678", "8", 8)); assertEquals(5, StringUtils.indexOf(new StringBuilder("aabaabaa"), "b", 3)); } @Test public void testIndexOfAny_StringCharArray() { assertEquals(-1, StringUtils.indexOfAny(null, (char[]) null)); assertEquals(-1, StringUtils.indexOfAny(null, new char[0])); assertEquals(-1, StringUtils.indexOfAny(null, new char[] {'a','b'})); assertEquals(-1, StringUtils.indexOfAny("", (char[]) null)); assertEquals(-1, StringUtils.indexOfAny("", new char[0])); assertEquals(-1, StringUtils.indexOfAny("", new char[] {'a','b'})); assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", (char[]) null)); assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", new char[0])); assertEquals(0, StringUtils.indexOfAny("zzabyycdxx", new char[] {'z','a'})); assertEquals(3, StringUtils.indexOfAny("zzabyycdxx", new char[] {'b','y'})); assertEquals(-1, StringUtils.indexOfAny("ab", new char[] {'z'})); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testIndexOfAny_StringCharArrayWithSupplementaryChars() { assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray())); assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray())); assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray())); assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray())); } @Test public void testIndexOfAny_StringString() { assertEquals(-1, StringUtils.indexOfAny(null, (String) null)); assertEquals(-1, StringUtils.indexOfAny(null, "")); assertEquals(-1, StringUtils.indexOfAny(null, "ab")); assertEquals(-1, StringUtils.indexOfAny("", (String) null)); assertEquals(-1, StringUtils.indexOfAny("", "")); assertEquals(-1, StringUtils.indexOfAny("", "ab")); assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", (String) null)); assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", "")); assertEquals(0, StringUtils.indexOfAny("zzabyycdxx", "za")); assertEquals(3, StringUtils.indexOfAny("zzabyycdxx", "by")); assertEquals(-1, StringUtils.indexOfAny("ab", "z")); } @Test public void testIndexOfAny_StringStringArray() { assertEquals(-1, StringUtils.indexOfAny(null, (String[]) null)); assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY)); assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (String[]) null)); assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0])); assertEquals(-1, StringUtils.indexOfAny(null, new String[0])); assertEquals(-1, StringUtils.indexOfAny("", new String[0])); assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {"llll"})); assertEquals(0, StringUtils.indexOfAny(FOOBAR, new String[] {""})); assertEquals(0, StringUtils.indexOfAny("", new String[] {""})); assertEquals(-1, StringUtils.indexOfAny("", new String[] {"a"})); assertEquals(-1, StringUtils.indexOfAny("", new String[] {null})); assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {null})); assertEquals(-1, StringUtils.indexOfAny(null, new String[] {null})); } /** * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html */ @Test public void testIndexOfAny_StringStringWithSupplementaryChars() { assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000)); assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001)); assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000)); assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001)); } @Test public void testIndexOfAnyBut_StringCharArray() { assertEquals(-1, StringUtils.indexOfAnyBut(null, (char[]) null)); assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[0])); assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[] {'a','b'})); assertEquals(-1, StringUtils.indexOfAnyBut("", (char[]) null)); assertEquals(-1, StringUtils.indexOfAnyBut("", new char[0])); assertEquals(-1, StringUtils.indexOfAnyBut("", new char[] {'a','b'})); assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", (char[]) null)); assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", new char[0])); assertEquals(3, StringUtils.indexOfAnyBut("zzabyycdxx", new char[] {'z','a'})); assertEquals(0, StringUtils.indexOfAnyBut("zzabyycdxx", new char[] {'b','y'})); assertEquals(-1, StringUtils.indexOfAnyBut("aba", new char[] {'a', 'b'})); assertEquals(0, StringUtils.indexOfAnyBut("aba", new char[] {'z'})); } @Test public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() { assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray())); assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray())); assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray())); assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray())); } @Test public void testIndexOfAnyBut_StringString() { assertEquals(-1, StringUtils.indexOfAnyBut(null, (String) null)); assertEquals(-1, StringUtils.indexOfAnyBut(null, "")); assertEquals(-1, StringUtils.indexOfAnyBut(null, "ab")); assertEquals(-1, StringUtils.indexOfAnyBut("", (String) null)); assertEquals(-1, StringUtils.indexOfAnyBut("", "")); assertEquals(-1, StringUtils.indexOfAnyBut("", "ab")); assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", (String) null)); assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", "")); assertEquals(3, StringUtils.indexOfAnyBut("zzabyycdxx", "za")); assertEquals(0, StringUtils.indexOfAnyBut("zzabyycdxx", "by")); assertEquals(0, StringUtils.indexOfAnyBut("ab", "z")); } @Test public void testIndexOfAnyBut_StringStringWithSupplementaryChars() { assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000)); assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001)); assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000)); assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001)); } @Test public void testIndexOfIgnoreCase_String() { assertEquals(-1, StringUtils.indexOfIgnoreCase(null, null)); assertEquals(-1, StringUtils.indexOfIgnoreCase(null, "")); assertEquals(-1, StringUtils.indexOfIgnoreCase("", null)); assertEquals(0, StringUtils.indexOfIgnoreCase("", "")); assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "a")); assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "A")); assertEquals(2, StringUtils.indexOfIgnoreCase("aabaabaa", "b")); assertEquals(2, StringUtils.indexOfIgnoreCase("aabaabaa", "B")); assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "ab")); assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB")); assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "")); } @Test public void testIndexOfIgnoreCase_StringInt() { assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1)); assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0)); assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1)); assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2)); assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3)); assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4)); assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5)); assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6)); assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7)); assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8)); assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1)); assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5)); assertEquals(-1, StringUtils.indexOfIgnoreCase("ab", "AAB", 0)); assertEquals(-1, StringUtils.indexOfIgnoreCase("aab", "AAB", 1)); } @Test public void testLastIndexOf_char() { assertEquals(-1, StringUtils.lastIndexOf(null, ' ')); assertEquals(-1, StringUtils.lastIndexOf("", ' ')); assertEquals(7, StringUtils.lastIndexOf("aabaabaa", 'a')); assertEquals(5, StringUtils.lastIndexOf("aabaabaa", 'b')); assertEquals(5, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), 'b')); } @Test public void testLastIndexOf_charInt() { assertEquals(-1, StringUtils.lastIndexOf(null, ' ', 0)); assertEquals(-1, StringUtils.lastIndexOf(null, ' ', -1)); assertEquals(-1, StringUtils.lastIndexOf("", ' ', 0)); assertEquals(-1, StringUtils.lastIndexOf("", ' ', -1)); assertEquals(7, StringUtils.lastIndexOf("aabaabaa", 'a', 8)); assertEquals(5, StringUtils.lastIndexOf("aabaabaa", 'b', 8)); assertEquals(2, StringUtils.lastIndexOf("aabaabaa", 'b', 3)); assertEquals(5, StringUtils.lastIndexOf("aabaabaa", 'b', 9)); assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", 'b', -1)); assertEquals(0, StringUtils.lastIndexOf("aabaabaa", 'a', 0)); assertEquals(2, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), 'b', 2)); } @Test public void testLastIndexOf_String() { assertEquals(-1, StringUtils.lastIndexOf(null, null)); assertEquals(-1, StringUtils.lastIndexOf("", null)); assertEquals(-1, StringUtils.lastIndexOf("", "a")); assertEquals(0, StringUtils.lastIndexOf("", "")); assertEquals(8, StringUtils.lastIndexOf("aabaabaa", "")); assertEquals(7, StringUtils.lastIndexOf("aabaabaa", "a")); assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b")); assertEquals(4, StringUtils.lastIndexOf("aabaabaa", "ab")); assertEquals(4, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), "ab")); } @Test public void testLastIndexOf_StringInt() { assertEquals(-1, StringUtils.lastIndexOf(null, null, 0)); assertEquals(-1, StringUtils.lastIndexOf(null, null, -1)); assertEquals(-1, StringUtils.lastIndexOf(null, "", 0)); assertEquals(-1, StringUtils.lastIndexOf(null, "", -1)); assertEquals(-1, StringUtils.lastIndexOf("", null, 0)); assertEquals(-1, StringUtils.lastIndexOf("", null, -1)); assertEquals(0, StringUtils.lastIndexOf("", "", 0)); assertEquals(-1, StringUtils.lastIndexOf("", "", -1)); assertEquals(0, StringUtils.lastIndexOf("", "", 9)); assertEquals(0, StringUtils.lastIndexOf("abc", "", 0)); assertEquals(-1, StringUtils.lastIndexOf("abc", "", -1)); assertEquals(3, StringUtils.lastIndexOf("abc", "", 9)); assertEquals(7, StringUtils.lastIndexOf("aabaabaa", "a", 8)); assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 8)); assertEquals(4, StringUtils.lastIndexOf("aabaabaa", "ab", 8)); assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "b", 3)); assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 9)); assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", -1)); assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", 0)); assertEquals(0, StringUtils.lastIndexOf("aabaabaa", "a", 0)); assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "a", -1)); // Test that fromIndex works correctly, i.e. cannot match after fromIndex assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 9)); assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 8)); assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 7)); // 7 is last index assertEquals(-1, StringUtils.lastIndexOf("12345678", "8", 6)); assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", 1)); assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "b", 2)); assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "ba", 2)); assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "ba", 3)); assertEquals(2, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), "b", 3)); } @Test public void testLastIndexOfAny_StringStringArray() { assertEquals(-1, StringUtils.lastIndexOfAny(null, (CharSequence) null)); // test both types of ... assertEquals(-1, StringUtils.lastIndexOfAny(null, (CharSequence[]) null)); // ... varargs invocation assertEquals(-1, StringUtils.lastIndexOfAny(null)); // Missing varag assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY)); assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, (CharSequence) null)); // test both types of ... assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, (CharSequence[]) null)); // ... varargs invocation assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR)); // Missing vararg assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY)); assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0])); assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[0])); assertEquals(-1, StringUtils.lastIndexOfAny("", new String[0])); assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {"llll"})); assertEquals(6, StringUtils.lastIndexOfAny(FOOBAR, new String[] {""})); assertEquals(0, StringUtils.lastIndexOfAny("", new String[] {""})); assertEquals(-1, StringUtils.lastIndexOfAny("", new String[] {"a"})); assertEquals(-1, StringUtils.lastIndexOfAny("", new String[] {null})); assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {null})); assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[] {null})); } @Test public void testLastIndexOfIgnoreCase_String() { assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "")); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", "a")); assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "")); assertEquals(8, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "")); assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "a")); assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A")); assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "b")); assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B")); assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "ab")); assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB")); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("ab", "AAB")); assertEquals(0, StringUtils.lastIndexOfIgnoreCase("aab", "AAB")); } @Test public void testLastIndexOfIgnoreCase_StringInt() { assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, 0)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, -1)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", 0)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", -1)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, 0)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, -1)); assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 0)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", "", -1)); assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 9)); assertEquals(0, StringUtils.lastIndexOfIgnoreCase("abc", "", 0)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("abc", "", -1)); assertEquals(3, StringUtils.lastIndexOfIgnoreCase("abc", "", 9)); assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 8)); assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 8)); assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB", 8)); assertEquals(2, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 3)); assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 9)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", -1)); assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 0)); assertEquals(0, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 0)); assertEquals(1, StringUtils.lastIndexOfIgnoreCase("aab", "AB", 1)); } @Test public void testLastOrdinalIndexOf() { assertEquals(-1, StringUtils.lastOrdinalIndexOf(null, "*", 42) ); assertEquals(-1, StringUtils.lastOrdinalIndexOf("*", null, 42) ); assertEquals(0, StringUtils.lastOrdinalIndexOf("", "", 42) ); assertEquals(7, StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 1) ); assertEquals(6, StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 2) ); assertEquals(5, StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 1) ); assertEquals(2, StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 2) ); assertEquals(4, StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 1) ); assertEquals(1, StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 2) ); assertEquals(8, StringUtils.lastOrdinalIndexOf("aabaabaa", "", 1) ); assertEquals(8, StringUtils.lastOrdinalIndexOf("aabaabaa", "", 2) ); } @Test public void testOrdinalIndexOf() { assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("", "", Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MIN_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1)); assertEquals(-1, StringUtils.ordinalIndexOf("", null, -1)); assertEquals(-1, StringUtils.ordinalIndexOf("", "", -1)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", -1)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", -1)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", -1)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", -1)); assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 0)); assertEquals(-1, StringUtils.ordinalIndexOf("", null, 0)); assertEquals(-1, StringUtils.ordinalIndexOf("", "", 0)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", 0)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", 0)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", 0)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", 0)); assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 1)); assertEquals(-1, StringUtils.ordinalIndexOf("", null, 1)); assertEquals(0, StringUtils.ordinalIndexOf("", "", 1)); assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "a", 1)); assertEquals(2, StringUtils.ordinalIndexOf("aabaabaa", "b", 1)); assertEquals(1, StringUtils.ordinalIndexOf("aabaabaa", "ab", 1)); assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", 1)); assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 2)); assertEquals(-1, StringUtils.ordinalIndexOf("", null, 2)); assertEquals(0, StringUtils.ordinalIndexOf("", "", 2)); assertEquals(1, StringUtils.ordinalIndexOf("aabaabaa", "a", 2)); assertEquals(5, StringUtils.ordinalIndexOf("aabaabaa", "b", 2)); assertEquals(4, StringUtils.ordinalIndexOf("aabaabaa", "ab", 2)); assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", 2)); assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MAX_VALUE)); assertEquals(0, StringUtils.ordinalIndexOf("", "", Integer.MAX_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MAX_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MAX_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MAX_VALUE)); assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MAX_VALUE)); assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 0)); assertEquals(0, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 1)); assertEquals(1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 2)); assertEquals(2, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 3)); assertEquals(3, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 4)); assertEquals(4, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 5)); assertEquals(5, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 6)); assertEquals(6, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 7)); assertEquals(7, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 8)); assertEquals(8, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 9)); assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 10)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.StringUtils} - Substring methods * * @version $Id$ */ public class StringUtilsIsTest { //----------------------------------------------------------------------- @Test public void testIsAlpha() { assertFalse(StringUtils.isAlpha(null)); assertFalse(StringUtils.isAlpha("")); assertFalse(StringUtils.isAlpha(" ")); assertTrue(StringUtils.isAlpha("a")); assertTrue(StringUtils.isAlpha("A")); assertTrue(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); assertFalse(StringUtils.isAlpha("ham kso")); assertFalse(StringUtils.isAlpha("1")); assertFalse(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); assertFalse(StringUtils.isAlpha("_")); assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh")); } @Test public void testIsAlphanumeric() { assertFalse(StringUtils.isAlphanumeric(null)); assertFalse(StringUtils.isAlphanumeric("")); assertFalse(StringUtils.isAlphanumeric(" ")); assertTrue(StringUtils.isAlphanumeric("a")); assertTrue(StringUtils.isAlphanumeric("A")); assertTrue(StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); assertFalse(StringUtils.isAlphanumeric("ham kso")); assertTrue(StringUtils.isAlphanumeric("1")); assertTrue(StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); assertFalse(StringUtils.isAlphanumeric("_")); assertFalse(StringUtils.isAlphanumeric("hkHKHik*khbkuh")); } @Test public void testIsWhitespace() { assertFalse(StringUtils.isWhitespace(null)); assertTrue(StringUtils.isWhitespace("")); assertTrue(StringUtils.isWhitespace(" ")); assertTrue(StringUtils.isWhitespace("\t \n \t")); assertFalse(StringUtils.isWhitespace("\t aa\n \t")); assertTrue(StringUtils.isWhitespace(" ")); assertFalse(StringUtils.isWhitespace(" a ")); assertFalse(StringUtils.isWhitespace("a ")); assertFalse(StringUtils.isWhitespace(" a")); assertFalse(StringUtils.isWhitespace("aba")); assertTrue(StringUtils.isWhitespace(StringUtilsTest.WHITESPACE)); assertFalse(StringUtils.isWhitespace(StringUtilsTest.NON_WHITESPACE)); } @Test public void testIsAlphaspace() { assertFalse(StringUtils.isAlphaSpace(null)); assertTrue(StringUtils.isAlphaSpace("")); assertTrue(StringUtils.isAlphaSpace(" ")); assertTrue(StringUtils.isAlphaSpace("a")); assertTrue(StringUtils.isAlphaSpace("A")); assertTrue(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); assertTrue(StringUtils.isAlphaSpace("ham kso")); assertFalse(StringUtils.isAlphaSpace("1")); assertFalse(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); assertFalse(StringUtils.isAlphaSpace("_")); assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh")); } @Test public void testIsAlphanumericSpace() { assertFalse(StringUtils.isAlphanumericSpace(null)); assertTrue(StringUtils.isAlphanumericSpace("")); assertTrue(StringUtils.isAlphanumericSpace(" ")); assertTrue(StringUtils.isAlphanumericSpace("a")); assertTrue(StringUtils.isAlphanumericSpace("A")); assertTrue(StringUtils.isAlphanumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); assertTrue(StringUtils.isAlphanumericSpace("ham kso")); assertTrue(StringUtils.isAlphanumericSpace("1")); assertTrue(StringUtils.isAlphanumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); assertFalse(StringUtils.isAlphanumericSpace("_")); assertFalse(StringUtils.isAlphanumericSpace("hkHKHik*khbkuh")); } @Test public void testIsAsciiPrintable_String() { assertFalse(StringUtils.isAsciiPrintable(null)); assertTrue(StringUtils.isAsciiPrintable("")); assertTrue(StringUtils.isAsciiPrintable(" ")); assertTrue(StringUtils.isAsciiPrintable("a")); assertTrue(StringUtils.isAsciiPrintable("A")); assertTrue(StringUtils.isAsciiPrintable("1")); assertTrue(StringUtils.isAsciiPrintable("Ceki")); assertTrue(StringUtils.isAsciiPrintable("!ab2c~")); assertTrue(StringUtils.isAsciiPrintable("1000")); assertTrue(StringUtils.isAsciiPrintable("10 00")); assertFalse(StringUtils.isAsciiPrintable("10\t00")); assertTrue(StringUtils.isAsciiPrintable("10.00")); assertTrue(StringUtils.isAsciiPrintable("10,00")); assertTrue(StringUtils.isAsciiPrintable("!ab-c~")); assertTrue(StringUtils.isAsciiPrintable("hkHK=Hik6i?UGH_KJgU7.tUJgKJ*GI87GI,kug")); assertTrue(StringUtils.isAsciiPrintable("\u0020")); assertTrue(StringUtils.isAsciiPrintable("\u0021")); assertTrue(StringUtils.isAsciiPrintable("\u007e")); assertFalse(StringUtils.isAsciiPrintable("\u007f")); assertTrue(StringUtils.isAsciiPrintable("G?lc?")); assertTrue(StringUtils.isAsciiPrintable("=?iso-8859-1?Q?G=FClc=FC?=")); assertFalse(StringUtils.isAsciiPrintable("G\u00fclc\u00fc")); } @Test public void testIsNumeric() { assertFalse(StringUtils.isNumeric(null)); assertFalse(StringUtils.isNumeric("")); assertFalse(StringUtils.isNumeric(" ")); assertFalse(StringUtils.isNumeric("a")); assertFalse(StringUtils.isNumeric("A")); assertFalse(StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); assertFalse(StringUtils.isNumeric("ham kso")); assertTrue(StringUtils.isNumeric("1")); assertTrue(StringUtils.isNumeric("1000")); assertFalse(StringUtils.isNumeric("2.3")); assertFalse(StringUtils.isNumeric("10 00")); assertFalse(StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); assertFalse(StringUtils.isNumeric("_")); assertFalse(StringUtils.isNumeric("hkHKHik*khbkuh")); assertFalse(StringUtils.isNumeric("+123")); assertFalse(StringUtils.isNumeric("-123")); } @Test public void testIsNumericSpace() { assertFalse(StringUtils.isNumericSpace(null)); assertTrue(StringUtils.isNumericSpace("")); assertTrue(StringUtils.isNumericSpace(" ")); assertFalse(StringUtils.isNumericSpace("a")); assertFalse(StringUtils.isNumericSpace("A")); assertFalse(StringUtils.isNumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl")); assertFalse(StringUtils.isNumericSpace("ham kso")); assertTrue(StringUtils.isNumericSpace("1")); assertTrue(StringUtils.isNumericSpace("1000")); assertFalse(StringUtils.isNumericSpace("2.3")); assertTrue(StringUtils.isNumericSpace("10 00")); assertFalse(StringUtils.isNumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug")); assertFalse(StringUtils.isNumericSpace("_")); assertFalse(StringUtils.isNumericSpace("hkHKHik*khbkuh")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import org.junit.Test; import static org.junit.Assert.*; import org.apache.commons.lang3.text.StrBuilder; /** * Unit tests {@link org.apache.commons.lang3.StringUtils} - StartsWith/EndsWith methods * * @version $Id$ */ public class StringUtilsStartsEndsWithTest { private static final String foo = "foo"; private static final String bar = "bar"; private static final String foobar = "foobar"; private static final String FOO = "FOO"; private static final String BAR = "BAR"; private static final String FOOBAR = "FOOBAR"; //----------------------------------------------------------------------- /** * Test StringUtils.startsWith() */ @Test public void testStartsWith() { assertTrue("startsWith(null, null)", StringUtils.startsWith(null, (String)null)); assertFalse("startsWith(FOOBAR, null)", StringUtils.startsWith(FOOBAR, (String)null)); assertFalse("startsWith(null, FOO)", StringUtils.startsWith(null, FOO)); assertTrue("startsWith(FOOBAR, \"\")", StringUtils.startsWith(FOOBAR, "")); assertTrue("startsWith(foobar, foo)", StringUtils.startsWith(foobar, foo)); assertTrue("startsWith(FOOBAR, FOO)", StringUtils.startsWith(FOOBAR, FOO)); assertFalse("startsWith(foobar, FOO)", StringUtils.startsWith(foobar, FOO)); assertFalse("startsWith(FOOBAR, foo)", StringUtils.startsWith(FOOBAR, foo)); assertFalse("startsWith(foo, foobar)", StringUtils.startsWith(foo, foobar)); assertFalse("startsWith(foo, foobar)", StringUtils.startsWith(bar, foobar)); assertFalse("startsWith(foobar, bar)", StringUtils.startsWith(foobar, bar)); assertFalse("startsWith(FOOBAR, BAR)", StringUtils.startsWith(FOOBAR, BAR)); assertFalse("startsWith(foobar, BAR)", StringUtils.startsWith(foobar, BAR)); assertFalse("startsWith(FOOBAR, bar)", StringUtils.startsWith(FOOBAR, bar)); } /** * Test StringUtils.testStartsWithIgnoreCase() */ @Test public void testStartsWithIgnoreCase() { assertTrue("startsWithIgnoreCase(null, null)", StringUtils.startsWithIgnoreCase(null, (String)null)); assertFalse("startsWithIgnoreCase(FOOBAR, null)", StringUtils.startsWithIgnoreCase(FOOBAR, (String)null)); assertFalse("startsWithIgnoreCase(null, FOO)", StringUtils.startsWithIgnoreCase(null, FOO)); assertTrue("startsWithIgnoreCase(FOOBAR, \"\")", StringUtils.startsWithIgnoreCase(FOOBAR, "")); assertTrue("startsWithIgnoreCase(foobar, foo)", StringUtils.startsWithIgnoreCase(foobar, foo)); assertTrue("startsWithIgnoreCase(FOOBAR, FOO)", StringUtils.startsWithIgnoreCase(FOOBAR, FOO)); assertTrue("startsWithIgnoreCase(foobar, FOO)", StringUtils.startsWithIgnoreCase(foobar, FOO)); assertTrue("startsWithIgnoreCase(FOOBAR, foo)", StringUtils.startsWithIgnoreCase(FOOBAR, foo)); assertFalse("startsWithIgnoreCase(foo, foobar)", StringUtils.startsWithIgnoreCase(foo, foobar)); assertFalse("startsWithIgnoreCase(foo, foobar)", StringUtils.startsWithIgnoreCase(bar, foobar)); assertFalse("startsWithIgnoreCase(foobar, bar)", StringUtils.startsWithIgnoreCase(foobar, bar)); assertFalse("startsWithIgnoreCase(FOOBAR, BAR)", StringUtils.startsWithIgnoreCase(FOOBAR, BAR)); assertFalse("startsWithIgnoreCase(foobar, BAR)", StringUtils.startsWithIgnoreCase(foobar, BAR)); assertFalse("startsWithIgnoreCase(FOOBAR, bar)", StringUtils.startsWithIgnoreCase(FOOBAR, bar)); } @Test public void testStartsWithAny() { assertFalse(StringUtils.startsWithAny(null, (String[])null)); assertFalse(StringUtils.startsWithAny(null, "abc")); assertFalse(StringUtils.startsWithAny("abcxyz", (String[])null)); assertFalse(StringUtils.startsWithAny("abcxyz")); assertTrue(StringUtils.startsWithAny("abcxyz", "abc")); assertTrue(StringUtils.startsWithAny("abcxyz", null, "xyz", "abc")); assertFalse(StringUtils.startsWithAny("abcxyz", null, "xyz", "abcd")); assertTrue("StringUtils.startsWithAny(abcxyz, StringBuilder(xyz), StringBuffer(abc))", StringUtils.startsWithAny("abcxyz", new StringBuilder("xyz"), new StringBuffer("abc"))); assertTrue("StringUtils.startsWithAny( StrBuilder(abcxyz), StringBuilder(xyz), StringBuffer(abc))", StringUtils.startsWithAny( new StrBuilder("abcxyz"), new StringBuilder("xyz"), new StringBuffer("abc"))); } /** * Test StringUtils.endsWith() */ @Test public void testEndsWith() { assertTrue("endsWith(null, null)", StringUtils.endsWith(null, (String)null)); assertFalse("endsWith(FOOBAR, null)", StringUtils.endsWith(FOOBAR, (String)null)); assertFalse("endsWith(null, FOO)", StringUtils.endsWith(null, FOO)); assertTrue("endsWith(FOOBAR, \"\")", StringUtils.endsWith(FOOBAR, "")); assertFalse("endsWith(foobar, foo)", StringUtils.endsWith(foobar, foo)); assertFalse("endsWith(FOOBAR, FOO)", StringUtils.endsWith(FOOBAR, FOO)); assertFalse("endsWith(foobar, FOO)", StringUtils.endsWith(foobar, FOO)); assertFalse("endsWith(FOOBAR, foo)", StringUtils.endsWith(FOOBAR, foo)); assertFalse("endsWith(foo, foobar)", StringUtils.endsWith(foo, foobar)); assertFalse("endsWith(foo, foobar)", StringUtils.endsWith(bar, foobar)); assertTrue("endsWith(foobar, bar)", StringUtils.endsWith(foobar, bar)); assertTrue("endsWith(FOOBAR, BAR)", StringUtils.endsWith(FOOBAR, BAR)); assertFalse("endsWith(foobar, BAR)", StringUtils.endsWith(foobar, BAR)); assertFalse("endsWith(FOOBAR, bar)", StringUtils.endsWith(FOOBAR, bar)); // "alpha,beta,gamma,delta".endsWith("delta") assertTrue("endsWith(\u03B1\u03B2\u03B3\u03B4, \u03B4)", StringUtils.endsWith("\u03B1\u03B2\u03B3\u03B4", "\u03B4")); // "alpha,beta,gamma,delta".endsWith("gamma,DELTA") assertFalse("endsWith(\u03B1\u03B2\u03B3\u03B4, \u03B3\u0394)", StringUtils.endsWith("\u03B1\u03B2\u03B3\u03B4", "\u03B3\u0394")); } /** * Test StringUtils.endsWithIgnoreCase() */ @Test public void testEndsWithIgnoreCase() { assertTrue("endsWithIgnoreCase(null, null)", StringUtils.endsWithIgnoreCase(null, (String)null)); assertFalse("endsWithIgnoreCase(FOOBAR, null)", StringUtils.endsWithIgnoreCase(FOOBAR, (String)null)); assertFalse("endsWithIgnoreCase(null, FOO)", StringUtils.endsWithIgnoreCase(null, FOO)); assertTrue("endsWithIgnoreCase(FOOBAR, \"\")", StringUtils.endsWithIgnoreCase(FOOBAR, "")); assertFalse("endsWithIgnoreCase(foobar, foo)", StringUtils.endsWithIgnoreCase(foobar, foo)); assertFalse("endsWithIgnoreCase(FOOBAR, FOO)", StringUtils.endsWithIgnoreCase(FOOBAR, FOO)); assertFalse("endsWithIgnoreCase(foobar, FOO)", StringUtils.endsWithIgnoreCase(foobar, FOO)); assertFalse("endsWithIgnoreCase(FOOBAR, foo)", StringUtils.endsWithIgnoreCase(FOOBAR, foo)); assertFalse("endsWithIgnoreCase(foo, foobar)", StringUtils.endsWithIgnoreCase(foo, foobar)); assertFalse("endsWithIgnoreCase(foo, foobar)", StringUtils.endsWithIgnoreCase(bar, foobar)); assertTrue("endsWithIgnoreCase(foobar, bar)", StringUtils.endsWithIgnoreCase(foobar, bar)); assertTrue("endsWithIgnoreCase(FOOBAR, BAR)", StringUtils.endsWithIgnoreCase(FOOBAR, BAR)); assertTrue("endsWithIgnoreCase(foobar, BAR)", StringUtils.endsWithIgnoreCase(foobar, BAR)); assertTrue("endsWithIgnoreCase(FOOBAR, bar)", StringUtils.endsWithIgnoreCase(FOOBAR, bar)); // javadoc assertTrue(StringUtils.endsWithIgnoreCase("abcdef", "def")); assertTrue(StringUtils.endsWithIgnoreCase("ABCDEF", "def")); assertFalse(StringUtils.endsWithIgnoreCase("ABCDEF", "cde")); // "alpha,beta,gamma,delta".endsWith("DELTA") assertTrue("endsWith(\u03B1\u03B2\u03B3\u03B4, \u0394)", StringUtils.endsWithIgnoreCase("\u03B1\u03B2\u03B3\u03B4", "\u0394")); // "alpha,beta,gamma,delta".endsWith("GAMMA") assertFalse("endsWith(\u03B1\u03B2\u03B3\u03B4, \u0393)", StringUtils.endsWithIgnoreCase("\u03B1\u03B2\u03B3\u03B4", "\u0393")); } @Test public void testEndsWithAny() { assertFalse("StringUtils.endsWithAny(null, null)", StringUtils.endsWithAny(null, (String)null)); assertFalse("StringUtils.endsWithAny(null, new String[] {abc})", StringUtils.endsWithAny(null, new String[] {"abc"})); assertFalse("StringUtils.endsWithAny(abcxyz, null)", StringUtils.endsWithAny("abcxyz", (String)null)); assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {\"\"})", StringUtils.endsWithAny("abcxyz", new String[] {""})); assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {xyz})", StringUtils.endsWithAny("abcxyz", new String[] {"xyz"})); assertTrue("StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})", StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"})); assertFalse("StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})", StringUtils.endsWithAny("defg", new String[] {null, "xyz", "abc"})); assertTrue("StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz"))); assertTrue("StringUtils.endsWithAny( StrBuilder(abcxyz), StringBuilder(abc), StringBuffer(xyz))", StringUtils.endsWithAny( new StrBuilder("abcxyz"), new StringBuilder("abc"), new StringBuffer("xyz"))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.StringUtils} - Substring methods * * @version $Id$ */ public class StringUtilsSubstringTest { private static final String FOO = "foo"; private static final String BAR = "bar"; private static final String BAZ = "baz"; private static final String FOOBAR = "foobar"; private static final String SENTENCE = "foo bar baz"; //----------------------------------------------------------------------- @Test public void testSubstring_StringInt() { assertEquals(null, StringUtils.substring(null, 0)); assertEquals("", StringUtils.substring("", 0)); assertEquals("", StringUtils.substring("", 2)); assertEquals("", StringUtils.substring(SENTENCE, 80)); assertEquals(BAZ, StringUtils.substring(SENTENCE, 8)); assertEquals(BAZ, StringUtils.substring(SENTENCE, -3)); assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0)); assertEquals("abc", StringUtils.substring("abc", -4)); assertEquals("abc", StringUtils.substring("abc", -3)); assertEquals("bc", StringUtils.substring("abc", -2)); assertEquals("c", StringUtils.substring("abc", -1)); assertEquals("abc", StringUtils.substring("abc", 0)); assertEquals("bc", StringUtils.substring("abc", 1)); assertEquals("c", StringUtils.substring("abc", 2)); assertEquals("", StringUtils.substring("abc", 3)); assertEquals("", StringUtils.substring("abc", 4)); } @Test public void testSubstring_StringIntInt() { assertEquals(null, StringUtils.substring(null, 0, 0)); assertEquals(null, StringUtils.substring(null, 1, 2)); assertEquals("", StringUtils.substring("", 0, 0)); assertEquals("", StringUtils.substring("", 1, 2)); assertEquals("", StringUtils.substring("", -2, -1)); assertEquals("", StringUtils.substring(SENTENCE, 8, 6)); assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3)); assertEquals("o", StringUtils.substring(SENTENCE, -9, 3)); assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8)); assertEquals("o", StringUtils.substring(SENTENCE, -9, -8)); assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80)); assertEquals("", StringUtils.substring(SENTENCE, 2, 2)); assertEquals("b",StringUtils.substring("abc", -2, -1)); } @Test public void testLeft_String() { assertSame(null, StringUtils.left(null, -1)); assertSame(null, StringUtils.left(null, 0)); assertSame(null, StringUtils.left(null, 2)); assertEquals("", StringUtils.left("", -1)); assertEquals("", StringUtils.left("", 0)); assertEquals("", StringUtils.left("", 2)); assertEquals("", StringUtils.left(FOOBAR, -1)); assertEquals("", StringUtils.left(FOOBAR, 0)); assertEquals(FOO, StringUtils.left(FOOBAR, 3)); assertSame(FOOBAR, StringUtils.left(FOOBAR, 80)); } @Test public void testRight_String() { assertSame(null, StringUtils.right(null, -1)); assertSame(null, StringUtils.right(null, 0)); assertSame(null, StringUtils.right(null, 2)); assertEquals("", StringUtils.right("", -1)); assertEquals("", StringUtils.right("", 0)); assertEquals("", StringUtils.right("", 2)); assertEquals("", StringUtils.right(FOOBAR, -1)); assertEquals("", StringUtils.right(FOOBAR, 0)); assertEquals(BAR, StringUtils.right(FOOBAR, 3)); assertSame(FOOBAR, StringUtils.right(FOOBAR, 80)); } @Test public void testMid_String() { assertSame(null, StringUtils.mid(null, -1, 0)); assertSame(null, StringUtils.mid(null, 0, -1)); assertSame(null, StringUtils.mid(null, 3, 0)); assertSame(null, StringUtils.mid(null, 3, 2)); assertEquals("", StringUtils.mid("", 0, -1)); assertEquals("", StringUtils.mid("", 0, 0)); assertEquals("", StringUtils.mid("", 0, 2)); assertEquals("", StringUtils.mid(FOOBAR, 3, -1)); assertEquals("", StringUtils.mid(FOOBAR, 3, 0)); assertEquals("b", StringUtils.mid(FOOBAR, 3, 1)); assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3)); assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3)); assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80)); assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80)); assertEquals("", StringUtils.mid(FOOBAR, 9, 3)); assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3)); } //----------------------------------------------------------------------- @Test public void testSubstringBefore_StringString() { assertEquals("foo", StringUtils.substringBefore("fooXXbarXXbaz", "XX")); assertEquals(null, StringUtils.substringBefore(null, null)); assertEquals(null, StringUtils.substringBefore(null, "")); assertEquals(null, StringUtils.substringBefore(null, "XX")); assertEquals("", StringUtils.substringBefore("", null)); assertEquals("", StringUtils.substringBefore("", "")); assertEquals("", StringUtils.substringBefore("", "XX")); assertEquals("foo", StringUtils.substringBefore("foo", null)); assertEquals("foo", StringUtils.substringBefore("foo", "b")); assertEquals("f", StringUtils.substringBefore("foot", "o")); assertEquals("", StringUtils.substringBefore("abc", "a")); assertEquals("a", StringUtils.substringBefore("abcba", "b")); assertEquals("ab", StringUtils.substringBefore("abc", "c")); assertEquals("", StringUtils.substringBefore("abc", "")); } @Test public void testSubstringAfter_StringString() { assertEquals("barXXbaz", StringUtils.substringAfter("fooXXbarXXbaz", "XX")); assertEquals(null, StringUtils.substringAfter(null, null)); assertEquals(null, StringUtils.substringAfter(null, "")); assertEquals(null, StringUtils.substringAfter(null, "XX")); assertEquals("", StringUtils.substringAfter("", null)); assertEquals("", StringUtils.substringAfter("", "")); assertEquals("", StringUtils.substringAfter("", "XX")); assertEquals("", StringUtils.substringAfter("foo", null)); assertEquals("ot", StringUtils.substringAfter("foot", "o")); assertEquals("bc", StringUtils.substringAfter("abc", "a")); assertEquals("cba", StringUtils.substringAfter("abcba", "b")); assertEquals("", StringUtils.substringAfter("abc", "c")); assertEquals("abc", StringUtils.substringAfter("abc", "")); assertEquals("", StringUtils.substringAfter("abc", "d")); } @Test public void testSubstringBeforeLast_StringString() { assertEquals("fooXXbar", StringUtils.substringBeforeLast("fooXXbarXXbaz", "XX")); assertEquals(null, StringUtils.substringBeforeLast(null, null)); assertEquals(null, StringUtils.substringBeforeLast(null, "")); assertEquals(null, StringUtils.substringBeforeLast(null, "XX")); assertEquals("", StringUtils.substringBeforeLast("", null)); assertEquals("", StringUtils.substringBeforeLast("", "")); assertEquals("", StringUtils.substringBeforeLast("", "XX")); assertEquals("foo", StringUtils.substringBeforeLast("foo", null)); assertEquals("foo", StringUtils.substringBeforeLast("foo", "b")); assertEquals("fo", StringUtils.substringBeforeLast("foo", "o")); assertEquals("abc\r\n", StringUtils.substringBeforeLast("abc\r\n", "d")); assertEquals("abc", StringUtils.substringBeforeLast("abcdabc", "d")); assertEquals("abcdabc", StringUtils.substringBeforeLast("abcdabcd", "d")); assertEquals("a", StringUtils.substringBeforeLast("abc", "b")); assertEquals("abc ", StringUtils.substringBeforeLast("abc \n", "\n")); assertEquals("a", StringUtils.substringBeforeLast("a", null)); assertEquals("a", StringUtils.substringBeforeLast("a", "")); assertEquals("", StringUtils.substringBeforeLast("a", "a")); } @Test public void testSubstringAfterLast_StringString() { assertEquals("baz", StringUtils.substringAfterLast("fooXXbarXXbaz", "XX")); assertEquals(null, StringUtils.substringAfterLast(null, null)); assertEquals(null, StringUtils.substringAfterLast(null, "")); assertEquals(null, StringUtils.substringAfterLast(null, "XX")); assertEquals("", StringUtils.substringAfterLast("", null)); assertEquals("", StringUtils.substringAfterLast("", "")); assertEquals("", StringUtils.substringAfterLast("", "a")); assertEquals("", StringUtils.substringAfterLast("foo", null)); assertEquals("", StringUtils.substringAfterLast("foo", "b")); assertEquals("t", StringUtils.substringAfterLast("foot", "o")); assertEquals("bc", StringUtils.substringAfterLast("abc", "a")); assertEquals("a", StringUtils.substringAfterLast("abcba", "b")); assertEquals("", StringUtils.substringAfterLast("abc", "c")); assertEquals("", StringUtils.substringAfterLast("", "d")); assertEquals("", StringUtils.substringAfterLast("abc", "")); } //----------------------------------------------------------------------- @Test public void testSubstringBetween_StringString() { assertEquals(null, StringUtils.substringBetween(null, "tag")); assertEquals("", StringUtils.substringBetween("", "")); assertEquals(null, StringUtils.substringBetween("", "abc")); assertEquals("", StringUtils.substringBetween(" ", " ")); assertEquals(null, StringUtils.substringBetween("abc", null)); assertEquals("", StringUtils.substringBetween("abc", "")); assertEquals(null, StringUtils.substringBetween("abc", "a")); assertEquals("bc", StringUtils.substringBetween("abca", "a")); assertEquals("bc", StringUtils.substringBetween("abcabca", "a")); assertEquals("bar", StringUtils.substringBetween("\nbar\n", "\n")); } @Test public void testSubstringBetween_StringStringString() { assertEquals(null, StringUtils.substringBetween(null, "", "")); assertEquals(null, StringUtils.substringBetween("", null, "")); assertEquals(null, StringUtils.substringBetween("", "", null)); assertEquals("", StringUtils.substringBetween("", "", "")); assertEquals("", StringUtils.substringBetween("foo", "", "")); assertEquals(null, StringUtils.substringBetween("foo", "", "]")); assertEquals(null, StringUtils.substringBetween("foo", "[", "]")); assertEquals("", StringUtils.substringBetween(" ", " ", " ")); assertEquals("bar", StringUtils.substringBetween("<foo>bar</foo>", "<foo>", "</foo>") ); } /** * Tests the substringsBetween method that returns an String Array of substrings. */ @Test public void testSubstringsBetween_StringStringString() { String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]"); assertEquals(3, results.length); assertEquals("one", results[0]); assertEquals("two", results[1]); assertEquals("three", results[2]); results = StringUtils.substringsBetween("[one], [two], three", "[", "]"); assertEquals(2, results.length); assertEquals("one", results[0]); assertEquals("two", results[1]); results = StringUtils.substringsBetween("[one], [two], three]", "[", "]"); assertEquals(2, results.length); assertEquals("one", results[0]); assertEquals("two", results[1]); results = StringUtils.substringsBetween("[one], two], three]", "[", "]"); assertEquals(1, results.length); assertEquals("one", results[0]); results = StringUtils.substringsBetween("one], two], [three]", "[", "]"); assertEquals(1, results.length); assertEquals("three", results[0]); // 'ab hello ba' will match, but 'ab non ba' won't // this is because the 'a' is shared between the two and can't be matched twice results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba"); assertEquals(1, results.length); assertEquals("hello", results[0]); results = StringUtils.substringsBetween("one, two, three", "[", "]"); assertNull(results); results = StringUtils.substringsBetween("[one, two, three", "[", "]"); assertNull(results); results = StringUtils.substringsBetween("one, two, three]", "[", "]"); assertNull(results); results = StringUtils.substringsBetween("[one], [two], [three]", "[", null); assertNull(results); results = StringUtils.substringsBetween("[one], [two], [three]", null, "]"); assertNull(results); results = StringUtils.substringsBetween("[one], [two], [three]", "", ""); assertNull(results); results = StringUtils.substringsBetween(null, "[", "]"); assertNull(results); results = StringUtils.substringsBetween("", "[", "]"); assertEquals(0, results.length); } //----------------------------------------------------------------------- @Test public void testCountMatches_String() { assertEquals(0, StringUtils.countMatches(null, null)); assertEquals(0, StringUtils.countMatches("blah", null)); assertEquals(0, StringUtils.countMatches(null, "DD")); assertEquals(0, StringUtils.countMatches("x", "")); assertEquals(0, StringUtils.countMatches("", "")); assertEquals(3, StringUtils.countMatches("one long someone sentence of one", "one")); assertEquals(0, StringUtils.countMatches("one long someone sentence of one", "two")); assertEquals(4, StringUtils.countMatches("oooooooooooo", "ooo")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.io.UnsupportedEncodingException; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.nio.CharBuffer; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.StringUtils}. * * @version $Id$ */ public class StringUtilsTest { static final String WHITESPACE; static final String NON_WHITESPACE; static final String TRIMMABLE; static final String NON_TRIMMABLE; static { String ws = ""; String nws = ""; String tr = ""; String ntr = ""; for (int i = 0; i < Character.MAX_VALUE; i++) { if (Character.isWhitespace((char) i)) { ws += String.valueOf((char) i); if (i > 32) { ntr += String.valueOf((char) i); } } else if (i < 40) { nws += String.valueOf((char) i); } } for (int i = 0; i <= 32; i++) { tr += String.valueOf((char) i); } WHITESPACE = ws; NON_WHITESPACE = nws; TRIMMABLE = tr; NON_TRIMMABLE = ntr; } private static final String[] ARRAY_LIST = { "foo", "bar", "baz" }; private static final String[] EMPTY_ARRAY_LIST = {}; private static final String[] NULL_ARRAY_LIST = {null}; private static final Object[] NULL_TO_STRING_LIST = { new Object(){ @Override public String toString() { return null; } } }; private static final String[] MIXED_ARRAY_LIST = {null, "", "foo"}; private static final Object[] MIXED_TYPE_LIST = {"foo", Long.valueOf(2L)}; private static final long[] LONG_PRIM_LIST = {1, 2}; private static final int[] INT_PRIM_LIST = {1, 2}; private static final byte[] BYTE_PRIM_LIST = {1, 2}; private static final short[] SHORT_PRIM_LIST = {1, 2}; private static final char[] CHAR_PRIM_LIST = {'1', '2'}; private static final float[] FLOAT_PRIM_LIST = {1, 2}; private static final double[] DOUBLE_PRIM_LIST = {1, 2}; private static final String SEPARATOR = ","; private static final char SEPARATOR_CHAR = ';'; private static final String TEXT_LIST = "foo,bar,baz"; private static final String TEXT_LIST_CHAR = "foo;bar;baz"; private static final String TEXT_LIST_NOSEP = "foobarbaz"; private static final String FOO_UNCAP = "foo"; private static final String FOO_CAP = "Foo"; private static final String SENTENCE_UNCAP = "foo bar baz"; private static final String SENTENCE_CAP = "Foo Bar Baz"; //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new StringUtils()); final Constructor<?>[] cons = StringUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(StringUtils.class.getModifiers())); assertFalse(Modifier.isFinal(StringUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testCaseFunctions() { assertEquals(null, StringUtils.upperCase(null)); assertEquals(null, StringUtils.upperCase(null, Locale.ENGLISH)); assertEquals(null, StringUtils.lowerCase(null)); assertEquals(null, StringUtils.lowerCase(null, Locale.ENGLISH)); assertEquals(null, StringUtils.capitalize(null)); assertEquals(null, StringUtils.uncapitalize(null)); assertEquals("capitalize(empty-string) failed", "", StringUtils.capitalize("") ); assertEquals("capitalize(single-char-string) failed", "X", StringUtils.capitalize("x") ); assertEquals("capitalize(String) failed", FOO_CAP, StringUtils.capitalize(FOO_CAP) ); assertEquals("capitalize(string) failed", FOO_CAP, StringUtils.capitalize(FOO_UNCAP) ); assertEquals("uncapitalize(String) failed", FOO_UNCAP, StringUtils.uncapitalize(FOO_CAP) ); assertEquals("uncapitalize(string) failed", FOO_UNCAP, StringUtils.uncapitalize(FOO_UNCAP) ); assertEquals("uncapitalize(empty-string) failed", "", StringUtils.uncapitalize("") ); assertEquals("uncapitalize(single-char-string) failed", "x", StringUtils.uncapitalize("X") ); // reflection type of tests: Sentences. assertEquals("uncapitalize(capitalize(String)) failed", SENTENCE_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(SENTENCE_UNCAP)) ); assertEquals("capitalize(uncapitalize(String)) failed", SENTENCE_CAP, StringUtils.capitalize(StringUtils.uncapitalize(SENTENCE_CAP)) ); // reflection type of tests: One word. assertEquals("uncapitalize(capitalize(String)) failed", FOO_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(FOO_UNCAP)) ); assertEquals("capitalize(uncapitalize(String)) failed", FOO_CAP, StringUtils.capitalize(StringUtils.uncapitalize(FOO_CAP)) ); assertEquals("upperCase(String) failed", "FOO TEST THING", StringUtils.upperCase("fOo test THING") ); assertEquals("upperCase(empty-string) failed", "", StringUtils.upperCase("") ); assertEquals("lowerCase(String) failed", "foo test thing", StringUtils.lowerCase("fOo test THING") ); assertEquals("lowerCase(empty-string) failed", "", StringUtils.lowerCase("") ); assertEquals("upperCase(String, Locale) failed", "FOO TEST THING", StringUtils.upperCase("fOo test THING", Locale.ENGLISH) ); assertEquals("upperCase(empty-string, Locale) failed", "", StringUtils.upperCase("", Locale.ENGLISH) ); assertEquals("lowerCase(String, Locale) failed", "foo test thing", StringUtils.lowerCase("fOo test THING", Locale.ENGLISH) ); assertEquals("lowerCase(empty-string, Locale) failed", "", StringUtils.lowerCase("", Locale.ENGLISH) ); } @Test public void testSwapCase_String() { assertEquals(null, StringUtils.swapCase(null)); assertEquals("", StringUtils.swapCase("")); assertEquals(" ", StringUtils.swapCase(" ")); assertEquals("i", WordUtils.swapCase("I") ); assertEquals("I", WordUtils.swapCase("i") ); assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123") ); assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123") ); assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123") ); assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123") ); final String test = "This String contains a TitleCase character: \u01C8"; final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; assertEquals(expect, WordUtils.swapCase(test)); } //----------------------------------------------------------------------- @Test public void testJoin_Objects() { assertEquals("abc", StringUtils.join("a", "b", "c")); assertEquals("a", StringUtils.join(null, "", "a")); assertEquals(null, StringUtils.join((Object[])null)); } @Test public void testJoin_Objectarray() { // assertEquals(null, StringUtils.join(null)); // generates warning assertEquals(null, StringUtils.join((Object[]) null)); // equivalent explicit cast // test additional varargs calls assertEquals("", StringUtils.join()); // empty array assertEquals("", StringUtils.join((Object) null)); // => new Object[]{null} assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST)); assertEquals("", StringUtils.join(NULL_ARRAY_LIST)); assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST)); assertEquals("abc", StringUtils.join(new String[] {"a", "b", "c"})); assertEquals("a", StringUtils.join(new String[] {null, "a", ""})); assertEquals("foo", StringUtils.join(MIXED_ARRAY_LIST)); assertEquals("foo2", StringUtils.join(MIXED_TYPE_LIST)); } @Test public void testJoin_ArrayCharSeparator() { assertEquals(null, StringUtils.join((Object[]) null, ',')); assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR)); assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR)); assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR)); assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR)); assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1)); assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1)); assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2)); assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2)); assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1)); } @Test public void testJoin_ArrayOfChars() { assertEquals(null, StringUtils.join((char[]) null, ',')); assertEquals("1;2", StringUtils.join(CHAR_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2", StringUtils.join(CHAR_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayOfBytes() { assertEquals(null, StringUtils.join((byte[]) null, ',')); assertEquals("1;2", StringUtils.join(BYTE_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2", StringUtils.join(BYTE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayOfInts() { assertEquals(null, StringUtils.join((int[]) null, ',')); assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayOfLongs() { assertEquals(null, StringUtils.join((long[]) null, ',')); assertEquals("1;2", StringUtils.join(LONG_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2", StringUtils.join(LONG_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayOfFloats() { assertEquals(null, StringUtils.join((float[]) null, ',')); assertEquals("1.0;2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayOfDoubles() { assertEquals(null, StringUtils.join((double[]) null, ',')); assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayOfShorts() { assertEquals(null, StringUtils.join((short[]) null, ',')); assertEquals("1;2", StringUtils.join(SHORT_PRIM_LIST, SEPARATOR_CHAR)); assertEquals("2", StringUtils.join(SHORT_PRIM_LIST, SEPARATOR_CHAR, 1, 2)); } @Test public void testJoin_ArrayString() { assertEquals(null, StringUtils.join((Object[]) null, null)); assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null)); assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, "")); assertEquals("", StringUtils.join(NULL_ARRAY_LIST, null)); assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null)); assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, "")); assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR)); assertEquals(TEXT_LIST, StringUtils.join(ARRAY_LIST, SEPARATOR)); assertEquals(",,foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR)); assertEquals("foo,2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR)); assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, "/", 0, MIXED_ARRAY_LIST.length-1)); assertEquals("", StringUtils.join(MIXED_ARRAY_LIST, "", 0, MIXED_ARRAY_LIST.length-1)); assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1)); assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2)); assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2)); assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1)); } @Test public void testJoin_IteratorChar() { assertEquals(null, StringUtils.join((Iterator<?>) null, ',')); assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR_CHAR)); assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), SEPARATOR_CHAR)); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR_CHAR)); assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), 'x')); } @Test public void testJoin_IteratorString() { assertEquals(null, StringUtils.join((Iterator<?>) null, null)); assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), null)); assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), "")); assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), "x")); assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), null)); assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), null)); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), null)); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), "")); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR)); assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR)); } @Test public void testJoin_IterableChar() { assertEquals(null, StringUtils.join((Iterable<?>) null, ',')); assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR)); assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR)); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR)); assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x')); } @Test public void testJoin_IterableString() { assertEquals(null, StringUtils.join((Iterable<?>) null, null)); assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), null)); assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), "")); assertEquals("foo", StringUtils.join(Collections.singleton("foo"), "x")); assertEquals("foo", StringUtils.join(Collections.singleton("foo"), null)); assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), null)); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), null)); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), "")); assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR)); assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR)); } @Test public void testSplit_String() { assertArrayEquals(null, StringUtils.split(null)); assertEquals(0, StringUtils.split("").length); String str = "a b .c"; String[] res = StringUtils.split(str); assertEquals(3, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals(".c", res[2]); str = " a "; res = StringUtils.split(str); assertEquals(1, res.length); assertEquals("a", res[0]); str = "a" + WHITESPACE + "b" + NON_WHITESPACE + "c"; res = StringUtils.split(str); assertEquals(2, res.length); assertEquals("a", res[0]); assertEquals("b" + NON_WHITESPACE + "c", res[1]); } @Test public void testSplit_StringChar() { assertArrayEquals(null, StringUtils.split(null, '.')); assertEquals(0, StringUtils.split("", '.').length); String str = "a.b.. c"; String[] res = StringUtils.split(str, '.'); assertEquals(3, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals(" c", res[2]); str = ".a."; res = StringUtils.split(str, '.'); assertEquals(1, res.length); assertEquals("a", res[0]); str = "a b c"; res = StringUtils.split(str,' '); assertEquals(3, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals("c", res[2]); } @Test public void testSplit_StringString_StringStringInt() { assertArrayEquals(null, StringUtils.split(null, ".")); assertArrayEquals(null, StringUtils.split(null, ".", 3)); assertEquals(0, StringUtils.split("", ".").length); assertEquals(0, StringUtils.split("", ".", 3).length); innerTestSplit('.', ".", ' '); innerTestSplit('.', ".", ','); innerTestSplit('.', ".,", 'x'); for (int i = 0; i < WHITESPACE.length(); i++) { for (int j = 0; j < NON_WHITESPACE.length(); j++) { innerTestSplit(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); innerTestSplit(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); } } String[] results; final String[] expectedResults = {"ab", "de fg"}; results = StringUtils.split("ab de fg", null, 2); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } final String[] expectedResults2 = {"ab", "cd:ef"}; results = StringUtils.split("ab:cd:ef",":", 2); assertEquals(expectedResults2.length, results.length); for (int i = 0; i < expectedResults2.length; i++) { assertEquals(expectedResults2[i], results[i]); } } private void innerTestSplit(final char separator, final String sepStr, final char noMatch) { final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; String[] res; // (str, sepStr) res = StringUtils.split(str, sepStr); assertEquals(msg, 3, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, "b", res[1]); assertEquals(msg, noMatch + "c", res[2]); final String str2 = separator + "a" + separator; res = StringUtils.split(str2, sepStr); assertEquals(msg, 1, res.length); assertEquals(msg, "a", res[0]); res = StringUtils.split(str, sepStr, -1); assertEquals(msg, 3, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, "b", res[1]); assertEquals(msg, noMatch + "c", res[2]); res = StringUtils.split(str, sepStr, 0); assertEquals(msg, 3, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, "b", res[1]); assertEquals(msg, noMatch + "c", res[2]); res = StringUtils.split(str, sepStr, 1); assertEquals(msg, 1, res.length); assertEquals(msg, str, res[0]); res = StringUtils.split(str, sepStr, 2); assertEquals(msg, 2, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, str.substring(2), res[1]); } @Test public void testSplitByWholeString_StringStringBoolean() { assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, "." ) ) ; assertEquals( 0, StringUtils.splitByWholeSeparator( "", "." ).length ) ; final String stringToSplitOnNulls = "ab de fg" ; final String[] splitOnNullExpectedResults = { "ab", "de", "fg" } ; final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ; assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; } final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously" ; final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy" ) ; assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) { assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; } final String[] splitWithMultipleSeparatorExpectedResults = {"ab", "cd", "ef"}; final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator("ab:cd::ef", ":"); assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length ); for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) { assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ; } } @Test public void testSplitByWholeString_StringStringBooleanInt() { assertArrayEquals( null, StringUtils.splitByWholeSeparator( null, ".", 3 ) ) ; assertEquals( 0, StringUtils.splitByWholeSeparator( "", ".", 3 ).length ) ; final String stringToSplitOnNulls = "ab de fg" ; final String[] splitOnNullExpectedResults = { "ab", "de fg" } ; //String[] splitOnNullExpectedResults = { "ab", "de" } ; final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ; assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ; for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) { assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ; } final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously" ; final String[] splitOnStringExpectedResults = { "abstemiously", "abstemiouslyaeiouyabstemiously" } ; //String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ; final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, "aeiouy", 2 ) ; assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ; for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i++ ) { assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ; } } @Test public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() { assertArrayEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, ".", -1 ) ) ; assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( "", ".", -1 ).length ) ; // test whitespace String input = "ab de fg" ; String[] expected = new String[] { "ab", "", "", "de", "fg" } ; String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ; assertEquals( expected.length, actual.length ) ; for ( int i = 0 ; i < actual.length ; i+= 1 ) { assertEquals( expected[i], actual[i] ); } // test delimiter singlechar input = "1::2:::3::::4"; expected = new String[] { "1", "", "2", "", "", "3", "", "", "", "4" }; actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", -1 ) ; assertEquals( expected.length, actual.length ) ; for ( int i = 0 ; i < actual.length ; i+= 1 ) { assertEquals( expected[i], actual[i] ); } // test delimiter multichar input = "1::2:::3::::4"; expected = new String[] { "1", "2", ":3", "", "4" }; actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, "::", -1 ) ; assertEquals( expected.length, actual.length ) ; for ( int i = 0 ; i < actual.length ; i+= 1 ) { assertEquals( expected[i], actual[i] ); } // test delimiter char with max input = "1::2::3:4"; expected = new String[] { "1", "", "2", ":3:4" }; actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, ":", 4 ) ; assertEquals( expected.length, actual.length ) ; for ( int i = 0 ; i < actual.length ; i+= 1 ) { assertEquals( expected[i], actual[i] ); } } @Test public void testSplitPreserveAllTokens_String() { assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null)); assertEquals(0, StringUtils.splitPreserveAllTokens("").length); String str = "abc def"; String[] res = StringUtils.splitPreserveAllTokens(str); assertEquals(2, res.length); assertEquals("abc", res[0]); assertEquals("def", res[1]); str = "abc def"; res = StringUtils.splitPreserveAllTokens(str); assertEquals(3, res.length); assertEquals("abc", res[0]); assertEquals("", res[1]); assertEquals("def", res[2]); str = " abc "; res = StringUtils.splitPreserveAllTokens(str); assertEquals(3, res.length); assertEquals("", res[0]); assertEquals("abc", res[1]); assertEquals("", res[2]); str = "a b .c"; res = StringUtils.splitPreserveAllTokens(str); assertEquals(3, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals(".c", res[2]); str = " a b .c"; res = StringUtils.splitPreserveAllTokens(str); assertEquals(4, res.length); assertEquals("", res[0]); assertEquals("a", res[1]); assertEquals("b", res[2]); assertEquals(".c", res[3]); str = "a b .c"; res = StringUtils.splitPreserveAllTokens(str); assertEquals(5, res.length); assertEquals("a", res[0]); assertEquals("", res[1]); assertEquals("b", res[2]); assertEquals("", res[3]); assertEquals(".c", res[4]); str = " a "; res = StringUtils.splitPreserveAllTokens(str); assertEquals(4, res.length); assertEquals("", res[0]); assertEquals("a", res[1]); assertEquals("", res[2]); assertEquals("", res[3]); str = " a b"; res = StringUtils.splitPreserveAllTokens(str); assertEquals(4, res.length); assertEquals("", res[0]); assertEquals("a", res[1]); assertEquals("", res[2]); assertEquals("b", res[3]); str = "a" + WHITESPACE + "b" + NON_WHITESPACE + "c"; res = StringUtils.splitPreserveAllTokens(str); assertEquals(WHITESPACE.length() + 1, res.length); assertEquals("a", res[0]); for(int i = 1; i < WHITESPACE.length()-1; i++) { assertEquals("", res[i]); } assertEquals("b" + NON_WHITESPACE + "c", res[WHITESPACE.length()]); } @Test public void testSplitPreserveAllTokens_StringChar() { assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, '.')); assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length); String str = "a.b. c"; String[] res = StringUtils.splitPreserveAllTokens(str, '.'); assertEquals(3, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals(" c", res[2]); str = "a.b.. c"; res = StringUtils.splitPreserveAllTokens(str, '.'); assertEquals(4, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals("", res[2]); assertEquals(" c", res[3]); str = ".a."; res = StringUtils.splitPreserveAllTokens(str, '.'); assertEquals(3, res.length); assertEquals("", res[0]); assertEquals("a", res[1]); assertEquals("", res[2]); str = ".a.."; res = StringUtils.splitPreserveAllTokens(str, '.'); assertEquals(4, res.length); assertEquals("", res[0]); assertEquals("a", res[1]); assertEquals("", res[2]); assertEquals("", res[3]); str = "..a."; res = StringUtils.splitPreserveAllTokens(str, '.'); assertEquals(4, res.length); assertEquals("", res[0]); assertEquals("", res[1]); assertEquals("a", res[2]); assertEquals("", res[3]); str = "..a"; res = StringUtils.splitPreserveAllTokens(str, '.'); assertEquals(3, res.length); assertEquals("", res[0]); assertEquals("", res[1]); assertEquals("a", res[2]); str = "a b c"; res = StringUtils.splitPreserveAllTokens(str,' '); assertEquals(3, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals("c", res[2]); str = "a b c"; res = StringUtils.splitPreserveAllTokens(str,' '); assertEquals(5, res.length); assertEquals("a", res[0]); assertEquals("", res[1]); assertEquals("b", res[2]); assertEquals("", res[3]); assertEquals("c", res[4]); str = " a b c"; res = StringUtils.splitPreserveAllTokens(str,' '); assertEquals(4, res.length); assertEquals("", res[0]); assertEquals("a", res[1]); assertEquals("b", res[2]); assertEquals("c", res[3]); str = " a b c"; res = StringUtils.splitPreserveAllTokens(str,' '); assertEquals(5, res.length); assertEquals("", res[0]); assertEquals("", res[1]); assertEquals("a", res[2]); assertEquals("b", res[3]); assertEquals("c", res[4]); str = "a b c "; res = StringUtils.splitPreserveAllTokens(str,' '); assertEquals(4, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals("c", res[2]); assertEquals("", res[3]); str = "a b c "; res = StringUtils.splitPreserveAllTokens(str,' '); assertEquals(5, res.length); assertEquals("a", res[0]); assertEquals("b", res[1]); assertEquals("c", res[2]); assertEquals("", res[3]); assertEquals("", res[3]); // Match example in javadoc { String[] results; final String[] expectedResults = {"a", "", "b", "c"}; results = StringUtils.splitPreserveAllTokens("a..b.c",'.'); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } } @Test public void testSplitPreserveAllTokens_StringString_StringStringInt() { assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".")); assertArrayEquals(null, StringUtils.splitPreserveAllTokens(null, ".", 3)); assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length); assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length); innerTestSplitPreserveAllTokens('.', ".", ' '); innerTestSplitPreserveAllTokens('.', ".", ','); innerTestSplitPreserveAllTokens('.', ".,", 'x'); for (int i = 0; i < WHITESPACE.length(); i++) { for (int j = 0; j < NON_WHITESPACE.length(); j++) { innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j)); innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j)); } } { String[] results; final String[] expectedResults = {"ab", "de fg"}; results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", " de fg"}; results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", "::de:fg"}; results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", "", " de fg"}; results = StringUtils.splitPreserveAllTokens("ab de fg", null, 3); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", "", "", "de fg"}; results = StringUtils.splitPreserveAllTokens("ab de fg", null, 4); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { final String[] expectedResults = {"ab", "cd:ef"}; String[] results; results = StringUtils.splitPreserveAllTokens("ab:cd:ef",":", 2); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", ":cd:ef"}; results = StringUtils.splitPreserveAllTokens("ab::cd:ef",":", 2); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", "", ":cd:ef"}; results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 3); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"ab", "", "", "cd:ef"}; results = StringUtils.splitPreserveAllTokens("ab:::cd:ef",":", 4); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"", "ab", "", "", "cd:ef"}; results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef",":", 5); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } { String[] results; final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"}; results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef",":", 6); assertEquals(expectedResults.length, results.length); for (int i = 0; i < expectedResults.length; i++) { assertEquals(expectedResults[i], results[i]); } } } private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) { final String msg = "Failed on separator hex(" + Integer.toHexString(separator) + "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")"; final String str = "a" + separator + "b" + separator + separator + noMatch + "c"; String[] res; // (str, sepStr) res = StringUtils.splitPreserveAllTokens(str, sepStr); assertEquals(msg, 4, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, "b", res[1]); assertEquals(msg, "", res[2]); assertEquals(msg, noMatch + "c", res[3]); final String str2 = separator + "a" + separator; res = StringUtils.splitPreserveAllTokens(str2, sepStr); assertEquals(msg, 3, res.length); assertEquals(msg, "", res[0]); assertEquals(msg, "a", res[1]); assertEquals(msg, "", res[2]); res = StringUtils.splitPreserveAllTokens(str, sepStr, -1); assertEquals(msg, 4, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, "b", res[1]); assertEquals(msg, "", res[2]); assertEquals(msg, noMatch + "c", res[3]); res = StringUtils.splitPreserveAllTokens(str, sepStr, 0); assertEquals(msg, 4, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, "b", res[1]); assertEquals(msg, "", res[2]); assertEquals(msg, noMatch + "c", res[3]); res = StringUtils.splitPreserveAllTokens(str, sepStr, 1); assertEquals(msg, 1, res.length); assertEquals(msg, str, res[0]); res = StringUtils.splitPreserveAllTokens(str, sepStr, 2); assertEquals(msg, 2, res.length); assertEquals(msg, "a", res[0]); assertEquals(msg, str.substring(2), res[1]); } @Test public void testSplitByCharacterType() { assertNull(StringUtils.splitByCharacterType(null)); assertEquals(0, StringUtils.splitByCharacterType("").length); assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitByCharacterType("ab de fg"))); assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitByCharacterType("ab de fg"))); assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitByCharacterType("ab:cd:ef"))); assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitByCharacterType("number5"))); assertTrue(ArrayUtils.isEquals(new String[] { "foo", "B", "ar" }, StringUtils.splitByCharacterType("fooBar"))); assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "B", "ar" }, StringUtils.splitByCharacterType("foo200Bar"))); assertTrue(ArrayUtils.isEquals(new String[] { "ASFR", "ules" }, StringUtils.splitByCharacterType("ASFRules"))); } @Test public void testSplitByCharacterTypeCamelCase() { assertNull(StringUtils.splitByCharacterTypeCamelCase(null)); assertEquals(0, StringUtils.splitByCharacterTypeCamelCase("").length); assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitByCharacterTypeCamelCase("ab de fg"))); assertTrue(ArrayUtils.isEquals(new String[] { "ab", " ", "de", " ", "fg" }, StringUtils.splitByCharacterTypeCamelCase("ab de fg"))); assertTrue(ArrayUtils.isEquals(new String[] { "ab", ":", "cd", ":", "ef" }, StringUtils.splitByCharacterTypeCamelCase("ab:cd:ef"))); assertTrue(ArrayUtils.isEquals(new String[] { "number", "5" }, StringUtils.splitByCharacterTypeCamelCase("number5"))); assertTrue(ArrayUtils.isEquals(new String[] { "foo", "Bar" }, StringUtils.splitByCharacterTypeCamelCase("fooBar"))); assertTrue(ArrayUtils.isEquals(new String[] { "foo", "200", "Bar" }, StringUtils.splitByCharacterTypeCamelCase("foo200Bar"))); assertTrue(ArrayUtils.isEquals(new String[] { "ASF", "Rules" }, StringUtils.splitByCharacterTypeCamelCase("ASFRules"))); } @Test public void testDeleteWhitespace_String() { assertEquals(null, StringUtils.deleteWhitespace(null)); assertEquals("", StringUtils.deleteWhitespace("")); assertEquals("", StringUtils.deleteWhitespace(" \u000C \t\t\u001F\n\n \u000B ")); assertEquals("", StringUtils.deleteWhitespace(StringUtilsTest.WHITESPACE)); assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.deleteWhitespace(StringUtilsTest.NON_WHITESPACE)); // Note: u-2007 and u-000A both cause problems in the source code // it should ignore 2007 but delete 000A assertEquals("\u00A0\u202F", StringUtils.deleteWhitespace(" \u00A0 \t\t\n\n \u202F ")); assertEquals("\u00A0\u202F", StringUtils.deleteWhitespace("\u00A0\u202F")); assertEquals("test", StringUtils.deleteWhitespace("\u000Bt \t\n\u0009e\rs\n\n \tt")); } @Test public void testLang623() { assertEquals("t", StringUtils.replaceChars("\u00DE", '\u00DE', 't')); assertEquals("t", StringUtils.replaceChars("\u00FE", '\u00FE', 't')); } @Test public void testReplace_StringStringString() { assertEquals(null, StringUtils.replace(null, null, null)); assertEquals(null, StringUtils.replace(null, null, "any")); assertEquals(null, StringUtils.replace(null, "any", null)); assertEquals(null, StringUtils.replace(null, "any", "any")); assertEquals("", StringUtils.replace("", null, null)); assertEquals("", StringUtils.replace("", null, "any")); assertEquals("", StringUtils.replace("", "any", null)); assertEquals("", StringUtils.replace("", "any", "any")); assertEquals("FOO", StringUtils.replace("FOO", "", "any")); assertEquals("FOO", StringUtils.replace("FOO", null, "any")); assertEquals("FOO", StringUtils.replace("FOO", "F", null)); assertEquals("FOO", StringUtils.replace("FOO", null, null)); assertEquals("", StringUtils.replace("foofoofoo", "foo", "")); assertEquals("barbarbar", StringUtils.replace("foofoofoo", "foo", "bar")); assertEquals("farfarfar", StringUtils.replace("foofoofoo", "oo", "ar")); } @Test public void testReplacePattern() { assertEquals("X", StringUtils.replacePattern("<A>\nxy\n</A>", "<A>.*</A>", "X")); } @Test public void testRemovePattern() { assertEquals("", StringUtils.removePattern("<A>x\\ny</A>", "<A>.*</A>")); } @Test public void testReplace_StringStringStringInt() { assertEquals(null, StringUtils.replace(null, null, null, 2)); assertEquals(null, StringUtils.replace(null, null, "any", 2)); assertEquals(null, StringUtils.replace(null, "any", null, 2)); assertEquals(null, StringUtils.replace(null, "any", "any", 2)); assertEquals("", StringUtils.replace("", null, null, 2)); assertEquals("", StringUtils.replace("", null, "any", 2)); assertEquals("", StringUtils.replace("", "any", null, 2)); assertEquals("", StringUtils.replace("", "any", "any", 2)); final String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'}); assertSame(str, StringUtils.replace(str, "x", "", -1)); assertEquals("f", StringUtils.replace("oofoo", "o", "", -1)); assertEquals("oofoo", StringUtils.replace("oofoo", "o", "", 0)); assertEquals("ofoo", StringUtils.replace("oofoo", "o", "", 1)); assertEquals("foo", StringUtils.replace("oofoo", "o", "", 2)); assertEquals("fo", StringUtils.replace("oofoo", "o", "", 3)); assertEquals("f", StringUtils.replace("oofoo", "o", "", 4)); assertEquals("f", StringUtils.replace("oofoo", "o", "", -5)); assertEquals("f", StringUtils.replace("oofoo", "o", "", 1000)); } @Test public void testReplaceOnce_StringStringString() { assertEquals(null, StringUtils.replaceOnce(null, null, null)); assertEquals(null, StringUtils.replaceOnce(null, null, "any")); assertEquals(null, StringUtils.replaceOnce(null, "any", null)); assertEquals(null, StringUtils.replaceOnce(null, "any", "any")); assertEquals("", StringUtils.replaceOnce("", null, null)); assertEquals("", StringUtils.replaceOnce("", null, "any")); assertEquals("", StringUtils.replaceOnce("", "any", null)); assertEquals("", StringUtils.replaceOnce("", "any", "any")); assertEquals("FOO", StringUtils.replaceOnce("FOO", "", "any")); assertEquals("FOO", StringUtils.replaceOnce("FOO", null, "any")); assertEquals("FOO", StringUtils.replaceOnce("FOO", "F", null)); assertEquals("FOO", StringUtils.replaceOnce("FOO", null, null)); assertEquals("foofoo", StringUtils.replaceOnce("foofoofoo", "foo", "")); } /** * Test method for 'StringUtils.replaceEach(String, String[], String[])' */ @Test public void testReplace_StringStringArrayStringArray() { //JAVADOC TESTS START assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"})); assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}),""); assertEquals(StringUtils.replaceEach("aba", null, null),"aba"); assertEquals(StringUtils.replaceEach("aba", new String[0], null),"aba"); assertEquals(StringUtils.replaceEach("aba", null, new String[0]),"aba"); assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null),"aba"); assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}),"b"); assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}),"aba"); assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"dcte"); //JAVADOC TESTS END assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"})); assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren", new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"})); // Test null safety inside arrays - LANG-552 assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}),"aba"); assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}),"cbc"); } /** * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])' */ @Test public void testReplace_StringStringArrayStringArrayBoolean() { //JAVADOC TESTS START assertNull(StringUtils.replaceEachRepeatedly(null, new String[]{"a"}, new String[]{"b"})); assertEquals(StringUtils.replaceEachRepeatedly("", new String[]{"a"}, new String[]{"b"}),""); assertEquals(StringUtils.replaceEachRepeatedly("aba", null, null),"aba"); assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[0], null),"aba"); assertEquals(StringUtils.replaceEachRepeatedly("aba", null, new String[0]),"aba"); assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[0], null),"aba"); assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[]{"a"}, new String[]{""}),"b"); assertEquals(StringUtils.replaceEachRepeatedly("aba", new String[]{null}, new String[]{"a"}),"aba"); assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}),"wcte"); assertEquals(StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}),"tcte"); try { StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}); fail("Should be a circular reference"); } catch (final IllegalStateException e) {} //JAVADOC TESTS END } @Test public void testReplaceChars_StringCharChar() { assertEquals(null, StringUtils.replaceChars(null, 'b', 'z')); assertEquals("", StringUtils.replaceChars("", 'b', 'z')); assertEquals("azcza", StringUtils.replaceChars("abcba", 'b', 'z')); assertEquals("abcba", StringUtils.replaceChars("abcba", 'x', 'z')); } @Test public void testReplaceChars_StringStringString() { assertEquals(null, StringUtils.replaceChars(null, null, null)); assertEquals(null, StringUtils.replaceChars(null, "", null)); assertEquals(null, StringUtils.replaceChars(null, "a", null)); assertEquals(null, StringUtils.replaceChars(null, null, "")); assertEquals(null, StringUtils.replaceChars(null, null, "x")); assertEquals("", StringUtils.replaceChars("", null, null)); assertEquals("", StringUtils.replaceChars("", "", null)); assertEquals("", StringUtils.replaceChars("", "a", null)); assertEquals("", StringUtils.replaceChars("", null, "")); assertEquals("", StringUtils.replaceChars("", null, "x")); assertEquals("abc", StringUtils.replaceChars("abc", null, null)); assertEquals("abc", StringUtils.replaceChars("abc", null, "")); assertEquals("abc", StringUtils.replaceChars("abc", null, "x")); assertEquals("abc", StringUtils.replaceChars("abc", "", null)); assertEquals("abc", StringUtils.replaceChars("abc", "", "")); assertEquals("abc", StringUtils.replaceChars("abc", "", "x")); assertEquals("ac", StringUtils.replaceChars("abc", "b", null)); assertEquals("ac", StringUtils.replaceChars("abc", "b", "")); assertEquals("axc", StringUtils.replaceChars("abc", "b", "x")); assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz")); assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y")); assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx")); assertEquals("abcba", StringUtils.replaceChars("abcba", "z", "w")); assertSame("abcba", StringUtils.replaceChars("abcba", "z", "w")); // Javadoc examples: assertEquals("jelly", StringUtils.replaceChars("hello", "ho", "jy")); assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz")); assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y")); assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx")); // From http://issues.apache.org/bugzilla/show_bug.cgi?id=25454 assertEquals("bcc", StringUtils.replaceChars("abc", "ab", "bc")); assertEquals("q651.506bera", StringUtils.replaceChars("d216.102oren", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789", "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234")); } @Test public void testOverlay_StringStringIntInt() { assertEquals(null, StringUtils.overlay(null, null, 2, 4)); assertEquals(null, StringUtils.overlay(null, null, -2, -4)); assertEquals("", StringUtils.overlay("", null, 0, 0)); assertEquals("", StringUtils.overlay("", "", 0, 0)); assertEquals("zzzz", StringUtils.overlay("", "zzzz", 0, 0)); assertEquals("zzzz", StringUtils.overlay("", "zzzz", 2, 4)); assertEquals("zzzz", StringUtils.overlay("", "zzzz", -2, -4)); assertEquals("abef", StringUtils.overlay("abcdef", null, 2, 4)); assertEquals("abef", StringUtils.overlay("abcdef", null, 4, 2)); assertEquals("abef", StringUtils.overlay("abcdef", "", 2, 4)); assertEquals("abef", StringUtils.overlay("abcdef", "", 4, 2)); assertEquals("abzzzzef", StringUtils.overlay("abcdef", "zzzz", 2, 4)); assertEquals("abzzzzef", StringUtils.overlay("abcdef", "zzzz", 4, 2)); assertEquals("zzzzef", StringUtils.overlay("abcdef", "zzzz", -1, 4)); assertEquals("zzzzef", StringUtils.overlay("abcdef", "zzzz", 4, -1)); assertEquals("zzzzabcdef", StringUtils.overlay("abcdef", "zzzz", -2, -1)); assertEquals("zzzzabcdef", StringUtils.overlay("abcdef", "zzzz", -1, -2)); assertEquals("abcdzzzz", StringUtils.overlay("abcdef", "zzzz", 4, 10)); assertEquals("abcdzzzz", StringUtils.overlay("abcdef", "zzzz", 10, 4)); assertEquals("abcdefzzzz", StringUtils.overlay("abcdef", "zzzz", 8, 10)); assertEquals("abcdefzzzz", StringUtils.overlay("abcdef", "zzzz", 10, 8)); } @Test public void testRepeat_StringInt() { assertEquals(null, StringUtils.repeat(null, 2)); assertEquals("", StringUtils.repeat("ab", 0)); assertEquals("", StringUtils.repeat("", 3)); assertEquals("aaa", StringUtils.repeat("a", 3)); assertEquals("ababab", StringUtils.repeat("ab", 3)); assertEquals("abcabcabc", StringUtils.repeat("abc", 3)); final String str = StringUtils.repeat("a", 10000); // bigger than pad limit assertEquals(10000, str.length()); assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); } @Test public void testRepeat_StringStringInt() { assertEquals(null, StringUtils.repeat(null, null, 2)); assertEquals(null, StringUtils.repeat(null, "x", 2)); assertEquals("", StringUtils.repeat("", null, 2)); assertEquals("", StringUtils.repeat("ab", "", 0)); assertEquals("", StringUtils.repeat("", "", 2)); assertEquals("xx", StringUtils.repeat("", "x", 3)); assertEquals("?, ?, ?", StringUtils.repeat("?", ", ", 3)); } @Test public void testChop() { final String[][] chopCases = { { FOO_UNCAP + "\r\n", FOO_UNCAP } , { FOO_UNCAP + "\n" , FOO_UNCAP } , { FOO_UNCAP + "\r", FOO_UNCAP }, { FOO_UNCAP + " \r", FOO_UNCAP + " " }, { "foo", "fo"}, { "foo\nfoo", "foo\nfo" }, { "\n", "" }, { "\r", "" }, { "\r\n", "" }, { null, null }, { "", "" }, { "a", "" }, }; for (final String[] chopCase : chopCases) { final String original = chopCase[0]; final String expectedResult = chopCase[1]; assertEquals("chop(String) failed", expectedResult, StringUtils.chop(original)); } } @SuppressWarnings("deprecation") // intentional test of deprecated method @Test public void testChomp() { final String[][] chompCases = { { FOO_UNCAP + "\r\n", FOO_UNCAP }, { FOO_UNCAP + "\n" , FOO_UNCAP }, { FOO_UNCAP + "\r", FOO_UNCAP }, { FOO_UNCAP + " \r", FOO_UNCAP + " " }, { FOO_UNCAP, FOO_UNCAP }, { FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"}, { FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n" }, { "foo\nfoo", "foo\nfoo" }, { "foo\n\rfoo", "foo\n\rfoo" }, { "\n", "" }, { "\r", "" }, { "a", "a" }, { "\r\n", "" }, { "", "" }, { null, null }, { FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"} }; for (final String[] chompCase : chompCases) { final String original = chompCase[0]; final String expectedResult = chompCase[1]; assertEquals("chomp(String) failed", expectedResult, StringUtils.chomp(original)); } assertEquals("chomp(String, String) failed", "foo", StringUtils.chomp("foobar", "bar")); assertEquals("chomp(String, String) failed", "foobar", StringUtils.chomp("foobar", "baz")); assertEquals("chomp(String, String) failed", "foo", StringUtils.chomp("foo", "foooo")); assertEquals("chomp(String, String) failed", "foobar", StringUtils.chomp("foobar", "")); assertEquals("chomp(String, String) failed", "foobar", StringUtils.chomp("foobar", null)); assertEquals("chomp(String, String) failed", "", StringUtils.chomp("", "foo")); assertEquals("chomp(String, String) failed", "", StringUtils.chomp("", null)); assertEquals("chomp(String, String) failed", "", StringUtils.chomp("", "")); assertEquals("chomp(String, String) failed", null, StringUtils.chomp(null, "foo")); assertEquals("chomp(String, String) failed", null, StringUtils.chomp(null, null)); assertEquals("chomp(String, String) failed", null, StringUtils.chomp(null, "")); assertEquals("chomp(String, String) failed", "", StringUtils.chomp("foo", "foo")); assertEquals("chomp(String, String) failed", " ", StringUtils.chomp(" foo", "foo")); assertEquals("chomp(String, String) failed", "foo ", StringUtils.chomp("foo ", "foo")); } //----------------------------------------------------------------------- @Test public void testRightPad_StringInt() { assertEquals(null, StringUtils.rightPad(null, 5)); assertEquals(" ", StringUtils.rightPad("", 5)); assertEquals("abc ", StringUtils.rightPad("abc", 5)); assertEquals("abc", StringUtils.rightPad("abc", 2)); assertEquals("abc", StringUtils.rightPad("abc", -1)); } @Test public void testRightPad_StringIntChar() { assertEquals(null, StringUtils.rightPad(null, 5, ' ')); assertEquals(" ", StringUtils.rightPad("", 5, ' ')); assertEquals("abc ", StringUtils.rightPad("abc", 5, ' ')); assertEquals("abc", StringUtils.rightPad("abc", 2, ' ')); assertEquals("abc", StringUtils.rightPad("abc", -1, ' ')); assertEquals("abcxx", StringUtils.rightPad("abc", 5, 'x')); final String str = StringUtils.rightPad("aaa", 10000, 'a'); // bigger than pad length assertEquals(10000, str.length()); assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); } @Test public void testRightPad_StringIntString() { assertEquals(null, StringUtils.rightPad(null, 5, "-+")); assertEquals(" ", StringUtils.rightPad("", 5, " ")); assertEquals(null, StringUtils.rightPad(null, 8, null)); assertEquals("abc-+-+", StringUtils.rightPad("abc", 7, "-+")); assertEquals("abc-+~", StringUtils.rightPad("abc", 6, "-+~")); assertEquals("abc-+", StringUtils.rightPad("abc", 5, "-+~")); assertEquals("abc", StringUtils.rightPad("abc", 2, " ")); assertEquals("abc", StringUtils.rightPad("abc", -1, " ")); assertEquals("abc ", StringUtils.rightPad("abc", 5, null)); assertEquals("abc ", StringUtils.rightPad("abc", 5, "")); } //----------------------------------------------------------------------- @Test public void testLeftPad_StringInt() { assertEquals(null, StringUtils.leftPad(null, 5)); assertEquals(" ", StringUtils.leftPad("", 5)); assertEquals(" abc", StringUtils.leftPad("abc", 5)); assertEquals("abc", StringUtils.leftPad("abc", 2)); } @Test public void testLeftPad_StringIntChar() { assertEquals(null, StringUtils.leftPad(null, 5, ' ')); assertEquals(" ", StringUtils.leftPad("", 5, ' ')); assertEquals(" abc", StringUtils.leftPad("abc", 5, ' ')); assertEquals("xxabc", StringUtils.leftPad("abc", 5, 'x')); assertEquals("\uffff\uffffabc", StringUtils.leftPad("abc", 5, '\uffff')); assertEquals("abc", StringUtils.leftPad("abc", 2, ' ')); final String str = StringUtils.leftPad("aaa", 10000, 'a'); // bigger than pad length assertEquals(10000, str.length()); assertTrue(StringUtils.containsOnly(str, new char[] {'a'})); } @Test public void testLeftPad_StringIntString() { assertEquals(null, StringUtils.leftPad(null, 5, "-+")); assertEquals(null, StringUtils.leftPad(null, 5, null)); assertEquals(" ", StringUtils.leftPad("", 5, " ")); assertEquals("-+-+abc", StringUtils.leftPad("abc", 7, "-+")); assertEquals("-+~abc", StringUtils.leftPad("abc", 6, "-+~")); assertEquals("-+abc", StringUtils.leftPad("abc", 5, "-+~")); assertEquals("abc", StringUtils.leftPad("abc", 2, " ")); assertEquals("abc", StringUtils.leftPad("abc", -1, " ")); assertEquals(" abc", StringUtils.leftPad("abc", 5, null)); assertEquals(" abc", StringUtils.leftPad("abc", 5, "")); } @Test public void testLengthString() { assertEquals(0, StringUtils.length(null)); assertEquals(0, StringUtils.length("")); assertEquals(0, StringUtils.length(StringUtils.EMPTY)); assertEquals(1, StringUtils.length("A")); assertEquals(1, StringUtils.length(" ")); assertEquals(8, StringUtils.length("ABCDEFGH")); } @Test public void testLengthStringBuffer() { assertEquals(0, StringUtils.length(new StringBuffer(""))); assertEquals(0, StringUtils.length(new StringBuffer(StringUtils.EMPTY))); assertEquals(1, StringUtils.length(new StringBuffer("A"))); assertEquals(1, StringUtils.length(new StringBuffer(" "))); assertEquals(8, StringUtils.length(new StringBuffer("ABCDEFGH"))); } @Test public void testLengthStringBuilder() { assertEquals(0, StringUtils.length(new StringBuilder(""))); assertEquals(0, StringUtils.length(new StringBuilder(StringUtils.EMPTY))); assertEquals(1, StringUtils.length(new StringBuilder("A"))); assertEquals(1, StringUtils.length(new StringBuilder(" "))); assertEquals(8, StringUtils.length(new StringBuilder("ABCDEFGH"))); } @Test public void testLength_CharBuffer() { assertEquals(0, StringUtils.length(CharBuffer.wrap(""))); assertEquals(1, StringUtils.length(CharBuffer.wrap("A"))); assertEquals(1, StringUtils.length(CharBuffer.wrap(" "))); assertEquals(8, StringUtils.length(CharBuffer.wrap("ABCDEFGH"))); } //----------------------------------------------------------------------- @Test public void testCenter_StringInt() { assertEquals(null, StringUtils.center(null, -1)); assertEquals(null, StringUtils.center(null, 4)); assertEquals(" ", StringUtils.center("", 4)); assertEquals("ab", StringUtils.center("ab", 0)); assertEquals("ab", StringUtils.center("ab", -1)); assertEquals("ab", StringUtils.center("ab", 1)); assertEquals(" ", StringUtils.center("", 4)); assertEquals(" ab ", StringUtils.center("ab", 4)); assertEquals("abcd", StringUtils.center("abcd", 2)); assertEquals(" a ", StringUtils.center("a", 4)); assertEquals(" a ", StringUtils.center("a", 5)); } @Test public void testCenter_StringIntChar() { assertEquals(null, StringUtils.center(null, -1, ' ')); assertEquals(null, StringUtils.center(null, 4, ' ')); assertEquals(" ", StringUtils.center("", 4, ' ')); assertEquals("ab", StringUtils.center("ab", 0, ' ')); assertEquals("ab", StringUtils.center("ab", -1, ' ')); assertEquals("ab", StringUtils.center("ab", 1, ' ')); assertEquals(" ", StringUtils.center("", 4, ' ')); assertEquals(" ab ", StringUtils.center("ab", 4, ' ')); assertEquals("abcd", StringUtils.center("abcd", 2, ' ')); assertEquals(" a ", StringUtils.center("a", 4, ' ')); assertEquals(" a ", StringUtils.center("a", 5, ' ')); assertEquals("xxaxx", StringUtils.center("a", 5, 'x')); } @Test public void testCenter_StringIntString() { assertEquals(null, StringUtils.center(null, 4, null)); assertEquals(null, StringUtils.center(null, -1, " ")); assertEquals(null, StringUtils.center(null, 4, " ")); assertEquals(" ", StringUtils.center("", 4, " ")); assertEquals("ab", StringUtils.center("ab", 0, " ")); assertEquals("ab", StringUtils.center("ab", -1, " ")); assertEquals("ab", StringUtils.center("ab", 1, " ")); assertEquals(" ", StringUtils.center("", 4, " ")); assertEquals(" ab ", StringUtils.center("ab", 4, " ")); assertEquals("abcd", StringUtils.center("abcd", 2, " ")); assertEquals(" a ", StringUtils.center("a", 4, " ")); assertEquals("yayz", StringUtils.center("a", 4, "yz")); assertEquals("yzyayzy", StringUtils.center("a", 7, "yz")); assertEquals(" abc ", StringUtils.center("abc", 7, null)); assertEquals(" abc ", StringUtils.center("abc", 7, "")); } //----------------------------------------------------------------------- @Test public void testReverse_String() { assertEquals(null, StringUtils.reverse(null) ); assertEquals("", StringUtils.reverse("") ); assertEquals("sdrawkcab", StringUtils.reverse("backwards") ); } @Test public void testReverseDelimited_StringChar() { assertEquals(null, StringUtils.reverseDelimited(null, '.') ); assertEquals("", StringUtils.reverseDelimited("", '.') ); assertEquals("c.b.a", StringUtils.reverseDelimited("a.b.c", '.') ); assertEquals("a b c", StringUtils.reverseDelimited("a b c", '.') ); assertEquals("", StringUtils.reverseDelimited("", '.') ); } //----------------------------------------------------------------------- @Test public void testDefault_String() { assertEquals("", StringUtils.defaultString(null)); assertEquals("", StringUtils.defaultString("")); assertEquals("abc", StringUtils.defaultString("abc")); } @Test public void testDefault_StringString() { assertEquals("NULL", StringUtils.defaultString(null, "NULL")); assertEquals("", StringUtils.defaultString("", "NULL")); assertEquals("abc", StringUtils.defaultString("abc", "NULL")); } @Test public void testDefaultIfEmpty_StringString() { assertEquals("NULL", StringUtils.defaultIfEmpty(null, "NULL")); assertEquals("NULL", StringUtils.defaultIfEmpty("", "NULL")); assertEquals("abc", StringUtils.defaultIfEmpty("abc", "NULL")); assertNull(StringUtils.defaultIfEmpty("", null)); // Tests compatibility for the API return type final String s = StringUtils.defaultIfEmpty("abc", "NULL"); assertEquals("abc", s); } @Test public void testDefaultIfBlank_StringString() { assertEquals("NULL", StringUtils.defaultIfBlank(null, "NULL")); assertEquals("NULL", StringUtils.defaultIfBlank("", "NULL")); assertEquals("NULL", StringUtils.defaultIfBlank(" ", "NULL")); assertEquals("abc", StringUtils.defaultIfBlank("abc", "NULL")); assertNull(StringUtils.defaultIfBlank("", null)); // Tests compatibility for the API return type final String s = StringUtils.defaultIfBlank("abc", "NULL"); assertEquals("abc", s); } @Test public void testDefaultIfEmpty_StringBuilders() { assertEquals("NULL", StringUtils.defaultIfEmpty(new StringBuilder(""), new StringBuilder("NULL")).toString()); assertEquals("abc", StringUtils.defaultIfEmpty(new StringBuilder("abc"), new StringBuilder("NULL")).toString()); assertNull(StringUtils.defaultIfEmpty(new StringBuilder(""), null)); // Tests compatibility for the API return type final StringBuilder s = StringUtils.defaultIfEmpty(new StringBuilder("abc"), new StringBuilder("NULL")); assertEquals("abc", s.toString()); } @Test public void testDefaultIfBlank_StringBuilders() { assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuilder(""), new StringBuilder("NULL")).toString()); assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuilder(" "), new StringBuilder("NULL")).toString()); assertEquals("abc", StringUtils.defaultIfBlank(new StringBuilder("abc"), new StringBuilder("NULL")).toString()); assertNull(StringUtils.defaultIfBlank(new StringBuilder(""), null)); // Tests compatibility for the API return type final StringBuilder s = StringUtils.defaultIfBlank(new StringBuilder("abc"), new StringBuilder("NULL")); assertEquals("abc", s.toString()); } @Test public void testDefaultIfEmpty_StringBuffers() { assertEquals("NULL", StringUtils.defaultIfEmpty(new StringBuffer(""), new StringBuffer("NULL")).toString()); assertEquals("abc", StringUtils.defaultIfEmpty(new StringBuffer("abc"), new StringBuffer("NULL")).toString()); assertNull(StringUtils.defaultIfEmpty(new StringBuffer(""), null)); // Tests compatibility for the API return type final StringBuffer s = StringUtils.defaultIfEmpty(new StringBuffer("abc"), new StringBuffer("NULL")); assertEquals("abc", s.toString()); } @Test public void testDefaultIfBlank_StringBuffers() { assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuffer(""), new StringBuffer("NULL")).toString()); assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuffer(" "), new StringBuffer("NULL")).toString()); assertEquals("abc", StringUtils.defaultIfBlank(new StringBuffer("abc"), new StringBuffer("NULL")).toString()); assertNull(StringUtils.defaultIfBlank(new StringBuffer(""), null)); // Tests compatibility for the API return type final StringBuffer s = StringUtils.defaultIfBlank(new StringBuffer("abc"), new StringBuffer("NULL")); assertEquals("abc", s.toString()); } @Test public void testDefaultIfEmpty_CharBuffers() { assertEquals("NULL", StringUtils.defaultIfEmpty(CharBuffer.wrap(""), CharBuffer.wrap("NULL")).toString()); assertEquals("abc", StringUtils.defaultIfEmpty(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL")).toString()); assertNull(StringUtils.defaultIfEmpty(CharBuffer.wrap(""), null)); // Tests compatibility for the API return type final CharBuffer s = StringUtils.defaultIfEmpty(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL")); assertEquals("abc", s.toString()); } @Test public void testDefaultIfBlank_CharBuffers() { assertEquals("NULL", StringUtils.defaultIfBlank(CharBuffer.wrap(""), CharBuffer.wrap("NULL")).toString()); assertEquals("NULL", StringUtils.defaultIfBlank(CharBuffer.wrap(" "), CharBuffer.wrap("NULL")).toString()); assertEquals("abc", StringUtils.defaultIfBlank(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL")).toString()); assertNull(StringUtils.defaultIfBlank(CharBuffer.wrap(""), null)); // Tests compatibility for the API return type final CharBuffer s = StringUtils.defaultIfBlank(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL")); assertEquals("abc", s.toString()); } //----------------------------------------------------------------------- @Test public void testAbbreviate_StringInt() { assertEquals(null, StringUtils.abbreviate(null, 10)); assertEquals("", StringUtils.abbreviate("", 10)); assertEquals("short", StringUtils.abbreviate("short", 10)); assertEquals("Now is ...", StringUtils.abbreviate("Now is the time for all good men to come to the aid of their party.", 10)); final String raspberry = "raspberry peach"; assertEquals("raspberry p...", StringUtils.abbreviate(raspberry, 14)); assertEquals("raspberry peach", StringUtils.abbreviate("raspberry peach", 15)); assertEquals("raspberry peach", StringUtils.abbreviate("raspberry peach", 16)); assertEquals("abc...", StringUtils.abbreviate("abcdefg", 6)); assertEquals("abcdefg", StringUtils.abbreviate("abcdefg", 7)); assertEquals("abcdefg", StringUtils.abbreviate("abcdefg", 8)); assertEquals("a...", StringUtils.abbreviate("abcdefg", 4)); assertEquals("", StringUtils.abbreviate("", 4)); try { @SuppressWarnings("unused") final String res = StringUtils.abbreviate("abc", 3); fail("StringUtils.abbreviate expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } } @Test public void testAbbreviate_StringIntInt() { assertEquals(null, StringUtils.abbreviate(null, 10, 12)); assertEquals("", StringUtils.abbreviate("", 0, 10)); assertEquals("", StringUtils.abbreviate("", 2, 10)); try { @SuppressWarnings("unused") final String res = StringUtils.abbreviate("abcdefghij", 0, 3); fail("StringUtils.abbreviate expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } try { @SuppressWarnings("unused") final String res = StringUtils.abbreviate("abcdefghij", 5, 6); fail("StringUtils.abbreviate expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } final String raspberry = "raspberry peach"; assertEquals("raspberry peach", StringUtils.abbreviate(raspberry, 11, 15)); assertEquals(null, StringUtils.abbreviate(null, 7, 14)); assertAbbreviateWithOffset("abcdefg...", -1, 10); assertAbbreviateWithOffset("abcdefg...", 0, 10); assertAbbreviateWithOffset("abcdefg...", 1, 10); assertAbbreviateWithOffset("abcdefg...", 2, 10); assertAbbreviateWithOffset("abcdefg...", 3, 10); assertAbbreviateWithOffset("abcdefg...", 4, 10); assertAbbreviateWithOffset("...fghi...", 5, 10); assertAbbreviateWithOffset("...ghij...", 6, 10); assertAbbreviateWithOffset("...hijk...", 7, 10); assertAbbreviateWithOffset("...ijklmno", 8, 10); assertAbbreviateWithOffset("...ijklmno", 9, 10); assertAbbreviateWithOffset("...ijklmno", 10, 10); assertAbbreviateWithOffset("...ijklmno", 10, 10); assertAbbreviateWithOffset("...ijklmno", 11, 10); assertAbbreviateWithOffset("...ijklmno", 12, 10); assertAbbreviateWithOffset("...ijklmno", 13, 10); assertAbbreviateWithOffset("...ijklmno", 14, 10); assertAbbreviateWithOffset("...ijklmno", 15, 10); assertAbbreviateWithOffset("...ijklmno", 16, 10); assertAbbreviateWithOffset("...ijklmno", Integer.MAX_VALUE, 10); } private void assertAbbreviateWithOffset(final String expected, final int offset, final int maxWidth) { final String abcdefghijklmno = "abcdefghijklmno"; final String message = "abbreviate(String,int,int) failed"; final String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth); if (offset >= 0 && offset < abcdefghijklmno.length()) { assertTrue(message + " -- should contain offset character", actual.indexOf((char)('a'+offset)) != -1); } assertTrue(message + " -- should not be greater than maxWidth", actual.length() <= maxWidth); assertEquals(message, expected, actual); } @Test public void testAbbreviateMiddle() { // javadoc examples assertNull( StringUtils.abbreviateMiddle(null, null, 0) ); assertEquals( "abc", StringUtils.abbreviateMiddle("abc", null, 0) ); assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 0) ); assertEquals( "abc", StringUtils.abbreviateMiddle("abc", ".", 3) ); assertEquals( "ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4) ); // JIRA issue (LANG-405) example (slightly different than actual expected result) assertEquals( "A very long text with un...f the text is complete.", StringUtils.abbreviateMiddle( "A very long text with unimportant stuff in the middle but interesting start and " + "end to see if the text is complete.", "...", 50) ); // Test a much longer text :) final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text"; assertEquals( "Start text->Close text", StringUtils.abbreviateMiddle( longText, "->", 22 ) ); // Test negative length assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1)); // Test boundaries // Fails to change anything as method ensures first and last char are kept assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1)); assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2)); // Test length of n=1 assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1)); // Test smallest length that can lead to success assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3)); // More from LANG-405 assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4)); assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5)); } //----------------------------------------------------------------------- @Test public void testDifference_StringString() { assertEquals(null, StringUtils.difference(null, null)); assertEquals("", StringUtils.difference("", "")); assertEquals("abc", StringUtils.difference("", "abc")); assertEquals("", StringUtils.difference("abc", "")); assertEquals("i am a robot", StringUtils.difference(null, "i am a robot")); assertEquals("i am a machine", StringUtils.difference("i am a machine", null)); assertEquals("robot", StringUtils.difference("i am a machine", "i am a robot")); assertEquals("", StringUtils.difference("abc", "abc")); assertEquals("you are a robot", StringUtils.difference("i am a robot", "you are a robot")); } @Test public void testDifferenceAt_StringString() { assertEquals(-1, StringUtils.indexOfDifference(null, null)); assertEquals(0, StringUtils.indexOfDifference(null, "i am a robot")); assertEquals(-1, StringUtils.indexOfDifference("", "")); assertEquals(0, StringUtils.indexOfDifference("", "abc")); assertEquals(0, StringUtils.indexOfDifference("abc", "")); assertEquals(0, StringUtils.indexOfDifference("i am a machine", null)); assertEquals(7, StringUtils.indexOfDifference("i am a machine", "i am a robot")); assertEquals(-1, StringUtils.indexOfDifference("foo", "foo")); assertEquals(0, StringUtils.indexOfDifference("i am a robot", "you are a robot")); //System.out.println("indexOfDiff: " + StringUtils.indexOfDifference("i am a robot", "not machine")); } //----------------------------------------------------------------------- @Test public void testGetLevenshteinDistance_StringString() { assertEquals(0, StringUtils.getLevenshteinDistance("", "") ); assertEquals(1, StringUtils.getLevenshteinDistance("", "a") ); assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "") ); assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog") ); assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant") ); assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo") ); assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant") ); assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") ); assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo") ); assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo") ); try { @SuppressWarnings("unused") final int d = StringUtils.getLevenshteinDistance("a", null); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } try { @SuppressWarnings("unused") final int d = StringUtils.getLevenshteinDistance(null, "a"); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } } @Test public void testGetLevenshteinDistance_StringStringInt() { // empty strings assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8)); assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7)); assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6)); // unequal strings, zero threshold assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0)); assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0)); // equal strings assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0)); assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2)); // same length assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2)); assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3)); // big stripe assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10)); // distance less than threshold assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8)); assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4)); // distance equal to threshold assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7)); assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3)); // distance greater than threshold assertEquals(-1, StringUtils.getLevenshteinDistance("a", "bbb", 2)); assertEquals(-1, StringUtils.getLevenshteinDistance("bbb", "a", 2)); assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "b", 6)); // stripe runs off array, strings not similar assertEquals(-1, StringUtils.getLevenshteinDistance("a", "bbb", 1)); assertEquals(-1, StringUtils.getLevenshteinDistance("bbb", "a", 1)); // stripe runs off array, strings are similar assertEquals(-1, StringUtils.getLevenshteinDistance("12345", "1234567", 1)); assertEquals(-1, StringUtils.getLevenshteinDistance("1234567", "12345", 1)); // old getLevenshteinDistance test cases assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog",1) ); assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant",3) ); assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo",7) ); assertEquals(-1, StringUtils.getLevenshteinDistance("elephant", "hippo",6) ); assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant",7) ); assertEquals(-1, StringUtils.getLevenshteinDistance("hippo", "elephant",6) ); assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz",8) ); assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo",8) ); assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo",1) ); // exceptions try { @SuppressWarnings("unused") final int d = StringUtils.getLevenshteinDistance("a", null, 0); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } try { @SuppressWarnings("unused") final int d = StringUtils.getLevenshteinDistance(null, "a", 0); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } try { @SuppressWarnings("unused") final int d = StringUtils.getLevenshteinDistance("a", "a", -1); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { // empty } } /** * A sanity check for {@link StringUtils#EMPTY}. */ @Test public void testEMPTY() { assertNotNull(StringUtils.EMPTY); assertEquals("", StringUtils.EMPTY); assertEquals(0, StringUtils.EMPTY.length()); } /** * Test for {@link StringUtils#isAllLowerCase(CharSequence)}. */ @Test public void testIsAllLowerCase() { assertFalse(StringUtils.isAllLowerCase(null)); assertFalse(StringUtils.isAllLowerCase(StringUtils.EMPTY)); assertTrue(StringUtils.isAllLowerCase("abc")); assertFalse(StringUtils.isAllLowerCase("abc ")); assertFalse(StringUtils.isAllLowerCase("abC")); } /** * Test for {@link StringUtils#isAllUpperCase(CharSequence)}. */ @Test public void testIsAllUpperCase() { assertFalse(StringUtils.isAllUpperCase(null)); assertFalse(StringUtils.isAllUpperCase(StringUtils.EMPTY)); assertTrue(StringUtils.isAllUpperCase("ABC")); assertFalse(StringUtils.isAllUpperCase("ABC ")); assertFalse(StringUtils.isAllUpperCase("aBC")); } @Test public void testRemoveStart() { // StringUtils.removeStart("", *) = "" assertNull(StringUtils.removeStart(null, null)); assertNull(StringUtils.removeStart(null, "")); assertNull(StringUtils.removeStart(null, "a")); // StringUtils.removeStart(*, null) = * assertEquals(StringUtils.removeStart("", null), ""); assertEquals(StringUtils.removeStart("", ""), ""); assertEquals(StringUtils.removeStart("", "a"), ""); // All others: assertEquals(StringUtils.removeStart("www.domain.com", "www."), "domain.com"); assertEquals(StringUtils.removeStart("domain.com", "www."), "domain.com"); assertEquals(StringUtils.removeStart("domain.com", ""), "domain.com"); assertEquals(StringUtils.removeStart("domain.com", null), "domain.com"); } @Test public void testRemoveStartIgnoreCase() { // StringUtils.removeStart("", *) = "" assertNull("removeStartIgnoreCase(null, null)", StringUtils.removeStartIgnoreCase(null, null)); assertNull("removeStartIgnoreCase(null, \"\")", StringUtils.removeStartIgnoreCase(null, "")); assertNull("removeStartIgnoreCase(null, \"a\")", StringUtils.removeStartIgnoreCase(null, "a")); // StringUtils.removeStart(*, null) = * assertEquals("removeStartIgnoreCase(\"\", null)", StringUtils.removeStartIgnoreCase("", null), ""); assertEquals("removeStartIgnoreCase(\"\", \"\")", StringUtils.removeStartIgnoreCase("", ""), ""); assertEquals("removeStartIgnoreCase(\"\", \"a\")", StringUtils.removeStartIgnoreCase("", "a"), ""); // All others: assertEquals("removeStartIgnoreCase(\"www.domain.com\", \"www.\")", StringUtils.removeStartIgnoreCase("www.domain.com", "www."), "domain.com"); assertEquals("removeStartIgnoreCase(\"domain.com\", \"www.\")", StringUtils.removeStartIgnoreCase("domain.com", "www."), "domain.com"); assertEquals("removeStartIgnoreCase(\"domain.com\", \"\")", StringUtils.removeStartIgnoreCase("domain.com", ""), "domain.com"); assertEquals("removeStartIgnoreCase(\"domain.com\", null)", StringUtils.removeStartIgnoreCase("domain.com", null), "domain.com"); // Case insensitive: assertEquals("removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")", StringUtils.removeStartIgnoreCase("www.domain.com", "WWW."), "domain.com"); } @Test public void testRemoveEnd() { // StringUtils.removeEnd("", *) = "" assertNull(StringUtils.removeEnd(null, null)); assertNull(StringUtils.removeEnd(null, "")); assertNull(StringUtils.removeEnd(null, "a")); // StringUtils.removeEnd(*, null) = * assertEquals(StringUtils.removeEnd("", null), ""); assertEquals(StringUtils.removeEnd("", ""), ""); assertEquals(StringUtils.removeEnd("", "a"), ""); // All others: assertEquals(StringUtils.removeEnd("www.domain.com.", ".com"), "www.domain.com."); assertEquals(StringUtils.removeEnd("www.domain.com", ".com"), "www.domain"); assertEquals(StringUtils.removeEnd("www.domain", ".com"), "www.domain"); assertEquals(StringUtils.removeEnd("domain.com", ""), "domain.com"); assertEquals(StringUtils.removeEnd("domain.com", null), "domain.com"); } @Test public void testRemoveEndIgnoreCase() { // StringUtils.removeEndIgnoreCase("", *) = "" assertNull("removeEndIgnoreCase(null, null)", StringUtils.removeEndIgnoreCase(null, null)); assertNull("removeEndIgnoreCase(null, \"\")", StringUtils.removeEndIgnoreCase(null, "")); assertNull("removeEndIgnoreCase(null, \"a\")", StringUtils.removeEndIgnoreCase(null, "a")); // StringUtils.removeEnd(*, null) = * assertEquals("removeEndIgnoreCase(\"\", null)", StringUtils.removeEndIgnoreCase("", null), ""); assertEquals("removeEndIgnoreCase(\"\", \"\")", StringUtils.removeEndIgnoreCase("", ""), ""); assertEquals("removeEndIgnoreCase(\"\", \"a\")", StringUtils.removeEndIgnoreCase("", "a"), ""); // All others: assertEquals("removeEndIgnoreCase(\"www.domain.com.\", \".com\")", StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com."); assertEquals("removeEndIgnoreCase(\"www.domain.com\", \".com\")", StringUtils.removeEndIgnoreCase("www.domain.com", ".com"), "www.domain"); assertEquals("removeEndIgnoreCase(\"www.domain\", \".com\")", StringUtils.removeEndIgnoreCase("www.domain", ".com"), "www.domain"); assertEquals("removeEndIgnoreCase(\"domain.com\", \"\")", StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com"); assertEquals("removeEndIgnoreCase(\"domain.com\", null)", StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com"); // Case insensitive: assertEquals("removeEndIgnoreCase(\"www.domain.com\", \".COM\")", StringUtils.removeEndIgnoreCase("www.domain.com", ".COM"), "www.domain"); assertEquals("removeEndIgnoreCase(\"www.domain.COM\", \".com\")", StringUtils.removeEndIgnoreCase("www.domain.COM", ".com"), "www.domain"); } @Test public void testRemove_String() { // StringUtils.remove(null, *) = null assertEquals(null, StringUtils.remove(null, null)); assertEquals(null, StringUtils.remove(null, "")); assertEquals(null, StringUtils.remove(null, "a")); // StringUtils.remove("", *) = "" assertEquals("", StringUtils.remove("", null)); assertEquals("", StringUtils.remove("", "")); assertEquals("", StringUtils.remove("", "a")); // StringUtils.remove(*, null) = * assertEquals(null, StringUtils.remove(null, null)); assertEquals("", StringUtils.remove("", null)); assertEquals("a", StringUtils.remove("a", null)); // StringUtils.remove(*, "") = * assertEquals(null, StringUtils.remove(null, "")); assertEquals("", StringUtils.remove("", "")); assertEquals("a", StringUtils.remove("a", "")); // StringUtils.remove("queued", "ue") = "qd" assertEquals("qd", StringUtils.remove("queued", "ue")); // StringUtils.remove("queued", "zz") = "queued" assertEquals("queued", StringUtils.remove("queued", "zz")); } @Test public void testRemove_char() { // StringUtils.remove(null, *) = null assertEquals(null, StringUtils.remove(null, 'a')); assertEquals(null, StringUtils.remove(null, 'a')); assertEquals(null, StringUtils.remove(null, 'a')); // StringUtils.remove("", *) = "" assertEquals("", StringUtils.remove("", 'a')); assertEquals("", StringUtils.remove("", 'a')); assertEquals("", StringUtils.remove("", 'a')); // StringUtils.remove("queued", 'u') = "qeed" assertEquals("qeed", StringUtils.remove("queued", 'u')); // StringUtils.remove("queued", 'z') = "queued" assertEquals("queued", StringUtils.remove("queued", 'z')); } @Test public void testDifferenceAt_StringArray() { assertEquals(-1, StringUtils.indexOfDifference((String[])null)); assertEquals(-1, StringUtils.indexOfDifference(new String[] {})); assertEquals(-1, StringUtils.indexOfDifference(new String[] {"abc"})); assertEquals(-1, StringUtils.indexOfDifference(new String[] {null, null})); assertEquals(-1, StringUtils.indexOfDifference(new String[] {"", ""})); assertEquals(0, StringUtils.indexOfDifference(new String[] {"", null})); assertEquals(0, StringUtils.indexOfDifference(new String[] {"abc", null, null})); assertEquals(0, StringUtils.indexOfDifference(new String[] {null, null, "abc"})); assertEquals(0, StringUtils.indexOfDifference(new String[] {"", "abc"})); assertEquals(0, StringUtils.indexOfDifference(new String[] {"abc", ""})); assertEquals(-1, StringUtils.indexOfDifference(new String[] {"abc", "abc"})); assertEquals(1, StringUtils.indexOfDifference(new String[] {"abc", "a"})); assertEquals(2, StringUtils.indexOfDifference(new String[] {"ab", "abxyz"})); assertEquals(2, StringUtils.indexOfDifference(new String[] {"abcde", "abxyz"})); assertEquals(0, StringUtils.indexOfDifference(new String[] {"abcde", "xyz"})); assertEquals(0, StringUtils.indexOfDifference(new String[] {"xyz", "abcde"})); assertEquals(7, StringUtils.indexOfDifference(new String[] {"i am a machine", "i am a robot"})); } @Test public void testGetCommonPrefix_StringArray() { assertEquals("", StringUtils.getCommonPrefix((String[])null)); assertEquals("", StringUtils.getCommonPrefix()); assertEquals("abc", StringUtils.getCommonPrefix("abc")); assertEquals("", StringUtils.getCommonPrefix(null, null)); assertEquals("", StringUtils.getCommonPrefix("", "")); assertEquals("", StringUtils.getCommonPrefix("", null)); assertEquals("", StringUtils.getCommonPrefix("abc", null, null)); assertEquals("", StringUtils.getCommonPrefix(null, null, "abc")); assertEquals("", StringUtils.getCommonPrefix("", "abc")); assertEquals("", StringUtils.getCommonPrefix("abc", "")); assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc")); assertEquals("a", StringUtils.getCommonPrefix("abc", "a")); assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz")); assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz")); assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz")); assertEquals("", StringUtils.getCommonPrefix("xyz", "abcde")); assertEquals("i am a ", StringUtils.getCommonPrefix("i am a machine", "i am a robot")); } @Test public void testNormalizeSpace() { assertEquals(null, StringUtils.normalizeSpace(null)); assertEquals("", StringUtils.normalizeSpace("")); assertEquals("", StringUtils.normalizeSpace(" ")); assertEquals("", StringUtils.normalizeSpace("\t")); assertEquals("", StringUtils.normalizeSpace("\n")); assertEquals("", StringUtils.normalizeSpace("\u0009")); assertEquals("", StringUtils.normalizeSpace("\u000B")); assertEquals("", StringUtils.normalizeSpace("\u000C")); assertEquals("", StringUtils.normalizeSpace("\u001C")); assertEquals("", StringUtils.normalizeSpace("\u001D")); assertEquals("", StringUtils.normalizeSpace("\u001E")); assertEquals("", StringUtils.normalizeSpace("\u001F")); assertEquals("", StringUtils.normalizeSpace("\f")); assertEquals("", StringUtils.normalizeSpace("\r")); assertEquals("a", StringUtils.normalizeSpace(" a ")); assertEquals("a b c", StringUtils.normalizeSpace(" a b c ")); assertEquals("a b c", StringUtils.normalizeSpace("a\t\f\r b\u000B c\n")); } @Test public void testLANG666() { assertEquals("12",StringUtils.stripEnd("120.00", ".0")); assertEquals("121",StringUtils.stripEnd("121.00", ".0")); } // Methods on StringUtils that are immutable in spirit (i.e. calculate the length) // should take a CharSequence parameter. Methods that are mutable in spirit (i.e. capitalize) // should take a String or String[] parameter and return String or String[]. // This test enforces that this is done. @Test public void testStringUtilsCharSequenceContract() { final Class<StringUtils> c = StringUtils.class; final Method[] methods = c.getMethods(); for (final Method m : methods) { if (m.getReturnType() == String.class || m.getReturnType() == String[].class) { // Assume this is mutable and ensure the first parameter is not CharSequence. // It may be String or it may be something else (String[], Object, Object[]) so // don't actively test for that. final Class<?>[] params = m.getParameterTypes(); if ( params.length > 0 && (params[0] == CharSequence.class || params[0] == CharSequence[].class)) { fail("The method " + m + " appears to be mutable in spirit and therefore must not accept a CharSequence"); } } else { // Assume this is immutable in spirit and ensure the first parameter is not String. // As above, it may be something other than CharSequence. final Class<?>[] params = m.getParameterTypes(); if ( params.length > 0 && (params[0] == String.class || params[0] == String[].class)) { fail("The method " + m + " appears to be immutable in spirit and therefore must not accept a String"); } } } } /** * Tests {@link StringUtils#toString(byte[], String)} * * @throws UnsupportedEncodingException * @see StringUtils#toString(byte[], String) */ @Test public void testToString() throws UnsupportedEncodingException { final String expectedString = "The quick brown fox jumped over the lazy dog."; String encoding = SystemUtils.FILE_ENCODING; byte[] expectedBytes = expectedString.getBytes(encoding); // sanity check start assertArrayEquals(expectedBytes, expectedString.getBytes()); // sanity check end assertEquals(expectedString, StringUtils.toString(expectedBytes, null)); assertEquals(expectedString, StringUtils.toString(expectedBytes, encoding)); encoding = "UTF-16"; expectedBytes = expectedString.getBytes(encoding); assertEquals(expectedString, StringUtils.toString(expectedBytes, encoding)); } @Test public void testEscapeSurrogatePairs() throws Exception { assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); // Examples from https://en.wikipedia.org/wiki/UTF-16 assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00")); assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD")); } /** * Tests LANG-858. * * @throws Exception */ @Test public void testEscapeSurrogatePairsLang858() throws Exception { assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD")); //fail LANG-858 assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858 } @Test public void testUnescapeSurrogatePairs() throws Exception { assertEquals("\uD83D\uDE30", StringEscapeUtils.unescapeCsv("\uD83D\uDE30")); // Examples from https://en.wikipedia.org/wiki/UTF-16 assertEquals("\uD800\uDC00", StringEscapeUtils.unescapeCsv("\uD800\uDC00")); assertEquals("\uD834\uDD1E", StringEscapeUtils.unescapeCsv("\uD834\uDD1E")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.unescapeCsv("\uDBFF\uDFFD")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.unescapeHtml3("\uDBFF\uDFFD")); assertEquals("\uDBFF\uDFFD", StringEscapeUtils.unescapeHtml4("\uDBFF\uDFFD")); } /** * Tests {@code appendIfMissing}. */ @Test public void testAppendIfMissing() { assertEquals("appendIfMissing(null,null)", null, StringUtils.appendIfMissing(null,null)); assertEquals("appendIfMissing(abc,null)", "abc", StringUtils.appendIfMissing("abc",null)); assertEquals("appendIfMissing(\"\",xyz)", "xyz", StringUtils.appendIfMissing("","xyz")); assertEquals("appendIfMissing(abc,xyz)", "abcxyz", StringUtils.appendIfMissing("abc","xyz")); assertEquals("appendIfMissing(abcxyz,xyz)", "abcxyz", StringUtils.appendIfMissing("abcxyz","xyz")); assertEquals("appendIfMissing(aXYZ,xyz)", "aXYZxyz", StringUtils.appendIfMissing("aXYZ","xyz")); assertEquals("appendIfMissing(null,null,null)", null, StringUtils.appendIfMissing(null,null,(CharSequence[]) null)); assertEquals("appendIfMissing(abc,null,null)", "abc", StringUtils.appendIfMissing("abc",null,(CharSequence[]) null)); assertEquals("appendIfMissing(\"\",xyz,null))", "xyz", StringUtils.appendIfMissing("","xyz",(CharSequence[]) null)); assertEquals("appendIfMissing(abc,xyz,{null})", "abcxyz", StringUtils.appendIfMissing("abc","xyz",new CharSequence[]{null})); assertEquals("appendIfMissing(abc,xyz,\"\")", "abc", StringUtils.appendIfMissing("abc","xyz","")); assertEquals("appendIfMissing(abc,xyz,mno)", "abcxyz", StringUtils.appendIfMissing("abc","xyz","mno")); assertEquals("appendIfMissing(abcxyz,xyz,mno)", "abcxyz", StringUtils.appendIfMissing("abcxyz","xyz","mno")); assertEquals("appendIfMissing(abcmno,xyz,mno)", "abcmno", StringUtils.appendIfMissing("abcmno","xyz","mno")); assertEquals("appendIfMissing(abcXYZ,xyz,mno)", "abcXYZxyz", StringUtils.appendIfMissing("abcXYZ","xyz","mno")); assertEquals("appendIfMissing(abcMNO,xyz,mno)", "abcMNOxyz", StringUtils.appendIfMissing("abcMNO","xyz","mno")); } /** * Tests {@code appendIfMissingIgnoreCase}. */ @Test public void testAppendIfMissingIgnoreCase() { assertEquals("appendIfMissingIgnoreCase(null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null)); assertEquals("appendIfMissingIgnoreCase(abc,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null)); assertEquals("appendIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz")); assertEquals("appendIfMissingIgnoreCase(abc,xyz)", "abcxyz", StringUtils.appendIfMissingIgnoreCase("abc","xyz")); assertEquals("appendIfMissingIgnoreCase(abcxyz,xyz)", "abcxyz", StringUtils.appendIfMissingIgnoreCase("abcxyz","xyz")); assertEquals("appendIfMissingIgnoreCase(abcXYZ,xyz)", "abcXYZ", StringUtils.appendIfMissingIgnoreCase("abcXYZ","xyz")); assertEquals("appendIfMissingIgnoreCase(null,null,null)", null, StringUtils.appendIfMissingIgnoreCase(null,null,(CharSequence[]) null)); assertEquals("appendIfMissingIgnoreCase(abc,null,null)", "abc", StringUtils.appendIfMissingIgnoreCase("abc",null,(CharSequence[]) null)); assertEquals("appendIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.appendIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); assertEquals("appendIfMissingIgnoreCase(abc,xyz,{null})", "abcxyz", StringUtils.appendIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); assertEquals("appendIfMissingIgnoreCase(abc,xyz,\"\")", "abc", StringUtils.appendIfMissingIgnoreCase("abc","xyz","")); assertEquals("appendIfMissingIgnoreCase(abc,xyz,mno)", "abcxyz", StringUtils.appendIfMissingIgnoreCase("abc","xyz","mno")); assertEquals("appendIfMissingIgnoreCase(abcxyz,xyz,mno)", "abcxyz", StringUtils.appendIfMissingIgnoreCase("abcxyz","xyz","mno")); assertEquals("appendIfMissingIgnoreCase(abcmno,xyz,mno)", "abcmno", StringUtils.appendIfMissingIgnoreCase("abcmno","xyz","mno")); assertEquals("appendIfMissingIgnoreCase(abcXYZ,xyz,mno)", "abcXYZ", StringUtils.appendIfMissingIgnoreCase("abcXYZ","xyz","mno")); assertEquals("appendIfMissingIgnoreCase(abcMNO,xyz,mno)", "abcMNO", StringUtils.appendIfMissingIgnoreCase("abcMNO","xyz","mno")); } /** * Tests {@code prependIfMissing}. */ @Test public void testPrependIfMissing() { assertEquals("prependIfMissing(null,null)", null, StringUtils.prependIfMissing(null,null)); assertEquals("prependIfMissing(abc,null)", "abc", StringUtils.prependIfMissing("abc",null)); assertEquals("prependIfMissing(\"\",xyz)", "xyz", StringUtils.prependIfMissing("","xyz")); assertEquals("prependIfMissing(abc,xyz)", "xyzabc", StringUtils.prependIfMissing("abc","xyz")); assertEquals("prependIfMissing(xyzabc,xyz)", "xyzabc", StringUtils.prependIfMissing("xyzabc","xyz")); assertEquals("prependIfMissing(XYZabc,xyz)", "xyzXYZabc", StringUtils.prependIfMissing("XYZabc","xyz")); assertEquals("prependIfMissing(null,null null)", null, StringUtils.prependIfMissing(null,null,(CharSequence[]) null)); assertEquals("prependIfMissing(abc,null,null)", "abc", StringUtils.prependIfMissing("abc",null,(CharSequence[]) null)); assertEquals("prependIfMissing(\"\",xyz,null)", "xyz", StringUtils.prependIfMissing("","xyz",(CharSequence[]) null)); assertEquals("prependIfMissing(abc,xyz,{null})","xyzabc", StringUtils.prependIfMissing("abc","xyz",new CharSequence[]{null})); assertEquals("prependIfMissing(abc,xyz,\"\")","abc", StringUtils.prependIfMissing("abc","xyz","")); assertEquals("prependIfMissing(abc,xyz,mno)","xyzabc", StringUtils.prependIfMissing("abc","xyz","mno")); assertEquals("prependIfMissing(xyzabc,xyz,mno)", "xyzabc", StringUtils.prependIfMissing("xyzabc","xyz","mno")); assertEquals("prependIfMissing(mnoabc,xyz,mno)", "mnoabc", StringUtils.prependIfMissing("mnoabc","xyz","mno")); assertEquals("prependIfMissing(XYZabc,xyz,mno)", "xyzXYZabc", StringUtils.prependIfMissing("XYZabc","xyz","mno")); assertEquals("prependIfMissing(MNOabc,xyz,mno)", "xyzMNOabc", StringUtils.prependIfMissing("MNOabc","xyz","mno")); } /** * Tests {@code prependIfMissingIgnoreCase}. */ @Test public void testPrependIfMissingIgnoreCase() { assertEquals("prependIfMissingIgnoreCase(null,null)", null, StringUtils.prependIfMissingIgnoreCase(null,null)); assertEquals("prependIfMissingIgnoreCase(abc,null)", "abc", StringUtils.prependIfMissingIgnoreCase("abc",null)); assertEquals("prependIfMissingIgnoreCase(\"\",xyz)", "xyz", StringUtils.prependIfMissingIgnoreCase("","xyz")); assertEquals("prependIfMissingIgnoreCase(abc,xyz)", "xyzabc", StringUtils.prependIfMissingIgnoreCase("abc","xyz")); assertEquals("prependIfMissingIgnoreCase(xyzabc,xyz)", "xyzabc", StringUtils.prependIfMissingIgnoreCase("xyzabc","xyz")); assertEquals("prependIfMissingIgnoreCase(XYZabc,xyz)", "XYZabc", StringUtils.prependIfMissingIgnoreCase("XYZabc","xyz")); assertEquals("prependIfMissingIgnoreCase(null,null null)", null, StringUtils.prependIfMissingIgnoreCase(null,null,(CharSequence[]) null)); assertEquals("prependIfMissingIgnoreCase(abc,null,null)", "abc", StringUtils.prependIfMissingIgnoreCase("abc",null,(CharSequence[]) null)); assertEquals("prependIfMissingIgnoreCase(\"\",xyz,null)", "xyz", StringUtils.prependIfMissingIgnoreCase("","xyz",(CharSequence[]) null)); assertEquals("prependIfMissingIgnoreCase(abc,xyz,{null})","xyzabc", StringUtils.prependIfMissingIgnoreCase("abc","xyz",new CharSequence[]{null})); assertEquals("prependIfMissingIgnoreCase(abc,xyz,\"\")","abc", StringUtils.prependIfMissingIgnoreCase("abc","xyz","")); assertEquals("prependIfMissingIgnoreCase(abc,xyz,mno)","xyzabc", StringUtils.prependIfMissingIgnoreCase("abc","xyz","mno")); assertEquals("prependIfMissingIgnoreCase(xyzabc,xyz,mno)", "xyzabc", StringUtils.prependIfMissingIgnoreCase("xyzabc","xyz","mno")); assertEquals("prependIfMissingIgnoreCase(mnoabc,xyz,mno)", "mnoabc", StringUtils.prependIfMissingIgnoreCase("mnoabc","xyz","mno")); assertEquals("prependIfMissingIgnoreCase(XYZabc,xyz,mno)", "XYZabc", StringUtils.prependIfMissingIgnoreCase("XYZabc","xyz","mno")); assertEquals("prependIfMissingIgnoreCase(MNOabc,xyz,mno)", "MNOabc", StringUtils.prependIfMissingIgnoreCase("MNOabc","xyz","mno")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.StringUtils} - Trim/Empty methods * * @version $Id$ */ public class StringUtilsTrimEmptyTest { private static final String FOO = "foo"; //----------------------------------------------------------------------- @Test public void testIsEmpty() { assertTrue(StringUtils.isEmpty(null)); assertTrue(StringUtils.isEmpty("")); assertFalse(StringUtils.isEmpty(" ")); assertFalse(StringUtils.isEmpty("foo")); assertFalse(StringUtils.isEmpty(" foo ")); } @Test public void testIsNotEmpty() { assertFalse(StringUtils.isNotEmpty(null)); assertFalse(StringUtils.isNotEmpty("")); assertTrue(StringUtils.isNotEmpty(" ")); assertTrue(StringUtils.isNotEmpty("foo")); assertTrue(StringUtils.isNotEmpty(" foo ")); } @Test public void testIsBlank() { assertTrue(StringUtils.isBlank(null)); assertTrue(StringUtils.isBlank("")); assertTrue(StringUtils.isBlank(StringUtilsTest.WHITESPACE)); assertFalse(StringUtils.isBlank("foo")); assertFalse(StringUtils.isBlank(" foo ")); } @Test public void testIsNotBlank() { assertFalse(StringUtils.isNotBlank(null)); assertFalse(StringUtils.isNotBlank("")); assertFalse(StringUtils.isNotBlank(StringUtilsTest.WHITESPACE)); assertTrue(StringUtils.isNotBlank("foo")); assertTrue(StringUtils.isNotBlank(" foo ")); } //----------------------------------------------------------------------- @Test public void testTrim() { assertEquals(FOO, StringUtils.trim(FOO + " ")); assertEquals(FOO, StringUtils.trim(" " + FOO + " ")); assertEquals(FOO, StringUtils.trim(" " + FOO)); assertEquals(FOO, StringUtils.trim(FOO + "")); assertEquals("", StringUtils.trim(" \t\r\n\b ")); assertEquals("", StringUtils.trim(StringUtilsTest.TRIMMABLE)); assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trim(StringUtilsTest.NON_TRIMMABLE)); assertEquals("", StringUtils.trim("")); assertEquals(null, StringUtils.trim(null)); } @Test public void testTrimToNull() { assertEquals(FOO, StringUtils.trimToNull(FOO + " ")); assertEquals(FOO, StringUtils.trimToNull(" " + FOO + " ")); assertEquals(FOO, StringUtils.trimToNull(" " + FOO)); assertEquals(FOO, StringUtils.trimToNull(FOO + "")); assertEquals(null, StringUtils.trimToNull(" \t\r\n\b ")); assertEquals(null, StringUtils.trimToNull(StringUtilsTest.TRIMMABLE)); assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToNull(StringUtilsTest.NON_TRIMMABLE)); assertEquals(null, StringUtils.trimToNull("")); assertEquals(null, StringUtils.trimToNull(null)); } @Test public void testTrimToEmpty() { assertEquals(FOO, StringUtils.trimToEmpty(FOO + " ")); assertEquals(FOO, StringUtils.trimToEmpty(" " + FOO + " ")); assertEquals(FOO, StringUtils.trimToEmpty(" " + FOO)); assertEquals(FOO, StringUtils.trimToEmpty(FOO + "")); assertEquals("", StringUtils.trimToEmpty(" \t\r\n\b ")); assertEquals("", StringUtils.trimToEmpty(StringUtilsTest.TRIMMABLE)); assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToEmpty(StringUtilsTest.NON_TRIMMABLE)); assertEquals("", StringUtils.trimToEmpty("")); assertEquals("", StringUtils.trimToEmpty(null)); } //----------------------------------------------------------------------- @Test public void testStrip_String() { assertEquals(null, StringUtils.strip(null)); assertEquals("", StringUtils.strip("")); assertEquals("", StringUtils.strip(" ")); assertEquals("abc", StringUtils.strip(" abc ")); assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); } @Test public void testStripToNull_String() { assertEquals(null, StringUtils.stripToNull(null)); assertEquals(null, StringUtils.stripToNull("")); assertEquals(null, StringUtils.stripToNull(" ")); assertEquals(null, StringUtils.stripToNull(StringUtilsTest.WHITESPACE)); assertEquals("ab c", StringUtils.stripToNull(" ab c ")); assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); } @Test public void testStripToEmpty_String() { assertEquals("", StringUtils.stripToEmpty(null)); assertEquals("", StringUtils.stripToEmpty("")); assertEquals("", StringUtils.stripToEmpty(" ")); assertEquals("", StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE)); assertEquals("ab c", StringUtils.stripToEmpty(" ab c ")); assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE)); } @Test public void testStrip_StringString() { // null strip assertEquals(null, StringUtils.strip(null, null)); assertEquals("", StringUtils.strip("", null)); assertEquals("", StringUtils.strip(" ", null)); assertEquals("abc", StringUtils.strip(" abc ", null)); assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); // "" strip assertEquals(null, StringUtils.strip(null, "")); assertEquals("", StringUtils.strip("", "")); assertEquals(" ", StringUtils.strip(" ", "")); assertEquals(" abc ", StringUtils.strip(" abc ", "")); assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); // " " strip assertEquals(null, StringUtils.strip(null, " ")); assertEquals("", StringUtils.strip("", " ")); assertEquals("", StringUtils.strip(" ", " ")); assertEquals("abc", StringUtils.strip(" abc ", " ")); // "ab" strip assertEquals(null, StringUtils.strip(null, "ab")); assertEquals("", StringUtils.strip("", "ab")); assertEquals(" ", StringUtils.strip(" ", "ab")); assertEquals(" abc ", StringUtils.strip(" abc ", "ab")); assertEquals("c", StringUtils.strip("abcabab", "ab")); assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, "")); } @Test public void testStripStart_StringString() { // null stripStart assertEquals(null, StringUtils.stripStart(null, null)); assertEquals("", StringUtils.stripStart("", null)); assertEquals("", StringUtils.stripStart(" ", null)); assertEquals("abc ", StringUtils.stripStart(" abc ", null)); assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); // "" stripStart assertEquals(null, StringUtils.stripStart(null, "")); assertEquals("", StringUtils.stripStart("", "")); assertEquals(" ", StringUtils.stripStart(" ", "")); assertEquals(" abc ", StringUtils.stripStart(" abc ", "")); assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); // " " stripStart assertEquals(null, StringUtils.stripStart(null, " ")); assertEquals("", StringUtils.stripStart("", " ")); assertEquals("", StringUtils.stripStart(" ", " ")); assertEquals("abc ", StringUtils.stripStart(" abc ", " ")); // "ab" stripStart assertEquals(null, StringUtils.stripStart(null, "ab")); assertEquals("", StringUtils.stripStart("", "ab")); assertEquals(" ", StringUtils.stripStart(" ", "ab")); assertEquals(" abc ", StringUtils.stripStart(" abc ", "ab")); assertEquals("cabab", StringUtils.stripStart("abcabab", "ab")); assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, "")); } @Test public void testStripEnd_StringString() { // null stripEnd assertEquals(null, StringUtils.stripEnd(null, null)); assertEquals("", StringUtils.stripEnd("", null)); assertEquals("", StringUtils.stripEnd(" ", null)); assertEquals(" abc", StringUtils.stripEnd(" abc ", null)); assertEquals(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null)); // "" stripEnd assertEquals(null, StringUtils.stripEnd(null, "")); assertEquals("", StringUtils.stripEnd("", "")); assertEquals(" ", StringUtils.stripEnd(" ", "")); assertEquals(" abc ", StringUtils.stripEnd(" abc ", "")); assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, "")); // " " stripEnd assertEquals(null, StringUtils.stripEnd(null, " ")); assertEquals("", StringUtils.stripEnd("", " ")); assertEquals("", StringUtils.stripEnd(" ", " ")); assertEquals(" abc", StringUtils.stripEnd(" abc ", " ")); // "ab" stripEnd assertEquals(null, StringUtils.stripEnd(null, "ab")); assertEquals("", StringUtils.stripEnd("", "ab")); assertEquals(" ", StringUtils.stripEnd(" ", "ab")); assertEquals(" abc ", StringUtils.stripEnd(" abc ", "ab")); assertEquals("abc", StringUtils.stripEnd("abcabab", "ab")); assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, "")); } @Test public void testStripAll() { // test stripAll method, merely an array version of the above strip final String[] empty = new String[0]; final String[] fooSpace = new String[] { " "+FOO+" ", " "+FOO, FOO+" " }; final String[] fooDots = new String[] { ".."+FOO+"..", ".."+FOO, FOO+".." }; final String[] foo = new String[] { FOO, FOO, FOO }; assertNull(StringUtils.stripAll((String[]) null)); // Additional varargs tests assertArrayEquals(empty, StringUtils.stripAll()); // empty array assertArrayEquals(new String[]{null}, StringUtils.stripAll((String) null)); // == new String[]{null} assertArrayEquals(empty, StringUtils.stripAll(empty)); assertArrayEquals(foo, StringUtils.stripAll(fooSpace)); assertNull(StringUtils.stripAll(null, null)); assertArrayEquals(foo, StringUtils.stripAll(fooSpace, null)); assertArrayEquals(foo, StringUtils.stripAll(fooDots, ".")); } @Test public void testStripAccents() { final String cue = "\u00C7\u00FA\u00EA"; assertEquals( "Failed to strip accents from " + cue, "Cue", StringUtils.stripAccents(cue)); final String lots = "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C7\u00C8\u00C9" + "\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D1\u00D2\u00D3" + "\u00D4\u00D5\u00D6\u00D9\u00DA\u00DB\u00DC\u00DD"; assertEquals( "Failed to strip accents from " + lots, "AAAAAACEEEEIIIINOOOOOUUUUY", StringUtils.stripAccents(lots)); assertNull( "Failed null safety", StringUtils.stripAccents(null) ); assertEquals( "Failed empty String", "", StringUtils.stripAccents("") ); assertEquals( "Failed to handle non-accented text", "control", StringUtils.stripAccents("control") ); assertEquals( "Failed to handle easy example", "eclair", StringUtils.stripAccents("\u00E9clair") ); } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3; import org.junit.Test; import static org.junit.Assert.*; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import java.io.File; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Locale; import org.junit.Assert; /** * Unit tests {@link org.apache.commons.lang3.SystemUtils}. * * Only limited testing can be performed. * * @version $Id$ */ public class SystemUtilsTest { @Test public void testConstructor() { assertNotNull(new SystemUtils()); final Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(SystemUtils.class.getModifiers())); assertFalse(Modifier.isFinal(SystemUtils.class.getModifiers())); } /** * Assums no security manager exists. */ @Test public void testGetJavaHome() { final File dir = SystemUtils.getJavaHome(); Assert.assertNotNull(dir); Assert.assertTrue(dir.exists()); } /** * Assums no security manager exists. */ @Test public void testGetJavaIoTmpDir() { final File dir = SystemUtils.getJavaIoTmpDir(); Assert.assertNotNull(dir); Assert.assertTrue(dir.exists()); } /** * Assums no security manager exists. */ @Test public void testGetUserDir() { final File dir = SystemUtils.getUserDir(); Assert.assertNotNull(dir); Assert.assertTrue(dir.exists()); } /** * Assums no security manager exists. */ @Test public void testGetUserHome() { final File dir = SystemUtils.getUserHome(); Assert.assertNotNull(dir); Assert.assertTrue(dir.exists()); } @Test public void testIS_JAVA() { final String javaVersion = System.getProperty("java.version"); if (javaVersion == null) { assertFalse(SystemUtils.IS_JAVA_1_1); assertFalse(SystemUtils.IS_JAVA_1_2); assertFalse(SystemUtils.IS_JAVA_1_3); assertFalse(SystemUtils.IS_JAVA_1_4); assertFalse(SystemUtils.IS_JAVA_1_5); assertFalse(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else if (javaVersion.startsWith("1.1")) { assertTrue(SystemUtils.IS_JAVA_1_1); assertFalse(SystemUtils.IS_JAVA_1_2); assertFalse(SystemUtils.IS_JAVA_1_3); assertFalse(SystemUtils.IS_JAVA_1_4); assertFalse(SystemUtils.IS_JAVA_1_5); assertFalse(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else if (javaVersion.startsWith("1.2")) { assertFalse(SystemUtils.IS_JAVA_1_1); assertTrue(SystemUtils.IS_JAVA_1_2); assertFalse(SystemUtils.IS_JAVA_1_3); assertFalse(SystemUtils.IS_JAVA_1_4); assertFalse(SystemUtils.IS_JAVA_1_5); assertFalse(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else if (javaVersion.startsWith("1.3")) { assertFalse(SystemUtils.IS_JAVA_1_1); assertFalse(SystemUtils.IS_JAVA_1_2); assertTrue(SystemUtils.IS_JAVA_1_3); assertFalse(SystemUtils.IS_JAVA_1_4); assertFalse(SystemUtils.IS_JAVA_1_5); assertFalse(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else if (javaVersion.startsWith("1.4")) { assertFalse(SystemUtils.IS_JAVA_1_1); assertFalse(SystemUtils.IS_JAVA_1_2); assertFalse(SystemUtils.IS_JAVA_1_3); assertTrue(SystemUtils.IS_JAVA_1_4); assertFalse(SystemUtils.IS_JAVA_1_5); assertFalse(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else if (javaVersion.startsWith("1.5")) { assertFalse(SystemUtils.IS_JAVA_1_1); assertFalse(SystemUtils.IS_JAVA_1_2); assertFalse(SystemUtils.IS_JAVA_1_3); assertFalse(SystemUtils.IS_JAVA_1_4); assertTrue(SystemUtils.IS_JAVA_1_5); assertFalse(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else if (javaVersion.startsWith("1.6")) { assertFalse(SystemUtils.IS_JAVA_1_1); assertFalse(SystemUtils.IS_JAVA_1_2); assertFalse(SystemUtils.IS_JAVA_1_3); assertFalse(SystemUtils.IS_JAVA_1_4); assertFalse(SystemUtils.IS_JAVA_1_5); assertTrue(SystemUtils.IS_JAVA_1_6); assertFalse(SystemUtils.IS_JAVA_1_7); } else { System.out.println("Can't test IS_JAVA value: "+javaVersion); } } @Test public void testIS_OS() { final String osName = System.getProperty("os.name"); if (osName == null) { assertFalse(SystemUtils.IS_OS_WINDOWS); assertFalse(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_SOLARIS); assertFalse(SystemUtils.IS_OS_LINUX); assertFalse(SystemUtils.IS_OS_MAC_OSX); } else if (osName.startsWith("Windows")) { assertFalse(SystemUtils.IS_OS_UNIX); assertTrue(SystemUtils.IS_OS_WINDOWS); } else if (osName.startsWith("Solaris")) { assertTrue(SystemUtils.IS_OS_SOLARIS); assertTrue(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_WINDOWS); } else if (osName.toLowerCase(Locale.ENGLISH).startsWith("linux")) { assertTrue(SystemUtils.IS_OS_LINUX); assertTrue(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_WINDOWS); } else if (osName.startsWith("Mac OS X")) { assertTrue(SystemUtils.IS_OS_MAC_OSX); assertTrue(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_WINDOWS); } else if (osName.startsWith("OS/2")) { assertTrue(SystemUtils.IS_OS_OS2); assertFalse(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_WINDOWS); } else if (osName.startsWith("SunOS")) { assertTrue(SystemUtils.IS_OS_SUN_OS); assertTrue(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_WINDOWS); } else if (osName.startsWith("FreeBSD")) { assertTrue(SystemUtils.IS_OS_FREE_BSD); assertTrue(SystemUtils.IS_OS_UNIX); assertFalse(SystemUtils.IS_OS_WINDOWS); } else { System.out.println("Can't test IS_OS value: "+osName); } } @Test public void testJavaVersionMatches() { String javaVersion = null; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = ""; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.0"; assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.1"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.2"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.3.0"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.3.1"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.4.0"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.4.1"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.4.2"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.5.0"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.6.0"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); javaVersion = "1.7.0"; assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5")); assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6")); assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.7")); } @Test public void testOSMatchesName() { String osName = null; assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); osName = ""; assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); osName = "Windows 95"; assertTrue(SystemUtils.isOSNameMatch(osName, "Windows")); osName = "Windows NT"; assertTrue(SystemUtils.isOSNameMatch(osName, "Windows")); osName = "OS/2"; assertFalse(SystemUtils.isOSNameMatch(osName, "Windows")); } @Test public void testOSMatchesNameAndVersion() { String osName = null; String osVersion = null; assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); osName = ""; osVersion = ""; assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); osName = "Windows 95"; osVersion = "4.0"; assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); osName = "Windows 95"; osVersion = "4.1"; assertTrue(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); osName = "Windows 98"; osVersion = "4.1"; assertTrue(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); osName = "Windows NT"; osVersion = "4.0"; assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); osName = "OS/2"; osVersion = "4.0"; assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1")); } @Test public void testJavaAwtHeadless() { final boolean atLeastJava14 = SystemUtils.isJavaVersionAtLeast(JAVA_1_4); final String expectedStringValue = System.getProperty("java.awt.headless"); final String expectedStringValueWithDefault = System.getProperty("java.awt.headless", "false"); assertNotNull(expectedStringValueWithDefault); if (atLeastJava14) { final boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue(); if (expectedStringValue != null) { assertEquals(expectedStringValue, SystemUtils.JAVA_AWT_HEADLESS); } assertEquals(expectedValue, SystemUtils.isJavaAwtHeadless()); } else { assertNull(expectedStringValue); assertNull(SystemUtils.JAVA_AWT_HEADLESS); assertEquals(expectedStringValueWithDefault, "" + SystemUtils.isJavaAwtHeadless()); } assertEquals(expectedStringValueWithDefault, "" + SystemUtils.isJavaAwtHeadless()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.AbstractList; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.Validate}. * * @version $Id$ */ public class ValidateTest { //----------------------------------------------------------------------- @Test public void testIsTrue1() { Validate.isTrue(true); try { Validate.isTrue(false); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated expression is false", ex.getMessage()); } } //----------------------------------------------------------------------- @Test public void testIsTrue2() { Validate.isTrue(true, "MSG"); try { Validate.isTrue(false, "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } } //----------------------------------------------------------------------- @Test public void testIsTrue3() { Validate.isTrue(true, "MSG", 6); try { Validate.isTrue(false, "MSG", 6); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } } //----------------------------------------------------------------------- @Test public void testIsTrue4() { Validate.isTrue(true, "MSG", 7); try { Validate.isTrue(false, "MSG", 7); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } } //----------------------------------------------------------------------- @Test public void testIsTrue5() { Validate.isTrue(true, "MSG", 7.4d); try { Validate.isTrue(false, "MSG", 7.4d); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNotNull1() { Validate.notNull(new Object()); try { Validate.notNull(null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated object is null", ex.getMessage()); } final String str = "Hi"; final String testStr = Validate.notNull(str); assertSame(str, testStr); } //----------------------------------------------------------------------- @Test public void testNotNull2() { Validate.notNull(new Object(), "MSG"); try { Validate.notNull(null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("MSG", ex.getMessage()); } final String str = "Hi"; final String testStr = Validate.notNull(str, "Message"); assertSame(str, testStr); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNotEmptyArray1() { Validate.notEmpty(new Object[] {null}); try { Validate.notEmpty((Object[]) null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated array is empty", ex.getMessage()); } try { Validate.notEmpty(new Object[0]); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated array is empty", ex.getMessage()); } final String[] array = new String[] {"hi"}; final String[] test = Validate.notEmpty(array); assertSame(array, test); } //----------------------------------------------------------------------- @Test public void testNotEmptyArray2() { Validate.notEmpty(new Object[] {null}, "MSG"); try { Validate.notEmpty((Object[]) null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("MSG", ex.getMessage()); } try { Validate.notEmpty(new Object[0], "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } final String[] array = new String[] {"hi"}; final String[] test = Validate.notEmpty(array, "Message"); assertSame(array, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNotEmptyCollection1() { final Collection<Integer> coll = new ArrayList<Integer>(); try { Validate.notEmpty((Collection<?>) null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated collection is empty", ex.getMessage()); } try { Validate.notEmpty(coll); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated collection is empty", ex.getMessage()); } coll.add(Integer.valueOf(8)); Validate.notEmpty(coll); final Collection<Integer> test = Validate.notEmpty(coll); assertSame(coll, test); } //----------------------------------------------------------------------- @Test public void testNotEmptyCollection2() { final Collection<Integer> coll = new ArrayList<Integer>(); try { Validate.notEmpty((Collection<?>) null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("MSG", ex.getMessage()); } try { Validate.notEmpty(coll, "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } coll.add(Integer.valueOf(8)); Validate.notEmpty(coll, "MSG"); final Collection<Integer> test = Validate.notEmpty(coll, "Message"); assertSame(coll, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNotEmptyMap1() { final Map<String, Integer> map = new HashMap<String, Integer>(); try { Validate.notEmpty((Map<?, ?>) null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated map is empty", ex.getMessage()); } try { Validate.notEmpty(map); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated map is empty", ex.getMessage()); } map.put("ll", Integer.valueOf(8)); Validate.notEmpty(map); final Map<String, Integer> test = Validate.notEmpty(map); assertSame(map, test); } //----------------------------------------------------------------------- @Test public void testNotEmptyMap2() { final Map<String, Integer> map = new HashMap<String, Integer>(); try { Validate.notEmpty((Map<?, ?>) null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("MSG", ex.getMessage()); } try { Validate.notEmpty(map, "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } map.put("ll", Integer.valueOf(8)); Validate.notEmpty(map, "MSG"); final Map<String, Integer> test = Validate.notEmpty(map, "Message"); assertSame(map, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNotEmptyString1() { Validate.notEmpty("hjl"); try { Validate.notEmpty((String) null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated character sequence is empty", ex.getMessage()); } try { Validate.notEmpty(""); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated character sequence is empty", ex.getMessage()); } final String str = "Hi"; final String testStr = Validate.notEmpty(str); assertSame(str, testStr); } //----------------------------------------------------------------------- @Test public void testNotEmptyString2() { Validate.notEmpty("a", "MSG"); try { Validate.notEmpty((String) null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("MSG", ex.getMessage()); } try { Validate.notEmpty("", "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } final String str = "Hi"; final String testStr = Validate.notEmpty(str, "Message"); assertSame(str, testStr); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNotBlankNullStringShouldThrow() { //given final String string = null; try { //when Validate.notBlank(string); fail("Expecting NullPointerException"); } catch (final NullPointerException e) { //then assertEquals("The validated character sequence is blank", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankMsgNullStringShouldThrow() { //given final String string = null; try { //when Validate.notBlank(string, "Message"); fail("Expecting NullPointerException"); } catch (final NullPointerException e) { //then assertEquals("Message", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankEmptyStringShouldThrow() { //given final String string = ""; try { //when Validate.notBlank(string); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { //then assertEquals("The validated character sequence is blank", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankBlankStringWithWhitespacesShouldThrow() { //given final String string = " "; try { //when Validate.notBlank(string); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { //then assertEquals("The validated character sequence is blank", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankBlankStringWithNewlinesShouldThrow() { //given final String string = " \n \t \r \n "; try { //when Validate.notBlank(string); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { //then assertEquals("The validated character sequence is blank", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankMsgBlankStringShouldThrow() { //given final String string = " \n \t \r \n "; try { //when Validate.notBlank(string, "Message"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { //then assertEquals("Message", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankMsgBlankStringWithWhitespacesShouldThrow() { //given final String string = " "; try { //when Validate.notBlank(string, "Message"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { //then assertEquals("Message", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankMsgEmptyStringShouldThrow() { //given final String string = ""; try { //when Validate.notBlank(string, "Message"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { //then assertEquals("Message", e.getMessage()); } } //----------------------------------------------------------------------- @Test public void testNotBlankNotBlankStringShouldNotThrow() { //given final String string = "abc"; //when Validate.notBlank(string); //then should not throw } //----------------------------------------------------------------------- @Test public void testNotBlankNotBlankStringWithWhitespacesShouldNotThrow() { //given final String string = " abc "; //when Validate.notBlank(string); //then should not throw } //----------------------------------------------------------------------- @Test public void testNotBlankNotBlankStringWithNewlinesShouldNotThrow() { //given final String string = " \n \t abc \r \n "; //when Validate.notBlank(string); //then should not throw } //----------------------------------------------------------------------- @Test public void testNotBlankMsgNotBlankStringShouldNotThrow() { //given final String string = "abc"; //when Validate.notBlank(string, "Message"); //then should not throw } //----------------------------------------------------------------------- @Test public void testNotBlankMsgNotBlankStringWithWhitespacesShouldNotThrow() { //given final String string = " abc "; //when Validate.notBlank(string, "Message"); //then should not throw } //----------------------------------------------------------------------- @Test public void testNotBlankMsgNotBlankStringWithNewlinesShouldNotThrow() { //given final String string = " \n \t abc \r \n "; //when Validate.notBlank(string, "Message"); //then should not throw } //----------------------------------------------------------------------- @Test public void testNotBlankReturnValues1() { final String str = "Hi"; final String test = Validate.notBlank(str); assertSame(str, test); } @Test public void testNotBlankReturnValues2() { final String str = "Hi"; final String test = Validate.notBlank(str, "Message"); assertSame(str, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNoNullElementsArray1() { String[] array = new String[] {"a", "b"}; Validate.noNullElements(array); try { Validate.noNullElements((Object[]) null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated object is null", ex.getMessage()); } array[1] = null; try { Validate.noNullElements(array); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated array contains null element at index: 1", ex.getMessage()); } array = new String[] {"a", "b"}; final String[] test = Validate.noNullElements(array); assertSame(array, test); } //----------------------------------------------------------------------- @Test public void testNoNullElementsArray2() { String[] array = new String[] {"a", "b"}; Validate.noNullElements(array, "MSG"); try { Validate.noNullElements((Object[]) null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated object is null", ex.getMessage()); } array[1] = null; try { Validate.noNullElements(array, "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } array = new String[] {"a", "b"}; final String[] test = Validate.noNullElements(array, "Message"); assertSame(array, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testNoNullElementsCollection1() { final List<String> coll = new ArrayList<String>(); coll.add("a"); coll.add("b"); Validate.noNullElements(coll); try { Validate.noNullElements((Collection<?>) null); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated object is null", ex.getMessage()); } coll.set(1, null); try { Validate.noNullElements(coll); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("The validated collection contains null element at index: 1", ex.getMessage()); } coll.set(1, "b"); final List<String> test = Validate.noNullElements(coll); assertSame(coll, test); } //----------------------------------------------------------------------- @Test public void testNoNullElementsCollection2() { final List<String> coll = new ArrayList<String>(); coll.add("a"); coll.add("b"); Validate.noNullElements(coll, "MSG"); try { Validate.noNullElements((Collection<?>) null, "MSG"); fail("Expecting NullPointerException"); } catch (final NullPointerException ex) { assertEquals("The validated object is null", ex.getMessage()); } coll.set(1, null); try { Validate.noNullElements(coll, "MSG"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) { assertEquals("MSG", ex.getMessage()); } coll.set(1, "b"); final List<String> test = Validate.noNullElements(coll, "Message"); assertSame(coll, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new Validate()); final Constructor<?>[] cons = Validate.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(Validate.class.getModifiers())); assertFalse(Modifier.isFinal(Validate.class.getModifiers())); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testValidIndex_withMessage_array() { final Object[] array = new Object[2]; Validate.validIndex(array, 0, "Broken: "); Validate.validIndex(array, 1, "Broken: "); try { Validate.validIndex(array, -1, "Broken: "); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("Broken: ", ex.getMessage()); } try { Validate.validIndex(array, 2, "Broken: "); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("Broken: ", ex.getMessage()); } final String[] strArray = new String[] {"Hi"}; final String[] test = Validate.noNullElements(strArray, "Message"); assertSame(strArray, test); } @Test public void testValidIndex_array() { final Object[] array = new Object[2]; Validate.validIndex(array, 0); Validate.validIndex(array, 1); try { Validate.validIndex(array, -1); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("The validated array index is invalid: -1", ex.getMessage()); } try { Validate.validIndex(array, 2); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("The validated array index is invalid: 2", ex.getMessage()); } final String[] strArray = new String[] {"Hi"}; final String[] test = Validate.noNullElements(strArray); assertSame(strArray, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testValidIndex_withMessage_collection() { final Collection<String> coll = new ArrayList<String>(); coll.add(null); coll.add(null); Validate.validIndex(coll, 0, "Broken: "); Validate.validIndex(coll, 1, "Broken: "); try { Validate.validIndex(coll, -1, "Broken: "); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("Broken: ", ex.getMessage()); } try { Validate.validIndex(coll, 2, "Broken: "); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("Broken: ", ex.getMessage()); } final List<String> strColl = Arrays.asList(new String[] {"Hi"}); final List<String> test = Validate.validIndex(strColl, 0, "Message"); assertSame(strColl, test); } @Test public void testValidIndex_collection() { final Collection<String> coll = new ArrayList<String>(); coll.add(null); coll.add(null); Validate.validIndex(coll, 0); Validate.validIndex(coll, 1); try { Validate.validIndex(coll, -1); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("The validated collection index is invalid: -1", ex.getMessage()); } try { Validate.validIndex(coll, 2); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("The validated collection index is invalid: 2", ex.getMessage()); } final List<String> strColl = Arrays.asList(new String[] {"Hi"}); final List<String> test = Validate.validIndex(strColl, 0); assertSame(strColl, test); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- @Test public void testValidIndex_withMessage_charSequence() { final CharSequence str = "Hi"; Validate.validIndex(str, 0, "Broken: "); Validate.validIndex(str, 1, "Broken: "); try { Validate.validIndex(str, -1, "Broken: "); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("Broken: ", ex.getMessage()); } try { Validate.validIndex(str, 2, "Broken: "); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("Broken: ", ex.getMessage()); } final String input = "Hi"; final String test = Validate.validIndex(input, 0, "Message"); assertSame(input, test); } @Test public void testValidIndex_charSequence() { final CharSequence str = "Hi"; Validate.validIndex(str, 0); Validate.validIndex(str, 1); try { Validate.validIndex(str, -1); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("The validated character sequence index is invalid: -1", ex.getMessage()); } try { Validate.validIndex(str, 2); fail("Expecting IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ex) { assertEquals("The validated character sequence index is invalid: 2", ex.getMessage()); } final String input = "Hi"; final String test = Validate.validIndex(input, 0); assertSame(input, test); } @Test public void testMatchesPattern() { final CharSequence str = "hi"; Validate.matchesPattern(str, "[a-z]*"); try { Validate.matchesPattern(str, "[0-9]*"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("The string hi does not match the pattern [0-9]*", e.getMessage()); } } @Test public void testMatchesPattern_withMessage() { final CharSequence str = "hi"; Validate.matchesPattern(str, "[a-z]*", "Does not match"); try { Validate.matchesPattern(str, "[0-9]*", "Does not match"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("Does not match", e.getMessage()); } } @Test public void testInclusiveBetween() { Validate.inclusiveBetween("a", "c", "b"); Validate.inclusiveBetween(0, 2, 1); Validate.inclusiveBetween(0, 2, 2); try { Validate.inclusiveBetween(0, 5, 6); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("The value 6 is not in the specified inclusive range of 0 to 5", e.getMessage()); } } @Test public void testInclusiveBetween_withMessage() { Validate.inclusiveBetween("a", "c", "b", "Error"); Validate.inclusiveBetween(0, 2, 1, "Error"); Validate.inclusiveBetween(0, 2, 2, "Error"); try { Validate.inclusiveBetween(0, 5, 6, "Error"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("Error", e.getMessage()); } } @Test public void testExclusiveBetween() { Validate.exclusiveBetween("a", "c", "b"); Validate.exclusiveBetween(0, 2, 1); try { Validate.exclusiveBetween(0, 5, 6); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("The value 6 is not in the specified exclusive range of 0 to 5", e.getMessage()); } try { Validate.exclusiveBetween(0, 5, 5); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("The value 5 is not in the specified exclusive range of 0 to 5", e.getMessage()); } } @Test public void testExclusiveBetween_withMessage() { Validate.exclusiveBetween("a", "c", "b", "Error"); Validate.exclusiveBetween(0, 2, 1, "Error"); try { Validate.exclusiveBetween(0, 5, 6, "Error"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("Error", e.getMessage()); } try { Validate.exclusiveBetween(0, 5, 5, "Error"); fail("Expecting IllegalArgumentException"); } catch (final IllegalArgumentException e) { assertEquals("Error", e.getMessage()); } } @Test public void testIsInstanceOf() { Validate.isInstanceOf(String.class, "hi"); Validate.isInstanceOf(Integer.class, 1); } @Test public void testIsInstanceOfExceptionMessage() { try { Validate.isInstanceOf(List.class, "hi"); fail("Expecting IllegalArgumentException"); } catch(final IllegalArgumentException e) { assertEquals("Expected type: java.util.List, actual: java.lang.String", e.getMessage()); } } @Test public void testIsInstanceOf_withMessage() { Validate.isInstanceOf(String.class, "hi", "Error"); Validate.isInstanceOf(Integer.class, 1, "Error"); try { Validate.isInstanceOf(List.class, "hi", "Error"); fail("Expecting IllegalArgumentException"); } catch(final IllegalArgumentException e) { assertEquals("Error", e.getMessage()); } } @Test public void testIsAssignable() { Validate.isAssignableFrom(CharSequence.class, String.class); Validate.isAssignableFrom(AbstractList.class, ArrayList.class); } @Test public void testIsAssignableExceptionMessage() { try { Validate.isAssignableFrom(List.class, String.class); fail("Expecting IllegalArgumentException"); } catch(final IllegalArgumentException e) { assertEquals("Cannot assign a java.lang.String to a java.util.List", e.getMessage()); } } @Test public void testIsAssignable_withMessage() { Validate.isAssignableFrom(CharSequence.class, String.class, "Error"); Validate.isAssignableFrom(AbstractList.class, ArrayList.class, "Error"); try { Validate.isAssignableFrom(List.class, String.class, "Error"); fail("Expecting IllegalArgumentException"); } catch(final IllegalArgumentException e) { assertEquals("Error", e.getMessage()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.math.BigInteger; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.CompareToBuilder}. * * @version $Id$ */ public class CompareToBuilderTest { //----------------------------------------------------------------------- static class TestObject implements Comparable<TestObject> { private int a; public TestObject(final int a) { this.a = a; } @Override public boolean equals(final Object o) { if (o == this) { return true; } if (!(o instanceof TestObject)) { return false; } final TestObject rhs = (TestObject) o; return a == rhs.a; } @Override public int hashCode() { return a; } public void setA(final int a) { this.a = a; } public int getA() { return a; } @Override public int compareTo(final TestObject rhs) { return a < rhs.a ? -1 : a > rhs.a ? +1 : 0; } } static class TestSubObject extends TestObject { private int b; public TestSubObject() { super(0); } public TestSubObject(final int a, final int b) { super(a); this.b = b; } @Override public boolean equals(final Object o) { if (o == this) { return true; } if (!(o instanceof TestSubObject)) { return false; } final TestSubObject rhs = (TestSubObject) o; return super.equals(o) && b == rhs.b; } } static class TestTransientSubObject extends TestObject { @SuppressWarnings("unused") private transient int t; public TestTransientSubObject(final int a, final int t) { super(a); this.t = t; } } @Test public void testReflectionCompare() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(4); assertTrue(CompareToBuilder.reflectionCompare(o1, o1) == 0); assertTrue(CompareToBuilder.reflectionCompare(o1, o2) == 0); o2.setA(5); assertTrue(CompareToBuilder.reflectionCompare(o1, o2) < 0); assertTrue(CompareToBuilder.reflectionCompare(o2, o1) > 0); } @Test(expected=NullPointerException.class) public void testReflectionCompareEx1() { final TestObject o1 = new TestObject(4); CompareToBuilder.reflectionCompare(o1, null); } @Test(expected=ClassCastException.class) public void testReflectionCompareEx2() { final TestObject o1 = new TestObject(4); final Object o2 = new Object(); CompareToBuilder.reflectionCompare(o1, o2); } @Test public void testReflectionHierarchyCompare() { testReflectionHierarchyCompare(false, null); } @Test public void testReflectionHierarchyCompareExcludeFields() { final String[] excludeFields = new String[] { "b" }; testReflectionHierarchyCompare(true, excludeFields); TestSubObject x; TestSubObject y; TestSubObject z; x = new TestSubObject(1, 1); y = new TestSubObject(2, 1); z = new TestSubObject(3, 1); assertXYZCompareOrder(x, y, z, true, excludeFields); x = new TestSubObject(1, 3); y = new TestSubObject(2, 2); z = new TestSubObject(3, 1); assertXYZCompareOrder(x, y, z, true, excludeFields); } @Test public void testReflectionHierarchyCompareTransients() { testReflectionHierarchyCompare(true, null); TestTransientSubObject x; TestTransientSubObject y; TestTransientSubObject z; x = new TestTransientSubObject(1, 1); y = new TestTransientSubObject(2, 2); z = new TestTransientSubObject(3, 3); assertXYZCompareOrder(x, y, z, true, null); x = new TestTransientSubObject(1, 1); y = new TestTransientSubObject(1, 2); z = new TestTransientSubObject(1, 3); assertXYZCompareOrder(x, y, z, true, null); } private void assertXYZCompareOrder(final Object x, final Object y, final Object z, final boolean testTransients, final String[] excludeFields) { assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients, null, excludeFields)); assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients, null, excludeFields)); assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients, null, excludeFields)); assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields)); assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields)); assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields)); assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients, null, excludeFields)); assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients, null, excludeFields)); assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients, null, excludeFields)); } private void testReflectionHierarchyCompare(final boolean testTransients, final String[] excludeFields) { final TestObject to1 = new TestObject(1); final TestObject to2 = new TestObject(2); final TestObject to3 = new TestObject(3); final TestSubObject tso1 = new TestSubObject(1, 1); final TestSubObject tso2 = new TestSubObject(2, 2); final TestSubObject tso3 = new TestSubObject(3, 3); assertReflectionCompareContract(to1, to1, to1, false, excludeFields); assertReflectionCompareContract(to1, to2, to3, false, excludeFields); assertReflectionCompareContract(tso1, tso1, tso1, false, excludeFields); assertReflectionCompareContract(tso1, tso2, tso3, false, excludeFields); assertReflectionCompareContract("1", "2", "3", false, excludeFields); assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients)); assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients)); // root class assertXYZCompareOrder(to1, to2, to3, true, null); // subclass assertXYZCompareOrder(tso1, tso2, tso3, true, null); } /** * See "Effective Java" under "Consider Implementing Comparable". * * @param x an object to compare * @param y an object to compare * @param z an object to compare * @param testTransients Whether to include transients in the comparison * @param excludeFields fields to exclude */ private void assertReflectionCompareContract(final Object x, final Object y, final Object z, final boolean testTransients, final String[] excludeFields) { // signum assertTrue(reflectionCompareSignum(x, y, testTransients, excludeFields) == -reflectionCompareSignum(y, x, testTransients, excludeFields)); // transitive if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) > 0 && CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields) > 0){ assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields) > 0); } // un-named if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) == 0) { assertTrue(reflectionCompareSignum(x, z, testTransients, excludeFields) == -reflectionCompareSignum(y, z, testTransients, excludeFields)); } // strongly recommended but not strictly required assertTrue(CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 == EqualsBuilder.reflectionEquals(x, y, testTransients)); } /** * Returns the signum of the result of comparing x and y with * <code>CompareToBuilder.reflectionCompare</code> * * @param lhs The "left-hand-side" of the comparison. * @param rhs The "right-hand-side" of the comparison. * @param testTransients Whether to include transients in the comparison * @param excludeFields fields to exclude * @return int The signum */ private int reflectionCompareSignum(final Object lhs, final Object rhs, final boolean testTransients, final String[] excludeFields) { return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum(); } @Test public void testAppendSuper() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(5); assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0); assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0); assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0); } @Test public void testObject() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(4); assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0); o2.setA(5); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0); } @Test public void testObjectBuild() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(4); assertEquals(Integer.valueOf(0), new CompareToBuilder().append(o1, o1).build()); assertEquals(Integer.valueOf(0), new CompareToBuilder().append(o1, o2).build()); o2.setA(5); assertTrue(new CompareToBuilder().append(o1, o2).build().intValue() < 0); assertTrue(new CompareToBuilder().append(o2, o1).build().intValue() > 0); assertTrue(new CompareToBuilder().append(o1, null).build().intValue() > 0); assertEquals(Integer.valueOf(0), new CompareToBuilder().append((Object) null, (Object) null).build()); assertTrue(new CompareToBuilder().append(null, o1).build().intValue() < 0); } @Test(expected=ClassCastException.class) public void testObjectEx2() { final TestObject o1 = new TestObject(4); final Object o2 = new Object(); new CompareToBuilder().append(o1, o2); } @Test public void testObjectComparator() { final String o1 = "Fred"; String o2 = "Fred"; assertTrue(new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0); o2 = "FRED"; assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0); assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0); o2 = "FREDA"; assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, null, String.CASE_INSENSITIVE_ORDER).toComparison() > 0); assertTrue(new CompareToBuilder().append((Object) null, (Object) null, String.CASE_INSENSITIVE_ORDER).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, o1, String.CASE_INSENSITIVE_ORDER).toComparison() < 0); } @Test public void testObjectComparatorNull() { final String o1 = "Fred"; String o2 = "Fred"; assertTrue(new CompareToBuilder().append(o1, o1, null).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() == 0); o2 = "Zebra"; assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, null, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((Object) null, (Object) null, null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, o1, null).toComparison() < 0); } @Test public void testLong() { final long o1 = 1L; final long o2 = 2L; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Long.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Long.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Long.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Long.MIN_VALUE, o1).toComparison() < 0); } @Test public void testInt() { final int o1 = 1; final int o2 = 2; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Integer.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Integer.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Integer.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Integer.MIN_VALUE, o1).toComparison() < 0); } @Test public void testShort() { final short o1 = 1; final short o2 = 2; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Short.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Short.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Short.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Short.MIN_VALUE, o1).toComparison() < 0); } @Test public void testChar() { final char o1 = 1; final char o2 = 2; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Character.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Character.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Character.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Character.MIN_VALUE, o1).toComparison() < 0); } @Test public void testByte() { final byte o1 = 1; final byte o2 = 2; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Byte.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Byte.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Byte.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Byte.MIN_VALUE, o1).toComparison() < 0); } @Test public void testDouble() { final double o1 = 1; final double o2 = 2; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Double.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Double.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Double.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Double.MIN_VALUE, o1).toComparison() < 0); assertTrue(new CompareToBuilder().append(Double.NaN, Double.NaN).toComparison() == 0); assertTrue(new CompareToBuilder().append(Double.NaN, Double.MAX_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Double.POSITIVE_INFINITY, Double.MAX_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Double.NEGATIVE_INFINITY, Double.MIN_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(o1, Double.NaN).toComparison() < 0); assertTrue(new CompareToBuilder().append(Double.NaN, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0); assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0); } @Test public void testFloat() { final float o1 = 1; final float o2 = 2; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Float.MAX_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(Float.MAX_VALUE, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(o1, Float.MIN_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Float.MIN_VALUE, o1).toComparison() < 0); assertTrue(new CompareToBuilder().append(Float.NaN, Float.NaN).toComparison() == 0); assertTrue(new CompareToBuilder().append(Float.NaN, Float.MAX_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Float.POSITIVE_INFINITY, Float.MAX_VALUE).toComparison() > 0); assertTrue(new CompareToBuilder().append(Float.NEGATIVE_INFINITY, Float.MIN_VALUE).toComparison() < 0); assertTrue(new CompareToBuilder().append(o1, Float.NaN).toComparison() < 0); assertTrue(new CompareToBuilder().append(Float.NaN, o1).toComparison() > 0); assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0); assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0); } @Test public void testBoolean() { final boolean o1 = true; final boolean o2 = false; assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0); assertTrue(new CompareToBuilder().append(o2, o2).toComparison() == 0); assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0); assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0); } @Test public void testObjectArray() { final TestObject[] obj1 = new TestObject[2]; obj1[0] = new TestObject(4); obj1[1] = new TestObject(5); final TestObject[] obj2 = new TestObject[2]; obj2[0] = new TestObject(4); obj2[1] = new TestObject(5); final TestObject[] obj3 = new TestObject[3]; obj3[0] = new TestObject(4); obj3[1] = new TestObject(5); obj3[2] = new TestObject(6); assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = new TestObject(7); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testLongArray() { final long[] obj1 = new long[2]; obj1[0] = 5L; obj1[1] = 6L; final long[] obj2 = new long[2]; obj2[0] = 5L; obj2[1] = 6L; final long[] obj3 = new long[3]; obj3[0] = 5L; obj3[1] = 6L; obj3[2] = 7L; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testIntArray() { final int[] obj1 = new int[2]; obj1[0] = 5; obj1[1] = 6; final int[] obj2 = new int[2]; obj2[0] = 5; obj2[1] = 6; final int[] obj3 = new int[3]; obj3[0] = 5; obj3[1] = 6; obj3[2] = 7; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testShortArray() { final short[] obj1 = new short[2]; obj1[0] = 5; obj1[1] = 6; final short[] obj2 = new short[2]; obj2[0] = 5; obj2[1] = 6; final short[] obj3 = new short[3]; obj3[0] = 5; obj3[1] = 6; obj3[2] = 7; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testCharArray() { final char[] obj1 = new char[2]; obj1[0] = 5; obj1[1] = 6; final char[] obj2 = new char[2]; obj2[0] = 5; obj2[1] = 6; final char[] obj3 = new char[3]; obj3[0] = 5; obj3[1] = 6; obj3[2] = 7; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testByteArray() { final byte[] obj1 = new byte[2]; obj1[0] = 5; obj1[1] = 6; final byte[] obj2 = new byte[2]; obj2[0] = 5; obj2[1] = 6; final byte[] obj3 = new byte[3]; obj3[0] = 5; obj3[1] = 6; obj3[2] = 7; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testDoubleArray() { final double[] obj1 = new double[2]; obj1[0] = 5; obj1[1] = 6; final double[] obj2 = new double[2]; obj2[0] = 5; obj2[1] = 6; final double[] obj3 = new double[3]; obj3[0] = 5; obj3[1] = 6; obj3[2] = 7; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((double[]) null, (double[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testFloatArray() { final float[] obj1 = new float[2]; obj1[0] = 5; obj1[1] = 6; final float[] obj2 = new float[2]; obj2[0] = 5; obj2[1] = 6; final float[] obj3 = new float[3]; obj3[0] = 5; obj3[1] = 6; obj3[2] = 7; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testBooleanArray() { final boolean[] obj1 = new boolean[2]; obj1[0] = true; obj1[1] = false; final boolean[] obj2 = new boolean[2]; obj2[0] = true; obj2[1] = false; final boolean[] obj3 = new boolean[3]; obj3[0] = true; obj3[1] = false; obj3[2] = true; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); obj1[1] = true; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0); assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0); assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0); } @Test public void testMultiLongArray() { final long[][] array1 = new long[2][2]; final long[][] array2 = new long[2][2]; final long[][] array3 = new long[2][3]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); array3[i][j] = (i + 1) * (j + 1); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 200; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiIntArray() { final int[][] array1 = new int[2][2]; final int[][] array2 = new int[2][2]; final int[][] array3 = new int[2][3]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); array3[i][j] = (i + 1) * (j + 1); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 200; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiShortArray() { final short[][] array1 = new short[2][2]; final short[][] array2 = new short[2][2]; final short[][] array3 = new short[2][3]; for (short i = 0; i < array1.length; ++i) { for (short j = 0; j < array1[0].length; j++) { array1[i][j] = (short)((i + 1) * (j + 1)); array2[i][j] = (short)((i + 1) * (j + 1)); array3[i][j] = (short)((i + 1) * (j + 1)); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 200; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiCharArray() { final char[][] array1 = new char[2][2]; final char[][] array2 = new char[2][2]; final char[][] array3 = new char[2][3]; for (short i = 0; i < array1.length; ++i) { for (short j = 0; j < array1[0].length; j++) { array1[i][j] = (char)((i + 1) * (j + 1)); array2[i][j] = (char)((i + 1) * (j + 1)); array3[i][j] = (char)((i + 1) * (j + 1)); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 200; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiByteArray() { final byte[][] array1 = new byte[2][2]; final byte[][] array2 = new byte[2][2]; final byte[][] array3 = new byte[2][3]; for (byte i = 0; i < array1.length; ++i) { for (byte j = 0; j < array1[0].length; j++) { array1[i][j] = (byte)((i + 1) * (j + 1)); array2[i][j] = (byte)((i + 1) * (j + 1)); array3[i][j] = (byte)((i + 1) * (j + 1)); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 127; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiFloatArray() { final float[][] array1 = new float[2][2]; final float[][] array2 = new float[2][2]; final float[][] array3 = new float[2][3]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); array3[i][j] = (i + 1) * (j + 1); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 127; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiDoubleArray() { final double[][] array1 = new double[2][2]; final double[][] array2 = new double[2][2]; final double[][] array3 = new double[2][3]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); array3[i][j] = (i + 1) * (j + 1); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 127; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMultiBooleanArray() { final boolean[][] array1 = new boolean[2][2]; final boolean[][] array2 = new boolean[2][2]; final boolean[][] array3 = new boolean[2][3]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = i == 1 ^ j == 1; array2[i][j] = i == 1 ^ j == 1; array3[i][j] = i == 1 ^ j == 1; } } array3[1][2] = false; array3[1][2] = false; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = true; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testRaggedArray() { final long array1[][] = new long[2][]; final long array2[][] = new long[2][]; final long array3[][] = new long[3][]; for (int i = 0; i < array1.length; ++i) { array1[i] = new long[2]; array2[i] = new long[2]; array3[i] = new long[3]; for (int j = 0; j < array1[i].length; ++j) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); array3[i][j] = (i + 1) * (j + 1); } } array3[1][2] = 100; array3[1][2] = 100; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); array1[1][1] = 200; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testMixedArray() { final Object array1[] = new Object[2]; final Object array2[] = new Object[2]; final Object array3[] = new Object[2]; for (int i = 0; i < array1.length; ++i) { array1[i] = new long[2]; array2[i] = new long[2]; array3[i] = new long[3]; for (int j = 0; j < 2; ++j) { ((long[]) array1[i])[j] = (i + 1) * (j + 1); ((long[]) array2[i])[j] = (i + 1) * (j + 1); ((long[]) array3[i])[j] = (i + 1) * (j + 1); } } ((long[]) array3[0])[2] = 1; ((long[]) array3[1])[2] = 1; assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0); assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0); assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0); ((long[]) array1[1])[1] = 200; assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0); assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0); } @Test public void testObjectArrayHiddenByObject() { final TestObject[] array1 = new TestObject[2]; array1[0] = new TestObject(4); array1[1] = new TestObject(5); final TestObject[] array2 = new TestObject[2]; array2[0] = new TestObject(4); array2[1] = new TestObject(5); final TestObject[] array3 = new TestObject[3]; array3[0] = new TestObject(4); array3[1] = new TestObject(5); array3[2] = new TestObject(6); final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = new TestObject(7); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testLongArrayHiddenByObject() { final long[] array1 = new long[2]; array1[0] = 5L; array1[1] = 6L; final long[] array2 = new long[2]; array2[0] = 5L; array2[1] = 6L; final long[] array3 = new long[3]; array3[0] = 5L; array3[1] = 6L; array3[2] = 7L; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testIntArrayHiddenByObject() { final int[] array1 = new int[2]; array1[0] = 5; array1[1] = 6; final int[] array2 = new int[2]; array2[0] = 5; array2[1] = 6; final int[] array3 = new int[3]; array3[0] = 5; array3[1] = 6; array3[2] = 7; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testShortArrayHiddenByObject() { final short[] array1 = new short[2]; array1[0] = 5; array1[1] = 6; final short[] array2 = new short[2]; array2[0] = 5; array2[1] = 6; final short[] array3 = new short[3]; array3[0] = 5; array3[1] = 6; array3[2] = 7; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testCharArrayHiddenByObject() { final char[] array1 = new char[2]; array1[0] = 5; array1[1] = 6; final char[] array2 = new char[2]; array2[0] = 5; array2[1] = 6; final char[] array3 = new char[3]; array3[0] = 5; array3[1] = 6; array3[2] = 7; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testByteArrayHiddenByObject() { final byte[] array1 = new byte[2]; array1[0] = 5; array1[1] = 6; final byte[] array2 = new byte[2]; array2[0] = 5; array2[1] = 6; final byte[] array3 = new byte[3]; array3[0] = 5; array3[1] = 6; array3[2] = 7; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testDoubleArrayHiddenByObject() { final double[] array1 = new double[2]; array1[0] = 5; array1[1] = 6; final double[] array2 = new double[2]; array2[0] = 5; array2[1] = 6; final double[] array3 = new double[3]; array3[0] = 5; array3[1] = 6; array3[2] = 7; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testFloatArrayHiddenByObject() { final float[] array1 = new float[2]; array1[0] = 5; array1[1] = 6; final float[] array2 = new float[2]; array2[0] = 5; array2[1] = 6; final float[] array3 = new float[3]; array3[0] = 5; array3[1] = 6; array3[2] = 7; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = 7; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } @Test public void testBooleanArrayHiddenByObject() { final boolean[] array1 = new boolean[2]; array1[0] = true; array1[1] = false; final boolean[] array2 = new boolean[2]; array2[0] = true; array2[1] = false; final boolean[] array3 = new boolean[3]; array3[0] = true; array3[1] = false; array3[2] = true; final Object obj1 = array1; final Object obj2 = array2; final Object obj3 = array3; assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0); assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0); assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0); array1[1] = true; assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0); assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.HashMap; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.DefaultToStringStyleTest}. * * @version $Id$ */ public class DefaultToStringStyleTest { private final Integer base = Integer.valueOf(5); private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base)); @Before public void setUp() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } @After public void tearDown() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } //---------------------------------------------------------------- @Test public void testBlank() { assertEquals(baseStr + "[]", new ToStringBuilder(base).toString()); } @Test public void testAppendSuper() { assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString()); assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testPerson() { final Person p = new Person(); p.name = "John Doe"; p.age = 33; p.smoker = false; final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p)); assertEquals(pBaseStr + "[name=John Doe,age=33,smoker=false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); } @Test public void testLong() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Arrays; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.EqualsBuilder}. * * @version $Id$ */ public class EqualsBuilderTest { //----------------------------------------------------------------------- static class TestObject { private int a; public TestObject() { } public TestObject(final int a) { this.a = a; } @Override public boolean equals(final Object o) { if (o == null) { return false; } if (o == this) { return true; } if (o.getClass() != getClass()) { return false; } final TestObject rhs = (TestObject) o; return a == rhs.a; } @Override public int hashCode() { return a; } public void setA(final int a) { this.a = a; } public int getA() { return a; } } static class TestSubObject extends TestObject { private int b; public TestSubObject() { super(0); } public TestSubObject(final int a, final int b) { super(a); this.b = b; } @Override public boolean equals(final Object o) { if (o == null) { return false; } if (o == this) { return true; } if (o.getClass() != getClass()) { return false; } final TestSubObject rhs = (TestSubObject) o; return super.equals(o) && b == rhs.b; } @Override public int hashCode() { return b *17 + super.hashCode(); } public void setB(final int b) { this.b = b; } public int getB() { return b; } } static class TestEmptySubObject extends TestObject { public TestEmptySubObject(final int a) { super(a); } } static class TestTSubObject extends TestObject { @SuppressWarnings("unused") private transient int t; public TestTSubObject(final int a, final int t) { super(a); this.t = t; } } static class TestTTSubObject extends TestTSubObject { @SuppressWarnings("unused") private transient int tt; public TestTTSubObject(final int a, final int t, final int tt) { super(a, t); this.tt = tt; } } static class TestTTLeafObject extends TestTTSubObject { @SuppressWarnings("unused") private final int leafValue; public TestTTLeafObject(final int a, final int t, final int tt, final int leafValue) { super(a, t, tt); this.leafValue = leafValue; } } static class TestTSubObject2 extends TestObject { private transient int t; public TestTSubObject2(final int a, final int t) { super(a); } public int getT() { return t; } public void setT(final int t) { this.t = t; } } @Test public void testReflectionEquals() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(5); assertTrue(EqualsBuilder.reflectionEquals(o1, o1)); assertTrue(!EqualsBuilder.reflectionEquals(o1, o2)); o2.setA(4); assertTrue(EqualsBuilder.reflectionEquals(o1, o2)); assertTrue(!EqualsBuilder.reflectionEquals(o1, this)); assertTrue(!EqualsBuilder.reflectionEquals(o1, null)); assertTrue(!EqualsBuilder.reflectionEquals(null, o2)); assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null)); } @Test public void testReflectionHierarchyEquals() { testReflectionHierarchyEquals(false); testReflectionHierarchyEquals(true); // Transients assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true)); assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false)); assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true)); assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true)); assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true)); } private void testReflectionHierarchyEquals(final boolean testTransients) { final TestObject to1 = new TestObject(4); final TestObject to1Bis = new TestObject(4); final TestObject to1Ter = new TestObject(4); final TestObject to2 = new TestObject(5); final TestEmptySubObject teso = new TestEmptySubObject(4); final TestTSubObject ttso = new TestTSubObject(4, 1); final TestTTSubObject tttso = new TestTTSubObject(4, 1, 2); final TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3); final TestSubObject tso1 = new TestSubObject(1, 4); final TestSubObject tso1bis = new TestSubObject(1, 4); final TestSubObject tso1ter = new TestSubObject(1, 4); final TestSubObject tso2 = new TestSubObject(2, 5); testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients); testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients); // More sanity checks: // same values assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients)); assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients)); // same super values, diff sub values assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients)); // diff super values, same sub values assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients)); // mix super and sub types: equals assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients)); assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients)); assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert // mix super and sub types: NOT equals assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo)); assertTrue(!EqualsBuilder.reflectionEquals(tso1, this)); } /** * Equivalence relationship tests inspired by "Effective Java": * <ul> * <li>reflection</li> * <li>symmetry</li> * <li>transitive</li> * <li>consistency</li> * <li>non-null reference</li> * </ul> * @param to a TestObject * @param toBis a TestObject, equal to to and toTer * @param toTer Left hand side, equal to to and toBis * @param to2 a different TestObject * @param oToChange a TestObject that will be changed * @param testTransients whether to test transient instance variables */ private void testReflectionEqualsEquivalenceRelationship( final TestObject to, final TestObject toBis, final TestObject toTer, final TestObject to2, final TestObject oToChange, final boolean testTransients) { // reflection test assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients)); assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients)); // symmetry test assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients)); // transitive test assertTrue( EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients) && EqualsBuilder.reflectionEquals(to, toTer, testTransients)); // consistency test oToChange.setA(to.getA()); if (oToChange instanceof TestSubObject) { ((TestSubObject) oToChange).setB(((TestSubObject) to).getB()); } assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients)); assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients)); oToChange.setA(to.getA() + 1); if (oToChange instanceof TestSubObject) { ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1); } assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients)); // non-null reference test assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients)); assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients)); assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients)); } @Test public void testSuper() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(5); assertTrue(new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals()); assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals()); assertFalse(new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals()); assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals()); } @Test public void testObject() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(5); assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); o2.setA(4); assertTrue(new EqualsBuilder().append(o1, o2).isEquals()); assertTrue(!new EqualsBuilder().append(o1, this).isEquals()); assertTrue(!new EqualsBuilder().append(o1, null).isEquals()); assertTrue(!new EqualsBuilder().append(null, o2).isEquals()); assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals()); } @Test public void testObjectBuild() { final TestObject o1 = new TestObject(4); final TestObject o2 = new TestObject(5); assertEquals(Boolean.TRUE, new EqualsBuilder().append(o1, o1).build()); assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, o2).build()); o2.setA(4); assertEquals(Boolean.TRUE, new EqualsBuilder().append(o1, o2).build()); assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, this).build()); assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, null).build()); assertEquals(Boolean.FALSE, new EqualsBuilder().append(null, o2).build()); assertEquals(Boolean.TRUE, new EqualsBuilder().append((Object) null, (Object) null).build()); } @Test public void testLong() { final long o1 = 1L; final long o2 = 2L; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); } @Test public void testInt() { final int o1 = 1; final int o2 = 2; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); } @Test public void testShort() { final short o1 = 1; final short o2 = 2; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); } @Test public void testChar() { final char o1 = 1; final char o2 = 2; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); } @Test public void testByte() { final byte o1 = 1; final byte o2 = 2; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); } @Test public void testDouble() { final double o1 = 1; final double o2 = 2; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals()); assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals()); assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals()); } @Test public void testFloat() { final float o1 = 1; final float o2 = 2; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals()); assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals()); assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals()); } @Test public void testAccessors() { final EqualsBuilder equalsBuilder = new EqualsBuilder(); assertTrue(equalsBuilder.isEquals()); equalsBuilder.setEquals(true); assertTrue(equalsBuilder.isEquals()); equalsBuilder.setEquals(false); assertFalse(equalsBuilder.isEquals()); } @Test public void testReset() { final EqualsBuilder equalsBuilder = new EqualsBuilder(); assertTrue(equalsBuilder.isEquals()); equalsBuilder.setEquals(false); assertFalse(equalsBuilder.isEquals()); equalsBuilder.reset(); assertTrue(equalsBuilder.isEquals()); } @Test public void testBoolean() { final boolean o1 = true; final boolean o2 = false; assertTrue(new EqualsBuilder().append(o1, o1).isEquals()); assertTrue(!new EqualsBuilder().append(o1, o2).isEquals()); } @Test public void testObjectArray() { TestObject[] obj1 = new TestObject[3]; obj1[0] = new TestObject(4); obj1[1] = new TestObject(5); obj1[2] = null; TestObject[] obj2 = new TestObject[3]; obj2[0] = new TestObject(4); obj2[1] = new TestObject(5); obj2[2] = null; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj2, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1].setA(6); assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1].setA(5); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[2] = obj1[1]; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[2] = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testLongArray() { long[] obj1 = new long[2]; obj1[0] = 5L; obj1[1] = 6L; long[] obj2 = new long[2]; obj2[0] = 5L; obj2[1] = 6L; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testIntArray() { int[] obj1 = new int[2]; obj1[0] = 5; obj1[1] = 6; int[] obj2 = new int[2]; obj2[0] = 5; obj2[1] = 6; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testShortArray() { short[] obj1 = new short[2]; obj1[0] = 5; obj1[1] = 6; short[] obj2 = new short[2]; obj2[0] = 5; obj2[1] = 6; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testCharArray() { char[] obj1 = new char[2]; obj1[0] = 5; obj1[1] = 6; char[] obj2 = new char[2]; obj2[0] = 5; obj2[1] = 6; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testByteArray() { byte[] obj1 = new byte[2]; obj1[0] = 5; obj1[1] = 6; byte[] obj2 = new byte[2]; obj2[0] = 5; obj2[1] = 6; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testDoubleArray() { double[] obj1 = new double[2]; obj1[0] = 5; obj1[1] = 6; double[] obj2 = new double[2]; obj2[0] = 5; obj2[1] = 6; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testFloatArray() { float[] obj1 = new float[2]; obj1[0] = 5; obj1[1] = 6; float[] obj2 = new float[2]; obj2[0] = 5; obj2[1] = 6; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testBooleanArray() { boolean[] obj1 = new boolean[2]; obj1[0] = true; obj1[1] = false; boolean[] obj2 = new boolean[2]; obj2[0] = true; obj2[1] = false; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); obj1[1] = true; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj2 = null; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); obj1 = null; assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testMultiLongArray() { final long[][] array1 = new long[2][2]; final long[][] array2 = new long[2][2]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiIntArray() { final int[][] array1 = new int[2][2]; final int[][] array2 = new int[2][2]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiShortArray() { final short[][] array1 = new short[2][2]; final short[][] array2 = new short[2][2]; for (short i = 0; i < array1.length; ++i) { for (short j = 0; j < array1[0].length; j++) { array1[i][j] = i; array2[i][j] = i; } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiCharArray() { final char[][] array1 = new char[2][2]; final char[][] array2 = new char[2][2]; for (char i = 0; i < array1.length; ++i) { for (char j = 0; j < array1[0].length; j++) { array1[i][j] = i; array2[i][j] = i; } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiByteArray() { final byte[][] array1 = new byte[2][2]; final byte[][] array2 = new byte[2][2]; for (byte i = 0; i < array1.length; ++i) { for (byte j = 0; j < array1[0].length; j++) { array1[i][j] = i; array2[i][j] = i; } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiFloatArray() { final float[][] array1 = new float[2][2]; final float[][] array2 = new float[2][2]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiDoubleArray() { final double[][] array1 = new double[2][2]; final double[][] array2 = new double[2][2]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMultiBooleanArray() { final boolean[][] array1 = new boolean[2][2]; final boolean[][] array2 = new boolean[2][2]; for (int i = 0; i < array1.length; ++i) { for (int j = 0; j < array1[0].length; j++) { array1[i][j] = i == 1 || j == 1; array2[i][j] = i == 1 || j == 1; } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = false; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); // compare 1 dim to 2. final boolean[] array3 = new boolean[]{true, true}; assertFalse(new EqualsBuilder().append(array1, array3).isEquals()); assertFalse(new EqualsBuilder().append(array3, array1).isEquals()); assertFalse(new EqualsBuilder().append(array2, array3).isEquals()); assertFalse(new EqualsBuilder().append(array3, array2).isEquals()); } @Test public void testRaggedArray() { final long array1[][] = new long[2][]; final long array2[][] = new long[2][]; for (int i = 0; i < array1.length; ++i) { array1[i] = new long[2]; array2[i] = new long[2]; for (int j = 0; j < array1[i].length; ++j) { array1[i][j] = (i + 1) * (j + 1); array2[i][j] = (i + 1) * (j + 1); } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); array1[1][1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testMixedArray() { final Object array1[] = new Object[2]; final Object array2[] = new Object[2]; for (int i = 0; i < array1.length; ++i) { array1[i] = new long[2]; array2[i] = new long[2]; for (int j = 0; j < 2; ++j) { ((long[]) array1[i])[j] = (i + 1) * (j + 1); ((long[]) array2[i])[j] = (i + 1) * (j + 1); } } assertTrue(new EqualsBuilder().append(array1, array1).isEquals()); assertTrue(new EqualsBuilder().append(array1, array2).isEquals()); ((long[]) array1[1])[1] = 0; assertTrue(!new EqualsBuilder().append(array1, array2).isEquals()); } @Test public void testObjectArrayHiddenByObject() { final TestObject[] array1 = new TestObject[2]; array1[0] = new TestObject(4); array1[1] = new TestObject(5); final TestObject[] array2 = new TestObject[2]; array2[0] = new TestObject(4); array2[1] = new TestObject(5); final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1].setA(6); assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testLongArrayHiddenByObject() { final long[] array1 = new long[2]; array1[0] = 5L; array1[1] = 6L; final long[] array2 = new long[2]; array2[0] = 5L; array2[1] = 6L; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testIntArrayHiddenByObject() { final int[] array1 = new int[2]; array1[0] = 5; array1[1] = 6; final int[] array2 = new int[2]; array2[0] = 5; array2[1] = 6; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testShortArrayHiddenByObject() { final short[] array1 = new short[2]; array1[0] = 5; array1[1] = 6; final short[] array2 = new short[2]; array2[0] = 5; array2[1] = 6; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testCharArrayHiddenByObject() { final char[] array1 = new char[2]; array1[0] = 5; array1[1] = 6; final char[] array2 = new char[2]; array2[0] = 5; array2[1] = 6; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testByteArrayHiddenByObject() { final byte[] array1 = new byte[2]; array1[0] = 5; array1[1] = 6; final byte[] array2 = new byte[2]; array2[0] = 5; array2[1] = 6; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testDoubleArrayHiddenByObject() { final double[] array1 = new double[2]; array1[0] = 5; array1[1] = 6; final double[] array2 = new double[2]; array2[0] = 5; array2[1] = 6; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testFloatArrayHiddenByObject() { final float[] array1 = new float[2]; array1[0] = 5; array1[1] = 6; final float[] array2 = new float[2]; array2[0] = 5; array2[1] = 6; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = 7; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } @Test public void testBooleanArrayHiddenByObject() { final boolean[] array1 = new boolean[2]; array1[0] = true; array1[1] = false; final boolean[] array2 = new boolean[2]; array2[0] = true; array2[1] = false; final Object obj1 = array1; final Object obj2 = array2; assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array1).isEquals()); assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals()); assertTrue(new EqualsBuilder().append(obj1, array2).isEquals()); array1[1] = true; assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals()); } public static class TestACanEqualB { private final int a; public TestACanEqualB(final int a) { this.a = a; } @Override public boolean equals(final Object o) { if (o == this) { return true; } if (o instanceof TestACanEqualB) { return this.a == ((TestACanEqualB) o).getA(); } if (o instanceof TestBCanEqualA) { return this.a == ((TestBCanEqualA) o).getB(); } return false; } @Override public int hashCode() { return a; } public int getA() { return this.a; } } public static class TestBCanEqualA { private final int b; public TestBCanEqualA(final int b) { this.b = b; } @Override public boolean equals(final Object o) { if (o == this) { return true; } if (o instanceof TestACanEqualB) { return this.b == ((TestACanEqualB) o).getA(); } if (o instanceof TestBCanEqualA) { return this.b == ((TestBCanEqualA) o).getB(); } return false; } @Override public int hashCode() { return b; } public int getB() { return this.b; } } /** * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses * of each other and do not share a parent aside from Object. * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069 */ @Test public void testUnrelatedClasses() { final Object[] x = new Object[]{new TestACanEqualB(1)}; final Object[] y = new Object[]{new TestBCanEqualA(1)}; // sanity checks: assertTrue(Arrays.equals(x, x)); assertTrue(Arrays.equals(y, y)); assertTrue(Arrays.equals(x, y)); assertTrue(Arrays.equals(y, x)); // real tests: assertTrue(x[0].equals(x[0])); assertTrue(y[0].equals(y[0])); assertTrue(x[0].equals(y[0])); assertTrue(y[0].equals(x[0])); assertTrue(new EqualsBuilder().append(x, x).isEquals()); assertTrue(new EqualsBuilder().append(y, y).isEquals()); assertTrue(new EqualsBuilder().append(x, y).isEquals()); assertTrue(new EqualsBuilder().append(y, x).isEquals()); } /** * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 */ @Test public void testNpeForNullElement() { final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) }; final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) }; // causes an NPE in 2.0 according to: // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067 new EqualsBuilder().append(x1, x2); } @Test public void testReflectionEqualsExcludeFields() throws Exception { final TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3); final TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4); // not equal when including all fields assertTrue(!EqualsBuilder.reflectionEquals(x1, x2)); // doesn't barf on null, empty array, or non-existent field, but still tests as not equal assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, (String[]) null)); assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {})); assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {"xxx"})); // not equal if only one of the differing fields excluded assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {"two"})); assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {"three"})); // equal if both differing fields excluded assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"two", "three"})); // still equal as long as both differing fields are among excluded assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"one", "two", "three"})); assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"one", "two", "three", "xxx"})); } static class TestObjectWithMultipleFields { @SuppressWarnings("unused") private final TestObject one; @SuppressWarnings("unused") private final TestObject two; @SuppressWarnings("unused") private final TestObject three; public TestObjectWithMultipleFields(final int one, final int two, final int three) { this.one = new TestObject(one); this.two = new TestObject(two); this.three = new TestObject(three); } } /** * Test cyclical object references which cause a StackOverflowException if * not handled properly. s. LANG-606 */ @Test public void testCyclicalObjectReferences() { final TestObjectReference refX1 = new TestObjectReference(1); final TestObjectReference x1 = new TestObjectReference(1); x1.setObjectReference(refX1); refX1.setObjectReference(x1); final TestObjectReference refX2 = new TestObjectReference(1); final TestObjectReference x2 = new TestObjectReference(1); x2.setObjectReference(refX2); refX2.setObjectReference(x2); final TestObjectReference refX3 = new TestObjectReference(2); final TestObjectReference x3 = new TestObjectReference(2); x3.setObjectReference(refX3); refX3.setObjectReference(x3); assertTrue(x1.equals(x2)); assertNull(EqualsBuilder.getRegistry()); assertFalse(x1.equals(x3)); assertNull(EqualsBuilder.getRegistry()); assertFalse(x2.equals(x3)); assertNull(EqualsBuilder.getRegistry()); } static class TestObjectReference { @SuppressWarnings("unused") private TestObjectReference reference; @SuppressWarnings("unused") private final TestObject one; public TestObjectReference(final int one) { this.one = new TestObject(one); } public void setObjectReference(final TestObjectReference reference) { this.reference = reference; } @Override public boolean equals(final Object obj) { return EqualsBuilder.reflectionEquals(this, obj); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import org.junit.Test; /** * Tests {@link org.apache.commons.lang3.builder.HashCodeBuilder} and * {@link org.apache.commons.lang3.builder.EqualsBuilderTest} to insure that equal * objects must have equal hash codes. * * @version $Id$ */ public class HashCodeBuilderAndEqualsBuilderTest { //----------------------------------------------------------------------- private void testInteger(final boolean testTransients) { final Integer i1 = Integer.valueOf(12345); final Integer i2 = Integer.valueOf(12345); assertEqualsAndHashCodeContract(i1, i2, testTransients); } @Test public void testInteger() { testInteger(false); } @Test public void testIntegerWithTransients() { testInteger(true); } @Test public void testFixture() { testFixture(false); } @Test public void testFixtureWithTransients() { testFixture(true); } private void testFixture(final boolean testTransients) { assertEqualsAndHashCodeContract(new TestFixture(2, 'c', "Test", (short) 2), new TestFixture(2, 'c', "Test", (short) 2), testTransients); assertEqualsAndHashCodeContract( new AllTransientFixture(2, 'c', "Test", (short) 2), new AllTransientFixture(2, 'c', "Test", (short) 2), testTransients); assertEqualsAndHashCodeContract( new SubTestFixture(2, 'c', "Test", (short) 2, "Same"), new SubTestFixture(2, 'c', "Test", (short) 2, "Same"), testTransients); assertEqualsAndHashCodeContract( new SubAllTransientFixture(2, 'c', "Test", (short) 2, "Same"), new SubAllTransientFixture(2, 'c', "Test", (short) 2, "Same"), testTransients); } /** * Asserts that if <code>lhs</code> equals <code>rhs</code> * then their hash codes MUST be identical. * * @param lhs The Left-Hand-Side of the equals test * @param rhs The Right-Hand-Side of the equals test * @param testTransients wether to test transient fields */ private void assertEqualsAndHashCodeContract(final Object lhs, final Object rhs, final boolean testTransients) { if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) { // test a couple of times for consistency. assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients)); assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients)); assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients)); } } static class TestFixture { int i; char c; String string; short s; TestFixture(final int i, final char c, final String string, final short s) { this.i = i; this.c = c; this.string = string; this.s = s; } } static class SubTestFixture extends TestFixture { transient String tString; SubTestFixture(final int i, final char c, final String string, final short s, final String tString) { super(i, c, string, s); this.tString = tString; } } static class AllTransientFixture { transient int i; transient char c; transient String string; transient short s; AllTransientFixture(final int i, final char c, final String string, final short s) { this.i = i; this.c = c; this.string = string; this.s = s; } } static class SubAllTransientFixture extends AllTransientFixture { transient String tString; SubAllTransientFixture(final int i, final char c, final String string, final short s, final String tString) { super(i, c, string, s); this.tString = tString; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.HashCodeBuilder}. * * @version $Id$ */ public class HashCodeBuilderTest { /** * A reflection test fixture. */ static class ReflectionTestCycleA { ReflectionTestCycleB b; @Override public int hashCode() { return HashCodeBuilder.reflectionHashCode(this); } } /** * A reflection test fixture. */ static class ReflectionTestCycleB { ReflectionTestCycleA a; @Override public int hashCode() { return HashCodeBuilder.reflectionHashCode(this); } } // ----------------------------------------------------------------------- @Test(expected=IllegalArgumentException.class) public void testConstructorEx1() { new HashCodeBuilder(0, 0); } @Test(expected=IllegalArgumentException.class) public void testConstructorEx2() { new HashCodeBuilder(2, 2); } static class TestObject { private int a; public TestObject(final int a) { this.a = a; } @Override public boolean equals(final Object o) { if (o == this) { return true; } if (!(o instanceof TestObject)) { return false; } final TestObject rhs = (TestObject) o; return a == rhs.a; } @Override public int hashCode() { return a; } public void setA(final int a) { this.a = a; } public int getA() { return a; } } static class TestSubObject extends TestObject { private int b; @SuppressWarnings("unused") transient private int t; public TestSubObject() { super(0); } public TestSubObject(final int a, final int b, final int t) { super(a); this.b = b; this.t = t; } @Override public boolean equals(final Object o) { if (o == this) { return true; } if (!(o instanceof TestSubObject)) { return false; } final TestSubObject rhs = (TestSubObject) o; return super.equals(o) && b == rhs.b; } @Override public int hashCode() { return b*17 + super.hashCode(); } } @Test public void testReflectionHashCode() { assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0))); assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456))); } @Test public void testReflectionHierarchyHashCode() { assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0))); assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true)); assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0))); assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject( 123456, 7890, 0), true)); } @Test(expected=IllegalArgumentException.class) public void testReflectionHierarchyHashCodeEx1() { HashCodeBuilder.reflectionHashCode(0, 0, new TestSubObject(0, 0, 0), true); } @Test(expected=IllegalArgumentException.class) public void testReflectionHierarchyHashCodeEx2() { HashCodeBuilder.reflectionHashCode(2, 2, new TestSubObject(0, 0, 0), true); } @Test(expected=IllegalArgumentException.class) public void testReflectionHashCodeEx1() { HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true); } @Test(expected=IllegalArgumentException.class) public void testReflectionHashCodeEx2() { HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true); } @Test(expected=IllegalArgumentException.class) public void testReflectionHashCodeEx3() { HashCodeBuilder.reflectionHashCode(13, 19, null, true); } @Test public void testSuper() { final Object obj = new Object(); assertEquals(17 * 37 + 19 * 41 + obj.hashCode(), new HashCodeBuilder(17, 37).appendSuper( new HashCodeBuilder(19, 41).append(obj).toHashCode()).toHashCode()); } @Test public void testObject() { Object obj = null; assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj = new Object(); assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testObjectBuild() { Object obj = null; assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).build().intValue()); obj = new Object(); assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).build().intValue()); } @Test @SuppressWarnings("cast") // cast is not really needed, keep for consistency public void testLong() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode()); assertEquals(17 * 37 + (int) (123456789L ^ 123456789L >> 32), new HashCodeBuilder(17, 37).append( (long) 123456789L).toHashCode()); } @Test @SuppressWarnings("cast") // cast is not really needed, keep for consistency public void testInt() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode()); assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode()); } @Test public void testShort() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode()); assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode()); } @Test public void testChar() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode()); assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode()); } @Test public void testByte() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode()); assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode()); } @Test @SuppressWarnings("cast") // cast is not really needed, keep for consistency public void testDouble() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode()); final double d = 1234567.89; final long l = Double.doubleToLongBits(d); assertEquals(17 * 37 + (int) (l ^ l >> 32), new HashCodeBuilder(17, 37).append(d).toHashCode()); } @Test @SuppressWarnings("cast") // cast is not really needed, keep for consistency public void testFloat() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode()); final float f = 1234.89f; final int i = Float.floatToIntBits(f); assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode()); } @Test public void testBoolean() { assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode()); assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode()); } @Test public void testObjectArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode()); final Object[] obj = new Object[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = new Object(); assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = new Object(); assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj) .toHashCode()); } @Test public void testObjectArrayAsObject() { final Object[] obj = new Object[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = new Object(); assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = new Object(); assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append( (Object) obj).toHashCode()); } @Test public void testLongArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode()); final long[] obj = new long[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = 5L; final int h1 = (int) (5L ^ 5L >> 32); assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = 6L; final int h2 = (int) (6L ^ 6L >> 32); assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testLongArrayAsObject() { final long[] obj = new long[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = 5L; final int h1 = (int) (5L ^ 5L >> 32); assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = 6L; final int h2 = (int) (6L ^ 6L >> 32); assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testIntArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode()); final int[] obj = new int[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testIntArrayAsObject() { final int[] obj = new int[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testShortArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode()); final short[] obj = new short[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = (short) 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = (short) 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testShortArrayAsObject() { final short[] obj = new short[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = (short) 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = (short) 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testCharArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode()); final char[] obj = new char[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = (char) 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = (char) 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testCharArrayAsObject() { final char[] obj = new char[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = (char) 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = (char) 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testByteArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode()); final byte[] obj = new byte[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = (byte) 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = (byte) 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testByteArrayAsObject() { final byte[] obj = new byte[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = (byte) 5; assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = (byte) 6; assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testDoubleArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode()); final double[] obj = new double[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = 5.4d; final long l1 = Double.doubleToLongBits(5.4d); final int h1 = (int) (l1 ^ l1 >> 32); assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = 6.3d; final long l2 = Double.doubleToLongBits(6.3d); final int h2 = (int) (l2 ^ l2 >> 32); assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testDoubleArrayAsObject() { final double[] obj = new double[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = 5.4d; final long l1 = Double.doubleToLongBits(5.4d); final int h1 = (int) (l1 ^ l1 >> 32); assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = 6.3d; final long l2 = Double.doubleToLongBits(6.3d); final int h2 = (int) (l2 ^ l2 >> 32); assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testFloatArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode()); final float[] obj = new float[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = 5.4f; final int h1 = Float.floatToIntBits(5.4f); assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = 6.3f; final int h2 = Float.floatToIntBits(6.3f); assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testFloatArrayAsObject() { final float[] obj = new float[2]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = 5.4f; final int h1 = Float.floatToIntBits(5.4f); assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = 6.3f; final int h2 = Float.floatToIntBits(6.3f); assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testBooleanArray() { assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode()); final boolean[] obj = new boolean[2]; assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = true; assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = false; assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testBooleanArrayAsObject() { final boolean[] obj = new boolean[2]; assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[0] = true; assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); obj[1] = false; assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode()); } @Test public void testBooleanMultiArray() { final boolean[][] obj = new boolean[2][]; assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = new boolean[0]; assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = new boolean[1]; assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0] = new boolean[2]; assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[0][0] = true; assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode()); obj[1] = new boolean[1]; assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode()); } @Test public void testReflectionHashCodeExcludeFields() throws Exception { final TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3); assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x)); assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, (String[]) null)); assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, new String[]{})); assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, new String[]{"xxx"})); assertEquals((17 * 37 + 1) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, new String[]{"two"})); assertEquals((17 * 37 + 1) * 37 + 2, HashCodeBuilder.reflectionHashCode(x, new String[]{"three"})); assertEquals(17 * 37 + 1, HashCodeBuilder.reflectionHashCode(x, new String[]{"two", "three"})); assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{"one", "two", "three"})); assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{"one", "two", "three", "xxx"})); } static class TestObjectWithMultipleFields { @SuppressWarnings("unused") private int one = 0; @SuppressWarnings("unused") private int two = 0; @SuppressWarnings("unused") private int three = 0; public TestObjectWithMultipleFields(final int one, final int two, final int three) { this.one = one; this.two = two; this.three = three; } } /** * Test Objects pointing to each other. */ @Test public void testReflectionObjectCycle() { final ReflectionTestCycleA a = new ReflectionTestCycleA(); final ReflectionTestCycleB b = new ReflectionTestCycleB(); a.b = b; b.a = a; // Used to caused: // java.lang.StackOverflowError // at java.lang.ClassLoader.getCallerClassLoader(Native Method) // at java.lang.Class.getDeclaredFields(Class.java:992) // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373) // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349) // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155) // at // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53) // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422) // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383) // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349) // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155) // at // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42) // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422) a.hashCode(); assertNull(HashCodeBuilder.getRegistry()); b.hashCode(); assertNull(HashCodeBuilder.getRegistry()); } /** * Ensures LANG-520 remains true */ @Test public void testToHashCodeEqualsHashCode() { final HashCodeBuilder hcb = new HashCodeBuilder(17, 37).append(new Object()).append('a'); assertEquals("hashCode() is no longer returning the same value as toHashCode() - see LANG-520", hcb.toHashCode(), hcb.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.HashMap; import org.apache.commons.lang3.SystemUtils; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.MultiLineToStringStyleTest}. * * @version $Id$ */ public class MultiLineToStringStyleTest { private final Integer base = Integer.valueOf(5); private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base)); @Before public void setUp() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.MULTI_LINE_STYLE); } @After public void tearDown() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } //---------------------------------------------------------------- @Test public void testBlank() { assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).toString()); } @Test public void testAppendSuper() { assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "]").toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]").toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "]").append("a", "hello").toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + " a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]").append("a", "hello").toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) null).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " 3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(i3).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=<null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=3" + SystemUtils.LINE_SEPARATOR + " b=4" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=<Integer>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=[]" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testPerson() { final Person p = new Person(); p.name = "Jane Doe"; p.age = 25; p.smoker = true; final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p)); assertEquals(pBaseStr + "[" + SystemUtils.LINE_SEPARATOR + " name=Jane Doe" + SystemUtils.LINE_SEPARATOR + " age=25" + SystemUtils.LINE_SEPARATOR + " smoker=true" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); } @Test public void testLong() { assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " 3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(3L).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " a=3" + SystemUtils.LINE_SEPARATOR + " b=4" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " {<null>,5,{3,6}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " {<null>,5,{3,6}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " {1,2,-3,4}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " {1,2,-3,4}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " {{1,2},<null>,{5}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " {{1,2},<null>,{5}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + " <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.HashMap; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.NoFieldNamesToStringStyleTest}. * * @version $Id$ */ public class NoFieldNamesToStringStyleTest { private final Integer base = Integer.valueOf(5); private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base)); @Before public void setUp() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE); } @After public void tearDown() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } //---------------------------------------------------------------- @Test public void testBlank() { assertEquals(baseStr + "[]", new ToStringBuilder(base).toString()); } @Test public void testAppendSuper() { assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString()); assertEquals(baseStr + "[hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString()); assertEquals(baseStr + "[<null>,hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString()); assertEquals(baseStr + "[hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", i3).toString()); assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals(baseStr + "[<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals(baseStr + "[[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testPerson() { final Person p = new Person(); p.name = "Ron Paul"; p.age = 72; p.smoker = false; final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p)); assertEquals(pBaseStr + "[Ron Paul,72,false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); } @Test public void testLong() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import java.util.ArrayList; import java.util.Collection; import java.util.List; import org.junit.Assert; import org.apache.commons.lang3.ArrayUtils; import org.junit.Test; /** * @version $Id$ */ public class ReflectionToStringBuilderExcludeTest { class TestFixture { @SuppressWarnings("unused") private final String secretField = SECRET_VALUE; @SuppressWarnings("unused") private final String showField = NOT_SECRET_VALUE; } private static final String NOT_SECRET_FIELD = "showField"; private static final String NOT_SECRET_VALUE = "Hello World!"; private static final String SECRET_FIELD = "secretField"; private static final String SECRET_VALUE = "secret value"; @Test public void test_toStringExclude() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD); this.validateSecretFieldAbsent(toString); } @Test public void test_toStringExcludeArray() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{SECRET_FIELD}); this.validateSecretFieldAbsent(toString); } @Test public void test_toStringExcludeArrayWithNull() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null}); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeArrayWithNulls() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null, null}); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeCollection() { final List<String> excludeList = new ArrayList<String>(); excludeList.add(SECRET_FIELD); final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); this.validateSecretFieldAbsent(toString); } @Test public void test_toStringExcludeCollectionWithNull() { final List<String> excludeList = new ArrayList<String>(); excludeList.add(null); final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeCollectionWithNulls() { final List<String> excludeList = new ArrayList<String>(); excludeList.add(null); excludeList.add(null); final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeEmptyArray() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), ArrayUtils.EMPTY_STRING_ARRAY); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeEmptyCollection() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList<String>()); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeNullArray() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null); this.validateSecretFieldPresent(toString); } @Test public void test_toStringExcludeNullCollection() { final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection<String>) null); this.validateSecretFieldPresent(toString); } private void validateNonSecretField(final String toString) { Assert.assertTrue(toString.indexOf(NOT_SECRET_FIELD) > ArrayUtils.INDEX_NOT_FOUND); Assert.assertTrue(toString.indexOf(NOT_SECRET_VALUE) > ArrayUtils.INDEX_NOT_FOUND); } private void validateSecretFieldAbsent(final String toString) { Assert.assertEquals(ArrayUtils.INDEX_NOT_FOUND, toString.indexOf(SECRET_VALUE)); this.validateNonSecretField(toString); } private void validateSecretFieldPresent(final String toString) { Assert.assertTrue(toString.indexOf(SECRET_VALUE) > 0); this.validateNonSecretField(toString); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.HashMap; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.ToStringStyle#SHORT_PREFIX_STYLE}. * * @version $Id$ */ public class ShortPrefixToStringStyleTest { private final Integer base = Integer.valueOf(5); private final String baseStr = "Integer"; @Before public void setUp() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.SHORT_PREFIX_STYLE); } @After public void tearDown() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } //---------------------------------------------------------------- @Test public void testBlank() { assertEquals(baseStr + "[]", new ToStringBuilder(base).toString()); } @Test public void testAppendSuper() { assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString()); assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testPerson() { final Person p = new Person(); p.name = "John Q. Public"; p.age = 45; p.smoker = true; final String pBaseStr = "ToStringStyleTest.Person"; assertEquals(pBaseStr + "[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); } @Test public void testLong() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.HashMap; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.SimpleToStringStyleTest}. * * @version $Id$ */ public class SimpleToStringStyleTest { private final Integer base = Integer.valueOf(5); @Before public void setUp() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.SIMPLE_STYLE); } @After public void tearDown() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } //---------------------------------------------------------------- @Test public void testBlank() { assertEquals("", new ToStringBuilder(base).toString()); } @Test public void testAppendSuper() { assertEquals("", new ToStringBuilder(base).appendSuper("").toString()); assertEquals("<null>", new ToStringBuilder(base).appendSuper("<null>").toString()); assertEquals("hello", new ToStringBuilder(base).appendSuper("").append("a", "hello").toString()); assertEquals("<null>,hello", new ToStringBuilder(base).appendSuper("<null>").append("a", "hello").toString()); assertEquals("hello", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals("<null>", new ToStringBuilder(base).append((Object) null).toString()); assertEquals("3", new ToStringBuilder(base).append(i3).toString()); assertEquals("<null>", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals("3", new ToStringBuilder(base).append("a", i3).toString()); assertEquals("3,4", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals("<Integer>", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals("<size=0>", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals("[]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals("<size=0>", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals("{}", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals("<size=0>", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals("{}", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testPerson() { final Person p = new Person(); p.name = "Jane Q. Public"; p.age = 47; p.smoker = false; assertEquals("Jane Q. Public,47,false", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); } @Test public void testLong() { assertEquals("3", new ToStringBuilder(base).append(3L).toString()); assertEquals("3", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals("3,4", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append(array).toString()); assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append(array).toString()); assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString()); assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals("<null>", new ToStringBuilder(base).append(array).toString()); assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import java.util.ArrayList; import java.util.HashMap; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.builder.ToStringStyle}. * * @version $Id$ */ public class StandardToStringStyleTest { private final Integer base = Integer.valueOf(5); private final String baseStr = "Integer"; private static final StandardToStringStyle STYLE = new StandardToStringStyle(); static { STYLE.setUseShortClassName(true); STYLE.setUseIdentityHashCode(false); STYLE.setArrayStart("["); STYLE.setArraySeparator(", "); STYLE.setArrayEnd("]"); STYLE.setNullText("%NULL%"); STYLE.setSizeStartText("%SIZE="); STYLE.setSizeEndText("%"); STYLE.setSummaryObjectStartText("%"); STYLE.setSummaryObjectEndText("%"); } @Before public void setUp() throws Exception { ToStringBuilder.setDefaultStyle(STYLE); } @After public void tearDown() throws Exception { ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } //---------------------------------------------------------------- @Test public void testBlank() { assertEquals(baseStr + "[]", new ToStringBuilder(base).toString()); } @Test public void testAppendSuper() { assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString()); assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).appendSuper("Integer@8888[%NULL%]").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString()); assertEquals(baseStr + "[%NULL%,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[%NULL%]").append("a", "hello").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) null).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); assertEquals(baseStr + "[a=%NULL%]", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals(baseStr + "[a=%Integer%]", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testPerson() { final Person p = new Person(); p.name = "Suzy Queue"; p.age = 19; p.smoker = false; final String pBaseStr = "ToStringStyleTest.Person"; assertEquals(pBaseStr + "[name=Suzy Queue,age=19,smoker=false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString()); } @Test public void testLong() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import org.apache.commons.lang3.SystemUtils; import org.junit.After; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.builder.ToStringBuilder}. * * @version $Id$ */ public class ToStringBuilderTest { private final Integer base = Integer.valueOf(5); private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base)); /* * All tests should leave the registry empty. */ @After public void after(){ validateNullToStringStyleRegistry(); } //----------------------------------------------------------------------- @Test public void testConstructorEx1() { assertEquals("<null>", new ToStringBuilder(null).toString()); } @Test public void testConstructorEx2() { assertEquals("<null>", new ToStringBuilder(null, null).toString()); new ToStringBuilder(this.base, null).toString(); } @Test public void testConstructorEx3() { assertEquals("<null>", new ToStringBuilder(null, null, null).toString()); new ToStringBuilder(this.base, null, null).toString(); new ToStringBuilder(this.base, ToStringStyle.DEFAULT_STYLE, null).toString(); } @Test public void testGetSetDefault() { try { ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE); assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle()); } finally { // reset for other tests ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); } } @Test(expected=IllegalArgumentException.class) public void testSetDefaultEx() { ToStringBuilder.setDefaultStyle(null); } @Test public void testBlank() { assertEquals(baseStr + "[]", new ToStringBuilder(base).toString()); } /** * Test wrapper for int primitive. */ @Test public void testReflectionInteger() { assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base)); } /** * Test wrapper for char primitive. */ @Test public void testReflectionCharacter() { final Character c = new Character('A'); assertEquals(this.toBaseString(c) + "[value=A]", ToStringBuilder.reflectionToString(c)); } /** * Test wrapper for char boolean. */ @Test public void testReflectionBoolean() { Boolean b; b = Boolean.TRUE; assertEquals(this.toBaseString(b) + "[value=true]", ToStringBuilder.reflectionToString(b)); b = Boolean.FALSE; assertEquals(this.toBaseString(b) + "[value=false]", ToStringBuilder.reflectionToString(b)); } /** * Create the same toString() as Object.toString(). * @param o the object to create the string for. * @return a String in the Object.toString format. */ private String toBaseString(final Object o) { return o.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(o)); } // Reflection Array tests // // Note on the following line of code repeated in the reflection array tests. // // assertReflectionArray("<null>", array); // // The expected value is not baseStr + "[<null>]" since array==null and is typed as Object. // The null array does not carry array type information. // If we added a primitive array type constructor and pile of associated methods, // then type declaring type information could be carried forward. IMHO, null is null. // // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com // public void assertReflectionArray(final String expected, final Object actual) { if (actual == null) { // Until ToStringBuilder supports null objects. return; } assertEquals(expected, ToStringBuilder.reflectionToString(actual)); assertEquals(expected, ToStringBuilder.reflectionToString(actual, null)); assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, true)); assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, false)); } @Test public void testReflectionObjectArray() { Object[] array = new Object[] { null, base, new int[] { 3, 6 } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{<null>,5,{3,6}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionLongArray() { long[] array = new long[] { 1, 2, -3, 4 }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionIntArray() { int[] array = new int[] { 1, 2, -3, 4 }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionShortArray() { short[] array = new short[] { 1, 2, -3, 4 }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionyteArray() { byte[] array = new byte[] { 1, 2, -3, 4 }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionCharArray() { char[] array = new char[] { 'A', '2', '_', 'D' }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{A,2,_,D}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionDoubleArray() { double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionFloatArray() { float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionBooleanArray() { boolean[] array = new boolean[] { true, false, false }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } // Reflection Array Array tests @Test public void testReflectionFloatArrayArray() { float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionLongArrayArray() { long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionIntArrayArray() { int[][] array = new int[][] { { 1, 2 }, null, { 5 } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionhortArrayArray() { short[][] array = new short[][] { { 1, 2 }, null, { 5 } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionByteArrayArray() { byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionCharArrayArray() { char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{A,B},<null>,{p}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionDoubleArrayArray() { double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } @Test public void testReflectionBooleanArrayArray() { boolean[][] array = new boolean[][] { { true, false }, null, { false } }; final String baseStr = this.toBaseString(array); assertEquals(baseStr + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array)); assertEquals(baseStr + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array)); array = null; assertReflectionArray("<null>", array); } // Reflection hierarchy tests @Test public void testReflectionHierarchyArrayList() {} // Defects4J: flaky method // @Test // public void testReflectionHierarchyArrayList() { // final List<Object> base = new ArrayList<Object>(); // final String baseStr = this.toBaseString(base); // // note, the test data depends on the internal representation of the ArrayList, which may differ between JDK versions and vendors // final String expectedWithTransients = baseStr + "[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]"; // final String toStringWithTransients = ToStringBuilder.reflectionToString(base, null, true); // if (!expectedWithTransients.equals(toStringWithTransients)) { // // representation different for IBM JDK 1.6.0, LANG-727 // if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) { // assertEquals(expectedWithTransients, toStringWithTransients); // } // } // final String expectedWithoutTransients = baseStr + "[size=0]"; // final String toStringWithoutTransients = ToStringBuilder.reflectionToString(base, null, false); // if (!expectedWithoutTransients.equals(toStringWithoutTransients)) { // // representation different for IBM JDK 1.6.0, LANG-727 // if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) { // assertEquals(expectedWithoutTransients, toStringWithoutTransients); // } // } // } @Test public void testReflectionHierarchy() { final ReflectionTestFixtureA baseA = new ReflectionTestFixtureA(); String baseStr = this.toBaseString(baseA); assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA)); assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null)); assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false)); assertEquals(baseStr + "[a=a,transientA=t]", ToStringBuilder.reflectionToString(baseA, null, true)); assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, null)); assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, Object.class)); assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class)); final ReflectionTestFixtureB baseB = new ReflectionTestFixtureB(); baseStr = this.toBaseString(baseB); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB)); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB)); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null)); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false)); assertEquals(baseStr + "[b=b,transientB=t,a=a,transientA=t]", ToStringBuilder.reflectionToString(baseB, null, true)); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, null)); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, Object.class)); assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class)); assertEquals(baseStr + "[b=b]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class)); } static class ReflectionTestFixtureA { @SuppressWarnings("unused") private final char a='a'; @SuppressWarnings("unused") private transient char transientA='t'; } static class ReflectionTestFixtureB extends ReflectionTestFixtureA { @SuppressWarnings("unused") private final char b='b'; @SuppressWarnings("unused") private transient char transientB='t'; } @Test public void testInnerClassReflection() { final Outer outer = new Outer(); assertEquals(toBaseString(outer) + "[inner=" + toBaseString(outer.inner) + "[]]", outer.toString()); } static class Outer { Inner inner = new Inner(); class Inner { @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } // Reflection cycle tests /** * Test an array element pointing to its container. */ @Test public void testReflectionArrayCycle() throws Exception { final Object[] objects = new Object[1]; objects[0] = objects; assertEquals( this.toBaseString(objects) + "[{" + this.toBaseString(objects) + "}]", ToStringBuilder.reflectionToString(objects)); } /** * Test an array element pointing to its container. */ @Test public void testReflectionArrayCycleLevel2() throws Exception { final Object[] objects = new Object[1]; final Object[] objectsLevel2 = new Object[1]; objects[0] = objectsLevel2; objectsLevel2[0] = objects; assertEquals( this.toBaseString(objects) + "[{{" + this.toBaseString(objects) + "}}]", ToStringBuilder.reflectionToString(objects)); assertEquals( this.toBaseString(objectsLevel2) + "[{{" + this.toBaseString(objectsLevel2) + "}}]", ToStringBuilder.reflectionToString(objectsLevel2)); } @Test public void testReflectionArrayArrayCycle() throws Exception { final Object[][] objects = new Object[2][2]; objects[0][0] = objects; objects[0][1] = objects; objects[1][0] = objects; objects[1][1] = objects; final String basicToString = this.toBaseString(objects); assertEquals( basicToString + "[{{" + basicToString + "," + basicToString + "},{" + basicToString + "," + basicToString + "}}]", ToStringBuilder.reflectionToString(objects)); } /** * A reflection test fixture. */ static class ReflectionTestCycleA { ReflectionTestCycleB b; @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } /** * A reflection test fixture. */ static class ReflectionTestCycleB { ReflectionTestCycleA a; @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } /** * A reflection test fixture. */ static class SimpleReflectionTestFixture { Object o; public SimpleReflectionTestFixture() { } public SimpleReflectionTestFixture(final Object o) { this.o = o; } @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } private static class SelfInstanceVarReflectionTestFixture { @SuppressWarnings("unused") private final SelfInstanceVarReflectionTestFixture typeIsSelf; public SelfInstanceVarReflectionTestFixture() { this.typeIsSelf = this; } @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } private static class SelfInstanceTwoVarsReflectionTestFixture { @SuppressWarnings("unused") private final SelfInstanceTwoVarsReflectionTestFixture typeIsSelf; private final String otherType = "The Other Type"; public SelfInstanceTwoVarsReflectionTestFixture() { this.typeIsSelf = this; } public String getOtherType(){ return this.otherType; } @Override public String toString() { return ToStringBuilder.reflectionToString(this); } } /** * Test an Object pointing to itself, the simplest test. * * @throws Exception */ @Test public void testSimpleReflectionObjectCycle() throws Exception { final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(); simple.o = simple; assertEquals(this.toBaseString(simple) + "[o=" + this.toBaseString(simple) + "]", simple.toString()); } /** * Test a class that defines an ivar pointing to itself. * * @throws Exception */ @Test public void testSelfInstanceVarReflectionObjectCycle() throws Exception { final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture(); assertEquals(this.toBaseString(test) + "[typeIsSelf=" + this.toBaseString(test) + "]", test.toString()); } /** * Test a class that defines an ivar pointing to itself. This test was * created to show that handling cyclical object resulted in a missing endFieldSeparator call. * * @throws Exception */ @Test public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception { final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture(); assertEquals(this.toBaseString(test) + "[typeIsSelf=" + this.toBaseString(test) + ",otherType=" + test.getOtherType().toString() + "]", test.toString()); } /** * Test Objects pointing to each other. * * @throws Exception */ @Test public void testReflectionObjectCycle() throws Exception { final ReflectionTestCycleA a = new ReflectionTestCycleA(); final ReflectionTestCycleB b = new ReflectionTestCycleB(); a.b = b; b.a = a; assertEquals( this.toBaseString(a) + "[b=" + this.toBaseString(b) + "[a=" + this.toBaseString(a) + "]]", a.toString()); } /** * Test a nasty combination of arrays and Objects pointing to each other. * objects[0] -> SimpleReflectionTestFixture[ o -> objects ] * * @throws Exception */ @Test public void testReflectionArrayAndObjectCycle() throws Exception { final Object[] objects = new Object[1]; final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects); objects[0] = simple; assertEquals( this.toBaseString(objects) + "[{" + this.toBaseString(simple) + "[o=" + this.toBaseString(objects) + "]" + "}]", ToStringBuilder.reflectionToString(objects)); assertEquals( this.toBaseString(simple) + "[o={" + this.toBaseString(simple) + "}]", ToStringBuilder.reflectionToString(simple)); } void validateNullToStringStyleRegistry() { final Map<Object, Object> registry = ToStringStyle.getRegistry(); assertNull("Expected null, actual: "+registry, registry); } // End: Reflection cycle tests @Test public void testAppendSuper() { assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString()); assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString()); } @Test public void testAppendToString() { assertEquals(baseStr + "[]", new ToStringBuilder(base).appendToString("Integer@8888[]").toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[]").append("a", "hello").toString()); assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").append("a", "hello").toString()); assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString(null).append("a", "hello").toString()); } @Test public void testObject() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString()); assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString()); assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString()); assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString()); } @Test public void testObjectBuild() { final Integer i3 = Integer.valueOf(3); final Integer i4 = Integer.valueOf(4); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).build()); assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).build()); assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).build()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).build()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).build()); assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).build()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).build()); assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).build()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).build()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).build()); assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).build()); assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).build()); } @Test public void testLong() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString()); } @SuppressWarnings("cast") // cast is not really needed, keep for consistency @Test public void testInt() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((int) 3).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (int) 3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (int) 3).append("b", (int) 4).toString()); } @Test public void testShort() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString()); } @Test public void testChar() { assertEquals(baseStr + "[A]", new ToStringBuilder(base).append((char) 65).toString()); assertEquals(baseStr + "[a=A]", new ToStringBuilder(base).append("a", (char) 65).toString()); assertEquals(baseStr + "[a=A,b=B]", new ToStringBuilder(base).append("a", (char) 65).append("b", (char) 66).toString()); } @Test public void testByte() { assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString()); assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString()); assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString()); } @SuppressWarnings("cast") @Test public void testDouble() { assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((double) 3.2).toString()); assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (double) 3.2).toString()); assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (double) 3.2).append("b", (double) 4.3).toString()); } @Test public void testFloat() { assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString()); assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString()); assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString()); } @Test public void testBoolean() { assertEquals(baseStr + "[true]", new ToStringBuilder(base).append(true).toString()); assertEquals(baseStr + "[a=true]", new ToStringBuilder(base).append("a", true).toString()); assertEquals(baseStr + "[a=true,b=false]", new ToStringBuilder(base).append("a", true).append("b", false).toString()); } @Test public void testObjectArray() { Object[] array = new Object[] {null, base, new int[] {3, 6}}; assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArray() { long[] array = new long[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testIntArray() { int[] array = new int[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testShortArray() { short[] array = new short[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testByteArray() { byte[] array = new byte[] {1, 2, -3, 4}; assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testCharArray() { char[] array = new char[] {'A', '2', '_', 'D'}; assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testDoubleArray() { double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3}; assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testFloatArray() { float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f}; assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testBooleanArray() { boolean[] array = new boolean[] {true, false, false}; assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testLongArrayArray() { long[][] array = new long[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testIntArrayArray() { int[][] array = new int[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testShortArrayArray() { short[][] array = new short[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testByteArrayArray() { byte[][] array = new byte[][] {{1, 2}, null, {5}}; assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testCharArrayArray() { char[][] array = new char[][] {{'A', 'B'}, null, {'p'}}; assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testDoubleArrayArray() { double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}}; assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testFloatArrayArray() { float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}}; assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testBooleanArrayArray() { boolean[][] array = new boolean[][] {{true, false}, null, {false}}; assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append((Object) array).toString()); array = null; assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString()); assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString()); } @Test public void testObjectCycle() { final ObjectCycle a = new ObjectCycle(); final ObjectCycle b = new ObjectCycle(); a.obj = b; b.obj = a; final String expected = toBaseString(a) + "[" + toBaseString(b) + "[" + toBaseString(a) + "]]"; assertEquals(expected, a.toString()); } static class ObjectCycle { Object obj; @Override public String toString() { return new ToStringBuilder(this).append(obj).toString(); } } @Test public void testSimpleReflectionStatics() { final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture(); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, true, true, SimpleReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); } /** * Tests ReflectionToStringBuilder.toString() for statics. */ @Test public void testReflectionStatics() { final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture(); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]", ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]", this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class)); } /** * Tests ReflectionToStringBuilder.toString() for statics. */ @Test public void testInheritedReflectionStatics() { final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture(); assertEquals( this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]", ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); assertEquals( this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]", this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class)); } /** * <p>This method uses reflection to build a suitable * <code>toString</code> value which includes static fields.</p> * * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private * fields. This means that it will throw a security exception if run * under a security manager, if the permissions are not set up correctly. * It is also not as efficient as testing explicitly. </p> * * <p>Transient fields are not output.</p> * * <p>Superclass fields will be appended up to and including the specified superclass. * A null superclass is treated as <code>java.lang.Object</code>.</p> * * <p>If the style is <code>null</code>, the default * <code>ToStringStyle</code> is used.</p> * * @param object the Object to be output * @param style the style of the <code>toString</code> to create, * may be <code>null</code> * @param reflectUpToClass the superclass to reflect up to (inclusive), * may be <code>null</code> * @return the String result * @throws IllegalArgumentException if the Object is <code>null</code> */ public <T> String toStringWithStatics(final T object, final ToStringStyle style, final Class<? super T> reflectUpToClass) { return ReflectionToStringBuilder.toString(object, style, false, true, reflectUpToClass); } /** * Tests ReflectionToStringBuilder setUpToClass(). */ @Test public void test_setUpToClass_valid() { final Integer val = Integer.valueOf(5); final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); test.setUpToClass(Number.class); test.toString(); } /** * Tests ReflectionToStringBuilder setUpToClass(). */ @Test(expected=IllegalArgumentException.class) public void test_setUpToClass_invalid() { final Integer val = Integer.valueOf(5); final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val); try { test.setUpToClass(String.class); } finally { test.toString(); } } /** * Tests ReflectionToStringBuilder.toString() for statics. */ class ReflectionStaticFieldsFixture { static final String staticString = "staticString"; static final int staticInt = 12345; static final transient String staticTransientString = "staticTransientString"; static final transient int staticTransientInt = 54321; String instanceString = "instanceString"; int instanceInt = 67890; transient String transientString = "transientString"; transient int transientInt = 98765; } /** * Test fixture for ReflectionToStringBuilder.toString() for statics. */ class SimpleReflectionStaticFieldsFixture { static final String staticString = "staticString"; static final int staticInt = 12345; } /** * Test fixture for ReflectionToStringBuilder.toString() for statics. */ class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture { static final String staticString2 = "staticString2"; static final int staticInt2 = 67890; } @Test public void testReflectionNull() { assertEquals("<null>", ReflectionToStringBuilder.toString(null)); } /** * Points out failure to print anything from appendToString methods using MULTI_LINE_STYLE. * See issue LANG-372. */ class MultiLineTestObject { Integer i = Integer.valueOf(31337); @Override public String toString() { return new ToStringBuilder(this).append("testInt", i).toString(); } } @Test public void testAppendToStringUsingMultiLineStyle() { final MultiLineTestObject obj = new MultiLineTestObject(); final ToStringBuilder testBuilder = new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE) .appendToString(obj.toString()); assertEquals(testBuilder.toString().indexOf("testInt=31337"), -1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import java.util.ArrayList; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import org.junit.Test; /** * Tests concurrent access for the default {@link ToStringStyle}. * <p> * The {@link ToStringStyle} class includes a registry to avoid infinite loops for objects with circular references. We * want to make sure that we do not get concurrency exceptions accessing this registry. * </p> * <p> * This test passes but only tests one aspect of the issue. * </p> * * @see <a href="https://issues.apache.org/jira/browse/LANG-762">[LANG-762] Handle or document ReflectionToStringBuilder * and ToStringBuilder for collections that are not thread safe</a> * @since 3.1 * @version $Id$ */ public class ToStringStyleConcurrencyTest { static class CollectionHolder<T extends Collection<?>> { T collection; CollectionHolder(final T collection) { this.collection = collection; } } private static final List<Integer> LIST; private static final int LIST_SIZE = 100000; private static final int REPEAT = 100; static { LIST = new ArrayList<Integer>(LIST_SIZE); for (int i = 0; i < LIST_SIZE; i++) { LIST.add(Integer.valueOf(i)); } } @Test public void testLinkedList() throws InterruptedException, ExecutionException { this.testConcurrency(new CollectionHolder<List<Integer>>(new LinkedList<Integer>())); } @Test public void testArrayList() throws InterruptedException, ExecutionException { this.testConcurrency(new CollectionHolder<List<Integer>>(new ArrayList<Integer>())); } @Test public void testCopyOnWriteArrayList() throws InterruptedException, ExecutionException { this.testConcurrency(new CollectionHolder<List<Integer>>(new CopyOnWriteArrayList<Integer>())); } private void testConcurrency(final CollectionHolder<List<Integer>> holder) throws InterruptedException, ExecutionException { final List<Integer> list = holder.collection; // make a big array that takes a long time to toString() list.addAll(LIST); // Create a thread pool with two threads to cause the most contention on the underlying resource. final ExecutorService threadPool = Executors.newFixedThreadPool(2); // Consumes toStrings final Callable<Integer> consumer = new Callable<Integer>() { @Override public Integer call() { for (int i = 0; i < REPEAT; i++) { // Calls ToStringStyle new ToStringBuilder(holder).append(holder.collection); } return Integer.valueOf(REPEAT); } }; final Collection<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>(); tasks.add(consumer); tasks.add(consumer); final List<Future<Integer>> futures = threadPool.invokeAll(tasks); for (final Future<Integer> future : futures) { future.get(); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.builder; import static org.junit.Assert.assertEquals; import org.junit.Test; /** * Test case for ToStringStyle. * * @version $Id$ */ public class ToStringStyleTest { private static class ToStringStyleImpl extends ToStringStyle { } //----------------------------------------------------------------------- @Test public void testSetArrayStart() { final ToStringStyle style = new ToStringStyleImpl(); style.setArrayStart(null); assertEquals("", style.getArrayStart()); } @Test public void testSetArrayEnd() { final ToStringStyle style = new ToStringStyleImpl(); style.setArrayEnd(null); assertEquals("", style.getArrayEnd()); } @Test public void testSetArraySeparator() { final ToStringStyle style = new ToStringStyleImpl(); style.setArraySeparator(null); assertEquals("", style.getArraySeparator()); } @Test public void testSetContentStart() { final ToStringStyle style = new ToStringStyleImpl(); style.setContentStart(null); assertEquals("", style.getContentStart()); } @Test public void testSetContentEnd() { final ToStringStyle style = new ToStringStyleImpl(); style.setContentEnd(null); assertEquals("", style.getContentEnd()); } @Test public void testSetFieldNameValueSeparator() { final ToStringStyle style = new ToStringStyleImpl(); style.setFieldNameValueSeparator(null); assertEquals("", style.getFieldNameValueSeparator()); } @Test public void testSetFieldSeparator() { final ToStringStyle style = new ToStringStyleImpl(); style.setFieldSeparator(null); assertEquals("", style.getFieldSeparator()); } @Test public void testSetNullText() { final ToStringStyle style = new ToStringStyleImpl(); style.setNullText(null); assertEquals("", style.getNullText()); } @Test public void testSetSizeStartText() { final ToStringStyle style = new ToStringStyleImpl(); style.setSizeStartText(null); assertEquals("", style.getSizeStartText()); } @Test public void testSetSizeEndText() { final ToStringStyle style = new ToStringStyleImpl(); style.setSizeEndText(null); assertEquals("", style.getSizeEndText()); } @Test public void testSetSummaryObjectStartText() { final ToStringStyle style = new ToStringStyleImpl(); style.setSummaryObjectStartText(null); assertEquals("", style.getSummaryObjectStartText()); } @Test public void testSetSummaryObjectEndText() { final ToStringStyle style = new ToStringStyleImpl(); style.setSummaryObjectEndText(null); assertEquals("", style.getSummaryObjectEndText()); } /** * An object used to test {@link ToStringStyle}. * */ static class Person { /** * Test String field. */ String name; /** * Test integer field. */ int age; /** * Test boolean field. */ boolean smoker; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; /** * Test class for {@code AtomicInitializer}. * * @version $Id$ */ public class AtomicInitializerTest extends AbstractConcurrentInitializerTest { /** * Returns the initializer to be tested. * * @return the {@code AtomicInitializer} */ @Override protected ConcurrentInitializer<Object> createInitializer() { return new AtomicInitializer<Object>() { @Override protected Object initialize() throws ConcurrentException { return new Object(); } }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import java.util.concurrent.atomic.AtomicInteger; import org.junit.Before; import org.junit.Test; /** * Test class for {@code AtomicSafeInitializer}. * * @version $Id$ */ public class AtomicSafeInitializerTest extends AbstractConcurrentInitializerTest { /** The instance to be tested. */ private AtomicSafeInitializerTestImpl initializer; @Before public void setUp() throws Exception { initializer = new AtomicSafeInitializerTestImpl(); } /** * Returns the initializer to be tested. * * @return the {@code AtomicSafeInitializer} under test */ @Override protected ConcurrentInitializer<Object> createInitializer() { return initializer; } /** * Tests that initialize() is called only once. */ @Test public void testNumberOfInitializeInvocations() throws ConcurrentException, InterruptedException { testGetConcurrent(); assertEquals("Wrong number of invocations", 1, initializer.initCounter.get()); } /** * A concrete test implementation of {@code AtomicSafeInitializer}. This * implementation also counts the number of invocations of the initialize() * method. */ private static class AtomicSafeInitializerTestImpl extends AtomicSafeInitializer<Object> { /** A counter for initialize() invocations. */ final AtomicInteger initCounter = new AtomicInteger(); @Override protected Object initialize() throws ConcurrentException { initCounter.incrementAndGet(); return new Object(); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import org.junit.Test; import static org.junit.Assert.*; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference; public class BackgroundInitializerTest { /** * Helper method for checking whether the initialize() method was correctly * called. start() must already have been invoked. * * @param init the initializer to test */ private void checkInitialize(final BackgroundInitializerTestImpl init) { try { final Integer result = init.get(); assertEquals("Wrong result", 1, result.intValue()); assertEquals("Wrong number of invocations", 1, init.initializeCalls); assertNotNull("No future", init.getFuture()); } catch (final ConcurrentException cex) { fail("Unexpected exception: " + cex); } } /** * Tests whether initialize() is invoked. */ @Test public void testInitialize() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); checkInitialize(init); } /** * Tries to obtain the executor before start(). It should not have been * initialized yet. */ @Test public void testGetActiveExecutorBeforeStart() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); assertNull("Got an executor", init.getActiveExecutor()); } /** * Tests whether an external executor is correctly detected. */ @Test public void testGetActiveExecutorExternal() { final ExecutorService exec = Executors.newSingleThreadExecutor(); try { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl( exec); init.start(); assertSame("Wrong executor", exec, init.getActiveExecutor()); checkInitialize(init); } finally { exec.shutdown(); } } /** * Tests getActiveExecutor() for a temporary executor. */ @Test public void testGetActiveExecutorTemp() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); assertNotNull("No active executor", init.getActiveExecutor()); checkInitialize(init); } /** * Tests the execution of the background task if a temporary executor has to * be created. */ @Test public void testInitializeTempExecutor() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); assertTrue("Wrong result of start()", init.start()); checkInitialize(init); assertTrue("Executor not shutdown", init.getActiveExecutor() .isShutdown()); } /** * Tests whether an external executor can be set using the * setExternalExecutor() method. */ @Test public void testSetExternalExecutor() throws Exception { final ExecutorService exec = Executors.newCachedThreadPool(); try { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.setExternalExecutor(exec); assertEquals("Wrong executor service", exec, init .getExternalExecutor()); assertTrue("Wrong result of start()", init.start()); assertSame("Wrong active executor", exec, init.getActiveExecutor()); checkInitialize(init); assertFalse("Executor was shutdown", exec.isShutdown()); } finally { exec.shutdown(); } } /** * Tests that setting an executor after start() causes an exception. */ @Test public void testSetExternalExecutorAfterStart() throws ConcurrentException { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); try { init.setExternalExecutor(Executors.newSingleThreadExecutor()); fail("Could set executor after start()!"); } catch (final IllegalStateException istex) { init.get(); } } /** * Tests invoking start() multiple times. Only the first invocation should * have an effect. */ @Test public void testStartMultipleTimes() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); assertTrue("Wrong result for start()", init.start()); for (int i = 0; i < 10; i++) { assertFalse("Could start again", init.start()); } checkInitialize(init); } /** * Tests calling get() before start(). This should cause an exception. */ @Test(expected=IllegalStateException.class) public void testGetBeforeStart() throws ConcurrentException { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.get(); } /** * Tests the get() method if background processing causes a runtime * exception. */ @Test public void testGetRuntimeException() throws Exception { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); final RuntimeException rex = new RuntimeException(); init.ex = rex; init.start(); try { init.get(); fail("Exception not thrown!"); } catch (final Exception ex) { assertEquals("Runtime exception not thrown", rex, ex); } } /** * Tests the get() method if background processing causes a checked * exception. */ @Test public void testGetCheckedException() throws Exception { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); final Exception ex = new Exception(); init.ex = ex; init.start(); try { init.get(); fail("Exception not thrown!"); } catch (final ConcurrentException cex) { assertEquals("Exception not thrown", ex, cex.getCause()); } } /** * Tests the get() method if waiting for the initialization is interrupted. */ @Test public void testGetInterruptedException() throws Exception { final ExecutorService exec = Executors.newSingleThreadExecutor(); final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl( exec); final CountDownLatch latch1 = new CountDownLatch(1); init.shouldSleep = true; init.start(); final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>(); final Thread getThread = new Thread() { @Override public void run() { try { init.get(); } catch (final ConcurrentException cex) { if (cex.getCause() instanceof InterruptedException) { iex.set((InterruptedException) cex.getCause()); } } finally { assertTrue("Thread not interrupted", isInterrupted()); latch1.countDown(); } } }; getThread.start(); getThread.interrupt(); latch1.await(); exec.shutdownNow(); exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS); assertNotNull("No interrupted exception", iex.get()); } /** * Tests isStarted() before start() was called. */ @Test public void testIsStartedFalse() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); assertFalse("Already started", init.isStarted()); } /** * Tests isStarted() after start(). */ @Test public void testIsStartedTrue() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); assertTrue("Not started", init.isStarted()); } /** * Tests isStarted() after the background task has finished. */ @Test public void testIsStartedAfterGet() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); checkInitialize(init); assertTrue("Not started", init.isStarted()); } /** * A concrete implementation of BackgroundInitializer. It also overloads * some methods that simplify testing. */ private static class BackgroundInitializerTestImpl extends BackgroundInitializer<Integer> { /** An exception to be thrown by initialize(). */ Exception ex; /** A flag whether the background task should sleep a while. */ boolean shouldSleep; /** The number of invocations of initialize(). */ volatile int initializeCalls; public BackgroundInitializerTestImpl() { super(); } public BackgroundInitializerTestImpl(final ExecutorService exec) { super(exec); } /** * Records this invocation. Optionally throws an exception or sleeps a * while. */ @Override protected Integer initialize() throws Exception { if (ex != null) { throw ex; } if (shouldSleep) { Thread.sleep(60000L); } return Integer.valueOf(++initializeCalls); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import java.util.concurrent.ThreadFactory; import org.easymock.EasyMock; import org.junit.Before; import org.junit.Test; /** * Test class for {@code BasicThreadFactory}. * * @version $Id$ */ public class BasicThreadFactoryTest { /** Constant for the test naming pattern. */ private static final String PATTERN = "testThread-%d"; /** The builder for creating a thread factory. */ private BasicThreadFactory.Builder builder; @Before public void setUp() throws Exception { builder = new BasicThreadFactory.Builder(); } /** * Tests the default options of a thread factory. * * @param factory the factory to be checked */ private void checkFactoryDefaults(final BasicThreadFactory factory) { assertNull("Got a naming pattern", factory.getNamingPattern()); assertNull("Got an exception handler", factory .getUncaughtExceptionHandler()); assertNull("Got a priority", factory.getPriority()); assertNull("Got a daemon flag", factory.getDaemonFlag()); assertNotNull("No wrapped factory", factory.getWrappedFactory()); } /** * Tests the default values used by the builder. */ @Test public void testBuildDefaults() { final BasicThreadFactory factory = builder.build(); checkFactoryDefaults(factory); } /** * Tries to set a null naming pattern. */ @Test(expected = NullPointerException.class) public void testBuildNamingPatternNull() { builder.namingPattern(null); } /** * Tries to set a null wrapped factory. */ @Test(expected = NullPointerException.class) public void testBuildWrappedFactoryNull() { builder.wrappedFactory(null); } /** * Tries to set a null exception handler. */ @Test(expected = NullPointerException.class) public void testBuildUncaughtExceptionHandlerNull() { builder.uncaughtExceptionHandler(null); } /** * Tests the reset() method of the builder. */ @Test public void testBuilderReset() { final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class); final Thread.UncaughtExceptionHandler exHandler = EasyMock .createMock(Thread.UncaughtExceptionHandler.class); EasyMock.replay(wrappedFactory, exHandler); builder.namingPattern(PATTERN).daemon(true).priority( Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler) .wrappedFactory(wrappedFactory); builder.reset(); final BasicThreadFactory factory = builder.build(); checkFactoryDefaults(factory); assertNotSame("Wrapped factory not reset", wrappedFactory, factory .getWrappedFactory()); EasyMock.verify(wrappedFactory, exHandler); } /** * Tests whether reset() is automatically called after build(). */ @Test public void testBuilderResetAfterBuild() { builder.wrappedFactory(EasyMock.createNiceMock(ThreadFactory.class)) .namingPattern(PATTERN).daemon(true).build(); checkFactoryDefaults(builder.build()); } /** * Tests whether the naming pattern is applied to new threads. */ @Test public void testNewThreadNamingPattern() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final int count = 12; for (int i = 0; i < count; i++) { EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread()); } EasyMock.replay(wrapped, r); final BasicThreadFactory factory = builder.wrappedFactory(wrapped) .namingPattern(PATTERN).build(); for (int i = 0; i < count; i++) { final Thread t = factory.newThread(r); assertEquals("Wrong thread name", String.format(PATTERN, Long .valueOf(i + 1)), t.getName()); assertEquals("Wrong thread count", i + 1, factory.getThreadCount()); } EasyMock.verify(wrapped, r); } /** * Tests whether the thread name is not modified if no naming pattern is * set. */ @Test public void testNewThreadNoNamingPattern() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final String name = "unchangedThreadName"; final Thread t = new Thread(name); EasyMock.expect(wrapped.newThread(r)).andReturn(t); EasyMock.replay(wrapped, r); final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build(); assertSame("Wrong thread", t, factory.newThread(r)); assertEquals("Name was changed", name, t.getName()); EasyMock.verify(wrapped, r); } /** * Helper method for testing whether the daemon flag is taken into account. * * @param flag the value of the flag */ private void checkDaemonFlag(final boolean flag) { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final Thread t = new Thread(); EasyMock.expect(wrapped.newThread(r)).andReturn(t); EasyMock.replay(wrapped, r); final BasicThreadFactory factory = builder.wrappedFactory(wrapped).daemon( flag).build(); assertSame("Wrong thread", t, factory.newThread(r)); assertTrue("Wrong daemon flag", flag == t.isDaemon()); EasyMock.verify(wrapped, r); } /** * Tests whether daemon threads can be created. */ @Test public void testNewThreadDaemonTrue() { checkDaemonFlag(true); } /** * Tests whether the daemon status of new threads can be turned off. */ @Test public void testNewThreadDaemonFalse() { checkDaemonFlag(false); } /** * Tests whether the daemon flag is not touched on newly created threads if * it is not specified. */ @Test public void testNewThreadNoDaemonFlag() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r1 = EasyMock.createMock(Runnable.class); final Runnable r2 = EasyMock.createMock(Runnable.class); final Thread t1 = new Thread(); final Thread t2 = new Thread(); t1.setDaemon(true); EasyMock.expect(wrapped.newThread(r1)).andReturn(t1); EasyMock.expect(wrapped.newThread(r2)).andReturn(t2); EasyMock.replay(wrapped, r1, r2); final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build(); assertSame("Wrong thread 1", t1, factory.newThread(r1)); assertTrue("No daemon thread", t1.isDaemon()); assertSame("Wrong thread 2", t2, factory.newThread(r2)); assertFalse("A daemon thread", t2.isDaemon()); EasyMock.verify(wrapped, r1, r2); } /** * Tests whether the priority is set on newly created threads. */ @Test public void testNewThreadPriority() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final Thread t = new Thread(); EasyMock.expect(wrapped.newThread(r)).andReturn(t); EasyMock.replay(wrapped, r); final int priority = Thread.NORM_PRIORITY + 1; final BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority( priority).build(); assertSame("Wrong thread", t, factory.newThread(r)); assertEquals("Wrong priority", priority, t.getPriority()); EasyMock.verify(wrapped, r); } /** * Tests whether the original priority is not changed if no priority is * specified. */ @Test public void testNewThreadNoPriority() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final int orgPriority = Thread.NORM_PRIORITY + 1; final Thread t = new Thread(); t.setPriority(orgPriority); EasyMock.expect(wrapped.newThread(r)).andReturn(t); EasyMock.replay(wrapped, r); final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build(); assertSame("Wrong thread", t, factory.newThread(r)); assertEquals("Wrong priority", orgPriority, t.getPriority()); EasyMock.verify(wrapped, r); } /** * Tests whether the exception handler is set if one is provided. */ @Test public void testNewThreadExHandler() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final Thread.UncaughtExceptionHandler handler = EasyMock .createMock(Thread.UncaughtExceptionHandler.class); final Thread t = new Thread(); EasyMock.expect(wrapped.newThread(r)).andReturn(t); EasyMock.replay(wrapped, r, handler); final BasicThreadFactory factory = builder.wrappedFactory(wrapped) .uncaughtExceptionHandler(handler).build(); assertSame("Wrong thread", t, factory.newThread(r)); assertEquals("Wrong exception handler", handler, t .getUncaughtExceptionHandler()); EasyMock.verify(wrapped, r, handler); } /** * Tests whether the original exception hander is not touched if none is * specified. */ @Test public void testNewThreadNoExHandler() { final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class); final Runnable r = EasyMock.createMock(Runnable.class); final Thread.UncaughtExceptionHandler handler = EasyMock .createMock(Thread.UncaughtExceptionHandler.class); final Thread t = new Thread(); t.setUncaughtExceptionHandler(handler); EasyMock.expect(wrapped.newThread(r)).andReturn(t); EasyMock.replay(wrapped, r, handler); final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build(); assertSame("Wrong thread", t, factory.newThread(r)); assertEquals("Wrong exception handler", handler, t .getUncaughtExceptionHandler()); EasyMock.verify(wrapped, r, handler); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import org.junit.Test; /** * Test class for {@code CallableBackgroundInitializer} * * @version $Id$ */ public class CallableBackgroundInitializerTest { /** Constant for the result of the call() invocation. */ private static final Integer RESULT = Integer.valueOf(42); /** * Tries to create an instance without a Callable. This should cause an * exception. */ @Test(expected=IllegalArgumentException.class) public void testInitNullCallable() { new CallableBackgroundInitializer<Object>(null); } /** * Tests whether the executor service is correctly passed to the super * class. */ @Test public void testInitExecutor() { final ExecutorService exec = Executors.newSingleThreadExecutor(); final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>( new TestCallable(), exec); assertEquals("Executor not set", exec, init.getExternalExecutor()); } /** * Tries to pass a null Callable to the constructor that takes an executor. * This should cause an exception. */ @Test(expected=IllegalArgumentException.class) public void testInitExecutorNullCallable() { final ExecutorService exec = Executors.newSingleThreadExecutor(); new CallableBackgroundInitializer<Integer>(null, exec); } /** * Tests the implementation of initialize(). */ @Test public void testInitialize() throws Exception { final TestCallable call = new TestCallable(); final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>( call); assertEquals("Wrong result", RESULT, init.initialize()); assertEquals("Wrong number of invocations", 1, call.callCount); } /** * A test Callable implementation for checking the initializer's * implementation of the initialize() method. */ private static class TestCallable implements Callable<Integer> { /** A counter for the number of call() invocations. */ int callCount; /** * Records this invocation and returns the test result. */ @Override public Integer call() throws Exception { callCount++; return RESULT; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import org.easymock.EasyMock; import org.junit.Test; /** * Test class for {@link ConcurrentUtils}. * * @version $Id$ */ public class ConcurrentUtilsTest { /** * Tests creating a ConcurrentException with a runtime exception as cause. */ @Test(expected = IllegalArgumentException.class) public void testConcurrentExceptionCauseUnchecked() { new ConcurrentException(new RuntimeException()); } /** * Tests creating a ConcurrentException with an error as cause. */ @Test(expected = IllegalArgumentException.class) public void testConcurrentExceptionCauseError() { new ConcurrentException("An error", new Error()); } /** * Tests creating a ConcurrentException with null as cause. */ @Test(expected = IllegalArgumentException.class) public void testConcurrentExceptionCauseNull() { new ConcurrentException(null); } /** * Tries to create a ConcurrentRuntimeException with a runtime as cause. */ @Test(expected = IllegalArgumentException.class) public void testConcurrentRuntimeExceptionCauseUnchecked() { new ConcurrentRuntimeException(new RuntimeException()); } /** * Tries to create a ConcurrentRuntimeException with an error as cause. */ @Test(expected = IllegalArgumentException.class) public void testConcurrentRuntimeExceptionCauseError() { new ConcurrentRuntimeException("An error", new Error()); } /** * Tries to create a ConcurrentRuntimeException with null as cause. */ @Test(expected = IllegalArgumentException.class) public void testConcurrentRuntimeExceptionCauseNull() { new ConcurrentRuntimeException(null); } /** * Tests extractCause() for a null exception. */ @Test public void testExtractCauseNull() { assertNull("Non null result", ConcurrentUtils.extractCause(null)); } /** * Tests extractCause() if the cause of the passed in exception is null. */ @Test public void testExtractCauseNullCause() { assertNull("Non null result", ConcurrentUtils .extractCause(new ExecutionException("Test", null))); } /** * Tests extractCause() if the cause is an error. */ @Test public void testExtractCauseError() { final Error err = new AssertionError("Test"); try { ConcurrentUtils.extractCause(new ExecutionException(err)); fail("Error not thrown!"); } catch (final Error e) { assertEquals("Wrong error", err, e); } } /** * Tests extractCause() if the cause is an unchecked exception. */ @Test public void testExtractCauseUncheckedException() { final RuntimeException rex = new RuntimeException("Test"); try { ConcurrentUtils.extractCause(new ExecutionException(rex)); fail("Runtime exception not thrown!"); } catch (final RuntimeException r) { assertEquals("Wrong exception", rex, r); } } /** * Tests extractCause() if the cause is a checked exception. */ @Test public void testExtractCauseChecked() { final Exception ex = new Exception("Test"); final ConcurrentException cex = ConcurrentUtils .extractCause(new ExecutionException(ex)); assertSame("Wrong cause", ex, cex.getCause()); } /** * Tests extractCauseUnchecked() for a null exception. */ @Test public void testExtractCauseUncheckedNull() { assertNull("Non null result", ConcurrentUtils.extractCauseUnchecked(null)); } /** * Tests extractCauseUnchecked() if the cause of the passed in exception is null. */ @Test public void testExtractCauseUncheckedNullCause() { assertNull("Non null result", ConcurrentUtils .extractCauseUnchecked(new ExecutionException("Test", null))); } /** * Tests extractCauseUnchecked() if the cause is an error. */ @Test public void testExtractCauseUncheckedError() { final Error err = new AssertionError("Test"); try { ConcurrentUtils.extractCauseUnchecked(new ExecutionException(err)); fail("Error not thrown!"); } catch (final Error e) { assertEquals("Wrong error", err, e); } } /** * Tests extractCauseUnchecked() if the cause is an unchecked exception. */ @Test public void testExtractCauseUncheckedUncheckedException() { final RuntimeException rex = new RuntimeException("Test"); try { ConcurrentUtils.extractCauseUnchecked(new ExecutionException(rex)); fail("Runtime exception not thrown!"); } catch (final RuntimeException r) { assertEquals("Wrong exception", rex, r); } } /** * Tests extractCauseUnchecked() if the cause is a checked exception. */ @Test public void testExtractCauseUncheckedChecked() { final Exception ex = new Exception("Test"); final ConcurrentRuntimeException cex = ConcurrentUtils .extractCauseUnchecked(new ExecutionException(ex)); assertSame("Wrong cause", ex, cex.getCause()); } /** * Tests handleCause() if the cause is an error. */ @Test public void testHandleCauseError() throws ConcurrentException { final Error err = new AssertionError("Test"); try { ConcurrentUtils.handleCause(new ExecutionException(err)); fail("Error not thrown!"); } catch (final Error e) { assertEquals("Wrong error", err, e); } } /** * Tests handleCause() if the cause is an unchecked exception. */ @Test public void testHandleCauseUncheckedException() throws ConcurrentException { final RuntimeException rex = new RuntimeException("Test"); try { ConcurrentUtils.handleCause(new ExecutionException(rex)); fail("Runtime exception not thrown!"); } catch (final RuntimeException r) { assertEquals("Wrong exception", rex, r); } } /** * Tests handleCause() if the cause is a checked exception. */ @Test public void testHandleCauseChecked() { final Exception ex = new Exception("Test"); try { ConcurrentUtils.handleCause(new ExecutionException(ex)); fail("ConcurrentException not thrown!"); } catch (final ConcurrentException cex) { assertEquals("Wrong cause", ex, cex.getCause()); } } /** * Tests handleCause() for a null parameter or a null cause. In this case * the method should do nothing. We can only test that no exception is * thrown. */ @Test public void testHandleCauseNull() throws ConcurrentException { ConcurrentUtils.handleCause(null); ConcurrentUtils.handleCause(new ExecutionException("Test", null)); } /** * Tests handleCauseUnchecked() if the cause is an error. */ @Test public void testHandleCauseUncheckedError() { final Error err = new AssertionError("Test"); try { ConcurrentUtils.handleCauseUnchecked(new ExecutionException(err)); fail("Error not thrown!"); } catch (final Error e) { assertEquals("Wrong error", err, e); } } /** * Tests handleCauseUnchecked() if the cause is an unchecked exception. */ @Test public void testHandleCauseUncheckedUncheckedException() { final RuntimeException rex = new RuntimeException("Test"); try { ConcurrentUtils.handleCauseUnchecked(new ExecutionException(rex)); fail("Runtime exception not thrown!"); } catch (final RuntimeException r) { assertEquals("Wrong exception", rex, r); } } /** * Tests handleCauseUnchecked() if the cause is a checked exception. */ @Test public void testHandleCauseUncheckedChecked() { final Exception ex = new Exception("Test"); try { ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)); fail("ConcurrentRuntimeException not thrown!"); } catch (final ConcurrentRuntimeException crex) { assertEquals("Wrong cause", ex, crex.getCause()); } } /** * Tests handleCauseUnchecked() for a null parameter or a null cause. In * this case the method should do nothing. We can only test that no * exception is thrown. */ @Test public void testHandleCauseUncheckedNull() { ConcurrentUtils.handleCauseUnchecked(null); ConcurrentUtils.handleCauseUnchecked(new ExecutionException("Test", null)); } //----------------------------------------------------------------------- /** * Tests initialize() for a null argument. */ @Test public void testInitializeNull() throws ConcurrentException { assertNull("Got a result", ConcurrentUtils.initialize(null)); } /** * Tests a successful initialize() operation. */ @Test public void testInitialize() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Object> init = EasyMock .createMock(ConcurrentInitializer.class); final Object result = new Object(); EasyMock.expect(init.get()).andReturn(result); EasyMock.replay(init); assertSame("Wrong result object", result, ConcurrentUtils .initialize(init)); EasyMock.verify(init); } /** * Tests initializeUnchecked() for a null argument. */ @Test public void testInitializeUncheckedNull() { assertNull("Got a result", ConcurrentUtils.initializeUnchecked(null)); } /** * Tests a successful initializeUnchecked() operation. */ @Test public void testInitializeUnchecked() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Object> init = EasyMock .createMock(ConcurrentInitializer.class); final Object result = new Object(); EasyMock.expect(init.get()).andReturn(result); EasyMock.replay(init); assertSame("Wrong result object", result, ConcurrentUtils .initializeUnchecked(init)); EasyMock.verify(init); } /** * Tests whether exceptions are correctly handled by initializeUnchecked(). */ @Test public void testInitializeUncheckedEx() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Object> init = EasyMock .createMock(ConcurrentInitializer.class); final Exception cause = new Exception(); EasyMock.expect(init.get()).andThrow(new ConcurrentException(cause)); EasyMock.replay(init); try { ConcurrentUtils.initializeUnchecked(init); fail("Exception not thrown!"); } catch (final ConcurrentRuntimeException crex) { assertSame("Wrong cause", cause, crex.getCause()); } EasyMock.verify(init); } //----------------------------------------------------------------------- /** * Tests constant future. */ @Test public void testConstantFuture_Integer() throws Exception { final Integer value = Integer.valueOf(5); final Future<Integer> test = ConcurrentUtils.constantFuture(value); assertTrue(test.isDone()); assertSame(value, test.get()); assertSame(value, test.get(1000, TimeUnit.SECONDS)); assertSame(value, test.get(1000, null)); assertFalse(test.isCancelled()); assertFalse(test.cancel(true)); assertFalse(test.cancel(false)); } /** * Tests constant future. */ @Test public void testConstantFuture_null() throws Exception { final Integer value = null; final Future<Integer> test = ConcurrentUtils.constantFuture(value); assertTrue(test.isDone()); assertSame(value, test.get()); assertSame(value, test.get(1000, TimeUnit.SECONDS)); assertSame(value, test.get(1000, null)); assertFalse(test.isCancelled()); assertFalse(test.cancel(true)); assertFalse(test.cancel(false)); } //----------------------------------------------------------------------- /** * Tests putIfAbsent() if the map contains the key in question. */ @Test public void testPutIfAbsentKeyPresent() { final String key = "testKey"; final Integer value = 42; final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); map.put(key, value); assertEquals("Wrong result", value, ConcurrentUtils.putIfAbsent(map, key, 0)); assertEquals("Wrong value in map", value, map.get(key)); } /** * Tests putIfAbsent() if the map does not contain the key in question. */ @Test public void testPutIfAbsentKeyNotPresent() { final String key = "testKey"; final Integer value = 42; final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); assertEquals("Wrong result", value, ConcurrentUtils.putIfAbsent(map, key, value)); assertEquals("Wrong value in map", value, map.get(key)); } /** * Tests putIfAbsent() if a null map is passed in. */ @Test public void testPutIfAbsentNullMap() { assertNull("Wrong result", ConcurrentUtils.putIfAbsent(null, "test", 100)); } /** * Tests createIfAbsent() if the key is found in the map. */ @Test public void testCreateIfAbsentKeyPresent() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Integer> init = EasyMock .createMock(ConcurrentInitializer.class); EasyMock.replay(init); final String key = "testKey"; final Integer value = 42; final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); map.put(key, value); assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, init)); assertEquals("Wrong value in map", value, map.get(key)); EasyMock.verify(init); } /** * Tests createIfAbsent() if the map does not contain the key in question. */ @Test public void testCreateIfAbsentKeyNotPresent() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Integer> init = EasyMock .createMock(ConcurrentInitializer.class); final String key = "testKey"; final Integer value = 42; EasyMock.expect(init.get()).andReturn(value); EasyMock.replay(init); final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsent(map, key, init)); assertEquals("Wrong value in map", value, map.get(key)); EasyMock.verify(init); } /** * Tests createIfAbsent() if a null map is passed in. */ @Test public void testCreateIfAbsentNullMap() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Integer> init = EasyMock .createMock(ConcurrentInitializer.class); EasyMock.replay(init); assertNull("Wrong result", ConcurrentUtils.createIfAbsent(null, "test", init)); EasyMock.verify(init); } /** * Tests createIfAbsent() if a null initializer is passed in. */ @Test public void testCreateIfAbsentNullInit() throws ConcurrentException { final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); final String key = "testKey"; final Integer value = 42; map.put(key, value); assertNull("Wrong result", ConcurrentUtils.createIfAbsent(map, key, null)); assertEquals("Map was changed", value, map.get(key)); } /** * Tests createIfAbsentUnchecked() if no exception is thrown. */ @Test public void testCreateIfAbsentUncheckedSuccess() { final String key = "testKey"; final Integer value = 42; final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>(); assertEquals("Wrong result", value, ConcurrentUtils.createIfAbsentUnchecked(map, key, new ConstantInitializer<Integer>(value))); assertEquals("Wrong value in map", value, map.get(key)); } /** * Tests createIfAbsentUnchecked() if an exception is thrown. */ @Test public void testCreateIfAbsentUncheckedException() throws ConcurrentException { @SuppressWarnings("unchecked") final ConcurrentInitializer<Integer> init = EasyMock .createMock(ConcurrentInitializer.class); final Exception ex = new Exception(); EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex)); EasyMock.replay(init); try { ConcurrentUtils.createIfAbsentUnchecked( new ConcurrentHashMap<String, Integer>(), "test", init); fail("Exception not thrown!"); } catch (final ConcurrentRuntimeException crex) { assertEquals("Wrong cause", ex, crex.getCause()); } EasyMock.verify(init); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.regex.Pattern; import org.junit.Before; import org.junit.Test; /** * Test class for {@code ConstantInitializer}. * * @version $Id$ */ public class ConstantInitializerTest { /** Constant for the object managed by the initializer. */ private static final Integer VALUE = 42; /** The initializer to be tested. */ private ConstantInitializer<Integer> init; @Before public void setUp() throws Exception { init = new ConstantInitializer<Integer>(VALUE); } /** * Helper method for testing equals() and hashCode(). * * @param obj the object to compare with the test instance * @param expected the expected result */ private void checkEquals(final Object obj, final boolean expected) { assertTrue("Wrong result of equals", expected == init.equals(obj)); if (obj != null) { assertTrue("Not symmetric", expected == obj.equals(init)); if (expected) { assertEquals("Different hash codes", init.hashCode(), obj.hashCode()); } } } /** * Tests whether the correct object is returned. */ @Test public void testGetObject() { assertEquals("Wrong object", VALUE, init.getObject()); } /** * Tests whether get() returns the correct object. */ @Test public void testGet() throws ConcurrentException { assertEquals("Wrong object", VALUE, init.get()); } /** * Tests equals() if the expected result is true. */ @Test public void testEqualsTrue() { checkEquals(init, true); ConstantInitializer<Integer> init2 = new ConstantInitializer<Integer>( Integer.valueOf(VALUE.intValue())); checkEquals(init2, true); init = new ConstantInitializer<Integer>(null); init2 = new ConstantInitializer<Integer>(null); checkEquals(init2, true); } /** * Tests equals() if the expected result is false. */ @Test public void testEqualsFalse() { ConstantInitializer<Integer> init2 = new ConstantInitializer<Integer>( null); checkEquals(init2, false); init2 = new ConstantInitializer<Integer>(VALUE + 1); checkEquals(init2, false); } /** * Tests equals() with objects of other classes. */ @Test public void testEqualsWithOtherObjects() { checkEquals(null, false); checkEquals(this, false); checkEquals(new ConstantInitializer<String>("Test"), false); } /** * Tests the string representation. */ @Test public void testToString() { final String s = init.toString(); final Pattern pattern = Pattern .compile("ConstantInitializer@\\d+ \\[ object = " + VALUE + " \\]"); assertTrue("Wrong string: " + s, pattern.matcher(s).matches()); } /** * Tests the string representation if the managed object is null. */ @Test public void testToStringNull() { final String s = new ConstantInitializer<Object>(null).toString(); assertTrue("Object not found: " + s, s.indexOf("object = null") > 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import org.junit.Before; /** * Test class for {@code LazyInitializer}. * * @version $Id$ */ public class LazyInitializerTest extends AbstractConcurrentInitializerTest { /** The initializer to be tested. */ private LazyInitializerTestImpl initializer; @Before public void setUp() throws Exception { initializer = new LazyInitializerTestImpl(); } /** * Returns the initializer to be tested. This implementation returns the * {@code LazyInitializer} created in the {@code setUp()} method. * * @return the initializer to be tested */ @Override protected ConcurrentInitializer<Object> createInitializer() { return initializer; } /** * A test implementation of LazyInitializer. This class creates a plain * Object. As Object does not provide a specific equals() method, it is easy * to check whether multiple instances were created. */ private static class LazyInitializerTestImpl extends LazyInitializer<Object> { @Override protected Object initialize() { return new Object(); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import org.junit.Before; import org.junit.Test; /** * Test class for {@link MultiBackgroundInitializer}. * * @version $Id$ */ public class MultiBackgroundInitializerTest { /** Constant for the names of the child initializers. */ private static final String CHILD_INIT = "childInitializer"; /** The initializer to be tested. */ private MultiBackgroundInitializer initializer; @Before public void setUp() throws Exception { initializer = new MultiBackgroundInitializer(); } /** * Tests whether a child initializer has been executed. Optionally the * expected executor service can be checked, too. * * @param child the child initializer * @param expExec the expected executor service (null if the executor should * not be checked) * @throws ConcurrentException if an error occurs */ private void checkChild(final BackgroundInitializer<?> child, final ExecutorService expExec) throws ConcurrentException { final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child; final Integer result = cinit.get(); assertEquals("Wrong result", 1, result.intValue()); assertEquals("Wrong number of executions", 1, cinit.initializeCalls); if (expExec != null) { assertEquals("Wrong executor service", expExec, cinit.currentExecutor); } } /** * Tests addInitializer() if a null name is passed in. This should cause an * exception. */ @Test(expected = IllegalArgumentException.class) public void testAddInitializerNullName() { initializer.addInitializer(null, new ChildBackgroundInitializer()); } /** * Tests addInitializer() if a null initializer is passed in. This should * cause an exception. */ @Test(expected = IllegalArgumentException.class) public void testAddInitializerNullInit() { initializer.addInitializer(CHILD_INIT, null); } /** * Tests the background processing if there are no child initializers. */ @Test public void testInitializeNoChildren() throws ConcurrentException { assertTrue("Wrong result of start()", initializer.start()); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); assertTrue("Got child initializers", res.initializerNames().isEmpty()); assertTrue("Executor not shutdown", initializer.getActiveExecutor() .isShutdown()); } /** * Helper method for testing the initialize() method. This method can * operate with both an external and a temporary executor service. * * @return the result object produced by the initializer */ private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize() throws ConcurrentException { final int count = 5; for (int i = 0; i < count; i++) { initializer.addInitializer(CHILD_INIT + i, new ChildBackgroundInitializer()); } initializer.start(); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); assertEquals("Wrong number of child initializers", count, res .initializerNames().size()); for (int i = 0; i < count; i++) { final String key = CHILD_INIT + i; assertTrue("Name not found: " + key, res.initializerNames() .contains(key)); assertEquals("Wrong result object", Integer.valueOf(1), res .getResultObject(key)); assertFalse("Exception flag", res.isException(key)); assertNull("Got an exception", res.getException(key)); checkChild(res.getInitializer(key), initializer.getActiveExecutor()); } return res; } /** * Tests background processing if a temporary executor is used. */ @Test public void testInitializeTempExec() throws ConcurrentException { checkInitialize(); assertTrue("Executor not shutdown", initializer.getActiveExecutor() .isShutdown()); } /** * Tests background processing if an external executor service is provided. */ @Test public void testInitializeExternalExec() throws ConcurrentException { final ExecutorService exec = Executors.newCachedThreadPool(); try { initializer = new MultiBackgroundInitializer(exec); checkInitialize(); assertEquals("Wrong executor", exec, initializer .getActiveExecutor()); assertFalse("Executor was shutdown", exec.isShutdown()); } finally { exec.shutdown(); } } /** * Tests the behavior of initialize() if a child initializer has a specific * executor service. Then this service should not be overridden. */ @Test public void testInitializeChildWithExecutor() throws ConcurrentException { final String initExec = "childInitializerWithExecutor"; final ExecutorService exec = Executors.newSingleThreadExecutor(); try { final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer(); final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer(); c2.setExternalExecutor(exec); initializer.addInitializer(CHILD_INIT, c1); initializer.addInitializer(initExec, c2); initializer.start(); initializer.get(); checkChild(c1, initializer.getActiveExecutor()); checkChild(c2, exec); } finally { exec.shutdown(); } } /** * Tries to add another child initializer after the start() method has been * called. This should not be allowed. */ @Test public void testAddInitializerAfterStart() throws ConcurrentException { initializer.start(); try { initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); fail("Could add initializer after start()!"); } catch (final IllegalStateException istex) { initializer.get(); } } /** * Tries to query an unknown child initializer from the results object. This * should cause an exception. */ @Test(expected = NoSuchElementException.class) public void testResultGetInitializerUnknown() throws ConcurrentException { final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); res.getInitializer("unknown"); } /** * Tries to query the results of an unknown child initializer from the * results object. This should cause an exception. */ @Test(expected = NoSuchElementException.class) public void testResultGetResultObjectUnknown() throws ConcurrentException { final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); res.getResultObject("unknown"); } /** * Tries to query the exception of an unknown child initializer from the * results object. This should cause an exception. */ @Test(expected = NoSuchElementException.class) public void testResultGetExceptionUnknown() throws ConcurrentException { final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); res.getException("unknown"); } /** * Tries to query the exception flag of an unknown child initializer from * the results object. This should cause an exception. */ @Test(expected = NoSuchElementException.class) public void testResultIsExceptionUnknown() throws ConcurrentException { final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize(); res.isException("unknown"); } /** * Tests that the set with the names of the initializers cannot be modified. */ @Test(expected = UnsupportedOperationException.class) public void testResultInitializerNamesModify() throws ConcurrentException { checkInitialize(); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); final Iterator<String> it = res.initializerNames().iterator(); it.next(); it.remove(); } /** * Tests the behavior of the initializer if one of the child initializers * throws a runtime exception. */ @Test public void testInitializeRuntimeEx() { final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); child.ex = new RuntimeException(); initializer.addInitializer(CHILD_INIT, child); initializer.start(); try { initializer.get(); fail("Runtime exception not thrown!"); } catch (final Exception ex) { assertEquals("Wrong exception", child.ex, ex); } } /** * Tests the behavior of the initializer if one of the child initializers * throws a checked exception. */ @Test public void testInitializeEx() throws ConcurrentException { final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); child.ex = new Exception(); initializer.addInitializer(CHILD_INIT, child); initializer.start(); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); assertTrue("No exception flag", res.isException(CHILD_INIT)); assertNull("Got a results object", res.getResultObject(CHILD_INIT)); final ConcurrentException cex = res.getException(CHILD_INIT); assertEquals("Wrong cause", child.ex, cex.getCause()); } /** * Tests the isSuccessful() method of the result object if no child * initializer has thrown an exception. */ @Test public void testInitializeResultsIsSuccessfulTrue() throws ConcurrentException { final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); initializer.addInitializer(CHILD_INIT, child); initializer.start(); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); assertTrue("Wrong success flag", res.isSuccessful()); } /** * Tests the isSuccessful() method of the result object if at least one * child initializer has thrown an exception. */ @Test public void testInitializeResultsIsSuccessfulFalse() throws ConcurrentException { final ChildBackgroundInitializer child = new ChildBackgroundInitializer(); child.ex = new Exception(); initializer.addInitializer(CHILD_INIT, child); initializer.start(); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); assertFalse("Wrong success flag", res.isSuccessful()); } /** * Tests whether MultiBackgroundInitializers can be combined in a nested * way. */ @Test public void testInitializeNested() throws ConcurrentException { final String nameMulti = "multiChildInitializer"; initializer .addInitializer(CHILD_INIT, new ChildBackgroundInitializer()); final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer(); final int count = 3; for (int i = 0; i < count; i++) { mi2 .addInitializer(CHILD_INIT + i, new ChildBackgroundInitializer()); } initializer.addInitializer(nameMulti, mi2); initializer.start(); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer .get(); final ExecutorService exec = initializer.getActiveExecutor(); checkChild(res.getInitializer(CHILD_INIT), exec); final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res .getResultObject(nameMulti); assertEquals("Wrong number of initializers", count, res2 .initializerNames().size()); for (int i = 0; i < count; i++) { checkChild(res2.getInitializer(CHILD_INIT + i), exec); } assertTrue("Executor not shutdown", exec.isShutdown()); } /** * A concrete implementation of {@code BackgroundInitializer} used for * defining background tasks for {@code MultiBackgroundInitializer}. */ private static class ChildBackgroundInitializer extends BackgroundInitializer<Integer> { /** Stores the current executor service. */ volatile ExecutorService currentExecutor; /** A counter for the invocations of initialize(). */ volatile int initializeCalls; /** An exception to be thrown by initialize(). */ Exception ex; /** * Records this invocation. Optionally throws an exception. */ @Override protected Integer initialize() throws Exception { currentExecutor = getActiveExecutor(); initializeCalls++; if (ex != null) { throw ex; } return Integer.valueOf(initializeCalls); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.concurrent; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.ScheduledFuture; import java.util.concurrent.ScheduledThreadPoolExecutor; import java.util.concurrent.TimeUnit; import org.easymock.EasyMock; import org.junit.Test; /** * Test class for TimedSemaphore. * * @version $Id$ */ public class TimedSemaphoreTest { /** Constant for the time period. */ private static final long PERIOD = 500; /** Constant for the time unit. */ private static final TimeUnit UNIT = TimeUnit.MILLISECONDS; /** Constant for the default limit. */ private static final int LIMIT = 10; /** * Tests creating a new instance. */ @Test public void testInit() { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); EasyMock.replay(service); final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, LIMIT); EasyMock.verify(service); assertEquals("Wrong service", service, semaphore.getExecutorService()); assertEquals("Wrong period", PERIOD, semaphore.getPeriod()); assertEquals("Wrong unit", UNIT, semaphore.getUnit()); assertEquals("Statistic available", 0, semaphore .getLastAcquiresPerPeriod()); assertEquals("Average available", 0.0, semaphore .getAverageCallsPerPeriod(), .05); assertFalse("Already shutdown", semaphore.isShutdown()); assertEquals("Wrong limit", LIMIT, semaphore.getLimit()); } /** * Tries to create an instance with a negative period. This should cause an * exception. */ @Test(expected = IllegalArgumentException.class) public void testInitInvalidPeriod() { new TimedSemaphore(0L, UNIT, LIMIT); } /** * Tests whether a default executor service is created if no service is * provided. */ @Test public void testInitDefaultService() { final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT); final ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) semaphore .getExecutorService(); assertFalse("Wrong periodic task policy", exec .getContinueExistingPeriodicTasksAfterShutdownPolicy()); assertFalse("Wrong delayed task policy", exec .getExecuteExistingDelayedTasksAfterShutdownPolicy()); assertFalse("Already shutdown", exec.isShutdown()); semaphore.shutdown(); } /** * Tests starting the timer. */ @Test public void testStartTimer() throws InterruptedException { final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD, UNIT, LIMIT); final ScheduledFuture<?> future = semaphore.startTimer(); assertNotNull("No future returned", future); Thread.sleep(PERIOD); final int trials = 10; int count = 0; do { Thread.sleep(PERIOD); if (count++ > trials) { fail("endOfPeriod() not called!"); } } while (semaphore.getPeriodEnds() <= 0); semaphore.shutdown(); } /** * Tests the shutdown() method if the executor belongs to the semaphore. In * this case it has to be shut down. */ @Test public void testShutdownOwnExecutor() { final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT); semaphore.shutdown(); assertTrue("Not shutdown", semaphore.isShutdown()); assertTrue("Executor not shutdown", semaphore.getExecutorService() .isShutdown()); } /** * Tests the shutdown() method for a shared executor service before a task * was started. This should do pretty much nothing. */ @Test public void testShutdownSharedExecutorNoTask() { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); EasyMock.replay(service); final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, LIMIT); semaphore.shutdown(); assertTrue("Not shutdown", semaphore.isShutdown()); EasyMock.verify(service); } /** * Prepares an executor service mock to expect the start of the timer. * * @param service the mock * @param future the future */ private void prepareStartTimer(final ScheduledExecutorService service, final ScheduledFuture<?> future) { service.scheduleAtFixedRate((Runnable) EasyMock.anyObject(), EasyMock .eq(PERIOD), EasyMock.eq(PERIOD), EasyMock.eq(UNIT)); EasyMock.expectLastCall().andReturn(future); } /** * Tests the shutdown() method for a shared executor after the task was * started. In this case the task must be canceled. */ @Test public void testShutdownSharedExecutorTask() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE); EasyMock.replay(service, future); final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD, UNIT, LIMIT); semaphore.acquire(); semaphore.shutdown(); assertTrue("Not shutdown", semaphore.isShutdown()); EasyMock.verify(service, future); } /** * Tests multiple invocations of the shutdown() method. */ @Test public void testShutdownMultipleTimes() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE); EasyMock.replay(service, future); final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD, UNIT, LIMIT); semaphore.acquire(); for (int i = 0; i < 10; i++) { semaphore.shutdown(); } EasyMock.verify(service, future); } /** * Tests the acquire() method if a limit is set. */ @Test public void testAcquireLimit() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.replay(service, future); final int count = 10; final CountDownLatch latch = new CountDownLatch(count - 1); final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1); final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count - 1); semaphore.setLimit(count - 1); // start a thread that calls the semaphore count times t.start(); latch.await(); // now the semaphore's limit should be reached and the thread blocked assertEquals("Wrong semaphore count", count - 1, semaphore .getAcquireCount()); // this wakes up the thread, it should call the semaphore once more semaphore.endOfPeriod(); t.join(); assertEquals("Wrong semaphore count (2)", 1, semaphore .getAcquireCount()); assertEquals("Wrong acquire() count", count - 1, semaphore .getLastAcquiresPerPeriod()); EasyMock.verify(service, future); } /** * Tests the acquire() method if more threads are involved than the limit. * This method starts a number of threads that all invoke the semaphore. The * semaphore's limit is set to 1, so in each period only a single thread can * acquire the semaphore. */ @Test public void testAcquireMultipleThreads() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.replay(service, future); final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD, UNIT, 1); semaphore.latch = new CountDownLatch(1); final int count = 10; final SemaphoreThread[] threads = new SemaphoreThread[count]; for (int i = 0; i < count; i++) { threads[i] = new SemaphoreThread(semaphore, null, 1, 0); threads[i].start(); } for (int i = 0; i < count; i++) { semaphore.latch.await(); assertEquals("Wrong count", 1, semaphore.getAcquireCount()); semaphore.latch = new CountDownLatch(1); semaphore.endOfPeriod(); assertEquals("Wrong acquire count", 1, semaphore .getLastAcquiresPerPeriod()); } for (int i = 0; i < count; i++) { threads[i].join(); } EasyMock.verify(service, future); } /** * Tests the acquire() method if no limit is set. A test thread is started * that calls the semaphore a large number of times. Even if the semaphore's * period does not end, the thread should never block. */ @Test public void testAcquireNoLimit() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.replay(service, future); final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service, PERIOD, UNIT, TimedSemaphore.NO_LIMIT); final int count = 1000; final CountDownLatch latch = new CountDownLatch(count); final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count); t.start(); latch.await(); EasyMock.verify(service, future); } /** * Tries to call acquire() after shutdown(). This should cause an exception. */ @Test(expected = IllegalStateException.class) public void testPassAfterShutdown() throws InterruptedException { final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT); semaphore.shutdown(); semaphore.acquire(); } /** * Tests a bigger number of invocations that span multiple periods. The * period is set to a very short time. A background thread calls the * semaphore a large number of times. While it runs at last one end of a * period should be reached. */ @Test public void testAcquireMultiplePeriods() throws InterruptedException { final int count = 1000; final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl( PERIOD / 10, TimeUnit.MILLISECONDS, 1); semaphore.setLimit(count / 4); final CountDownLatch latch = new CountDownLatch(count); final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count); t.start(); latch.await(); semaphore.shutdown(); assertTrue("End of period not reached", semaphore.getPeriodEnds() > 0); } /** * Tests the methods for statistics. */ @Test public void testGetAverageCallsPerPeriod() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.replay(service, future); final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, LIMIT); semaphore.acquire(); semaphore.endOfPeriod(); assertEquals("Wrong average (1)", 1.0, semaphore .getAverageCallsPerPeriod(), .005); semaphore.acquire(); semaphore.acquire(); semaphore.endOfPeriod(); assertEquals("Wrong average (2)", 1.5, semaphore .getAverageCallsPerPeriod(), .005); EasyMock.verify(service, future); } /** * Tests whether the available non-blocking calls can be queried. */ @Test public void testGetAvailablePermits() throws InterruptedException { final ScheduledExecutorService service = EasyMock .createMock(ScheduledExecutorService.class); final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class); prepareStartTimer(service, future); EasyMock.replay(service, future); final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, LIMIT); for (int i = 0; i < LIMIT; i++) { assertEquals("Wrong available count at " + i, LIMIT - i, semaphore .getAvailablePermits()); semaphore.acquire(); } semaphore.endOfPeriod(); assertEquals("Wrong available count in new period", LIMIT, semaphore .getAvailablePermits()); EasyMock.verify(service, future); } /** * A specialized implementation of {@code TimedSemaphore} that is easier to * test. */ private static class TimedSemaphoreTestImpl extends TimedSemaphore { /** A mock scheduled future. */ ScheduledFuture<?> schedFuture; /** A latch for synchronizing with the main thread. */ volatile CountDownLatch latch; /** Counter for the endOfPeriod() invocations. */ private int periodEnds; public TimedSemaphoreTestImpl(final long timePeriod, final TimeUnit timeUnit, final int limit) { super(timePeriod, timeUnit, limit); } public TimedSemaphoreTestImpl(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { super(service, timePeriod, timeUnit, limit); } /** * Returns the number of invocations of the endOfPeriod() method. * * @return the endOfPeriod() invocations */ public int getPeriodEnds() { synchronized (this) { return periodEnds; } } /** * Invokes the latch if one is set. */ @Override public synchronized void acquire() throws InterruptedException { super.acquire(); if (latch != null) { latch.countDown(); } } /** * Counts the number of invocations. */ @Override protected synchronized void endOfPeriod() { super.endOfPeriod(); periodEnds++; } /** * Either returns the mock future or calls the super method. */ @Override protected ScheduledFuture<?> startTimer() { return schedFuture != null ? schedFuture : super.startTimer(); } } /** * A test thread class that will be used by tests for triggering the * semaphore. The thread calls the semaphore a configurable number of times. * When this is done, it can notify the main thread. */ private static class SemaphoreThread extends Thread { /** The semaphore. */ private final TimedSemaphore semaphore; /** A latch for communication with the main thread. */ private final CountDownLatch latch; /** The number of acquire() calls. */ private final int count; /** The number of invocations of the latch. */ private final int latchCount; public SemaphoreThread(final TimedSemaphore b, final CountDownLatch l, final int c, final int lc) { semaphore = b; latch = l; count = c; latchCount = lc; } /** * Calls acquire() on the semaphore for the specified number of times. * Optionally the latch will also be triggered to synchronize with the * main test thread. */ @Override public void run() { try { for (int i = 0; i < count; i++) { semaphore.acquire(); if (i < latchCount) { latch.countDown(); } } } catch (final InterruptedException iex) { Thread.currentThread().interrupt(); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.event; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertSame; import java.beans.PropertyChangeEvent; import java.beans.PropertyVetoException; import java.beans.VetoableChangeListener; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Date; import java.util.List; import org.easymock.EasyMock; import org.junit.Test; /** * @since 3.0 * @version $Id$ */ public class EventListenerSupportTest { @Test(expected=NullPointerException.class) public void testAddNullListener() { final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); listenerSupport.addListener(null); } @Test(expected=NullPointerException.class) public void testRemoveNullListener() { final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); listenerSupport.removeListener(null); } @Test public void testEventDispatchOrder() throws PropertyVetoException { final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); final List<VetoableChangeListener> calledListeners = new ArrayList<VetoableChangeListener>(); final VetoableChangeListener listener1 = createListener(calledListeners); final VetoableChangeListener listener2 = createListener(calledListeners); listenerSupport.addListener(listener1); listenerSupport.addListener(listener2); listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); assertEquals(calledListeners.size(), 2); assertSame(calledListeners.get(0), listener1); assertSame(calledListeners.get(1), listener2); } @Test(expected=IllegalArgumentException.class) public void testCreateWithNonInterfaceParameter() { EventListenerSupport.create(String.class); } @Test(expected=NullPointerException.class) public void testCreateWithNullParameter() { EventListenerSupport.create(null); } @Test public void testRemoveListenerDuringEvent() throws PropertyVetoException { final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); for (int i = 0; i < 10; ++i) { addDeregisterListener(listenerSupport); } assertEquals(listenerSupport.getListenerCount(), 10); listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5)); assertEquals(listenerSupport.getListenerCount(), 0); } @Test public void testGetListeners() { final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); final VetoableChangeListener[] listeners = listenerSupport.getListeners(); assertEquals(0, listeners.length); assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); final VetoableChangeListener[] empty = listeners; //for fun, show that the same empty instance is used assertSame(empty, listenerSupport.getListeners()); final VetoableChangeListener listener1 = EasyMock.createNiceMock(VetoableChangeListener.class); listenerSupport.addListener(listener1); assertEquals(1, listenerSupport.getListeners().length); final VetoableChangeListener listener2 = EasyMock.createNiceMock(VetoableChangeListener.class); listenerSupport.addListener(listener2); assertEquals(2, listenerSupport.getListeners().length); listenerSupport.removeListener(listener1); assertEquals(1, listenerSupport.getListeners().length); listenerSupport.removeListener(listener2); assertSame(empty, listenerSupport.getListeners()); } @Test public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException { final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class); listenerSupport.addListener(new VetoableChangeListener() { @Override public void vetoableChange(final PropertyChangeEvent e) { } }); listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class)); //serialize: final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(listenerSupport); objectOutputStream.close(); //deserialize: @SuppressWarnings("unchecked") final EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream( new ByteArrayInputStream(outputStream.toByteArray())).readObject(); //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners(); assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType()); assertEquals(1, listeners.length); //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted final VetoableChangeListener listener = listeners[0]; final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9); listener.vetoableChange(evt); EasyMock.replay(listener); deserializedListenerSupport.fire().vetoableChange(evt); EasyMock.verify(listener); //remove listener and verify we get an empty array of listeners deserializedListenerSupport.removeListener(listener); assertEquals(0, deserializedListenerSupport.getListeners().length); } @Test public void testSubclassInvocationHandling() throws PropertyVetoException { @SuppressWarnings("serial") final EventListenerSupport<VetoableChangeListener> eventListenerSupport = new EventListenerSupport<VetoableChangeListener>( VetoableChangeListener.class) { @Override protected java.lang.reflect.InvocationHandler createInvocationHandler() { return new ProxyInvocationHandler() { /** * {@inheritDoc} */ @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { return "vetoableChange".equals(method.getName()) && "Hour".equals(((PropertyChangeEvent) args[0]).getPropertyName()) ? null : super.invoke(proxy, method, args); } }; } }; final VetoableChangeListener listener = EasyMock.createNiceMock(VetoableChangeListener.class); eventListenerSupport.addListener(listener); final Object source = new Date(); final PropertyChangeEvent ignore = new PropertyChangeEvent(source, "Hour", 5, 6); final PropertyChangeEvent respond = new PropertyChangeEvent(source, "Day", 6, 7); listener.vetoableChange(respond); EasyMock.replay(listener); eventListenerSupport.fire().vetoableChange(ignore); eventListenerSupport.fire().vetoableChange(respond); EasyMock.verify(listener); } private void addDeregisterListener(final EventListenerSupport<VetoableChangeListener> listenerSupport) { listenerSupport.addListener(new VetoableChangeListener() { @Override public void vetoableChange(final PropertyChangeEvent e) { listenerSupport.removeListener(this); } }); } private VetoableChangeListener createListener(final List<VetoableChangeListener> calledListeners) { return new VetoableChangeListener() { @Override public void vetoableChange(final PropertyChangeEvent e) { calledListeners.add(this); } }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.event; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.beans.VetoableChangeListener; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.Proxy; import java.util.Date; import java.util.Map; import java.util.TreeMap; import javax.naming.event.ObjectChangeListener; import org.junit.Test; /** * @since 3.0 * @version $Id$ */ public class EventUtilsTest { @Test public void testConstructor() { assertNotNull(new EventUtils()); final Constructor<?>[] cons = EventUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(EventUtils.class.getModifiers())); assertFalse(Modifier.isFinal(EventUtils.class.getModifiers())); } @Test public void testAddEventListener() { final PropertyChangeSource src = new PropertyChangeSource(); final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); final PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class); assertEquals(0, handler.getEventCount("propertyChange")); EventUtils.addEventListener(src, PropertyChangeListener.class, listener); assertEquals(0, handler.getEventCount("propertyChange")); src.setProperty("newValue"); assertEquals(1, handler.getEventCount("propertyChange")); } @Test public void testAddEventListenerWithNoAddMethod() { final PropertyChangeSource src = new PropertyChangeSource(); final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); final ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class); try { EventUtils.addEventListener(src, ObjectChangeListener.class, listener); fail("Should not be allowed to add a listener to an object that doesn't support it."); } catch (final IllegalArgumentException e) { assertEquals("Class " + src.getClass().getName() + " does not have a public add" + ObjectChangeListener.class.getSimpleName() + " method which takes a parameter of type " + ObjectChangeListener.class.getName() + ".", e.getMessage()); } } @Test public void testAddEventListenerThrowsException() { final ExceptionEventSource src = new ExceptionEventSource(); try { EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() { @Override public void propertyChange(final PropertyChangeEvent e) { // Do nothing! } }); fail("Add method should have thrown an exception, so method should fail."); } catch (final RuntimeException e) { } } @Test public void testAddEventListenerWithPrivateAddMethod() { final PropertyChangeSource src = new PropertyChangeSource(); final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); final VetoableChangeListener listener = handler.createListener(VetoableChangeListener.class); try { EventUtils.addEventListener(src, VetoableChangeListener.class, listener); fail("Should not be allowed to add a listener to an object that doesn't support it."); } catch (final IllegalArgumentException e) { assertEquals("Class " + src.getClass().getName() + " does not have a public add" + VetoableChangeListener.class.getSimpleName() + " method which takes a parameter of type " + VetoableChangeListener.class.getName() + ".", e.getMessage()); } } @Test public void testBindEventsToMethod() { final PropertyChangeSource src = new PropertyChangeSource(); final EventCounter counter = new EventCounter(); EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class); assertEquals(0, counter.getCount()); src.setProperty("newValue"); assertEquals(1, counter.getCount()); } @Test public void testBindEventsToMethodWithEvent() { final PropertyChangeSource src = new PropertyChangeSource(); final EventCounterWithEvent counter = new EventCounterWithEvent(); EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class); assertEquals(0, counter.getCount()); src.setProperty("newValue"); assertEquals(1, counter.getCount()); } @Test public void testBindFilteredEventsToMethod() { final MultipleEventSource src = new MultipleEventSource(); final EventCounter counter = new EventCounter(); EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); assertEquals(0, counter.getCount()); src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); assertEquals(1, counter.getCount()); src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); assertEquals(1, counter.getCount()); } public static interface MultipleEventListener { public void event1(PropertyChangeEvent e); public void event2(PropertyChangeEvent e); } public static class EventCounter { private int count; public void eventOccurred() { count++; } public int getCount() { return count; } } public static class EventCounterWithEvent { private int count; public void eventOccurred(final PropertyChangeEvent e) { count++; } public int getCount() { return count; } } private static class EventCountingInvociationHandler implements InvocationHandler { private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>(); public <L> L createListener(final Class<L> listenerType) { return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]{listenerType}, this)); } public int getEventCount(final String eventName) { final Integer count = eventCounts.get(eventName); return count == null ? 0 : count.intValue(); } @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { final Integer count = eventCounts.get(method.getName()); if (count == null) { eventCounts.put(method.getName(), Integer.valueOf(1)); } else { eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); } return null; } } public static class MultipleEventSource { private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class); public void addMultipleEventListener(final MultipleEventListener listener) { listeners.addListener(listener); } } public static class ExceptionEventSource { public void addPropertyChangeListener(final PropertyChangeListener listener) { throw new RuntimeException(); } } public static class PropertyChangeSource { private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class); private String property; public void setProperty(final String property) { final String oldValue = this.property; this.property = property; listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); } protected void addVetoableChangeListener(final VetoableChangeListener listener) { // Do nothing! } public void addPropertyChangeListener(final PropertyChangeListener listener) { listeners.addListener(listener); } public void removePropertyChangeListener(final PropertyChangeListener listener) { listeners.removeListener(listener); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.exception; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Date; import org.apache.commons.lang3.StringUtils; import org.junit.Test; /** * JUnit tests for ContextedException. */ public class ContextedExceptionTest extends AbstractExceptionContextTest<ContextedException> { @Override public void setUp() throws Exception { exceptionContext = new ContextedException(new Exception(TEST_MESSAGE)); super.setUp(); } @Test public void testContextedException() { exceptionContext = new ContextedException(); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(StringUtils.isEmpty(message)); } @Test public void testContextedExceptionString() { exceptionContext = new ContextedException(TEST_MESSAGE); assertEquals(TEST_MESSAGE, exceptionContext.getMessage()); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); } @Test public void testContextedExceptionThrowable() { exceptionContext = new ContextedException(new Exception(TEST_MESSAGE)); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); assertTrue(message.indexOf(TEST_MESSAGE)>=0); } @Test public void testContextedExceptionStringThrowable() { exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE)); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0); assertTrue(message.indexOf(TEST_MESSAGE_2)>=0); } @Test public void testContextedExceptionStringThrowableContext() { exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0); assertTrue(message.indexOf(TEST_MESSAGE_2)>=0); } @Test public void testNullExceptionPassing() { exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) .addContextValue("test1", null) .addContextValue("test2", "some value") .addContextValue("test Date", new Date()) .addContextValue("test Nbr", Integer.valueOf(5)) .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); final String message = exceptionContext.getMessage(); assertTrue(message != null); } @Test public void testRawMessage() { assertEquals(Exception.class.getName() + ": " + TEST_MESSAGE, exceptionContext.getRawMessage()); exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); assertEquals(TEST_MESSAGE_2, exceptionContext.getRawMessage()); exceptionContext = new ContextedException(null, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); assertNull(exceptionContext.getRawMessage()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.exception; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Date; import org.apache.commons.lang3.StringUtils; import org.junit.Before; import org.junit.Test; /** * JUnit tests for ContextedRuntimeException. */ public class ContextedRuntimeExceptionTest extends AbstractExceptionContextTest<ContextedRuntimeException> { @Override @Before public void setUp() throws Exception { exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE)); super.setUp(); } @Test public void testContextedException() { exceptionContext = new ContextedRuntimeException(); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(StringUtils.isEmpty(message)); } @Test public void testContextedExceptionString() { exceptionContext = new ContextedRuntimeException(TEST_MESSAGE); assertEquals(TEST_MESSAGE, exceptionContext.getMessage()); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); } @Test public void testContextedExceptionThrowable() { exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE)); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); assertTrue(message.indexOf(TEST_MESSAGE)>=0); } @Test public void testContextedExceptionStringThrowable() { exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE)); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0); assertTrue(message.indexOf(TEST_MESSAGE_2)>=0); } @Test public void testContextedExceptionStringThrowableContext() { // Use an anonymous subclass to make sure users can provide custom implementations exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext() {}); final String message = exceptionContext.getMessage(); final String trace = ExceptionUtils.getStackTrace(exceptionContext); assertTrue(trace.indexOf("ContextedException")>=0); assertTrue(trace.indexOf(TEST_MESSAGE)>=0); assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0); assertTrue(message.indexOf(TEST_MESSAGE_2)>=0); } @Test public void testNullExceptionPassing() { exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null) .addContextValue("test1", null) .addContextValue("test2", "some value") .addContextValue("test Date", new Date()) .addContextValue("test Nbr", Integer.valueOf(5)) .addContextValue("test Poorly written obj", new ObjectWithFaultyToString()); final String message = exceptionContext.getMessage(); assertTrue(message != null); } @Test public void testRawMessage() { assertEquals(Exception.class.getName() + ": " + TEST_MESSAGE, exceptionContext.getRawMessage()); exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); assertEquals(TEST_MESSAGE_2, exceptionContext.getRawMessage()); exceptionContext = new ContextedRuntimeException(null, new Exception(TEST_MESSAGE), new DefaultExceptionContext()); assertNull(exceptionContext.getRawMessage()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.exception; import org.junit.Before; import org.junit.Test; /** * JUnit tests for DefaultExceptionContext. * */ public class DefaultExceptionContextTest extends AbstractExceptionContextTest<DefaultExceptionContext> { @Override @Before public void setUp() throws Exception { exceptionContext = new DefaultExceptionContext(); super.setUp(); } @Test public void testFormattedExceptionMessageNull() { exceptionContext = new DefaultExceptionContext(); exceptionContext.getFormattedExceptionMessage(null); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.exception; import org.junit.After; import org.junit.Test; import org.junit.Before; import static org.junit.Assert.*; import java.io.ByteArrayOutputStream; import java.io.PrintStream; import java.io.PrintWriter; import java.io.StringWriter; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.List; /** * Tests {@link org.apache.commons.lang3.exception.ExceptionUtils}. * * <h3>Notes</h3> * <p> * Make sure this exception code does not depend on Java 1.4 nested exceptions. SVN revision 38990 does not compile with * Java 1.3.1. * </p> * <ul> * <li>Compiled with Sun Java 1.3.1_15</li> * <li>Tested with Sun Java 1.3.1_15</li> * <li>Tested with Sun Java 1.4.2_12</li> * <li>Tested with Sun Java 1.5.0_08</li> * <li>All of the above on Windows XP SP2 + patches.</li> * </ul> * <p> * Gary Gregory; August 16, 2006. * </p> * * @since 1.0 */ public class ExceptionUtilsTest { private NestableException nested; private Throwable withCause; private Throwable withoutCause; private Throwable jdkNoCause; private ExceptionWithCause cyclicCause; @Before public void setUp() { withoutCause = createExceptionWithoutCause(); nested = new NestableException(withoutCause); withCause = new ExceptionWithCause(nested); jdkNoCause = new NullPointerException(); final ExceptionWithCause a = new ExceptionWithCause(null); final ExceptionWithCause b = new ExceptionWithCause(a); a.setCause(b); cyclicCause = new ExceptionWithCause(a); } @After public void tearDown() throws Exception { withoutCause = null; nested = null; withCause = null; jdkNoCause = null; cyclicCause = null; } //----------------------------------------------------------------------- private Throwable createExceptionWithoutCause() { try { throw new ExceptionWithoutCause(); } catch (final Throwable t) { return t; } } private Throwable createExceptionWithCause() { try { try { throw new ExceptionWithCause(createExceptionWithoutCause()); } catch (final Throwable t) { throw new ExceptionWithCause(t); } } catch (final Throwable t) { return t; } } //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new ExceptionUtils()); final Constructor<?>[] cons = ExceptionUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(ExceptionUtils.class.getModifiers())); assertFalse(Modifier.isFinal(ExceptionUtils.class.getModifiers())); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") // Specifically tests the deprecated methods @Test public void testGetCause_Throwable() { assertSame(null, ExceptionUtils.getCause(null)); assertSame(null, ExceptionUtils.getCause(withoutCause)); assertSame(withoutCause, ExceptionUtils.getCause(nested)); assertSame(nested, ExceptionUtils.getCause(withCause)); assertSame(null, ExceptionUtils.getCause(jdkNoCause)); assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(cyclicCause)); assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), ExceptionUtils.getCause(cyclicCause.getCause())); assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(((ExceptionWithCause) cyclicCause.getCause()).getCause())); } @SuppressWarnings("deprecation") // Specifically tests the deprecated methods @Test public void testGetCause_ThrowableArray() { assertSame(null, ExceptionUtils.getCause(null, null)); assertSame(null, ExceptionUtils.getCause(null, new String[0])); // not known type, so match on supplied method names assertSame(nested, ExceptionUtils.getCause(withCause, null)); // default names assertSame(null, ExceptionUtils.getCause(withCause, new String[0])); assertSame(null, ExceptionUtils.getCause(withCause, new String[] {null})); assertSame(nested, ExceptionUtils.getCause(withCause, new String[] {"getCause"})); // not known type, so match on supplied method names assertSame(null, ExceptionUtils.getCause(withoutCause, null)); assertSame(null, ExceptionUtils.getCause(withoutCause, new String[0])); assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {null})); assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {"getCause"})); assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {"getTargetException"})); } @Test public void testGetRootCause_Throwable() { assertSame(null, ExceptionUtils.getRootCause(null)); assertSame(null, ExceptionUtils.getRootCause(withoutCause)); assertSame(withoutCause, ExceptionUtils.getRootCause(nested)); assertSame(withoutCause, ExceptionUtils.getRootCause(withCause)); assertSame(null, ExceptionUtils.getRootCause(jdkNoCause)); assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), ExceptionUtils.getRootCause(cyclicCause)); } //----------------------------------------------------------------------- @Test public void testGetThrowableCount_Throwable() { assertEquals(0, ExceptionUtils.getThrowableCount(null)); assertEquals(1, ExceptionUtils.getThrowableCount(withoutCause)); assertEquals(2, ExceptionUtils.getThrowableCount(nested)); assertEquals(3, ExceptionUtils.getThrowableCount(withCause)); assertEquals(1, ExceptionUtils.getThrowableCount(jdkNoCause)); assertEquals(3, ExceptionUtils.getThrowableCount(cyclicCause)); } //----------------------------------------------------------------------- @Test public void testGetThrowables_Throwable_null() { assertEquals(0, ExceptionUtils.getThrowables(null).length); } @Test public void testGetThrowables_Throwable_withoutCause() { final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause); assertEquals(1, throwables.length); assertSame(withoutCause, throwables[0]); } @Test public void testGetThrowables_Throwable_nested() { final Throwable[] throwables = ExceptionUtils.getThrowables(nested); assertEquals(2, throwables.length); assertSame(nested, throwables[0]); assertSame(withoutCause, throwables[1]); } @Test public void testGetThrowables_Throwable_withCause() { final Throwable[] throwables = ExceptionUtils.getThrowables(withCause); assertEquals(3, throwables.length); assertSame(withCause, throwables[0]); assertSame(nested, throwables[1]); assertSame(withoutCause, throwables[2]); } @Test public void testGetThrowables_Throwable_jdkNoCause() { final Throwable[] throwables = ExceptionUtils.getThrowables(jdkNoCause); assertEquals(1, throwables.length); assertSame(jdkNoCause, throwables[0]); } @Test public void testGetThrowables_Throwable_recursiveCause() { final Throwable[] throwables = ExceptionUtils.getThrowables(cyclicCause); assertEquals(3, throwables.length); assertSame(cyclicCause, throwables[0]); assertSame(cyclicCause.getCause(), throwables[1]); assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), throwables[2]); } //----------------------------------------------------------------------- @Test public void testGetThrowableList_Throwable_null() { final List<?> throwables = ExceptionUtils.getThrowableList(null); assertEquals(0, throwables.size()); } @Test public void testGetThrowableList_Throwable_withoutCause() { final List<?> throwables = ExceptionUtils.getThrowableList(withoutCause); assertEquals(1, throwables.size()); assertSame(withoutCause, throwables.get(0)); } @Test public void testGetThrowableList_Throwable_nested() { final List<?> throwables = ExceptionUtils.getThrowableList(nested); assertEquals(2, throwables.size()); assertSame(nested, throwables.get(0)); assertSame(withoutCause, throwables.get(1)); } @Test public void testGetThrowableList_Throwable_withCause() { final List<?> throwables = ExceptionUtils.getThrowableList(withCause); assertEquals(3, throwables.size()); assertSame(withCause, throwables.get(0)); assertSame(nested, throwables.get(1)); assertSame(withoutCause, throwables.get(2)); } @Test public void testGetThrowableList_Throwable_jdkNoCause() { final List<?> throwables = ExceptionUtils.getThrowableList(jdkNoCause); assertEquals(1, throwables.size()); assertSame(jdkNoCause, throwables.get(0)); } @Test public void testGetThrowableList_Throwable_recursiveCause() { final List<?> throwables = ExceptionUtils.getThrowableList(cyclicCause); assertEquals(3, throwables.size()); assertSame(cyclicCause, throwables.get(0)); assertSame(cyclicCause.getCause(), throwables.get(1)); assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), throwables.get(2)); } //----------------------------------------------------------------------- @Test public void testIndexOf_ThrowableClass() { assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null)); assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class)); assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class)); assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null)); assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class)); assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class)); assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null)); assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class)); assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class)); assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class)); } @Test public void testIndexOf_ThrowableClassInt() { assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class, 0)); assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class, 0)); assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class, 0)); assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null)); assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0)); assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class, 0)); assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class, 0)); assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, -1)); assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 1)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 9)); assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class, 0)); } //----------------------------------------------------------------------- @Test public void testIndexOfType_ThrowableClass() { assertEquals(-1, ExceptionUtils.indexOfType(null, null)); assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class)); assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null)); assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class)); assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class)); assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class)); assertEquals(-1, ExceptionUtils.indexOfType(nested, null)); assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class)); assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class)); assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class)); assertEquals(-1, ExceptionUtils.indexOfType(withCause, null)); assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class)); assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class)); assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class)); assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class)); } @Test public void testIndexOfType_ThrowableClassInt() { assertEquals(-1, ExceptionUtils.indexOfType(null, null, 0)); assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class, 0)); assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null)); assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class, 0)); assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfType(nested, null, 0)); assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class, 0)); assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class, 0)); assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfType(withCause, null)); assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0)); assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class, 0)); assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class, 0)); assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, -1)); assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0)); assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 1)); assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 9)); assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class, 0)); } //----------------------------------------------------------------------- @Test public void testPrintRootCauseStackTrace_Throwable() throws Exception { ExceptionUtils.printRootCauseStackTrace(null); // could pipe system.err to a known stream, but not much point as // internally this method calls stram method anyway } @Test public void testPrintRootCauseStackTrace_ThrowableStream() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(1024); ExceptionUtils.printRootCauseStackTrace(null, (PrintStream) null); ExceptionUtils.printRootCauseStackTrace(null, new PrintStream(out)); assertEquals(0, out.toString().length()); out = new ByteArrayOutputStream(1024); try { ExceptionUtils.printRootCauseStackTrace(withCause, (PrintStream) null); fail(); } catch (final IllegalArgumentException ex) { } out = new ByteArrayOutputStream(1024); final Throwable withCause = createExceptionWithCause(); ExceptionUtils.printRootCauseStackTrace(withCause, new PrintStream(out)); String stackTrace = out.toString(); assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); out = new ByteArrayOutputStream(1024); ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintStream(out)); stackTrace = out.toString(); assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); } @Test public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception { StringWriter writer = new StringWriter(1024); ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null); ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer)); assertEquals(0, writer.getBuffer().length()); writer = new StringWriter(1024); try { ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null); fail(); } catch (final IllegalArgumentException ex) { } writer = new StringWriter(1024); final Throwable withCause = createExceptionWithCause(); ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer)); String stackTrace = writer.toString(); assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1); writer = new StringWriter(1024); ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer)); stackTrace = writer.toString(); assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1); } //----------------------------------------------------------------------- @Test public void testGetRootCauseStackTrace_Throwable() throws Exception { assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length); final Throwable withCause = createExceptionWithCause(); String[] stackTrace = ExceptionUtils.getRootCauseStackTrace(withCause); boolean match = false; for (final String element : stackTrace) { if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) { match = true; break; } } assertTrue(match); stackTrace = ExceptionUtils.getRootCauseStackTrace(withoutCause); match = false; for (final String element : stackTrace) { if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) { match = true; break; } } assertFalse(match); } @Test(expected=IllegalArgumentException.class) public void testRemoveCommonFrames_ListList() throws Exception { ExceptionUtils.removeCommonFrames(null, null); } @Test public void test_getMessage_Throwable() { Throwable th = null; assertEquals("", ExceptionUtils.getMessage(th)); th = new IllegalArgumentException("Base"); assertEquals("IllegalArgumentException: Base", ExceptionUtils.getMessage(th)); th = new ExceptionWithCause("Wrapper", th); assertEquals("ExceptionUtilsTest.ExceptionWithCause: Wrapper", ExceptionUtils.getMessage(th)); } @Test public void test_getRootCauseMessage_Throwable() { Throwable th = null; assertEquals("", ExceptionUtils.getRootCauseMessage(th)); th = new IllegalArgumentException("Base"); assertEquals("IllegalArgumentException: Base", ExceptionUtils.getRootCauseMessage(th)); th = new ExceptionWithCause("Wrapper", th); assertEquals("IllegalArgumentException: Base", ExceptionUtils.getRootCauseMessage(th)); } //----------------------------------------------------------------------- /** * Provides a method with a well known chained/nested exception * name which matches the full signature (e.g. has a return value * of <code>Throwable</code>. */ private static class ExceptionWithCause extends Exception { private Throwable cause; public ExceptionWithCause(final String str, final Throwable cause) { super(str); setCause(cause); } public ExceptionWithCause(final Throwable cause) { super(); setCause(cause); } @Override public Throwable getCause() { return cause; } public void setCause(final Throwable cause) { this.cause = cause; } } /** * Provides a method with a well known chained/nested exception * name which does not match the full signature (e.g. lacks a * return value of <code>Throwable</code>. */ private static class ExceptionWithoutCause extends Exception { @SuppressWarnings("unused") public void getTargetException() { } } // Temporary classes to allow the nested exception code to be removed // prior to a rewrite of this test class. private static class NestableException extends Exception { @SuppressWarnings("unused") public NestableException() { super(); } public NestableException(final Throwable t) { super(t); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.commons.lang3.math; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import org.junit.Test; /** * Test cases for the {@link Fraction} class * * @version $Id$ */ public class FractionTest { private static final int SKIP = 500; //53 //-------------------------------------------------------------------------- @Test public void testConstants() { assertEquals(0, Fraction.ZERO.getNumerator()); assertEquals(1, Fraction.ZERO.getDenominator()); assertEquals(1, Fraction.ONE.getNumerator()); assertEquals(1, Fraction.ONE.getDenominator()); assertEquals(1, Fraction.ONE_HALF.getNumerator()); assertEquals(2, Fraction.ONE_HALF.getDenominator()); assertEquals(1, Fraction.ONE_THIRD.getNumerator()); assertEquals(3, Fraction.ONE_THIRD.getDenominator()); assertEquals(2, Fraction.TWO_THIRDS.getNumerator()); assertEquals(3, Fraction.TWO_THIRDS.getDenominator()); assertEquals(1, Fraction.ONE_QUARTER.getNumerator()); assertEquals(4, Fraction.ONE_QUARTER.getDenominator()); assertEquals(2, Fraction.TWO_QUARTERS.getNumerator()); assertEquals(4, Fraction.TWO_QUARTERS.getDenominator()); assertEquals(3, Fraction.THREE_QUARTERS.getNumerator()); assertEquals(4, Fraction.THREE_QUARTERS.getDenominator()); assertEquals(1, Fraction.ONE_FIFTH.getNumerator()); assertEquals(5, Fraction.ONE_FIFTH.getDenominator()); assertEquals(2, Fraction.TWO_FIFTHS.getNumerator()); assertEquals(5, Fraction.TWO_FIFTHS.getDenominator()); assertEquals(3, Fraction.THREE_FIFTHS.getNumerator()); assertEquals(5, Fraction.THREE_FIFTHS.getDenominator()); assertEquals(4, Fraction.FOUR_FIFTHS.getNumerator()); assertEquals(5, Fraction.FOUR_FIFTHS.getDenominator()); } @Test public void testFactory_int_int() { Fraction f = null; // zero f = Fraction.getFraction(0, 1); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction(0, 2); assertEquals(0, f.getNumerator()); assertEquals(2, f.getDenominator()); // normal f = Fraction.getFraction(1, 1); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction(2, 1); assertEquals(2, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction(23, 345); assertEquals(23, f.getNumerator()); assertEquals(345, f.getDenominator()); // improper f = Fraction.getFraction(22, 7); assertEquals(22, f.getNumerator()); assertEquals(7, f.getDenominator()); // negatives f = Fraction.getFraction(-6, 10); assertEquals(-6, f.getNumerator()); assertEquals(10, f.getDenominator()); f = Fraction.getFraction(6, -10); assertEquals(-6, f.getNumerator()); assertEquals(10, f.getDenominator()); f = Fraction.getFraction(-6, -10); assertEquals(6, f.getNumerator()); assertEquals(10, f.getDenominator()); // zero denominator try { f = Fraction.getFraction(1, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(2, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(-3, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // very large: can't represent as unsimplified fraction, although try { f = Fraction.getFraction(4, Integer.MIN_VALUE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(1, Integer.MIN_VALUE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testFactory_int_int_int() { Fraction f = null; // zero f = Fraction.getFraction(0, 0, 2); assertEquals(0, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction(2, 0, 2); assertEquals(4, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction(0, 1, 2); assertEquals(1, f.getNumerator()); assertEquals(2, f.getDenominator()); // normal f = Fraction.getFraction(1, 1, 2); assertEquals(3, f.getNumerator()); assertEquals(2, f.getDenominator()); // negatives try { f = Fraction.getFraction(1, -6, -10); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(1, -6, -10); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(1, -6, -10); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // negative whole f = Fraction.getFraction(-1, 6, 10); assertEquals(-16, f.getNumerator()); assertEquals(10, f.getDenominator()); try { f = Fraction.getFraction(-1, -6, 10); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(-1, 6, -10); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(-1, -6, -10); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // zero denominator try { f = Fraction.getFraction(0, 1, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(1, 2, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(-1, -3, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(Integer.MAX_VALUE, 1, 2); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // very large f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE); assertEquals(-Integer.MAX_VALUE, f.getNumerator()); assertEquals(Integer.MAX_VALUE, f.getDenominator()); try { // negative denominators not allowed in this constructor. f = Fraction.getFraction(0, 4, Integer.MIN_VALUE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(1, 1, Integer.MAX_VALUE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(-1, 2, Integer.MAX_VALUE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testReducedFactory_int_int() { Fraction f = null; // zero f = Fraction.getReducedFraction(0, 1); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); // normal f = Fraction.getReducedFraction(1, 1); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getReducedFraction(2, 1); assertEquals(2, f.getNumerator()); assertEquals(1, f.getDenominator()); // improper f = Fraction.getReducedFraction(22, 7); assertEquals(22, f.getNumerator()); assertEquals(7, f.getDenominator()); // negatives f = Fraction.getReducedFraction(-6, 10); assertEquals(-3, f.getNumerator()); assertEquals(5, f.getDenominator()); f = Fraction.getReducedFraction(6, -10); assertEquals(-3, f.getNumerator()); assertEquals(5, f.getDenominator()); f = Fraction.getReducedFraction(-6, -10); assertEquals(3, f.getNumerator()); assertEquals(5, f.getDenominator()); // zero denominator try { f = Fraction.getReducedFraction(1, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getReducedFraction(2, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getReducedFraction(-3, 0); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // reduced f = Fraction.getReducedFraction(0, 2); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getReducedFraction(2, 2); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getReducedFraction(2, 4); assertEquals(1, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getReducedFraction(15, 10); assertEquals(3, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getReducedFraction(121, 22); assertEquals(11, f.getNumerator()); assertEquals(2, f.getDenominator()); // Extreme values // OK, can reduce before negating f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE); assertEquals(1, f.getNumerator()); assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator()); // Can't reduce, negation will throw try { f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE); fail("Expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // LANG-662 f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); assertEquals(1, f.getDenominator()); } @Test public void testFactory_double() { Fraction f = null; try { f = Fraction.getFraction(Double.NaN); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(Double.POSITIVE_INFINITY); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction(Double.NEGATIVE_INFINITY); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = Fraction.getFraction((double) Integer.MAX_VALUE + 1); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // zero f = Fraction.getFraction(0.0d); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); // one f = Fraction.getFraction(1.0d); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); // one half f = Fraction.getFraction(0.5d); assertEquals(1, f.getNumerator()); assertEquals(2, f.getDenominator()); // negative f = Fraction.getFraction(-0.875d); assertEquals(-7, f.getNumerator()); assertEquals(8, f.getDenominator()); // over 1 f = Fraction.getFraction(1.25d); assertEquals(5, f.getNumerator()); assertEquals(4, f.getDenominator()); // two thirds f = Fraction.getFraction(0.66666d); assertEquals(2, f.getNumerator()); assertEquals(3, f.getDenominator()); // small f = Fraction.getFraction(1.0d/10001d); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); // normal Fraction f2 = null; for (int i = 1; i <= 100; i++) { // denominator for (int j = 1; j <= i; j++) { // numerator try { f = Fraction.getFraction((double) j / (double) i); } catch (final ArithmeticException ex) { System.err.println(j + " " + i); throw ex; } f2 = Fraction.getReducedFraction(j, i); assertEquals(f2.getNumerator(), f.getNumerator()); assertEquals(f2.getDenominator(), f.getDenominator()); } } // save time by skipping some tests! ( for (int i = 1001; i <= 10000; i+=SKIP) { // denominator for (int j = 1; j <= i; j++) { // numerator try { f = Fraction.getFraction((double) j / (double) i); } catch (final ArithmeticException ex) { System.err.println(j + " " + i); throw ex; } f2 = Fraction.getReducedFraction(j, i); assertEquals(f2.getNumerator(), f.getNumerator()); assertEquals(f2.getDenominator(), f.getDenominator()); } } } @Test(expected=IllegalArgumentException.class) public void testFactory_String() { Fraction.getFraction(null); } @Test public void testFactory_String_double() { Fraction f = null; f = Fraction.getFraction("0.0"); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction("0.2"); assertEquals(1, f.getNumerator()); assertEquals(5, f.getDenominator()); f = Fraction.getFraction("0.5"); assertEquals(1, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction("0.66666"); assertEquals(2, f.getNumerator()); assertEquals(3, f.getDenominator()); try { f = Fraction.getFraction("2.3R"); fail("Expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("2147483648"); // too big fail("Expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("."); fail("Expecting NumberFormatException"); } catch (final NumberFormatException ex) {} } @Test public void testFactory_String_proper() { Fraction f = null; f = Fraction.getFraction("0 0/1"); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction("1 1/5"); assertEquals(6, f.getNumerator()); assertEquals(5, f.getDenominator()); f = Fraction.getFraction("7 1/2"); assertEquals(15, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction("1 2/4"); assertEquals(6, f.getNumerator()); assertEquals(4, f.getDenominator()); f = Fraction.getFraction("-7 1/2"); assertEquals(-15, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction("-1 2/4"); assertEquals(-6, f.getNumerator()); assertEquals(4, f.getDenominator()); try { f = Fraction.getFraction("2 3"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("a 3"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("2 b/4"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("2 "); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction(" 3"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction(" "); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} } @Test public void testFactory_String_improper() { Fraction f = null; f = Fraction.getFraction("0/1"); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction("1/5"); assertEquals(1, f.getNumerator()); assertEquals(5, f.getDenominator()); f = Fraction.getFraction("1/2"); assertEquals(1, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction("2/3"); assertEquals(2, f.getNumerator()); assertEquals(3, f.getDenominator()); f = Fraction.getFraction("7/3"); assertEquals(7, f.getNumerator()); assertEquals(3, f.getDenominator()); f = Fraction.getFraction("2/4"); assertEquals(2, f.getNumerator()); assertEquals(4, f.getDenominator()); try { f = Fraction.getFraction("2/d"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("2e/3"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("2/"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} try { f = Fraction.getFraction("/"); fail("expecting NumberFormatException"); } catch (final NumberFormatException ex) {} } @Test public void testGets() { Fraction f = null; f = Fraction.getFraction(3, 5, 6); assertEquals(23, f.getNumerator()); assertEquals(3, f.getProperWhole()); assertEquals(5, f.getProperNumerator()); assertEquals(6, f.getDenominator()); f = Fraction.getFraction(-3, 5, 6); assertEquals(-23, f.getNumerator()); assertEquals(-3, f.getProperWhole()); assertEquals(5, f.getProperNumerator()); assertEquals(6, f.getDenominator()); f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1); assertEquals(Integer.MIN_VALUE, f.getNumerator()); assertEquals(Integer.MIN_VALUE, f.getProperWhole()); assertEquals(0, f.getProperNumerator()); assertEquals(1, f.getDenominator()); } @Test public void testConversions() { Fraction f = null; f = Fraction.getFraction(3, 7, 8); assertEquals(3, f.intValue()); assertEquals(3L, f.longValue()); assertEquals(3.875f, f.floatValue(), 0.00001f); assertEquals(3.875d, f.doubleValue(), 0.00001d); } @Test public void testReduce() { Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); assertEquals(2, result.getNumerator()); assertEquals(3, result.getDenominator()); f = Fraction.getFraction(-2, -3); result = f.reduce(); assertEquals(2, result.getNumerator()); assertEquals(3, result.getDenominator()); f = Fraction.getFraction(2, -3); result = f.reduce(); assertEquals(-2, result.getNumerator()); assertEquals(3, result.getDenominator()); f = Fraction.getFraction(-2, 3); result = f.reduce(); assertEquals(-2, result.getNumerator()); assertEquals(3, result.getDenominator()); assertSame(f, result); f = Fraction.getFraction(2, 3); result = f.reduce(); assertEquals(2, result.getNumerator()); assertEquals(3, result.getDenominator()); assertSame(f, result); f = Fraction.getFraction(0, 1); result = f.reduce(); assertEquals(0, result.getNumerator()); assertEquals(1, result.getDenominator()); assertSame(f, result); f = Fraction.getFraction(0, 100); result = f.reduce(); assertEquals(0, result.getNumerator()); assertEquals(1, result.getDenominator()); assertSame(result, Fraction.ZERO); f = Fraction.getFraction(Integer.MIN_VALUE, 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); assertEquals(1, result.getDenominator()); } @Test public void testInvert() { Fraction f = null; f = Fraction.getFraction(50, 75); f = f.invert(); assertEquals(75, f.getNumerator()); assertEquals(50, f.getDenominator()); f = Fraction.getFraction(4, 3); f = f.invert(); assertEquals(3, f.getNumerator()); assertEquals(4, f.getDenominator()); f = Fraction.getFraction(-15, 47); f = f.invert(); assertEquals(-47, f.getNumerator()); assertEquals(15, f.getDenominator()); f = Fraction.getFraction(0, 3); try { f = f.invert(); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // large values f = Fraction.getFraction(Integer.MIN_VALUE, 1); try { f = f.invert(); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} f = Fraction.getFraction(Integer.MAX_VALUE, 1); f = f.invert(); assertEquals(1, f.getNumerator()); assertEquals(Integer.MAX_VALUE, f.getDenominator()); } @Test public void testNegate() { Fraction f = null; f = Fraction.getFraction(50, 75); f = f.negate(); assertEquals(-50, f.getNumerator()); assertEquals(75, f.getDenominator()); f = Fraction.getFraction(-50, 75); f = f.negate(); assertEquals(50, f.getNumerator()); assertEquals(75, f.getDenominator()); // large values f = Fraction.getFraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE); f = f.negate(); assertEquals(Integer.MIN_VALUE+2, f.getNumerator()); assertEquals(Integer.MAX_VALUE, f.getDenominator()); f = Fraction.getFraction(Integer.MIN_VALUE, 1); try { f = f.negate(); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testAbs() { Fraction f = null; f = Fraction.getFraction(50, 75); f = f.abs(); assertEquals(50, f.getNumerator()); assertEquals(75, f.getDenominator()); f = Fraction.getFraction(-50, 75); f = f.abs(); assertEquals(50, f.getNumerator()); assertEquals(75, f.getDenominator()); f = Fraction.getFraction(Integer.MAX_VALUE, 1); f = f.abs(); assertEquals(Integer.MAX_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction(Integer.MAX_VALUE, -1); f = f.abs(); assertEquals(Integer.MAX_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction(Integer.MIN_VALUE, 1); try { f = f.abs(); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testPow() { Fraction f = null; f = Fraction.getFraction(3, 5); assertEquals(Fraction.ONE, f.pow(0)); f = Fraction.getFraction(3, 5); assertSame(f, f.pow(1)); assertEquals(f, f.pow(1)); f = Fraction.getFraction(3, 5); f = f.pow(2); assertEquals(9, f.getNumerator()); assertEquals(25, f.getDenominator()); f = Fraction.getFraction(3, 5); f = f.pow(3); assertEquals(27, f.getNumerator()); assertEquals(125, f.getDenominator()); f = Fraction.getFraction(3, 5); f = f.pow(-1); assertEquals(5, f.getNumerator()); assertEquals(3, f.getDenominator()); f = Fraction.getFraction(3, 5); f = f.pow(-2); assertEquals(25, f.getNumerator()); assertEquals(9, f.getDenominator()); // check unreduced fractions stay that way. f = Fraction.getFraction(6, 10); assertEquals(Fraction.ONE, f.pow(0)); f = Fraction.getFraction(6, 10); assertEquals(f, f.pow(1)); assertFalse(f.pow(1).equals(Fraction.getFraction(3,5))); f = Fraction.getFraction(6, 10); f = f.pow(2); assertEquals(9, f.getNumerator()); assertEquals(25, f.getDenominator()); f = Fraction.getFraction(6, 10); f = f.pow(3); assertEquals(27, f.getNumerator()); assertEquals(125, f.getDenominator()); f = Fraction.getFraction(6, 10); f = f.pow(-1); assertEquals(10, f.getNumerator()); assertEquals(6, f.getDenominator()); f = Fraction.getFraction(6, 10); f = f.pow(-2); assertEquals(25, f.getNumerator()); assertEquals(9, f.getDenominator()); // zero to any positive power is still zero. f = Fraction.getFraction(0, 1231); f = f.pow(1); assertTrue(0==f.compareTo(Fraction.ZERO)); assertEquals(0, f.getNumerator()); assertEquals(1231, f.getDenominator()); f = f.pow(2); assertTrue(0==f.compareTo(Fraction.ZERO)); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); // zero to negative powers should throw an exception try { f = f.pow(-1); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f = f.pow(Integer.MIN_VALUE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // one to any power is still one. f = Fraction.getFraction(1, 1); f = f.pow(0); assertEquals(f, Fraction.ONE); f = f.pow(1); assertEquals(f, Fraction.ONE); f = f.pow(-1); assertEquals(f, Fraction.ONE); f = f.pow(Integer.MAX_VALUE); assertEquals(f, Fraction.ONE); f = f.pow(Integer.MIN_VALUE); assertEquals(f, Fraction.ONE); f = Fraction.getFraction(Integer.MAX_VALUE, 1); try { f = f.pow(2); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} // Numerator growing too negative during the pow operation. f = Fraction.getFraction(Integer.MIN_VALUE, 1); try { f = f.pow(3); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} f = Fraction.getFraction(65536, 1); try { f = f.pow(2); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testAdd() { Fraction f = null; Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(1, 5); f = f1.add(f2); assertEquals(4, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(2, 5); f = f1.add(f2); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(3, 5); f = f1.add(f2); assertEquals(6, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(-4, 5); f = f1.add(f2); assertEquals(-1, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1); f2 = Fraction.ONE; f = f1.add(f2); assertEquals(Integer.MAX_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(1, 2); f = f1.add(f2); assertEquals(11, f.getNumerator()); assertEquals(10, f.getDenominator()); f1 = Fraction.getFraction(3, 8); f2 = Fraction.getFraction(1, 6); f = f1.add(f2); assertEquals(13, f.getNumerator()); assertEquals(24, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(1, 5); f = f1.add(f2); assertSame(f2, f); f = f2.add(f1); assertSame(f2, f); f1 = Fraction.getFraction(-1, 13*13*2*2); f2 = Fraction.getFraction(-2, 13*17*2); f = f1.add(f2); assertEquals(13*13*17*2*2, f.getDenominator()); assertEquals(-17 - 2*13*2, f.getNumerator()); try { f.add(null); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) {} // if this fraction is added naively, it will overflow. // check that it doesn't. f1 = Fraction.getFraction(1,32768*3); f2 = Fraction.getFraction(1,59049); f = f1.add(f2); assertEquals(52451, f.getNumerator()); assertEquals(1934917632, f.getDenominator()); f1 = Fraction.getFraction(Integer.MIN_VALUE, 3); f2 = Fraction.ONE_THIRD; f = f1.add(f2); assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); assertEquals(3, f.getDenominator()); f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1); f2 = Fraction.ONE; f = f1.add(f2); assertEquals(Integer.MAX_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f = f.add(Fraction.ONE); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (final ArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = Fraction.getFraction(Integer.MIN_VALUE, 5); f2 = Fraction.getFraction(-1,5); try { f = f1.add(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (final ArithmeticException ex) {} try { f= Fraction.getFraction(-Integer.MAX_VALUE, 1); f = f.add(f); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f= Fraction.getFraction(-Integer.MAX_VALUE, 1); f = f.add(f); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} f1 = Fraction.getFraction(3,327680); f2 = Fraction.getFraction(2,59049); try { f = f1.add(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (final ArithmeticException ex) {} } @Test public void testSubtract() { Fraction f = null; Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(1, 5); f = f1.subtract(f2); assertEquals(2, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(7, 5); f2 = Fraction.getFraction(2, 5); f = f1.subtract(f2); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(3, 5); f = f1.subtract(f2); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(-4, 5); f = f1.subtract(f2); assertEquals(7, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(4, 5); f = f1.subtract(f2); assertEquals(-4, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(-4, 5); f = f1.subtract(f2); assertEquals(4, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(1, 2); f = f1.subtract(f2); assertEquals(1, f.getNumerator()); assertEquals(10, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(1, 5); f = f2.subtract(f1); assertSame(f2, f); try { f.subtract(null); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) {} // if this fraction is subtracted naively, it will overflow. // check that it doesn't. f1 = Fraction.getFraction(1,32768*3); f2 = Fraction.getFraction(1,59049); f = f1.subtract(f2); assertEquals(-13085, f.getNumerator()); assertEquals(1934917632, f.getDenominator()); f1 = Fraction.getFraction(Integer.MIN_VALUE, 3); f2 = Fraction.ONE_THIRD.negate(); f = f1.subtract(f2); assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); assertEquals(3, f.getDenominator()); f1 = Fraction.getFraction(Integer.MAX_VALUE, 1); f2 = Fraction.ONE; f = f1.subtract(f2); assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f1 = Fraction.getFraction(1, Integer.MAX_VALUE); f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1); f = f1.subtract(f2); fail("expecting ArithmeticException"); //should overflow } catch (final ArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = Fraction.getFraction(Integer.MIN_VALUE, 5); f2 = Fraction.getFraction(1,5); try { f = f1.subtract(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (final ArithmeticException ex) {} try { f= Fraction.getFraction(Integer.MIN_VALUE, 1); f = f.subtract(Fraction.ONE); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f= Fraction.getFraction(Integer.MAX_VALUE, 1); f = f.subtract(Fraction.ONE.negate()); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} f1 = Fraction.getFraction(3,327680); f2 = Fraction.getFraction(2,59049); try { f = f1.subtract(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (final ArithmeticException ex) {} } @Test public void testMultiply() { Fraction f = null; Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(2, 5); f = f1.multiplyBy(f2); assertEquals(6, f.getNumerator()); assertEquals(25, f.getDenominator()); f1 = Fraction.getFraction(6, 10); f2 = Fraction.getFraction(6, 10); f = f1.multiplyBy(f2); assertEquals(9, f.getNumerator()); assertEquals(25, f.getDenominator()); f = f.multiplyBy(f2); assertEquals(27, f.getNumerator()); assertEquals(125, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(-2, 5); f = f1.multiplyBy(f2); assertEquals(-6, f.getNumerator()); assertEquals(25, f.getDenominator()); f1 = Fraction.getFraction(-3, 5); f2 = Fraction.getFraction(-2, 5); f = f1.multiplyBy(f2); assertEquals(6, f.getNumerator()); assertEquals(25, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(2, 7); f = f1.multiplyBy(f2); assertSame(Fraction.ZERO, f); f1 = Fraction.getFraction(2, 7); f2 = Fraction.ONE; f = f1.multiplyBy(f2); assertEquals(2, f.getNumerator()); assertEquals(7, f.getDenominator()); f1 = Fraction.getFraction(Integer.MAX_VALUE, 1); f2 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.multiplyBy(f2); assertEquals(Integer.MIN_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f.multiplyBy(null); fail("expecting IllegalArgumentException"); } catch (final IllegalArgumentException ex) {} try { f1 = Fraction.getFraction(1, Integer.MAX_VALUE); f = f1.multiplyBy(f1); // should overflow fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f1 = Fraction.getFraction(1, -Integer.MAX_VALUE); f = f1.multiplyBy(f1); // should overflow fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testDivide() { Fraction f = null; Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(2, 5); f = f1.divideBy(f2); assertEquals(3, f.getNumerator()); assertEquals(2, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.ZERO; try { f = f1.divideBy(f2); fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(2, 7); f = f1.divideBy(f2); assertSame(Fraction.ZERO, f); f1 = Fraction.getFraction(2, 7); f2 = Fraction.ONE; f = f1.divideBy(f2); assertEquals(2, f.getNumerator()); assertEquals(7, f.getDenominator()); f1 = Fraction.getFraction(1, Integer.MAX_VALUE); f = f1.divideBy(f1); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f2 = Fraction.getFraction(1, Integer.MAX_VALUE); f = f1.divideBy(f2); assertEquals(Integer.MIN_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f.divideBy(null); fail("IllegalArgumentException"); } catch (final IllegalArgumentException ex) {} try { f1 = Fraction.getFraction(1, Integer.MAX_VALUE); f = f1.divideBy(f1.invert()); // should overflow fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} try { f1 = Fraction.getFraction(1, -Integer.MAX_VALUE); f = f1.divideBy(f1.invert()); // should overflow fail("expecting ArithmeticException"); } catch (final ArithmeticException ex) {} } @Test public void testEquals() { Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); assertFalse(f1.equals(null)); assertFalse(f1.equals(new Object())); assertFalse(f1.equals(Integer.valueOf(6))); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(2, 5); assertFalse(f1.equals(f2)); assertTrue(f1.equals(f1)); assertTrue(f2.equals(f2)); f2 = Fraction.getFraction(3, 5); assertTrue(f1.equals(f2)); f2 = Fraction.getFraction(6, 10); assertFalse(f1.equals(f2)); } @Test public void testHashCode() { final Fraction f1 = Fraction.getFraction(3, 5); Fraction f2 = Fraction.getFraction(3, 5); assertTrue(f1.hashCode() == f2.hashCode()); f2 = Fraction.getFraction(2, 5); assertTrue(f1.hashCode() != f2.hashCode()); f2 = Fraction.getFraction(6, 10); assertTrue(f1.hashCode() != f2.hashCode()); } @Test public void testCompareTo() { Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); assertTrue(f1.compareTo(f1) == 0); try { f1.compareTo(null); fail("expecting NullPointerException"); } catch (final NullPointerException ex) {} f2 = Fraction.getFraction(2, 5); assertTrue(f1.compareTo(f2) > 0); assertTrue(f2.compareTo(f2) == 0); f2 = Fraction.getFraction(4, 5); assertTrue(f1.compareTo(f2) < 0); assertTrue(f2.compareTo(f2) == 0); f2 = Fraction.getFraction(3, 5); assertTrue(f1.compareTo(f2) == 0); assertTrue(f2.compareTo(f2) == 0); f2 = Fraction.getFraction(6, 10); assertTrue(f1.compareTo(f2) == 0); assertTrue(f2.compareTo(f2) == 0); f2 = Fraction.getFraction(-1, 1, Integer.MAX_VALUE); assertTrue(f1.compareTo(f2) > 0); assertTrue(f2.compareTo(f2) == 0); } @Test public void testToString() { Fraction f = null; f = Fraction.getFraction(3, 5); final String str = f.toString(); assertEquals("3/5", str); assertSame(str, f.toString()); f = Fraction.getFraction(7, 5); assertEquals("7/5", f.toString()); f = Fraction.getFraction(4, 2); assertEquals("4/2", f.toString()); f = Fraction.getFraction(0, 2); assertEquals("0/2", f.toString()); f = Fraction.getFraction(2, 2); assertEquals("2/2", f.toString()); f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1); assertEquals("-2147483648/1", f.toString()); f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE); assertEquals("-2147483648/2147483647", f.toString()); } @Test public void testToProperString() { Fraction f = null; f = Fraction.getFraction(3, 5); final String str = f.toProperString(); assertEquals("3/5", str); assertSame(str, f.toProperString()); f = Fraction.getFraction(7, 5); assertEquals("1 2/5", f.toProperString()); f = Fraction.getFraction(14, 10); assertEquals("1 4/10", f.toProperString()); f = Fraction.getFraction(4, 2); assertEquals("2", f.toProperString()); f = Fraction.getFraction(0, 2); assertEquals("0", f.toProperString()); f = Fraction.getFraction(2, 2); assertEquals("1", f.toProperString()); f = Fraction.getFraction(-7, 5); assertEquals("-1 2/5", f.toProperString()); f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1); assertEquals("-2147483648", f.toProperString()); f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE); assertEquals("-1 1/2147483647", f.toProperString()); assertEquals("-1", Fraction.getFraction(-1).toProperString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.math; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.math.IEEE754rUtils}. * * @version $Id$ */ public class IEEE754rUtilsTest { @Test public void testLang381() { assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01); assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01); assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN))); assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01); assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01); assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN))); final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; assertEquals(42.0, IEEE754rUtils.max(a), 0.01); assertEquals(1.2, IEEE754rUtils.min(a), 0.01); final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; assertEquals(42.0, IEEE754rUtils.max(b), 0.01); assertEquals(1.2, IEEE754rUtils.min(b), 0.01); final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01); assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01); final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01); assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01); } @Test public void testEnforceExceptions() { try { IEEE754rUtils.min( (float[]) null); fail("IllegalArgumentException expected for null input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.min(new float[0]); fail("IllegalArgumentException expected for empty input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.max( (float[]) null); fail("IllegalArgumentException expected for null input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.max(new float[0]); fail("IllegalArgumentException expected for empty input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.min( (double[]) null); fail("IllegalArgumentException expected for null input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.min(new double[0]); fail("IllegalArgumentException expected for empty input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.max( (double[]) null); fail("IllegalArgumentException expected for null input"); } catch(final IllegalArgumentException iae) { /* expected */ } try { IEEE754rUtils.max(new double[0]); fail("IllegalArgumentException expected for empty input"); } catch(final IllegalArgumentException iae) { /* expected */ } } @Test public void testConstructorExists() { new IEEE754rUtils(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.math; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.math.BigDecimal; import java.math.BigInteger; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.math.NumberUtils}. * * @version $Id$ */ public class NumberUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new NumberUtils()); final Constructor<?>[] cons = NumberUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(NumberUtils.class.getModifiers())); assertFalse(Modifier.isFinal(NumberUtils.class.getModifiers())); } //--------------------------------------------------------------------- /** * Test for {@link NumberUtils#toInt(String)}. */ @Test public void testToIntString() { assertTrue("toInt(String) 1 failed", NumberUtils.toInt("12345") == 12345); assertTrue("toInt(String) 2 failed", NumberUtils.toInt("abc") == 0); assertTrue("toInt(empty) failed", NumberUtils.toInt("") == 0); assertTrue("toInt(null) failed", NumberUtils.toInt(null) == 0); } /** * Test for {@link NumberUtils#toInt(String, int)}. */ @Test public void testToIntStringI() { assertTrue("toInt(String,int) 1 failed", NumberUtils.toInt("12345", 5) == 12345); assertTrue("toInt(String,int) 2 failed", NumberUtils.toInt("1234.5", 5) == 5); } /** * Test for {@link NumberUtils#toLong(String)}. */ @Test public void testToLongString() { assertTrue("toLong(String) 1 failed", NumberUtils.toLong("12345") == 12345l); assertTrue("toLong(String) 2 failed", NumberUtils.toLong("abc") == 0l); assertTrue("toLong(String) 3 failed", NumberUtils.toLong("1L") == 0l); assertTrue("toLong(String) 4 failed", NumberUtils.toLong("1l") == 0l); assertTrue("toLong(Long.MAX_VALUE) failed", NumberUtils.toLong(Long.MAX_VALUE+"") == Long.MAX_VALUE); assertTrue("toLong(Long.MIN_VALUE) failed", NumberUtils.toLong(Long.MIN_VALUE+"") == Long.MIN_VALUE); assertTrue("toLong(empty) failed", NumberUtils.toLong("") == 0l); assertTrue("toLong(null) failed", NumberUtils.toLong(null) == 0l); } /** * Test for {@link NumberUtils#toLong(String, long)}. */ @Test public void testToLongStringL() { assertTrue("toLong(String,long) 1 failed", NumberUtils.toLong("12345", 5l) == 12345l); assertTrue("toLong(String,long) 2 failed", NumberUtils.toLong("1234.5", 5l) == 5l); } /** * Test for {@link NumberUtils#toFloat(String)}. */ @Test public void testToFloatString() { assertTrue("toFloat(String) 1 failed", NumberUtils.toFloat("-1.2345") == -1.2345f); assertTrue("toFloat(String) 2 failed", NumberUtils.toFloat("1.2345") == 1.2345f); assertTrue("toFloat(String) 3 failed", NumberUtils.toFloat("abc") == 0.0f); assertTrue("toFloat(Float.MAX_VALUE) failed", NumberUtils.toFloat(Float.MAX_VALUE+"") == Float.MAX_VALUE); assertTrue("toFloat(Float.MIN_VALUE) failed", NumberUtils.toFloat(Float.MIN_VALUE+"") == Float.MIN_VALUE); assertTrue("toFloat(empty) failed", NumberUtils.toFloat("") == 0.0f); assertTrue("toFloat(null) failed", NumberUtils.toFloat(null) == 0.0f); } /** * Test for {@link NumberUtils#toFloat(String, float)}. */ @Test public void testToFloatStringF() { assertTrue("toFloat(String,int) 1 failed", NumberUtils.toFloat("1.2345", 5.1f) == 1.2345f); assertTrue("toFloat(String,int) 2 failed", NumberUtils.toFloat("a", 5.0f) == 5.0f); } /** * Test for {(@link NumberUtils#createNumber(String)} */ @Test public void testStringCreateNumberEnsureNoPrecisionLoss(){ String shouldBeFloat = "1.23"; String shouldBeDouble = "3.40282354e+38"; String shouldBeBigDecimal = "1.797693134862315759e+308"; assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float); assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal); } /** * Test for {@link NumberUtils#toDouble(String)}. */ @Test public void testStringToDoubleString() { assertTrue("toDouble(String) 1 failed", NumberUtils.toDouble("-1.2345") == -1.2345d); assertTrue("toDouble(String) 2 failed", NumberUtils.toDouble("1.2345") == 1.2345d); assertTrue("toDouble(String) 3 failed", NumberUtils.toDouble("abc") == 0.0d); assertTrue("toDouble(Double.MAX_VALUE) failed", NumberUtils.toDouble(Double.MAX_VALUE+"") == Double.MAX_VALUE); assertTrue("toDouble(Double.MIN_VALUE) failed", NumberUtils.toDouble(Double.MIN_VALUE+"") == Double.MIN_VALUE); assertTrue("toDouble(empty) failed", NumberUtils.toDouble("") == 0.0d); assertTrue("toDouble(null) failed", NumberUtils.toDouble(null) == 0.0d); } /** * Test for {@link NumberUtils#toDouble(String, double)}. */ @Test public void testStringToDoubleStringD() { assertTrue("toDouble(String,int) 1 failed", NumberUtils.toDouble("1.2345", 5.1d) == 1.2345d); assertTrue("toDouble(String,int) 2 failed", NumberUtils.toDouble("a", 5.0d) == 5.0d); } /** * Test for {@link NumberUtils#toByte(String)}. */ @Test public void testToByteString() { assertTrue("toByte(String) 1 failed", NumberUtils.toByte("123") == 123); assertTrue("toByte(String) 2 failed", NumberUtils.toByte("abc") == 0); assertTrue("toByte(empty) failed", NumberUtils.toByte("") == 0); assertTrue("toByte(null) failed", NumberUtils.toByte(null) == 0); } /** * Test for {@link NumberUtils#toByte(String, byte)}. */ @Test public void testToByteStringI() { assertTrue("toByte(String,byte) 1 failed", NumberUtils.toByte("123", (byte) 5) == 123); assertTrue("toByte(String,byte) 2 failed", NumberUtils.toByte("12.3", (byte) 5) == 5); } /** * Test for {@link NumberUtils#toShort(String)}. */ @Test public void testToShortString() { assertTrue("toShort(String) 1 failed", NumberUtils.toShort("12345") == 12345); assertTrue("toShort(String) 2 failed", NumberUtils.toShort("abc") == 0); assertTrue("toShort(empty) failed", NumberUtils.toShort("") == 0); assertTrue("toShort(null) failed", NumberUtils.toShort(null) == 0); } /** * Test for {@link NumberUtils#toShort(String, short)}. */ @Test public void testToShortStringI() { assertTrue("toShort(String,short) 1 failed", NumberUtils.toShort("12345", (short) 5) == 12345); assertTrue("toShort(String,short) 2 failed", NumberUtils.toShort("1234.5", (short) 5) == 5); } @Test public void testCreateNumber() { // a lot of things can go wrong assertEquals("createNumber(String) 1 failed", Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5")); assertEquals("createNumber(String) 2 failed", Integer.valueOf("12345"), NumberUtils.createNumber("12345")); assertEquals("createNumber(String) 3 failed", Double.valueOf("1234.5"), NumberUtils.createNumber("1234.5D")); assertEquals("createNumber(String) 3 failed", Double.valueOf("1234.5"), NumberUtils.createNumber("1234.5d")); assertEquals("createNumber(String) 4 failed", Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5F")); assertEquals("createNumber(String) 4 failed", Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5f")); assertEquals("createNumber(String) 5 failed", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber("" + (Integer.MAX_VALUE + 1L))); assertEquals("createNumber(String) 6 failed", Long.valueOf(12345), NumberUtils.createNumber("12345L")); assertEquals("createNumber(String) 6 failed", Long.valueOf(12345), NumberUtils.createNumber("12345l")); assertEquals("createNumber(String) 7 failed", Float.valueOf("-1234.5"), NumberUtils.createNumber("-1234.5")); assertEquals("createNumber(String) 8 failed", Integer.valueOf("-12345"), NumberUtils.createNumber("-12345")); assertTrue("createNumber(String) 9a failed", 0xFADE == NumberUtils.createNumber("0xFADE").intValue()); assertTrue("createNumber(String) 9b failed", 0xFADE == NumberUtils.createNumber("0Xfade").intValue()); assertTrue("createNumber(String) 10a failed", -0xFADE == NumberUtils.createNumber("-0xFADE").intValue()); assertTrue("createNumber(String) 10b failed", -0xFADE == NumberUtils.createNumber("-0Xfade").intValue()); assertEquals("createNumber(String) 11 failed", Double.valueOf("1.1E200"), NumberUtils.createNumber("1.1E200")); assertEquals("createNumber(String) 12 failed", Float.valueOf("1.1E20"), NumberUtils.createNumber("1.1E20")); assertEquals("createNumber(String) 13 failed", Double.valueOf("-1.1E200"), NumberUtils.createNumber("-1.1E200")); assertEquals("createNumber(String) 14 failed", Double.valueOf("1.1E-200"), NumberUtils.createNumber("1.1E-200")); assertEquals("createNumber(null) failed", null, NumberUtils.createNumber(null)); assertEquals("createNumber(String) failed", new BigInteger("12345678901234567890"), NumberUtils .createNumber("12345678901234567890L")); assertEquals("createNumber(String) 15 failed", new BigDecimal("1.1E-700"), NumberUtils .createNumber("1.1E-700F")); assertEquals("createNumber(String) 16 failed", Long.valueOf("10" + Integer.MAX_VALUE), NumberUtils .createNumber("10" + Integer.MAX_VALUE + "L")); assertEquals("createNumber(String) 17 failed", Long.valueOf("10" + Integer.MAX_VALUE), NumberUtils .createNumber("10" + Integer.MAX_VALUE)); assertEquals("createNumber(String) 18 failed", new BigInteger("10" + Long.MAX_VALUE), NumberUtils .createNumber("10" + Long.MAX_VALUE)); // LANG-521 assertEquals("createNumber(String) LANG-521 failed", Float.valueOf("2."), NumberUtils.createNumber("2.")); // LANG-638 assertFalse("createNumber(String) succeeded", checkCreateNumber("1eE")); // LANG-693 assertEquals("createNumber(String) LANG-693 failed", Double.valueOf(Double.MAX_VALUE), NumberUtils .createNumber("" + Double.MAX_VALUE)); // LANG-822 // ensure that the underlying negative number would create a BigDecimal final Number bigNum = NumberUtils.createNumber("-1.1E-700F"); assertNotNull(bigNum); assertEquals(BigDecimal.class, bigNum.getClass()); } @Test public void TestLang747() { assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000")); assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000")); assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000")); assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000")); assertEquals(Integer.valueOf(0x7FFFFFFF), NumberUtils.createNumber("0x7FFFFFFF")); assertEquals(Long.valueOf(0x80000000L), NumberUtils.createNumber("0x80000000")); assertEquals(Long.valueOf(0xFFFFFFFFL), NumberUtils.createNumber("0xFFFFFFFF")); // Leading zero tests assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x08000000")); assertEquals(Integer.valueOf(0x7FFFFFFF), NumberUtils.createNumber("0x007FFFFFFF")); assertEquals(Long.valueOf(0x80000000L), NumberUtils.createNumber("0x080000000")); assertEquals(Long.valueOf(0xFFFFFFFFL), NumberUtils.createNumber("0x00FFFFFFFF")); assertEquals(Long.valueOf(0x800000000L), NumberUtils.createNumber("0x800000000")); assertEquals(Long.valueOf(0x8000000000L), NumberUtils.createNumber("0x8000000000")); assertEquals(Long.valueOf(0x80000000000L), NumberUtils.createNumber("0x80000000000")); assertEquals(Long.valueOf(0x800000000000L), NumberUtils.createNumber("0x800000000000")); assertEquals(Long.valueOf(0x8000000000000L), NumberUtils.createNumber("0x8000000000000")); assertEquals(Long.valueOf(0x80000000000000L), NumberUtils.createNumber("0x80000000000000")); assertEquals(Long.valueOf(0x800000000000000L), NumberUtils.createNumber("0x800000000000000")); assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber("0x7FFFFFFFFFFFFFFF")); // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long assertEquals(new BigInteger("8000000000000000", 16), NumberUtils.createNumber("0x8000000000000000")); assertEquals(new BigInteger("FFFFFFFFFFFFFFFF", 16), NumberUtils.createNumber("0xFFFFFFFFFFFFFFFF")); // Leading zero tests assertEquals(Long.valueOf(0x80000000000000L), NumberUtils.createNumber("0x00080000000000000")); assertEquals(Long.valueOf(0x800000000000000L), NumberUtils.createNumber("0x0800000000000000")); assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber("0x07FFFFFFFFFFFFFFF")); // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long assertEquals(new BigInteger("8000000000000000", 16), NumberUtils.createNumber("0x00008000000000000000")); assertEquals(new BigInteger("FFFFFFFFFFFFFFFF", 16), NumberUtils.createNumber("0x0FFFFFFFFFFFFFFFF")); } @Test(expected=NumberFormatException.class) // Check that the code fails to create a valid number when preceeded by -- rather than - public void testCreateNumberFailure_1() { NumberUtils.createNumber("--1.1E-700F"); } @Test(expected=NumberFormatException.class) // Check that the code fails to create a valid number when both e and E are present (with decimal) public void testCreateNumberFailure_2() { NumberUtils.createNumber("-1.1E+0-7e00"); } @Test(expected=NumberFormatException.class) // Check that the code fails to create a valid number when both e and E are present (no decimal) public void testCreateNumberFailure_3() { NumberUtils.createNumber("-11E+0-7e00"); } @Test(expected=NumberFormatException.class) // Check that the code fails to create a valid number when both e and E are present (no decimal) public void testCreateNumberFailure_4() { NumberUtils.createNumber("1eE+00001"); } // Tests to show when magnitude causes switch to next Number type // Will probably need to be adjusted if code is changed to check precision (LANG-693) @Test public void testCreateNumberMagnitude() { // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type assertEquals(Float.valueOf(Float.MAX_VALUE), NumberUtils.createNumber("3.4028235e+38")); assertEquals(Double.valueOf(3.4028236e+38), NumberUtils.createNumber("3.4028236e+38")); // Test Double.MAX_VALUE assertEquals(Double.valueOf(Double.MAX_VALUE), NumberUtils.createNumber("1.7976931348623157e+308")); // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal) assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308")); assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678")); assertEquals(Long.valueOf(0x123456789L), NumberUtils.createNumber("0x123456789")); assertEquals(Long.valueOf(0x7fffffffffffffffL), NumberUtils.createNumber("0x7fffffffffffffff")); // Does not appear to be a way to create a literal BigInteger of this magnitude assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("0x7fffffffffffffff0")); assertEquals(Long.valueOf(0x7fffffffffffffffL), NumberUtils.createNumber("#7fffffffffffffff")); assertEquals(new BigInteger("7fffffffffffffff0",16), NumberUtils.createNumber("#7fffffffffffffff0")); assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber("017777777777")); // 31 bits assertEquals(Long.valueOf(037777777777L), NumberUtils.createNumber("037777777777")); // 32 bits assertEquals(Long.valueOf(0777777777777777777777L), NumberUtils.createNumber("0777777777777777777777")); // 63 bits assertEquals(new BigInteger("1777777777777777777777",8), NumberUtils.createNumber("01777777777777777777777"));// 64 bits } @Test public void testCreateFloat() { assertEquals("createFloat(String) failed", Float.valueOf("1234.5"), NumberUtils.createFloat("1234.5")); assertEquals("createFloat(null) failed", null, NumberUtils.createFloat(null)); this.testCreateFloatFailure(""); this.testCreateFloatFailure(" "); this.testCreateFloatFailure("\b\t\n\f\r"); // Funky whitespaces this.testCreateFloatFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); } protected void testCreateFloatFailure(final String str) { try { final Float value = NumberUtils.createFloat(str); fail("createFloat(\"" + str + "\") should have failed: " + value); } catch (final NumberFormatException ex) { // empty } } @Test public void testCreateDouble() { assertEquals("createDouble(String) failed", Double.valueOf("1234.5"), NumberUtils.createDouble("1234.5")); assertEquals("createDouble(null) failed", null, NumberUtils.createDouble(null)); this.testCreateDoubleFailure(""); this.testCreateDoubleFailure(" "); this.testCreateDoubleFailure("\b\t\n\f\r"); // Funky whitespaces this.testCreateDoubleFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); } protected void testCreateDoubleFailure(final String str) { try { final Double value = NumberUtils.createDouble(str); fail("createDouble(\"" + str + "\") should have failed: " + value); } catch (final NumberFormatException ex) { // empty } } @Test public void testCreateInteger() { assertEquals("createInteger(String) failed", Integer.valueOf("12345"), NumberUtils.createInteger("12345")); assertEquals("createInteger(null) failed", null, NumberUtils.createInteger(null)); this.testCreateIntegerFailure(""); this.testCreateIntegerFailure(" "); this.testCreateIntegerFailure("\b\t\n\f\r"); // Funky whitespaces this.testCreateIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); } protected void testCreateIntegerFailure(final String str) { try { final Integer value = NumberUtils.createInteger(str); fail("createInteger(\"" + str + "\") should have failed: " + value); } catch (final NumberFormatException ex) { // empty } } @Test public void testCreateLong() { assertEquals("createLong(String) failed", Long.valueOf("12345"), NumberUtils.createLong("12345")); assertEquals("createLong(null) failed", null, NumberUtils.createLong(null)); this.testCreateLongFailure(""); this.testCreateLongFailure(" "); this.testCreateLongFailure("\b\t\n\f\r"); // Funky whitespaces this.testCreateLongFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); } protected void testCreateLongFailure(final String str) { try { final Long value = NumberUtils.createLong(str); fail("createLong(\"" + str + "\") should have failed: " + value); } catch (final NumberFormatException ex) { // empty } } @Test public void testCreateBigInteger() { assertEquals("createBigInteger(String) failed", new BigInteger("12345"), NumberUtils.createBigInteger("12345")); assertEquals("createBigInteger(null) failed", null, NumberUtils.createBigInteger(null)); this.testCreateBigIntegerFailure(""); this.testCreateBigIntegerFailure(" "); this.testCreateBigIntegerFailure("\b\t\n\f\r"); // Funky whitespaces this.testCreateBigIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); assertEquals("createBigInteger(String) failed", new BigInteger("255"), NumberUtils.createBigInteger("0xff")); assertEquals("createBigInteger(String) failed", new BigInteger("255"), NumberUtils.createBigInteger("#ff")); assertEquals("createBigInteger(String) failed", new BigInteger("-255"), NumberUtils.createBigInteger("-0xff")); assertEquals("createBigInteger(String) failed", new BigInteger("255"), NumberUtils.createBigInteger("0377")); assertEquals("createBigInteger(String) failed", new BigInteger("-255"), NumberUtils.createBigInteger("-0377")); assertEquals("createBigInteger(String) failed", new BigInteger("-255"), NumberUtils.createBigInteger("-0377")); assertEquals("createBigInteger(String) failed", new BigInteger("-0"), NumberUtils.createBigInteger("-0")); assertEquals("createBigInteger(String) failed", new BigInteger("0"), NumberUtils.createBigInteger("0")); testCreateBigIntegerFailure("#"); testCreateBigIntegerFailure("-#"); testCreateBigIntegerFailure("0x"); testCreateBigIntegerFailure("-0x"); } protected void testCreateBigIntegerFailure(final String str) { try { final BigInteger value = NumberUtils.createBigInteger(str); fail("createBigInteger(\"" + str + "\") should have failed: " + value); } catch (final NumberFormatException ex) { // empty } } @Test public void testCreateBigDecimal() { assertEquals("createBigDecimal(String) failed", new BigDecimal("1234.5"), NumberUtils.createBigDecimal("1234.5")); assertEquals("createBigDecimal(null) failed", null, NumberUtils.createBigDecimal(null)); this.testCreateBigDecimalFailure(""); this.testCreateBigDecimalFailure(" "); this.testCreateBigDecimalFailure("\b\t\n\f\r"); // Funky whitespaces this.testCreateBigDecimalFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F"); this.testCreateBigDecimalFailure("-"); // sign alone not valid this.testCreateBigDecimalFailure("--"); // comment in NumberUtils suggests some implementations may incorrectly allow this this.testCreateBigDecimalFailure("--0"); this.testCreateBigDecimalFailure("+"); // sign alone not valid this.testCreateBigDecimalFailure("++"); // in case this was also allowed by some JVMs this.testCreateBigDecimalFailure("++0"); } protected void testCreateBigDecimalFailure(final String str) { try { final BigDecimal value = NumberUtils.createBigDecimal(str); fail("createBigDecimal(\"" + str + "\") should have failed: " + value); } catch (final NumberFormatException ex) { // empty } } // min/max tests // ---------------------------------------------------------------------- @Test(expected = IllegalArgumentException.class) public void testMinLong_nullArray() { NumberUtils.min((long[]) null); } @Test(expected = IllegalArgumentException.class) public void testMinLong_emptyArray() { NumberUtils.min(new long[0]); } @Test public void testMinLong() { assertEquals( "min(long[]) failed for array length 1", 5, NumberUtils.min(new long[] { 5 })); assertEquals( "min(long[]) failed for array length 2", 6, NumberUtils.min(new long[] { 6, 9 })); assertEquals(-10, NumberUtils.min(new long[] { -10, -5, 0, 5, 10 })); assertEquals(-10, NumberUtils.min(new long[] { -5, 0, -10, 5, 10 })); } @Test(expected = IllegalArgumentException.class) public void testMinInt_nullArray() { NumberUtils.min((int[]) null); } @Test(expected = IllegalArgumentException.class) public void testMinInt_emptyArray() { NumberUtils.min(new int[0]); } @Test public void testMinInt() { assertEquals( "min(int[]) failed for array length 1", 5, NumberUtils.min(new int[] { 5 })); assertEquals( "min(int[]) failed for array length 2", 6, NumberUtils.min(new int[] { 6, 9 })); assertEquals(-10, NumberUtils.min(new int[] { -10, -5, 0, 5, 10 })); assertEquals(-10, NumberUtils.min(new int[] { -5, 0, -10, 5, 10 })); } @Test(expected = IllegalArgumentException.class) public void testMinShort_nullArray() { NumberUtils.min((short[]) null); } @Test(expected = IllegalArgumentException.class) public void testMinShort_emptyArray() { NumberUtils.min(new short[0]); } @Test public void testMinShort() { assertEquals( "min(short[]) failed for array length 1", 5, NumberUtils.min(new short[] { 5 })); assertEquals( "min(short[]) failed for array length 2", 6, NumberUtils.min(new short[] { 6, 9 })); assertEquals(-10, NumberUtils.min(new short[] { -10, -5, 0, 5, 10 })); assertEquals(-10, NumberUtils.min(new short[] { -5, 0, -10, 5, 10 })); } @Test(expected = IllegalArgumentException.class) public void testMinByte_nullArray() { NumberUtils.min((byte[]) null); } @Test(expected = IllegalArgumentException.class) public void testMinByte_emptyArray() { NumberUtils.min(new byte[0]); } @Test public void testMinByte() { assertEquals( "min(byte[]) failed for array length 1", 5, NumberUtils.min(new byte[] { 5 })); assertEquals( "min(byte[]) failed for array length 2", 6, NumberUtils.min(new byte[] { 6, 9 })); assertEquals(-10, NumberUtils.min(new byte[] { -10, -5, 0, 5, 10 })); assertEquals(-10, NumberUtils.min(new byte[] { -5, 0, -10, 5, 10 })); } @Test(expected = IllegalArgumentException.class) public void testMinDouble_nullArray() { NumberUtils.min((double[]) null); } @Test(expected = IllegalArgumentException.class) public void testMinDouble_emptyArray() { NumberUtils.min(new double[0]); } @Test public void testMinDouble() { assertEquals( "min(double[]) failed for array length 1", 5.12, NumberUtils.min(new double[] { 5.12 }), 0); assertEquals( "min(double[]) failed for array length 2", 6.23, NumberUtils.min(new double[] { 6.23, 9.34 }), 0); assertEquals( "min(double[]) failed for array length 5", -10.45, NumberUtils.min(new double[] { -10.45, -5.56, 0, 5.67, 10.78 }), 0); assertEquals(-10, NumberUtils.min(new double[] { -10, -5, 0, 5, 10 }), 0.0001); assertEquals(-10, NumberUtils.min(new double[] { -5, 0, -10, 5, 10 }), 0.0001); } @Test(expected = IllegalArgumentException.class) public void testMinFloat_nullArray() { NumberUtils.min((float[]) null); } @Test(expected = IllegalArgumentException.class) public void testMinFloat_emptyArray() { NumberUtils.min(new float[0]); } @Test public void testMinFloat() { assertEquals( "min(float[]) failed for array length 1", 5.9f, NumberUtils.min(new float[] { 5.9f }), 0); assertEquals( "min(float[]) failed for array length 2", 6.8f, NumberUtils.min(new float[] { 6.8f, 9.7f }), 0); assertEquals( "min(float[]) failed for array length 5", -10.6f, NumberUtils.min(new float[] { -10.6f, -5.5f, 0, 5.4f, 10.3f }), 0); assertEquals(-10, NumberUtils.min(new float[] { -10, -5, 0, 5, 10 }), 0.0001f); assertEquals(-10, NumberUtils.min(new float[] { -5, 0, -10, 5, 10 }), 0.0001f); } @Test(expected = IllegalArgumentException.class) public void testMaxLong_nullArray() { NumberUtils.max((long[]) null); } @Test(expected = IllegalArgumentException.class) public void testMaxLong_emptyArray() { NumberUtils.max(new long[0]); } @Test public void testMaxLong() { assertEquals( "max(long[]) failed for array length 1", 5, NumberUtils.max(new long[] { 5 })); assertEquals( "max(long[]) failed for array length 2", 9, NumberUtils.max(new long[] { 6, 9 })); assertEquals( "max(long[]) failed for array length 5", 10, NumberUtils.max(new long[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new long[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new long[] { -5, 0, 10, 5, -10 })); } @Test(expected = IllegalArgumentException.class) public void testMaxInt_nullArray() { NumberUtils.max((int[]) null); } @Test(expected = IllegalArgumentException.class) public void testMaxInt_emptyArray() { NumberUtils.max(new int[0]); } @Test public void testMaxInt() { assertEquals( "max(int[]) failed for array length 1", 5, NumberUtils.max(new int[] { 5 })); assertEquals( "max(int[]) failed for array length 2", 9, NumberUtils.max(new int[] { 6, 9 })); assertEquals( "max(int[]) failed for array length 5", 10, NumberUtils.max(new int[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new int[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new int[] { -5, 0, 10, 5, -10 })); } @Test(expected = IllegalArgumentException.class) public void testMaxShort_nullArray() { NumberUtils.max((short[]) null); } @Test(expected = IllegalArgumentException.class) public void testMaxShort_emptyArray() { NumberUtils.max(new short[0]); } @Test public void testMaxShort() { assertEquals( "max(short[]) failed for array length 1", 5, NumberUtils.max(new short[] { 5 })); assertEquals( "max(short[]) failed for array length 2", 9, NumberUtils.max(new short[] { 6, 9 })); assertEquals( "max(short[]) failed for array length 5", 10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 })); } @Test(expected = IllegalArgumentException.class) public void testMaxByte_nullArray() { NumberUtils.max((byte[]) null); } @Test(expected = IllegalArgumentException.class) public void testMaxByte_emptyArray() { NumberUtils.max(new byte[0]); } @Test public void testMaxByte() { assertEquals( "max(byte[]) failed for array length 1", 5, NumberUtils.max(new byte[] { 5 })); assertEquals( "max(byte[]) failed for array length 2", 9, NumberUtils.max(new byte[] { 6, 9 })); assertEquals( "max(byte[]) failed for array length 5", 10, NumberUtils.max(new byte[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new byte[] { -10, -5, 0, 5, 10 })); assertEquals(10, NumberUtils.max(new byte[] { -5, 0, 10, 5, -10 })); } @Test(expected = IllegalArgumentException.class) public void testMaxDouble_nullArray() { NumberUtils.max((double[]) null); } @Test(expected = IllegalArgumentException.class) public void testMaxDouble_emptyArray() { NumberUtils.max(new double[0]); } @Test public void testMaxDouble() { final double[] d = null; try { NumberUtils.max(d); fail("No exception was thrown for null input."); } catch (final IllegalArgumentException ex) {} try { NumberUtils.max(new double[0]); fail("No exception was thrown for empty input."); } catch (final IllegalArgumentException ex) {} assertEquals( "max(double[]) failed for array length 1", 5.1f, NumberUtils.max(new double[] { 5.1f }), 0); assertEquals( "max(double[]) failed for array length 2", 9.2f, NumberUtils.max(new double[] { 6.3f, 9.2f }), 0); assertEquals( "max(double[]) failed for float length 5", 10.4f, NumberUtils.max(new double[] { -10.5f, -5.6f, 0, 5.7f, 10.4f }), 0); assertEquals(10, NumberUtils.max(new double[] { -10, -5, 0, 5, 10 }), 0.0001); assertEquals(10, NumberUtils.max(new double[] { -5, 0, 10, 5, -10 }), 0.0001); } @Test(expected = IllegalArgumentException.class) public void testMaxFloat_nullArray() { NumberUtils.max((float[]) null); } @Test(expected = IllegalArgumentException.class) public void testMaxFloat_emptyArray() { NumberUtils.max(new float[0]); } @Test public void testMaxFloat() { assertEquals( "max(float[]) failed for array length 1", 5.1f, NumberUtils.max(new float[] { 5.1f }), 0); assertEquals( "max(float[]) failed for array length 2", 9.2f, NumberUtils.max(new float[] { 6.3f, 9.2f }), 0); assertEquals( "max(float[]) failed for float length 5", 10.4f, NumberUtils.max(new float[] { -10.5f, -5.6f, 0, 5.7f, 10.4f }), 0); assertEquals(10, NumberUtils.max(new float[] { -10, -5, 0, 5, 10 }), 0.0001f); assertEquals(10, NumberUtils.max(new float[] { -5, 0, 10, 5, -10 }), 0.0001f); } @Test public void testMinimumLong() { assertEquals("minimum(long,long,long) 1 failed", 12345L, NumberUtils.min(12345L, 12345L + 1L, 12345L + 2L)); assertEquals("minimum(long,long,long) 2 failed", 12345L, NumberUtils.min(12345L + 1L, 12345L, 12345 + 2L)); assertEquals("minimum(long,long,long) 3 failed", 12345L, NumberUtils.min(12345L + 1L, 12345L + 2L, 12345L)); assertEquals("minimum(long,long,long) 4 failed", 12345L, NumberUtils.min(12345L + 1L, 12345L, 12345L)); assertEquals("minimum(long,long,long) 5 failed", 12345L, NumberUtils.min(12345L, 12345L, 12345L)); } @Test public void testMinimumInt() { assertEquals("minimum(int,int,int) 1 failed", 12345, NumberUtils.min(12345, 12345 + 1, 12345 + 2)); assertEquals("minimum(int,int,int) 2 failed", 12345, NumberUtils.min(12345 + 1, 12345, 12345 + 2)); assertEquals("minimum(int,int,int) 3 failed", 12345, NumberUtils.min(12345 + 1, 12345 + 2, 12345)); assertEquals("minimum(int,int,int) 4 failed", 12345, NumberUtils.min(12345 + 1, 12345, 12345)); assertEquals("minimum(int,int,int) 5 failed", 12345, NumberUtils.min(12345, 12345, 12345)); } @Test public void testMinimumShort() { final short low = 1234; final short mid = 1234 + 1; final short high = 1234 + 2; assertEquals("minimum(short,short,short) 1 failed", low, NumberUtils.min(low, mid, high)); assertEquals("minimum(short,short,short) 1 failed", low, NumberUtils.min(mid, low, high)); assertEquals("minimum(short,short,short) 1 failed", low, NumberUtils.min(mid, high, low)); assertEquals("minimum(short,short,short) 1 failed", low, NumberUtils.min(low, mid, low)); } @Test public void testMinimumByte() { final byte low = 123; final byte mid = 123 + 1; final byte high = 123 + 2; assertEquals("minimum(byte,byte,byte) 1 failed", low, NumberUtils.min(low, mid, high)); assertEquals("minimum(byte,byte,byte) 1 failed", low, NumberUtils.min(mid, low, high)); assertEquals("minimum(byte,byte,byte) 1 failed", low, NumberUtils.min(mid, high, low)); assertEquals("minimum(byte,byte,byte) 1 failed", low, NumberUtils.min(low, mid, low)); } @Test public void testMinimumDouble() { final double low = 12.3; final double mid = 12.3 + 1; final double high = 12.3 + 2; assertEquals(low, NumberUtils.min(low, mid, high), 0.0001); assertEquals(low, NumberUtils.min(mid, low, high), 0.0001); assertEquals(low, NumberUtils.min(mid, high, low), 0.0001); assertEquals(low, NumberUtils.min(low, mid, low), 0.0001); assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001); } @Test public void testMinimumFloat() { final float low = 12.3f; final float mid = 12.3f + 1; final float high = 12.3f + 2; assertEquals(low, NumberUtils.min(low, mid, high), 0.0001f); assertEquals(low, NumberUtils.min(mid, low, high), 0.0001f); assertEquals(low, NumberUtils.min(mid, high, low), 0.0001f); assertEquals(low, NumberUtils.min(low, mid, low), 0.0001f); assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001f); } @Test public void testMaximumLong() { assertEquals("maximum(long,long,long) 1 failed", 12345L, NumberUtils.max(12345L, 12345L - 1L, 12345L - 2L)); assertEquals("maximum(long,long,long) 2 failed", 12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L - 2L)); assertEquals("maximum(long,long,long) 3 failed", 12345L, NumberUtils.max(12345L - 1L, 12345L - 2L, 12345L)); assertEquals("maximum(long,long,long) 4 failed", 12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L)); assertEquals("maximum(long,long,long) 5 failed", 12345L, NumberUtils.max(12345L, 12345L, 12345L)); } @Test public void testMaximumInt() { assertEquals("maximum(int,int,int) 1 failed", 12345, NumberUtils.max(12345, 12345 - 1, 12345 - 2)); assertEquals("maximum(int,int,int) 2 failed", 12345, NumberUtils.max(12345 - 1, 12345, 12345 - 2)); assertEquals("maximum(int,int,int) 3 failed", 12345, NumberUtils.max(12345 - 1, 12345 - 2, 12345)); assertEquals("maximum(int,int,int) 4 failed", 12345, NumberUtils.max(12345 - 1, 12345, 12345)); assertEquals("maximum(int,int,int) 5 failed", 12345, NumberUtils.max(12345, 12345, 12345)); } @Test public void testMaximumShort() { final short low = 1234; final short mid = 1234 + 1; final short high = 1234 + 2; assertEquals("maximum(short,short,short) 1 failed", high, NumberUtils.max(low, mid, high)); assertEquals("maximum(short,short,short) 1 failed", high, NumberUtils.max(mid, low, high)); assertEquals("maximum(short,short,short) 1 failed", high, NumberUtils.max(mid, high, low)); assertEquals("maximum(short,short,short) 1 failed", high, NumberUtils.max(high, mid, high)); } @Test public void testMaximumByte() { final byte low = 123; final byte mid = 123 + 1; final byte high = 123 + 2; assertEquals("maximum(byte,byte,byte) 1 failed", high, NumberUtils.max(low, mid, high)); assertEquals("maximum(byte,byte,byte) 1 failed", high, NumberUtils.max(mid, low, high)); assertEquals("maximum(byte,byte,byte) 1 failed", high, NumberUtils.max(mid, high, low)); assertEquals("maximum(byte,byte,byte) 1 failed", high, NumberUtils.max(high, mid, high)); } @Test public void testMaximumDouble() { final double low = 12.3; final double mid = 12.3 + 1; final double high = 12.3 + 2; assertEquals(high, NumberUtils.max(low, mid, high), 0.0001); assertEquals(high, NumberUtils.max(mid, low, high), 0.0001); assertEquals(high, NumberUtils.max(mid, high, low), 0.0001); assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001); assertEquals(high, NumberUtils.max(high, mid, high), 0.0001); } @Test public void testMaximumFloat() { final float low = 12.3f; final float mid = 12.3f + 1; final float high = 12.3f + 2; assertEquals(high, NumberUtils.max(low, mid, high), 0.0001f); assertEquals(high, NumberUtils.max(mid, low, high), 0.0001f); assertEquals(high, NumberUtils.max(mid, high, low), 0.0001f); assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001f); assertEquals(high, NumberUtils.max(high, mid, high), 0.0001f); } // Testing JDK against old Lang functionality @Test public void testCompareDouble() { assertTrue(Double.compare(Double.NaN, Double.NaN) == 0); assertTrue(Double.compare(Double.NaN, Double.POSITIVE_INFINITY) == +1); assertTrue(Double.compare(Double.NaN, Double.MAX_VALUE) == +1); assertTrue(Double.compare(Double.NaN, 1.2d) == +1); assertTrue(Double.compare(Double.NaN, 0.0d) == +1); assertTrue(Double.compare(Double.NaN, -0.0d) == +1); assertTrue(Double.compare(Double.NaN, -1.2d) == +1); assertTrue(Double.compare(Double.NaN, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(Double.NaN, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.NaN) == -1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY) == 0); assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, 1.2d) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, 0.0d) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, -0.0d) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, -1.2d) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(Double.MAX_VALUE, Double.NaN) == -1); assertTrue(Double.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(Double.MAX_VALUE, Double.MAX_VALUE) == 0); assertTrue(Double.compare(Double.MAX_VALUE, 1.2d) == +1); assertTrue(Double.compare(Double.MAX_VALUE, 0.0d) == +1); assertTrue(Double.compare(Double.MAX_VALUE, -0.0d) == +1); assertTrue(Double.compare(Double.MAX_VALUE, -1.2d) == +1); assertTrue(Double.compare(Double.MAX_VALUE, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(1.2d, Double.NaN) == -1); assertTrue(Double.compare(1.2d, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(1.2d, Double.MAX_VALUE) == -1); assertTrue(Double.compare(1.2d, 1.2d) == 0); assertTrue(Double.compare(1.2d, 0.0d) == +1); assertTrue(Double.compare(1.2d, -0.0d) == +1); assertTrue(Double.compare(1.2d, -1.2d) == +1); assertTrue(Double.compare(1.2d, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(1.2d, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(0.0d, Double.NaN) == -1); assertTrue(Double.compare(0.0d, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(0.0d, Double.MAX_VALUE) == -1); assertTrue(Double.compare(0.0d, 1.2d) == -1); assertTrue(Double.compare(0.0d, 0.0d) == 0); assertTrue(Double.compare(0.0d, -0.0d) == +1); assertTrue(Double.compare(0.0d, -1.2d) == +1); assertTrue(Double.compare(0.0d, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(0.0d, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(-0.0d, Double.NaN) == -1); assertTrue(Double.compare(-0.0d, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(-0.0d, Double.MAX_VALUE) == -1); assertTrue(Double.compare(-0.0d, 1.2d) == -1); assertTrue(Double.compare(-0.0d, 0.0d) == -1); assertTrue(Double.compare(-0.0d, -0.0d) == 0); assertTrue(Double.compare(-0.0d, -1.2d) == +1); assertTrue(Double.compare(-0.0d, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(-0.0d, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(-1.2d, Double.NaN) == -1); assertTrue(Double.compare(-1.2d, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(-1.2d, Double.MAX_VALUE) == -1); assertTrue(Double.compare(-1.2d, 1.2d) == -1); assertTrue(Double.compare(-1.2d, 0.0d) == -1); assertTrue(Double.compare(-1.2d, -0.0d) == -1); assertTrue(Double.compare(-1.2d, -1.2d) == 0); assertTrue(Double.compare(-1.2d, -Double.MAX_VALUE) == +1); assertTrue(Double.compare(-1.2d, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(-Double.MAX_VALUE, Double.NaN) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, Double.MAX_VALUE) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, 1.2d) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, 0.0d) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, -0.0d) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, -1.2d) == -1); assertTrue(Double.compare(-Double.MAX_VALUE, -Double.MAX_VALUE) == 0); assertTrue(Double.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.NaN) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, 1.2d) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, 0.0d) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, -0.0d) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, -1.2d) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE) == -1); assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) == 0); } @Test public void testCompareFloat() { assertTrue(Float.compare(Float.NaN, Float.NaN) == 0); assertTrue(Float.compare(Float.NaN, Float.POSITIVE_INFINITY) == +1); assertTrue(Float.compare(Float.NaN, Float.MAX_VALUE) == +1); assertTrue(Float.compare(Float.NaN, 1.2f) == +1); assertTrue(Float.compare(Float.NaN, 0.0f) == +1); assertTrue(Float.compare(Float.NaN, -0.0f) == +1); assertTrue(Float.compare(Float.NaN, -1.2f) == +1); assertTrue(Float.compare(Float.NaN, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(Float.NaN, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.NaN) == -1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY) == 0); assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, 1.2f) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, 0.0f) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, -0.0f) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, -1.2f) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(Float.MAX_VALUE, Float.NaN) == -1); assertTrue(Float.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(Float.MAX_VALUE, Float.MAX_VALUE) == 0); assertTrue(Float.compare(Float.MAX_VALUE, 1.2f) == +1); assertTrue(Float.compare(Float.MAX_VALUE, 0.0f) == +1); assertTrue(Float.compare(Float.MAX_VALUE, -0.0f) == +1); assertTrue(Float.compare(Float.MAX_VALUE, -1.2f) == +1); assertTrue(Float.compare(Float.MAX_VALUE, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(1.2f, Float.NaN) == -1); assertTrue(Float.compare(1.2f, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(1.2f, Float.MAX_VALUE) == -1); assertTrue(Float.compare(1.2f, 1.2f) == 0); assertTrue(Float.compare(1.2f, 0.0f) == +1); assertTrue(Float.compare(1.2f, -0.0f) == +1); assertTrue(Float.compare(1.2f, -1.2f) == +1); assertTrue(Float.compare(1.2f, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(1.2f, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(0.0f, Float.NaN) == -1); assertTrue(Float.compare(0.0f, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(0.0f, Float.MAX_VALUE) == -1); assertTrue(Float.compare(0.0f, 1.2f) == -1); assertTrue(Float.compare(0.0f, 0.0f) == 0); assertTrue(Float.compare(0.0f, -0.0f) == +1); assertTrue(Float.compare(0.0f, -1.2f) == +1); assertTrue(Float.compare(0.0f, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(0.0f, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(-0.0f, Float.NaN) == -1); assertTrue(Float.compare(-0.0f, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(-0.0f, Float.MAX_VALUE) == -1); assertTrue(Float.compare(-0.0f, 1.2f) == -1); assertTrue(Float.compare(-0.0f, 0.0f) == -1); assertTrue(Float.compare(-0.0f, -0.0f) == 0); assertTrue(Float.compare(-0.0f, -1.2f) == +1); assertTrue(Float.compare(-0.0f, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(-0.0f, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(-1.2f, Float.NaN) == -1); assertTrue(Float.compare(-1.2f, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(-1.2f, Float.MAX_VALUE) == -1); assertTrue(Float.compare(-1.2f, 1.2f) == -1); assertTrue(Float.compare(-1.2f, 0.0f) == -1); assertTrue(Float.compare(-1.2f, -0.0f) == -1); assertTrue(Float.compare(-1.2f, -1.2f) == 0); assertTrue(Float.compare(-1.2f, -Float.MAX_VALUE) == +1); assertTrue(Float.compare(-1.2f, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(-Float.MAX_VALUE, Float.NaN) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, Float.MAX_VALUE) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, 1.2f) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, 0.0f) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, -0.0f) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, -1.2f) == -1); assertTrue(Float.compare(-Float.MAX_VALUE, -Float.MAX_VALUE) == 0); assertTrue(Float.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.NaN) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, 1.2f) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, 0.0f) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, -0.0f) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, -1.2f) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE) == -1); assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY) == 0); } @Test public void testIsDigits() { assertFalse("isDigits(null) failed", NumberUtils.isDigits(null)); assertFalse("isDigits('') failed", NumberUtils.isDigits("")); assertTrue("isDigits(String) failed", NumberUtils.isDigits("12345")); assertFalse("isDigits(String) neg 1 failed", NumberUtils.isDigits("1234.5")); assertFalse("isDigits(String) neg 3 failed", NumberUtils.isDigits("1ab")); assertFalse("isDigits(String) neg 4 failed", NumberUtils.isDigits("abc")); } /** * Tests isNumber(String) and tests that createNumber(String) returns * a valid number iff isNumber(String) returns false. */ @Test public void testIsNumber() { String val = "12345"; assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val)); val = "1234.5"; assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val)); val = ".12345"; assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val)); val = "1234E5"; assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val)); val = "1234E+5"; assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val)); val = "1234E-5"; assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val)); val = "123.4E5"; assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val)); val = "-1234"; assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val)); val = "-1234.5"; assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val)); val = "-.12345"; assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val)); val = "-1234E5"; assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val)); val = "0"; assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val)); val = "-0"; assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val)); val = "01234"; assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val)); val = "-01234"; assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val)); val = "0xABC123"; assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val)); val = "0x0"; assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val)); val = "123.4E21D"; assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val)); val = "-221.23F"; assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val)); val = "22338L"; assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val)); val = null; assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val)); val = ""; assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val)); val = "--2.3"; assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val)); val = ".12.3"; assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val)); val = "-123E"; assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val)); val = "-123E+-212"; assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val)); val = "-123E2.12"; assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val)); val = "0xGF"; assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val)); val = "0xFAE-1"; assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val)); val = "."; assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val)); val = "-0ABC123"; assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val)); val = "123.4E-D"; assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val)); val = "123.4ED"; assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val)); val = "1234E5l"; assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val)); val = "11a"; assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val)); val = "1a"; assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val)); val = "a"; assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val)); val = "11g"; assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val)); val = "11z"; assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val)); val = "11def"; assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val)); val = "11d11"; assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val)); val = "11 11"; assertTrue("isNumber(String) 22 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 22 Neg failed", !checkCreateNumber(val)); val = " 1111"; assertTrue("isNumber(String) 23 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 23 Neg failed", !checkCreateNumber(val)); val = "1111 "; assertTrue("isNumber(String) 24 Neg failed", !NumberUtils.isNumber(val)); assertTrue("isNumber(String)/createNumber(String) 24 Neg failed", !checkCreateNumber(val)); // LANG-521 val = "2."; assertTrue("isNumber(String) LANG-521 failed", NumberUtils.isNumber(val)); // LANG-664 val = "1.1L"; assertFalse("isNumber(String) LANG-664 failed", NumberUtils.isNumber(val)); } private boolean checkCreateNumber(final String val) { try { final Object obj = NumberUtils.createNumber(val); if (obj == null) { return false; } return true; } catch (final NumberFormatException e) { return false; } } @SuppressWarnings("cast") // suppress instanceof warning check @Test public void testConstants() { assertTrue(NumberUtils.LONG_ZERO instanceof Long); assertTrue(NumberUtils.LONG_ONE instanceof Long); assertTrue(NumberUtils.LONG_MINUS_ONE instanceof Long); assertTrue(NumberUtils.INTEGER_ZERO instanceof Integer); assertTrue(NumberUtils.INTEGER_ONE instanceof Integer); assertTrue(NumberUtils.INTEGER_MINUS_ONE instanceof Integer); assertTrue(NumberUtils.SHORT_ZERO instanceof Short); assertTrue(NumberUtils.SHORT_ONE instanceof Short); assertTrue(NumberUtils.SHORT_MINUS_ONE instanceof Short); assertTrue(NumberUtils.BYTE_ZERO instanceof Byte); assertTrue(NumberUtils.BYTE_ONE instanceof Byte); assertTrue(NumberUtils.BYTE_MINUS_ONE instanceof Byte); assertTrue(NumberUtils.DOUBLE_ZERO instanceof Double); assertTrue(NumberUtils.DOUBLE_ONE instanceof Double); assertTrue(NumberUtils.DOUBLE_MINUS_ONE instanceof Double); assertTrue(NumberUtils.FLOAT_ZERO instanceof Float); assertTrue(NumberUtils.FLOAT_ONE instanceof Float); assertTrue(NumberUtils.FLOAT_MINUS_ONE instanceof Float); assertTrue(NumberUtils.LONG_ZERO.longValue() == 0); assertTrue(NumberUtils.LONG_ONE.longValue() == 1); assertTrue(NumberUtils.LONG_MINUS_ONE.longValue() == -1); assertTrue(NumberUtils.INTEGER_ZERO.intValue() == 0); assertTrue(NumberUtils.INTEGER_ONE.intValue() == 1); assertTrue(NumberUtils.INTEGER_MINUS_ONE.intValue() == -1); assertTrue(NumberUtils.SHORT_ZERO.shortValue() == 0); assertTrue(NumberUtils.SHORT_ONE.shortValue() == 1); assertTrue(NumberUtils.SHORT_MINUS_ONE.shortValue() == -1); assertTrue(NumberUtils.BYTE_ZERO.byteValue() == 0); assertTrue(NumberUtils.BYTE_ONE.byteValue() == 1); assertTrue(NumberUtils.BYTE_MINUS_ONE.byteValue() == -1); assertTrue(NumberUtils.DOUBLE_ZERO.doubleValue() == 0.0d); assertTrue(NumberUtils.DOUBLE_ONE.doubleValue() == 1.0d); assertTrue(NumberUtils.DOUBLE_MINUS_ONE.doubleValue() == -1.0d); assertTrue(NumberUtils.FLOAT_ZERO.floatValue() == 0.0f); assertTrue(NumberUtils.FLOAT_ONE.floatValue() == 1.0f); assertTrue(NumberUtils.FLOAT_MINUS_ONE.floatValue() == -1.0f); } @Test public void testLang300() { NumberUtils.createNumber("-1l"); NumberUtils.createNumber("01l"); NumberUtils.createNumber("1l"); } @Test public void testLang381() { assertTrue(Double.isNaN(NumberUtils.min(1.2, 2.5, Double.NaN))); assertTrue(Double.isNaN(NumberUtils.max(1.2, 2.5, Double.NaN))); assertTrue(Float.isNaN(NumberUtils.min(1.2f, 2.5f, Float.NaN))); assertTrue(Float.isNaN(NumberUtils.max(1.2f, 2.5f, Float.NaN))); final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; assertTrue(Double.isNaN(NumberUtils.max(a))); assertTrue(Double.isNaN(NumberUtils.min(a))); final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN }; assertTrue(Double.isNaN(NumberUtils.max(b))); assertTrue(Double.isNaN(NumberUtils.min(b))); final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; assertTrue(Float.isNaN(NumberUtils.max(aF))); final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN }; assertTrue(Float.isNaN(NumberUtils.max(bF))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @since 2.2 * @see MutableBoolean * @version $Id$ */ public class MutableBooleanTest { @Test public void testCompareTo() { final MutableBoolean mutBool = new MutableBoolean(false); assertEquals(0, mutBool.compareTo(new MutableBoolean(false))); assertEquals(-1, mutBool.compareTo(new MutableBoolean(true))); mutBool.setValue(true); assertEquals(+1, mutBool.compareTo(new MutableBoolean(false))); assertEquals(0, mutBool.compareTo(new MutableBoolean(true))); } @Test(expected=NullPointerException.class) public void testCompareToNull() { final MutableBoolean mutBool = new MutableBoolean(false); mutBool.compareTo(null); } // ---------------------------------------------------------------- @Test public void testConstructors() { assertFalse(new MutableBoolean().booleanValue()); assertTrue(new MutableBoolean(true).booleanValue()); assertFalse(new MutableBoolean(false).booleanValue()); assertTrue(new MutableBoolean(Boolean.TRUE).booleanValue()); assertFalse(new MutableBoolean(Boolean.FALSE).booleanValue()); } @Test(expected=NullPointerException.class) public void testConstructorNull() { new MutableBoolean(null); } @Test public void testEquals() { final MutableBoolean mutBoolA = new MutableBoolean(false); final MutableBoolean mutBoolB = new MutableBoolean(false); final MutableBoolean mutBoolC = new MutableBoolean(true); assertTrue(mutBoolA.equals(mutBoolA)); assertTrue(mutBoolA.equals(mutBoolB)); assertTrue(mutBoolB.equals(mutBoolA)); assertTrue(mutBoolB.equals(mutBoolB)); assertFalse(mutBoolA.equals(mutBoolC)); assertFalse(mutBoolB.equals(mutBoolC)); assertTrue(mutBoolC.equals(mutBoolC)); assertFalse(mutBoolA.equals(null)); assertFalse(mutBoolA.equals(Boolean.FALSE)); assertFalse(mutBoolA.equals("false")); } @Test public void testGetSet() { assertFalse(new MutableBoolean().booleanValue()); assertEquals(Boolean.FALSE, new MutableBoolean().getValue()); final MutableBoolean mutBool = new MutableBoolean(false); assertEquals(Boolean.FALSE, mutBool.toBoolean()); assertFalse(mutBool.booleanValue()); assertTrue(mutBool.isFalse()); assertFalse(mutBool.isTrue()); mutBool.setValue(Boolean.TRUE); assertEquals(Boolean.TRUE, mutBool.toBoolean()); assertTrue(mutBool.booleanValue()); assertFalse(mutBool.isFalse()); assertTrue(mutBool.isTrue()); mutBool.setValue(false); assertFalse(mutBool.booleanValue()); mutBool.setValue(true); assertTrue(mutBool.booleanValue()); } @Test(expected=NullPointerException.class) public void testSetNull() { final MutableBoolean mutBool = new MutableBoolean(false); mutBool.setValue(null); } @Test public void testHashCode() { final MutableBoolean mutBoolA = new MutableBoolean(false); final MutableBoolean mutBoolB = new MutableBoolean(false); final MutableBoolean mutBoolC = new MutableBoolean(true); assertEquals(mutBoolA.hashCode(), mutBoolA.hashCode()); assertEquals(mutBoolA.hashCode(), mutBoolB.hashCode()); assertFalse(mutBoolA.hashCode() == mutBoolC.hashCode()); assertEquals(mutBoolA.hashCode(), Boolean.FALSE.hashCode()); assertEquals(mutBoolC.hashCode(), Boolean.TRUE.hashCode()); } @Test public void testToString() { assertEquals(Boolean.FALSE.toString(), new MutableBoolean(false).toString()); assertEquals(Boolean.TRUE.toString(), new MutableBoolean(true).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableByte */ public class MutableByteTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals((byte) 0, new MutableByte().byteValue()); assertEquals((byte) 1, new MutableByte((byte) 1).byteValue()); assertEquals((byte) 2, new MutableByte(Byte.valueOf((byte) 2)).byteValue()); assertEquals((byte) 3, new MutableByte(new MutableByte((byte) 3)).byteValue()); assertEquals((byte) 2, new MutableByte("2").byteValue()); } @Test(expected=NullPointerException.class) public void testConstructorNull() { new MutableByte((Number)null); } @Test public void testGetSet() { final MutableByte mutNum = new MutableByte((byte) 0); assertEquals((byte) 0, new MutableByte().byteValue()); assertEquals(Byte.valueOf((byte) 0), new MutableByte().getValue()); mutNum.setValue((byte) 1); assertEquals((byte) 1, mutNum.byteValue()); assertEquals(Byte.valueOf((byte) 1), mutNum.getValue()); mutNum.setValue(Byte.valueOf((byte) 2)); assertEquals((byte) 2, mutNum.byteValue()); assertEquals(Byte.valueOf((byte) 2), mutNum.getValue()); mutNum.setValue(new MutableByte((byte) 3)); assertEquals((byte) 3, mutNum.byteValue()); assertEquals(Byte.valueOf((byte) 3), mutNum.getValue()); } @Test(expected=NullPointerException.class) public void testSetNull() { final MutableByte mutNum = new MutableByte((byte) 0); mutNum.setValue(null); } @Test public void testEquals() { final MutableByte mutNumA = new MutableByte((byte) 0); final MutableByte mutNumB = new MutableByte((byte) 0); final MutableByte mutNumC = new MutableByte((byte) 1); assertTrue(mutNumA.equals(mutNumA)); assertTrue(mutNumA.equals(mutNumB)); assertTrue(mutNumB.equals(mutNumA)); assertTrue(mutNumB.equals(mutNumB)); assertFalse(mutNumA.equals(mutNumC)); assertFalse(mutNumB.equals(mutNumC)); assertTrue(mutNumC.equals(mutNumC)); assertFalse(mutNumA.equals(null)); assertFalse(mutNumA.equals(Byte.valueOf((byte) 0))); assertFalse(mutNumA.equals("0")); } @Test public void testHashCode() { final MutableByte mutNumA = new MutableByte((byte) 0); final MutableByte mutNumB = new MutableByte((byte) 0); final MutableByte mutNumC = new MutableByte((byte) 1); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertTrue(mutNumA.hashCode() == Byte.valueOf((byte) 0).hashCode()); } @Test public void testCompareTo() { final MutableByte mutNum = new MutableByte((byte) 0); assertEquals((byte) 0, mutNum.compareTo(new MutableByte((byte) 0))); assertEquals((byte) +1, mutNum.compareTo(new MutableByte((byte) -1))); assertEquals((byte) -1, mutNum.compareTo(new MutableByte((byte) 1))); } @Test(expected=NullPointerException.class) public void testCompareToNull() { final MutableByte mutNum = new MutableByte((byte) 0); mutNum.compareTo(null); } @Test public void testPrimitiveValues() { final MutableByte mutNum = new MutableByte( (byte) 1 ); assertEquals( 1.0F, mutNum.floatValue(), 0 ); assertEquals( 1.0, mutNum.doubleValue(), 0 ); assertEquals( (byte) 1, mutNum.byteValue() ); assertEquals( (short) 1, mutNum.shortValue() ); assertEquals( 1, mutNum.intValue() ); assertEquals( 1L, mutNum.longValue() ); } @Test public void testToByte() { assertEquals(Byte.valueOf((byte) 0), new MutableByte((byte) 0).toByte()); assertEquals(Byte.valueOf((byte) 123), new MutableByte((byte) 123).toByte()); } @Test public void testIncrement() { final MutableByte mutNum = new MutableByte((byte) 1); mutNum.increment(); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testDecrement() { final MutableByte mutNum = new MutableByte((byte) 1); mutNum.decrement(); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testAddValuePrimitive() { final MutableByte mutNum = new MutableByte((byte) 1); mutNum.add((byte)1); assertEquals((byte) 2, mutNum.byteValue()); } @Test public void testAddValueObject() { final MutableByte mutNum = new MutableByte((byte) 1); mutNum.add(Integer.valueOf(1)); assertEquals((byte) 2, mutNum.byteValue()); } @Test public void testSubtractValuePrimitive() { final MutableByte mutNum = new MutableByte((byte) 1); mutNum.subtract((byte) 1); assertEquals((byte) 0, mutNum.byteValue()); } @Test public void testSubtractValueObject() { final MutableByte mutNum = new MutableByte((byte) 1); mutNum.subtract(Integer.valueOf(1)); assertEquals((byte) 0, mutNum.byteValue()); } @Test public void testToString() { assertEquals("0", new MutableByte((byte) 0).toString()); assertEquals("10", new MutableByte((byte) 10).toString()); assertEquals("-123", new MutableByte((byte) -123).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableDouble */ public class MutableDoubleTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); assertEquals(1d, new MutableDouble(1d).doubleValue(), 0.0001d); assertEquals(2d, new MutableDouble(Double.valueOf(2d)).doubleValue(), 0.0001d); assertEquals(3d, new MutableDouble(new MutableDouble(3d)).doubleValue(), 0.0001d); assertEquals(2d, new MutableDouble("2.0").doubleValue(), 0.0001d); } @Test(expected=NullPointerException.class) public void testConstructorNull() { new MutableDouble((Number)null); } @Test public void testGetSet() { final MutableDouble mutNum = new MutableDouble(0d); assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d); assertEquals(Double.valueOf(0), new MutableDouble().getValue()); mutNum.setValue(1); assertEquals(1d, mutNum.doubleValue(), 0.0001d); assertEquals(Double.valueOf(1d), mutNum.getValue()); mutNum.setValue(Double.valueOf(2d)); assertEquals(2d, mutNum.doubleValue(), 0.0001d); assertEquals(Double.valueOf(2d), mutNum.getValue()); mutNum.setValue(new MutableDouble(3d)); assertEquals(3d, mutNum.doubleValue(), 0.0001d); assertEquals(Double.valueOf(3d), mutNum.getValue()); } @Test(expected=NullPointerException.class) public void testSetNull() { final MutableDouble mutNum = new MutableDouble(0d); mutNum.setValue(null); } @Test public void testNanInfinite() { MutableDouble mutNum = new MutableDouble(Double.NaN); assertTrue(mutNum.isNaN()); mutNum = new MutableDouble(Double.POSITIVE_INFINITY); assertTrue(mutNum.isInfinite()); mutNum = new MutableDouble(Double.NEGATIVE_INFINITY); assertTrue(mutNum.isInfinite()); } @Test public void testEquals() { final MutableDouble mutNumA = new MutableDouble(0d); final MutableDouble mutNumB = new MutableDouble(0d); final MutableDouble mutNumC = new MutableDouble(1d); assertTrue(mutNumA.equals(mutNumA)); assertTrue(mutNumA.equals(mutNumB)); assertTrue(mutNumB.equals(mutNumA)); assertTrue(mutNumB.equals(mutNumB)); assertFalse(mutNumA.equals(mutNumC)); assertFalse(mutNumB.equals(mutNumC)); assertTrue(mutNumC.equals(mutNumC)); assertFalse(mutNumA.equals(null)); assertFalse(mutNumA.equals(Double.valueOf(0d))); assertFalse(mutNumA.equals("0")); } @Test public void testHashCode() { final MutableDouble mutNumA = new MutableDouble(0d); final MutableDouble mutNumB = new MutableDouble(0d); final MutableDouble mutNumC = new MutableDouble(1d); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertTrue(mutNumA.hashCode() == Double.valueOf(0d).hashCode()); } @Test public void testCompareTo() { final MutableDouble mutNum = new MutableDouble(0d); assertEquals(0, mutNum.compareTo(new MutableDouble(0d))); assertEquals(+1, mutNum.compareTo(new MutableDouble(-1d))); assertEquals(-1, mutNum.compareTo(new MutableDouble(1d))); } @Test(expected=NullPointerException.class) public void testCompareToNull() { final MutableDouble mutNum = new MutableDouble(0d); mutNum.compareTo(null); } @Test public void testPrimitiveValues() { final MutableDouble mutNum = new MutableDouble(1.7); assertEquals( 1.7F, mutNum.floatValue(), 0 ); assertEquals( 1.7, mutNum.doubleValue(), 0 ); assertEquals( (byte) 1, mutNum.byteValue() ); assertEquals( (short) 1, mutNum.shortValue() ); assertEquals( 1, mutNum.intValue() ); assertEquals( 1L, mutNum.longValue() ); } @Test public void testToDouble() { assertEquals(Double.valueOf(0d), new MutableDouble(0d).toDouble()); assertEquals(Double.valueOf(12.3d), new MutableDouble(12.3d).toDouble()); } @Test public void testIncrement() { final MutableDouble mutNum = new MutableDouble(1); mutNum.increment(); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testDecrement() { final MutableDouble mutNum = new MutableDouble(1); mutNum.decrement(); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testAddValuePrimitive() { final MutableDouble mutNum = new MutableDouble(1); mutNum.add(1.1d); assertEquals(2.1d, mutNum.doubleValue(), 0.01d); } @Test public void testAddValueObject() { final MutableDouble mutNum = new MutableDouble(1); mutNum.add(Double.valueOf(1.1d)); assertEquals(2.1d, mutNum.doubleValue(), 0.01d); } @Test public void testSubtractValuePrimitive() { final MutableDouble mutNum = new MutableDouble(1); mutNum.subtract(0.9d); assertEquals(0.1d, mutNum.doubleValue(), 0.01d); } @Test public void testSubtractValueObject() { final MutableDouble mutNum = new MutableDouble(1); mutNum.subtract(Double.valueOf(0.9d)); assertEquals(0.1d, mutNum.doubleValue(), 0.01d); } @Test public void testToString() { assertEquals("0.0", new MutableDouble(0d).toString()); assertEquals("10.0", new MutableDouble(10d).toString()); assertEquals("-123.0", new MutableDouble(-123d).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableFloat */ public class MutableFloatTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals(0f, new MutableFloat().floatValue(), 0.0001f); assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f); assertEquals(2f, new MutableFloat(Float.valueOf(2f)).floatValue(), 0.0001f); assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f); assertEquals(2f, new MutableFloat("2.0").floatValue(), 0.0001f); } @Test(expected=NullPointerException.class) public void testConstructorNull() { new MutableFloat((Number)null); } @Test public void testGetSet() { final MutableFloat mutNum = new MutableFloat(0f); assertEquals(0f, new MutableFloat().floatValue(), 0.0001f); assertEquals(Float.valueOf(0), new MutableFloat().getValue()); mutNum.setValue(1); assertEquals(1f, mutNum.floatValue(), 0.0001f); assertEquals(Float.valueOf(1f), mutNum.getValue()); mutNum.setValue(Float.valueOf(2f)); assertEquals(2f, mutNum.floatValue(), 0.0001f); assertEquals(Float.valueOf(2f), mutNum.getValue()); mutNum.setValue(new MutableFloat(3f)); assertEquals(3f, mutNum.floatValue(), 0.0001f); assertEquals(Float.valueOf(3f), mutNum.getValue()); } @Test(expected=NullPointerException.class) public void testSetNull() { final MutableFloat mutNum = new MutableFloat(0f); mutNum.setValue(null); } @Test public void testNanInfinite() { MutableFloat mutNum = new MutableFloat(Float.NaN); assertTrue(mutNum.isNaN()); mutNum = new MutableFloat(Float.POSITIVE_INFINITY); assertTrue(mutNum.isInfinite()); mutNum = new MutableFloat(Float.NEGATIVE_INFINITY); assertTrue(mutNum.isInfinite()); } @Test public void testEquals() { final MutableFloat mutNumA = new MutableFloat(0f); final MutableFloat mutNumB = new MutableFloat(0f); final MutableFloat mutNumC = new MutableFloat(1f); assertTrue(mutNumA.equals(mutNumA)); assertTrue(mutNumA.equals(mutNumB)); assertTrue(mutNumB.equals(mutNumA)); assertTrue(mutNumB.equals(mutNumB)); assertFalse(mutNumA.equals(mutNumC)); assertFalse(mutNumB.equals(mutNumC)); assertTrue(mutNumC.equals(mutNumC)); assertFalse(mutNumA.equals(null)); assertFalse(mutNumA.equals(Float.valueOf(0f))); assertFalse(mutNumA.equals("0")); } @Test public void testHashCode() { final MutableFloat mutNumA = new MutableFloat(0f); final MutableFloat mutNumB = new MutableFloat(0f); final MutableFloat mutNumC = new MutableFloat(1f); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertTrue(mutNumA.hashCode() == Float.valueOf(0f).hashCode()); } @Test public void testCompareTo() { final MutableFloat mutNum = new MutableFloat(0f); assertEquals(0, mutNum.compareTo(new MutableFloat(0f))); assertEquals(+1, mutNum.compareTo(new MutableFloat(-1f))); assertEquals(-1, mutNum.compareTo(new MutableFloat(1f))); } @Test(expected=NullPointerException.class) public void testCompareToNull() { final MutableFloat mutNum = new MutableFloat(0f); mutNum.compareTo(null); } @Test public void testPrimitiveValues() { final MutableFloat mutNum = new MutableFloat(1.7F); assertEquals( 1, mutNum.intValue() ); assertEquals( 1.7, mutNum.doubleValue(), 0.00001 ); assertEquals( (byte) 1, mutNum.byteValue() ); assertEquals( (short) 1, mutNum.shortValue() ); assertEquals( 1, mutNum.intValue() ); assertEquals( 1L, mutNum.longValue() ); } @Test public void testToFloat() { assertEquals(Float.valueOf(0f), new MutableFloat(0f).toFloat()); assertEquals(Float.valueOf(12.3f), new MutableFloat(12.3f).toFloat()); } @Test public void testIncrement() { final MutableFloat mutNum = new MutableFloat(1); mutNum.increment(); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testDecrement() { final MutableFloat mutNum = new MutableFloat(1); mutNum.decrement(); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testAddValuePrimitive() { final MutableFloat mutNum = new MutableFloat(1); mutNum.add(1.1f); assertEquals(2.1f, mutNum.floatValue(), 0.01f); } @Test public void testAddValueObject() { final MutableFloat mutNum = new MutableFloat(1); mutNum.add(Float.valueOf(1.1f)); assertEquals(2.1f, mutNum.floatValue(), 0.01f); } @Test public void testSubtractValuePrimitive() { final MutableFloat mutNum = new MutableFloat(1); mutNum.subtract(0.9f); assertEquals(0.1f, mutNum.floatValue(), 0.01f); } @Test public void testSubtractValueObject() { final MutableFloat mutNum = new MutableFloat(1); mutNum.subtract(Float.valueOf(0.9f)); assertEquals(0.1f, mutNum.floatValue(), 0.01f); } @Test public void testToString() { assertEquals("0.0", new MutableFloat(0f).toString()); assertEquals("10.0", new MutableFloat(10f).toString()); assertEquals("-123.0", new MutableFloat(-123f).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableInt */ public class MutableIntTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals(0, new MutableInt().intValue()); assertEquals(1, new MutableInt(1).intValue()); assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue()); assertEquals(3, new MutableInt(new MutableLong(3)).intValue()); assertEquals(2, new MutableInt("2").intValue()); } @Test(expected=NullPointerException.class) public void testConstructorNull() { new MutableInt((Number)null); } @Test public void testGetSet() { final MutableInt mutNum = new MutableInt(0); assertEquals(0, new MutableInt().intValue()); assertEquals(Integer.valueOf(0), new MutableInt().getValue()); mutNum.setValue(1); assertEquals(1, mutNum.intValue()); assertEquals(Integer.valueOf(1), mutNum.getValue()); mutNum.setValue(Integer.valueOf(2)); assertEquals(2, mutNum.intValue()); assertEquals(Integer.valueOf(2), mutNum.getValue()); mutNum.setValue(new MutableLong(3)); assertEquals(3, mutNum.intValue()); assertEquals(Integer.valueOf(3), mutNum.getValue()); } @Test(expected=NullPointerException.class) public void testSetNull() { final MutableInt mutNum = new MutableInt(0); mutNum.setValue(null); } @Test public void testEquals() { this.testEquals(new MutableInt(0), new MutableInt(0), new MutableInt(1)); // Should Numbers be supported? GaryG July-21-2005. //this.testEquals(mutNumA, Integer.valueOf(0), mutNumC); } /** * @param numA must not be a 0 Integer; must not equal numC. * @param numB must equal numA; must not equal numC. * @param numC must not equal numA; must not equal numC. */ void testEquals(final Number numA, final Number numB, final Number numC) { assertTrue(numA.equals(numA)); assertTrue(numA.equals(numB)); assertTrue(numB.equals(numA)); assertTrue(numB.equals(numB)); assertFalse(numA.equals(numC)); assertFalse(numB.equals(numC)); assertTrue(numC.equals(numC)); assertFalse(numA.equals(null)); assertFalse(numA.equals(Integer.valueOf(0))); assertFalse(numA.equals("0")); } @Test public void testHashCode() { final MutableInt mutNumA = new MutableInt(0); final MutableInt mutNumB = new MutableInt(0); final MutableInt mutNumC = new MutableInt(1); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertTrue(mutNumA.hashCode() == Integer.valueOf(0).hashCode()); } @Test public void testCompareTo() { final MutableInt mutNum = new MutableInt(0); assertEquals(0, mutNum.compareTo(new MutableInt(0))); assertEquals(+1, mutNum.compareTo(new MutableInt(-1))); assertEquals(-1, mutNum.compareTo(new MutableInt(1))); } @Test(expected=NullPointerException.class) public void testCompareToNull() { final MutableInt mutNum = new MutableInt(0); mutNum.compareTo(null); } @Test public void testPrimitiveValues() { final MutableInt mutNum = new MutableInt(1); assertEquals( (byte) 1, mutNum.byteValue() ); assertEquals( (short) 1, mutNum.shortValue() ); assertEquals( 1.0F, mutNum.floatValue(), 0 ); assertEquals( 1.0, mutNum.doubleValue(), 0 ); assertEquals( 1L, mutNum.longValue() ); } @Test public void testToInteger() { assertEquals(Integer.valueOf(0), new MutableInt(0).toInteger()); assertEquals(Integer.valueOf(123), new MutableInt(123).toInteger()); } @Test public void testIncrement() { final MutableInt mutNum = new MutableInt(1); mutNum.increment(); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testDecrement() { final MutableInt mutNum = new MutableInt(1); mutNum.decrement(); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testAddValuePrimitive() { final MutableInt mutNum = new MutableInt(1); mutNum.add(1); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testAddValueObject() { final MutableInt mutNum = new MutableInt(1); mutNum.add(Integer.valueOf(1)); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testSubtractValuePrimitive() { final MutableInt mutNum = new MutableInt(1); mutNum.subtract(1); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testSubtractValueObject() { final MutableInt mutNum = new MutableInt(1); mutNum.subtract(Integer.valueOf(1)); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testToString() { assertEquals("0", new MutableInt(0).toString()); assertEquals("10", new MutableInt(10).toString()); assertEquals("-123", new MutableInt(-123).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableLong */ public class MutableLongTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals(0, new MutableLong().longValue()); assertEquals(1, new MutableLong(1).longValue()); assertEquals(2, new MutableLong(Long.valueOf(2)).longValue()); assertEquals(3, new MutableLong(new MutableLong(3)).longValue()); assertEquals(2, new MutableLong("2").longValue()); } @Test(expected=NullPointerException.class) public void testConstructorNull() { new MutableLong((Number)null); } @Test public void testGetSet() { final MutableLong mutNum = new MutableLong(0); assertEquals(0, new MutableLong().longValue()); assertEquals(Long.valueOf(0), new MutableLong().getValue()); mutNum.setValue(1); assertEquals(1, mutNum.longValue()); assertEquals(Long.valueOf(1), mutNum.getValue()); mutNum.setValue(Long.valueOf(2)); assertEquals(2, mutNum.longValue()); assertEquals(Long.valueOf(2), mutNum.getValue()); mutNum.setValue(new MutableLong(3)); assertEquals(3, mutNum.longValue()); assertEquals(Long.valueOf(3), mutNum.getValue()); } @Test(expected=NullPointerException.class) public void testSetNull() { final MutableLong mutNum = new MutableLong(0); mutNum.setValue(null); } @Test public void testEquals() { final MutableLong mutNumA = new MutableLong(0); final MutableLong mutNumB = new MutableLong(0); final MutableLong mutNumC = new MutableLong(1); assertTrue(mutNumA.equals(mutNumA)); assertTrue(mutNumA.equals(mutNumB)); assertTrue(mutNumB.equals(mutNumA)); assertTrue(mutNumB.equals(mutNumB)); assertFalse(mutNumA.equals(mutNumC)); assertFalse(mutNumB.equals(mutNumC)); assertTrue(mutNumC.equals(mutNumC)); assertFalse(mutNumA.equals(null)); assertFalse(mutNumA.equals(Long.valueOf(0))); assertFalse(mutNumA.equals("0")); } @Test public void testHashCode() { final MutableLong mutNumA = new MutableLong(0); final MutableLong mutNumB = new MutableLong(0); final MutableLong mutNumC = new MutableLong(1); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertTrue(mutNumA.hashCode() == Long.valueOf(0).hashCode()); } @Test public void testCompareTo() { final MutableLong mutNum = new MutableLong(0); assertEquals(0, mutNum.compareTo(new MutableLong(0))); assertEquals(+1, mutNum.compareTo(new MutableLong(-1))); assertEquals(-1, mutNum.compareTo(new MutableLong(1))); } @Test(expected=NullPointerException.class) public void testCompareToNull() { final MutableLong mutNum = new MutableLong(0); mutNum.compareTo(null); } @Test public void testPrimitiveValues() { final MutableLong mutNum = new MutableLong(1L); assertEquals( 1.0F, mutNum.floatValue(), 0 ); assertEquals( 1.0, mutNum.doubleValue(), 0 ); assertEquals( (byte) 1, mutNum.byteValue() ); assertEquals( (short) 1, mutNum.shortValue() ); assertEquals( 1, mutNum.intValue() ); assertEquals( 1L, mutNum.longValue() ); } @Test public void testToLong() { assertEquals(Long.valueOf(0L), new MutableLong(0L).toLong()); assertEquals(Long.valueOf(123L), new MutableLong(123L).toLong()); } @Test public void testIncrement() { final MutableLong mutNum = new MutableLong(1); mutNum.increment(); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testDecrement() { final MutableLong mutNum = new MutableLong(1); mutNum.decrement(); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testAddValuePrimitive() { final MutableLong mutNum = new MutableLong(1); mutNum.add(1); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testAddValueObject() { final MutableLong mutNum = new MutableLong(1); mutNum.add(Long.valueOf(1)); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testSubtractValuePrimitive() { final MutableLong mutNum = new MutableLong(1); mutNum.subtract(1); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testSubtractValueObject() { final MutableLong mutNum = new MutableLong(1); mutNum.subtract(Long.valueOf(1)); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testToString() { assertEquals("0", new MutableLong(0).toString()); assertEquals("10", new MutableLong(10).toString()); assertEquals("-123", new MutableLong(-123).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableShort */ public class MutableObjectTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals(null, new MutableObject<String>().getValue()); final Integer i = Integer.valueOf(6); assertSame(i, new MutableObject<Integer>(i).getValue()); assertSame("HI", new MutableObject<String>("HI").getValue()); assertSame(null, new MutableObject<Object>(null).getValue()); } @Test public void testGetSet() { final MutableObject<String> mutNum = new MutableObject<String>(); assertEquals(null, new MutableObject<Object>().getValue()); mutNum.setValue("HELLO"); assertSame("HELLO", mutNum.getValue()); mutNum.setValue(null); assertSame(null, mutNum.getValue()); } @Test public void testEquals() { final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); final MutableObject<String> mutNumC = new MutableObject<String>("BETA"); final MutableObject<String> mutNumD = new MutableObject<String>(null); assertTrue(mutNumA.equals(mutNumA)); assertTrue(mutNumA.equals(mutNumB)); assertTrue(mutNumB.equals(mutNumA)); assertTrue(mutNumB.equals(mutNumB)); assertFalse(mutNumA.equals(mutNumC)); assertFalse(mutNumB.equals(mutNumC)); assertTrue(mutNumC.equals(mutNumC)); assertFalse(mutNumA.equals(mutNumD)); assertTrue(mutNumD.equals(mutNumD)); assertFalse(mutNumA.equals(null)); assertFalse(mutNumA.equals(new Object())); assertFalse(mutNumA.equals("0")); } @Test public void testHashCode() { final MutableObject<String> mutNumA = new MutableObject<String>("ALPHA"); final MutableObject<String> mutNumB = new MutableObject<String>("ALPHA"); final MutableObject<String> mutNumC = new MutableObject<String>("BETA"); final MutableObject<String> mutNumD = new MutableObject<String>(null); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertFalse(mutNumA.hashCode() == mutNumD.hashCode()); assertTrue(mutNumA.hashCode() == "ALPHA".hashCode()); assertEquals(0, mutNumD.hashCode()); } @Test public void testToString() { assertEquals("HI", new MutableObject<String>("HI").toString()); assertEquals("10.0", new MutableObject<Double>(Double.valueOf(10)).toString()); assertEquals("null", new MutableObject<Object>(null).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.mutable; import org.junit.Test; import static org.junit.Assert.*; /** * JUnit tests. * * @version $Id$ * @see MutableShort */ public class MutableShortTest { // ---------------------------------------------------------------- @Test public void testConstructors() { assertEquals((short) 0, new MutableShort().shortValue()); assertEquals((short) 1, new MutableShort((short) 1).shortValue()); assertEquals((short) 2, new MutableShort(Short.valueOf((short) 2)).shortValue()); assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue()); assertEquals((short) 2, new MutableShort("2").shortValue()); try { new MutableShort((Number)null); fail(); } catch (final NullPointerException ex) {} } @Test public void testGetSet() { final MutableShort mutNum = new MutableShort((short) 0); assertEquals((short) 0, new MutableShort().shortValue()); assertEquals(Short.valueOf((short) 0), new MutableShort().getValue()); mutNum.setValue((short) 1); assertEquals((short) 1, mutNum.shortValue()); assertEquals(Short.valueOf((short) 1), mutNum.getValue()); mutNum.setValue(Short.valueOf((short) 2)); assertEquals((short) 2, mutNum.shortValue()); assertEquals(Short.valueOf((short) 2), mutNum.getValue()); mutNum.setValue(new MutableShort((short) 3)); assertEquals((short) 3, mutNum.shortValue()); assertEquals(Short.valueOf((short) 3), mutNum.getValue()); try { mutNum.setValue(null); fail(); } catch (final NullPointerException ex) {} } @Test public void testEquals() { final MutableShort mutNumA = new MutableShort((short) 0); final MutableShort mutNumB = new MutableShort((short) 0); final MutableShort mutNumC = new MutableShort((short) 1); assertTrue(mutNumA.equals(mutNumA)); assertTrue(mutNumA.equals(mutNumB)); assertTrue(mutNumB.equals(mutNumA)); assertTrue(mutNumB.equals(mutNumB)); assertFalse(mutNumA.equals(mutNumC)); assertFalse(mutNumB.equals(mutNumC)); assertTrue(mutNumC.equals(mutNumC)); assertFalse(mutNumA.equals(null)); assertFalse(mutNumA.equals(Short.valueOf((short) 0))); assertFalse(mutNumA.equals("0")); } @Test public void testHashCode() { final MutableShort mutNumA = new MutableShort((short) 0); final MutableShort mutNumB = new MutableShort((short) 0); final MutableShort mutNumC = new MutableShort((short) 1); assertTrue(mutNumA.hashCode() == mutNumA.hashCode()); assertTrue(mutNumA.hashCode() == mutNumB.hashCode()); assertFalse(mutNumA.hashCode() == mutNumC.hashCode()); assertTrue(mutNumA.hashCode() == Short.valueOf((short) 0).hashCode()); } @Test public void testCompareTo() { final MutableShort mutNum = new MutableShort((short) 0); assertEquals((short) 0, mutNum.compareTo(new MutableShort((short) 0))); assertEquals((short) +1, mutNum.compareTo(new MutableShort((short) -1))); assertEquals((short) -1, mutNum.compareTo(new MutableShort((short) 1))); try { mutNum.compareTo(null); fail(); } catch (final NullPointerException ex) {} } @Test public void testPrimitiveValues() { final MutableShort mutNum = new MutableShort( (short) 1 ); assertEquals( 1.0F, mutNum.floatValue(), 0 ); assertEquals( 1.0, mutNum.doubleValue(), 0 ); assertEquals( (byte) 1, mutNum.byteValue() ); assertEquals( (short) 1, mutNum.shortValue() ); assertEquals( 1, mutNum.intValue() ); assertEquals( 1L, mutNum.longValue() ); } @Test public void testToShort() { assertEquals(Short.valueOf((short) 0), new MutableShort((short) 0).toShort()); assertEquals(Short.valueOf((short) 123), new MutableShort((short) 123).toShort()); } @Test public void testIncrement() { final MutableShort mutNum = new MutableShort((short) 1); mutNum.increment(); assertEquals(2, mutNum.intValue()); assertEquals(2L, mutNum.longValue()); } @Test public void testDecrement() { final MutableShort mutNum = new MutableShort((short) 1); mutNum.decrement(); assertEquals(0, mutNum.intValue()); assertEquals(0L, mutNum.longValue()); } @Test public void testAddValuePrimitive() { final MutableShort mutNum = new MutableShort((short) 1); mutNum.add((short) 1); assertEquals((short) 2, mutNum.shortValue()); } @Test public void testAddValueObject() { final MutableShort mutNum = new MutableShort((short) 1); mutNum.add(Short.valueOf((short) 1)); assertEquals((short) 2, mutNum.shortValue()); } @Test public void testSubtractValuePrimitive() { final MutableShort mutNum = new MutableShort((short) 1); mutNum.subtract((short) 1); assertEquals((short) 0, mutNum.shortValue()); } @Test public void testSubtractValueObject() { final MutableShort mutNum = new MutableShort((short) 1); mutNum.subtract(Short.valueOf((short) 1)); assertEquals((short) 0, mutNum.shortValue()); } @Test public void testToString() { assertEquals("0", new MutableShort((short) 0).toString()); assertEquals("10", new MutableShort((short) 10).toString()); assertEquals("-123", new MutableShort((short) -123).toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.reflect; import org.junit.Test; import org.junit.Before; import static org.junit.Assert.*; import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.math.NumberUtils; import org.apache.commons.lang3.mutable.MutableObject; /** * Unit tests ConstructorUtils * @version $Id$ */ public class ConstructorUtilsTest { public static class TestBean { private final String toString; public TestBean() { toString = "()"; } public TestBean(final int i) { toString = "(int)"; } public TestBean(final Integer i) { toString = "(Integer)"; } public TestBean(final double d) { toString = "(double)"; } public TestBean(final String s) { toString = "(String)"; } public TestBean(final Object o) { toString = "(Object)"; } @Override public String toString() { return toString; } } private static class PrivateClass { @SuppressWarnings("unused") public PrivateClass() { } } private final Map<Class<?>, Class<?>[]> classCache; public ConstructorUtilsTest() { classCache = new HashMap<Class<?>, Class<?>[]>(); } @Before public void setUp() throws Exception { classCache.clear(); } @Test public void testConstructor() throws Exception { assertNotNull(MethodUtils.class.newInstance()); } @Test public void testInvokeConstructor() throws Exception { assertEquals("()", ConstructorUtils.invokeConstructor(TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); assertEquals("()", ConstructorUtils.invokeConstructor(TestBean.class, (Object[]) null).toString()); assertEquals("()", ConstructorUtils.invokeConstructor(TestBean.class).toString()); assertEquals("(String)", ConstructorUtils.invokeConstructor( TestBean.class, "").toString()); assertEquals("(Object)", ConstructorUtils.invokeConstructor( TestBean.class, new Object()).toString()); assertEquals("(Object)", ConstructorUtils.invokeConstructor( TestBean.class, Boolean.TRUE).toString()); assertEquals("(Integer)", ConstructorUtils.invokeConstructor( TestBean.class, NumberUtils.INTEGER_ONE).toString()); assertEquals("(int)", ConstructorUtils.invokeConstructor( TestBean.class, NumberUtils.BYTE_ONE).toString()); assertEquals("(double)", ConstructorUtils.invokeConstructor( TestBean.class, NumberUtils.LONG_ONE).toString()); assertEquals("(double)", ConstructorUtils.invokeConstructor( TestBean.class, NumberUtils.DOUBLE_ONE).toString()); } @Test public void testInvokeExactConstructor() throws Exception { assertEquals("()", ConstructorUtils.invokeExactConstructor( TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString()); assertEquals("()", ConstructorUtils.invokeExactConstructor( TestBean.class, (Object[]) null).toString()); assertEquals("(String)", ConstructorUtils.invokeExactConstructor( TestBean.class, "").toString()); assertEquals("(Object)", ConstructorUtils.invokeExactConstructor( TestBean.class, new Object()).toString()); assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor( TestBean.class, NumberUtils.INTEGER_ONE).toString()); assertEquals("(double)", ConstructorUtils.invokeExactConstructor( TestBean.class, new Object[] { NumberUtils.DOUBLE_ONE }, new Class[] { Double.TYPE }).toString()); try { ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } try { ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } try { ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } } @Test public void testGetAccessibleConstructor() throws Exception { assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY))); assertNull(ConstructorUtils.getAccessibleConstructor(PrivateClass.class .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY))); } @Test public void testGetAccessibleConstructorFromDescription() throws Exception { assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class, ArrayUtils.EMPTY_CLASS_ARRAY)); assertNull(ConstructorUtils.getAccessibleConstructor( PrivateClass.class, ArrayUtils.EMPTY_CLASS_ARRAY)); } @Test public void testGetMatchingAccessibleMethod() throws Exception { expectMatchingAccessibleConstructorParameterTypes(TestBean.class, ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null, ArrayUtils.EMPTY_CLASS_ARRAY); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(String.class), singletonArray(String.class)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Object.class), singletonArray(Object.class)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Boolean.class), singletonArray(Object.class)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Byte.class), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Short.class), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Short.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Character.class), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Character.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Integer.class), singletonArray(Integer.class)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Integer.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Long.class), singletonArray(Double.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Long.TYPE), singletonArray(Double.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Float.class), singletonArray(Double.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Float.TYPE), singletonArray(Double.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Double.class), singletonArray(Double.TYPE)); expectMatchingAccessibleConstructorParameterTypes(TestBean.class, singletonArray(Double.TYPE), singletonArray(Double.TYPE)); } @Test public void testNullArgument() { expectMatchingAccessibleConstructorParameterTypes(MutableObject.class, singletonArray(null), singletonArray(Object.class)); } private void expectMatchingAccessibleConstructorParameterTypes(final Class<?> cls, final Class<?>[] requestTypes, final Class<?>[] actualTypes) { final Constructor<?> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, requestTypes); assertTrue(toString(c.getParameterTypes()) + " not equals " + toString(actualTypes), Arrays.equals(actualTypes, c .getParameterTypes())); } private String toString(final Class<?>[] c) { return Arrays.asList(c).toString(); } private Class<?>[] singletonArray(final Class<?> c) { Class<?>[] result = classCache.get(c); if (result == null) { result = new Class[] { c }; classCache.put(c, result); } return result; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.reflect; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeNotNull; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.List; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.reflect.testbed.Ambig; import org.apache.commons.lang3.reflect.testbed.Foo; import org.apache.commons.lang3.reflect.testbed.PrivatelyShadowedChild; import org.apache.commons.lang3.reflect.testbed.PublicChild; import org.apache.commons.lang3.reflect.testbed.PubliclyShadowedChild; import org.apache.commons.lang3.reflect.testbed.StaticContainer; import org.apache.commons.lang3.reflect.testbed.StaticContainerChild; import org.junit.Before; import org.junit.Test; /** * Unit tests FieldUtils * * @version $Id$ */ public class FieldUtilsTest { static final String S = "s"; static final String SS = "ss"; static final Integer I0 = Integer.valueOf(0); static final Integer I1 = Integer.valueOf(1); static final Double D0 = Double.valueOf(0.0); static final Double D1 = Double.valueOf(1.0); private PublicChild publicChild; private PubliclyShadowedChild publiclyShadowedChild; private PrivatelyShadowedChild privatelyShadowedChild; private final Class<?> parentClass = PublicChild.class.getSuperclass(); @Before public void setUp() { StaticContainer.reset(); publicChild = new PublicChild(); publiclyShadowedChild = new PubliclyShadowedChild(); privatelyShadowedChild = new PrivatelyShadowedChild(); } @Test public void testConstructor() { assertNotNull(new FieldUtils()); final Constructor<?>[] cons = FieldUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(FieldUtils.class.getModifiers())); assertFalse(Modifier.isFinal(FieldUtils.class.getModifiers())); } @Test public void testGetField() { assertEquals(Foo.class, FieldUtils.getField(PublicChild.class, "VALUE").getDeclaringClass()); assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s").getDeclaringClass()); assertNull(FieldUtils.getField(PublicChild.class, "b")); assertNull(FieldUtils.getField(PublicChild.class, "i")); assertNull(FieldUtils.getField(PublicChild.class, "d")); assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d").getDeclaringClass()); assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE").getDeclaringClass()); assertEquals(parentClass, FieldUtils.getField(PrivatelyShadowedChild.class, "s").getDeclaringClass()); assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, "b")); assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, "i")); assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, "d")); } @Test(expected = IllegalArgumentException.class) public void testGetFieldIllegalArgumentException1() { FieldUtils.getField(null, "none"); } @Test(expected = IllegalArgumentException.class) public void testGetFieldIllegalArgumentException2() { FieldUtils.getField(PublicChild.class, null); } @Test public void testGetFieldForceAccess() { assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, "VALUE", true).getDeclaringClass()); assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "s", true).getDeclaringClass()); assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "b", true).getDeclaringClass()); assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "i", true).getDeclaringClass()); assertEquals(parentClass, FieldUtils.getField(PublicChild.class, "d", true).getDeclaringClass()); assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, "VALUE", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, "VALUE", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); } @Test(expected = IllegalArgumentException.class) public void testGetFieldForceAccessIllegalArgumentException1() { FieldUtils.getField(null, "none", true); } @Test(expected = IllegalArgumentException.class) public void testGetFieldForceAccessIllegalArgumentException2() { FieldUtils.getField(PublicChild.class, null, true); } @Test public void testGetAllFields() { assertArrayEquals(new Field[0], FieldUtils.getAllFields(Object.class)); final Field[] fieldsNumber = Number.class.getDeclaredFields(); assertArrayEquals(fieldsNumber, FieldUtils.getAllFields(Number.class)); final Field[] fieldsInteger = Integer.class.getDeclaredFields(); assertArrayEquals(ArrayUtils.addAll(fieldsInteger, fieldsNumber), FieldUtils.getAllFields(Integer.class)); assertEquals(5, FieldUtils.getAllFields(PublicChild.class).length); } private <T> List<T> asArrayList(T... values) { final ArrayList<T> arrayList = new ArrayList<T>(); for (T t : values) { arrayList.add(t); } return arrayList; } @Test public void testGetAllFieldsList() { assertEquals(0, FieldUtils.getAllFieldsList(Object.class).size()); final List<Field> fieldsNumber = asArrayList(Number.class.getDeclaredFields()); assertEquals(fieldsNumber, FieldUtils.getAllFieldsList(Number.class)); final List<Field> fieldsInteger = asArrayList(Integer.class.getDeclaredFields()); final List<Field> allFieldsInteger = new ArrayList<Field>(fieldsInteger); allFieldsInteger.addAll(fieldsNumber); assertEquals(allFieldsInteger, FieldUtils.getAllFieldsList(Integer.class)); assertEquals(5, FieldUtils.getAllFieldsList(PublicChild.class).size()); } @Test public void testGetDeclaredField() { assertNull(FieldUtils.getDeclaredField(PublicChild.class, "VALUE")); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s")); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b")); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i")); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d")); assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE")); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i").getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d").getDeclaringClass()); assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE")); assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s")); assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b")); assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i")); assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d")); } @Test(expected = IllegalArgumentException.class) public void testGetDeclaredFieldAccessIllegalArgumentException1() { FieldUtils.getDeclaredField(null, "none"); } @Test(expected = IllegalArgumentException.class) public void testGetDeclaredFieldAccessIllegalArgumentException2() { FieldUtils.getDeclaredField(PublicChild.class, null); } @Test public void testGetDeclaredFieldForceAccess() { assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, "VALUE", true).getDeclaringClass()); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "s", true)); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "b", true)); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "i", true)); assertNull(FieldUtils.getDeclaredField(PublicChild.class, "d", true)); assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "VALUE", true)); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "s", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "b", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "i", true).getDeclaringClass()); assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, "d", true).getDeclaringClass()); assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "VALUE", true)); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "s", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "b", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "i", true).getDeclaringClass()); assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, "d", true).getDeclaringClass()); } @Test(expected = IllegalArgumentException.class) public void testGetDeclaredFieldForceAccessIllegalArgumentException1() { FieldUtils.getDeclaredField(null, "none", true); } @Test(expected = IllegalArgumentException.class) public void testGetDeclaredFieldForceAccessIllegalArgumentException2() { FieldUtils.getDeclaredField(PublicChild.class, null, true); } @Test public void testReadStaticField() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); } @Test(expected = IllegalArgumentException.class) public void testReadStaticFieldIllegalArgumentException1() throws Exception { FieldUtils.readStaticField(null); } @Test(expected = IllegalArgumentException.class) public void testReadStaticFieldIllegalArgumentException2() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); final Field nonStaticField = FieldUtils.getField(PublicChild.class, "s"); assumeNotNull(nonStaticField); FieldUtils.readStaticField(nonStaticField); } @Test public void testReadStaticFieldForceAccess() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE"))); assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(PublicChild.class, "VALUE"))); } @Test(expected = IllegalArgumentException.class) public void testReadStaticFieldForceAccessIllegalArgumentException1() throws Exception { FieldUtils.readStaticField(null, true); } @Test(expected = IllegalArgumentException.class) public void testReadStaticFieldForceAccessIllegalArgumentException2() throws Exception { final Field nonStaticField = FieldUtils.getField(PublicChild.class, "s", true); assumeNotNull(nonStaticField); FieldUtils.readStaticField(nonStaticField); } @Test public void testReadNamedStaticField() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE")); assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE")); assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE")); assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, "VALUE")); try { FieldUtils.readStaticField(null, "none"); fail("null class should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readStaticField(Foo.class, null); fail("null field name should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readStaticField(Foo.class, "does_not_exist"); fail("a field that doesn't exist should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readStaticField(PublicChild.class, "s"); fail("non-static field should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } } @Test public void testReadNamedStaticFieldForceAccess() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, "VALUE", true)); assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, "VALUE", true)); assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, "VALUE", true)); assertEquals("child", FieldUtils.readStaticField(PublicChild.class, "VALUE", true)); try { FieldUtils.readStaticField(null, "none", true); fail("null class should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readStaticField(Foo.class, null, true); fail("null field name should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readStaticField(Foo.class, "does_not_exist", true); fail("a field that doesn't exist should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readStaticField(PublicChild.class, "s", false); fail("non-static field should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } } @Test public void testReadDeclaredNamedStaticField() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE")); try { assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception { assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE", true)); assertEquals("child", FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE", true)); try { assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, "VALUE", true)); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true)); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testReadField() throws Exception { final Field parentS = FieldUtils.getDeclaredField(parentClass, "s"); assertEquals("s", FieldUtils.readField(parentS, publicChild)); assertEquals("s", FieldUtils.readField(parentS, publiclyShadowedChild)); assertEquals("s", FieldUtils.readField(parentS, privatelyShadowedChild)); final Field parentB = FieldUtils.getDeclaredField(parentClass, "b", true); assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild)); assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild)); assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild)); final Field parentI = FieldUtils.getDeclaredField(parentClass, "i", true); assertEquals(I0, FieldUtils.readField(parentI, publicChild)); assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild)); assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild)); final Field parentD = FieldUtils.getDeclaredField(parentClass, "d", true); assertEquals(D0, FieldUtils.readField(parentD, publicChild)); assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild)); assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild)); try { FieldUtils.readField((Field) null, publicChild); fail("a null field should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } } @Test public void testReadFieldForceAccess() throws Exception { final Field parentS = FieldUtils.getDeclaredField(parentClass, "s"); parentS.setAccessible(false); assertEquals("s", FieldUtils.readField(parentS, publicChild, true)); assertEquals("s", FieldUtils.readField(parentS, publiclyShadowedChild, true)); assertEquals("s", FieldUtils.readField(parentS, privatelyShadowedChild, true)); final Field parentB = FieldUtils.getDeclaredField(parentClass, "b", true); parentB.setAccessible(false); assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild, true)); assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild, true)); assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild, true)); final Field parentI = FieldUtils.getDeclaredField(parentClass, "i", true); parentI.setAccessible(false); assertEquals(I0, FieldUtils.readField(parentI, publicChild, true)); assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild, true)); assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild, true)); final Field parentD = FieldUtils.getDeclaredField(parentClass, "d", true); parentD.setAccessible(false); assertEquals(D0, FieldUtils.readField(parentD, publicChild, true)); assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild, true)); assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild, true)); try { FieldUtils.readField((Field) null, publicChild, true); fail("a null field should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } } @Test public void testReadNamedField() throws Exception { assertEquals("s", FieldUtils.readField(publicChild, "s")); assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s")); assertEquals("s", FieldUtils.readField(privatelyShadowedChild, "s")); try { FieldUtils.readField(publicChild, null); fail("a null field name should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readField((Object) null, "none"); fail("a null target should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b")); try { assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(I0, FieldUtils.readField(publicChild, "i")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i")); try { assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, "i")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(D0, FieldUtils.readField(publicChild, "d")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d")); try { assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, "d")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testReadNamedFieldForceAccess() throws Exception { assertEquals("s", FieldUtils.readField(publicChild, "s", true)); assertEquals("ss", FieldUtils.readField(publiclyShadowedChild, "s", true)); assertEquals("ss", FieldUtils.readField(privatelyShadowedChild, "s", true)); assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, "b", true)); assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, "b", true)); assertEquals(Boolean.TRUE, FieldUtils.readField(privatelyShadowedChild, "b", true)); assertEquals(I0, FieldUtils.readField(publicChild, "i", true)); assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, "i", true)); assertEquals(I1, FieldUtils.readField(privatelyShadowedChild, "i", true)); assertEquals(D0, FieldUtils.readField(publicChild, "d", true)); assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, "d", true)); assertEquals(D1, FieldUtils.readField(privatelyShadowedChild, "d", true)); try { FieldUtils.readField(publicChild, null, true); fail("a null field name should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readField((Object) null, "none", true); fail("a null target should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } } @Test public void testReadDeclaredNamedField() throws Exception { try { FieldUtils.readDeclaredField(publicChild, null); fail("a null field name should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readDeclaredField((Object) null, "none"); fail("a null target should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); try { assertEquals("s", FieldUtils.readDeclaredField(privatelyShadowedChild, "s")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); try { assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); try { assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, "i")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); try { assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, "d")); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testReadDeclaredNamedFieldForceAccess() throws Exception { try { FieldUtils.readDeclaredField(publicChild, null, true); fail("a null field name should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { FieldUtils.readDeclaredField((Object) null, "none", true); fail("a null target should cause an IllegalArgumentException"); } catch (final IllegalArgumentException e) { // expected } try { assertEquals("s", FieldUtils.readDeclaredField(publicChild, "s", true)); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); assertEquals("ss", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); try { assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, "b", true)); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); try { assertEquals(I0, FieldUtils.readDeclaredField(publicChild, "i", true)); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); try { assertEquals(D0, FieldUtils.readDeclaredField(publicChild, "d", true)); fail("expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); } @Test public void testWriteStaticField() throws Exception { Field field = StaticContainer.class.getDeclaredField("mutablePublic"); FieldUtils.writeStaticField(field, "new"); assertEquals("new", StaticContainer.mutablePublic); field = StaticContainer.class.getDeclaredField("mutableProtected"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("mutablePackage"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("mutablePrivate"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PUBLIC"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PROTECTED"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PACKAGE"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PRIVATE"); try { FieldUtils.writeStaticField(field, "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } } @Test public void testWriteStaticFieldForceAccess() throws Exception { Field field = StaticContainer.class.getDeclaredField("mutablePublic"); FieldUtils.writeStaticField(field, "new", true); assertEquals("new", StaticContainer.mutablePublic); field = StaticContainer.class.getDeclaredField("mutableProtected"); FieldUtils.writeStaticField(field, "new", true); assertEquals("new", StaticContainer.getMutableProtected()); field = StaticContainer.class.getDeclaredField("mutablePackage"); FieldUtils.writeStaticField(field, "new", true); assertEquals("new", StaticContainer.getMutablePackage()); field = StaticContainer.class.getDeclaredField("mutablePrivate"); FieldUtils.writeStaticField(field, "new", true); assertEquals("new", StaticContainer.getMutablePrivate()); field = StaticContainer.class.getDeclaredField("IMMUTABLE_PUBLIC"); try { FieldUtils.writeStaticField(field, "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PROTECTED"); try { FieldUtils.writeStaticField(field, "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PACKAGE"); try { FieldUtils.writeStaticField(field, "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = StaticContainer.class.getDeclaredField("IMMUTABLE_PRIVATE"); try { FieldUtils.writeStaticField(field, "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } } @Test public void testWriteNamedStaticField() throws Exception { FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new"); assertEquals("new", StaticContainer.mutablePublic); try { FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testWriteNamedStaticFieldForceAccess() throws Exception { FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePublic", "new", true); assertEquals("new", StaticContainer.mutablePublic); FieldUtils.writeStaticField(StaticContainerChild.class, "mutableProtected", "new", true); assertEquals("new", StaticContainer.getMutableProtected()); FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePackage", "new", true); assertEquals("new", StaticContainer.getMutablePackage()); FieldUtils.writeStaticField(StaticContainerChild.class, "mutablePrivate", "new", true); assertEquals("new", StaticContainer.getMutablePrivate()); try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PUBLIC", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PROTECTED", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PACKAGE", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } } @Test public void testWriteDeclaredNamedStaticField() throws Exception { FieldUtils.writeStaticField(StaticContainer.class, "mutablePublic", "new"); assertEquals("new", StaticContainer.mutablePublic); try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new"); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testWriteDeclaredNamedStaticFieldForceAccess() throws Exception { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePublic", "new", true); assertEquals("new", StaticContainer.mutablePublic); FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutableProtected", "new", true); assertEquals("new", StaticContainer.getMutableProtected()); FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePackage", "new", true); assertEquals("new", StaticContainer.getMutablePackage()); FieldUtils.writeDeclaredStaticField(StaticContainer.class, "mutablePrivate", "new", true); assertEquals("new", StaticContainer.getMutablePrivate()); try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PUBLIC", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PROTECTED", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PACKAGE", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } try { FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new", true); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } } @Test public void testWriteField() throws Exception { Field field = parentClass.getDeclaredField("s"); FieldUtils.writeField(field, publicChild, "S"); assertEquals("S", field.get(publicChild)); field = parentClass.getDeclaredField("b"); try { FieldUtils.writeField(field, publicChild, Boolean.TRUE); fail("Expected IllegalAccessException"); } catch (final IllegalAccessException e) { // pass } field = parentClass.getDeclaredField("i"); try { FieldUtils.writeField(field, publicChild, Integer.valueOf(Integer.MAX_VALUE)); } catch (final IllegalAccessException e) { // pass } field = parentClass.getDeclaredField("d"); try { FieldUtils.writeField(field, publicChild, Double.valueOf(Double.MAX_VALUE)); } catch (final IllegalAccessException e) { // pass } } @Test public void testWriteFieldForceAccess() throws Exception { Field field = parentClass.getDeclaredField("s"); FieldUtils.writeField(field, publicChild, "S", true); assertEquals("S", field.get(publicChild)); field = parentClass.getDeclaredField("b"); FieldUtils.writeField(field, publicChild, Boolean.TRUE, true); assertEquals(Boolean.TRUE, field.get(publicChild)); field = parentClass.getDeclaredField("i"); FieldUtils.writeField(field, publicChild, Integer.valueOf(Integer.MAX_VALUE), true); assertEquals(Integer.valueOf(Integer.MAX_VALUE), field.get(publicChild)); field = parentClass.getDeclaredField("d"); FieldUtils.writeField(field, publicChild, Double.valueOf(Double.MAX_VALUE), true); assertEquals(Double.valueOf(Double.MAX_VALUE), field.get(publicChild)); } @Test public void testWriteNamedField() throws Exception { FieldUtils.writeField(publicChild, "s", "S"); assertEquals("S", FieldUtils.readField(publicChild, "s")); try { FieldUtils.writeField(publicChild, "b", Boolean.TRUE); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeField(publicChild, "i", Integer.valueOf(1)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } FieldUtils.writeField(publiclyShadowedChild, "s", "S"); assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s")); FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE); assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b")); FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0)); assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i")); FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0)); assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d")); FieldUtils.writeField(privatelyShadowedChild, "s", "S"); assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s")); try { FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.TRUE); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(1)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testWriteNamedFieldForceAccess() throws Exception { FieldUtils.writeField(publicChild, "s", "S", true); assertEquals("S", FieldUtils.readField(publicChild, "s", true)); FieldUtils.writeField(publicChild, "b", Boolean.TRUE, true); assertEquals(Boolean.TRUE, FieldUtils.readField(publicChild, "b", true)); FieldUtils.writeField(publicChild, "i", Integer.valueOf(1), true); assertEquals(Integer.valueOf(1), FieldUtils.readField(publicChild, "i", true)); FieldUtils.writeField(publicChild, "d", Double.valueOf(1.0), true); assertEquals(Double.valueOf(1.0), FieldUtils.readField(publicChild, "d", true)); FieldUtils.writeField(publiclyShadowedChild, "s", "S", true); assertEquals("S", FieldUtils.readField(publiclyShadowedChild, "s", true)); FieldUtils.writeField(publiclyShadowedChild, "b", Boolean.FALSE, true); assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, "b", true)); FieldUtils.writeField(publiclyShadowedChild, "i", Integer.valueOf(0), true); assertEquals(Integer.valueOf(0), FieldUtils.readField(publiclyShadowedChild, "i", true)); FieldUtils.writeField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); assertEquals(Double.valueOf(0.0), FieldUtils.readField(publiclyShadowedChild, "d", true)); FieldUtils.writeField(privatelyShadowedChild, "s", "S", true); assertEquals("S", FieldUtils.readField(privatelyShadowedChild, "s", true)); FieldUtils.writeField(privatelyShadowedChild, "b", Boolean.FALSE, true); assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, "b", true)); FieldUtils.writeField(privatelyShadowedChild, "i", Integer.valueOf(0), true); assertEquals(Integer.valueOf(0), FieldUtils.readField(privatelyShadowedChild, "i", true)); FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); assertEquals(Double.valueOf(0.0), FieldUtils.readField(privatelyShadowedChild, "d", true)); } @Test public void testWriteDeclaredNamedField() throws Exception { try { FieldUtils.writeDeclaredField(publicChild, "s", "S"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S"); assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s")); FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE); assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b")); FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0)); assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i")); FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0)); assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d")); try { FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S"); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.TRUE); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(1)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(1.0)); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } } @Test public void testWriteDeclaredNamedFieldForceAccess() throws Exception { try { FieldUtils.writeDeclaredField(publicChild, "s", "S", true); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(publicChild, "b", Boolean.TRUE, true); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(publicChild, "i", Integer.valueOf(1), true); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } try { FieldUtils.writeDeclaredField(publicChild, "d", Double.valueOf(1.0), true); fail("Expected IllegalArgumentException"); } catch (final IllegalArgumentException e) { // pass } FieldUtils.writeDeclaredField(publiclyShadowedChild, "s", "S", true); assertEquals("S", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true)); FieldUtils.writeDeclaredField(publiclyShadowedChild, "b", Boolean.FALSE, true); assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, "b", true)); FieldUtils.writeDeclaredField(publiclyShadowedChild, "i", Integer.valueOf(0), true); assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(publiclyShadowedChild, "i", true)); FieldUtils.writeDeclaredField(publiclyShadowedChild, "d", Double.valueOf(0.0), true); assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, "d", true)); FieldUtils.writeDeclaredField(privatelyShadowedChild, "s", "S", true); assertEquals("S", FieldUtils.readDeclaredField(privatelyShadowedChild, "s", true)); FieldUtils.writeDeclaredField(privatelyShadowedChild, "b", Boolean.FALSE, true); assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, "b", true)); FieldUtils.writeDeclaredField(privatelyShadowedChild, "i", Integer.valueOf(0), true); assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true)); FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true); assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true)); } @Test(expected = IllegalArgumentException.class) public void testAmbig() { FieldUtils.getField(Ambig.class, "VALUE"); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.reflect; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Method; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.math.NumberUtils; import org.apache.commons.lang3.mutable.Mutable; import org.apache.commons.lang3.mutable.MutableObject; import org.junit.Before; import org.junit.Test; /** * Unit tests MethodUtils * @version $Id$ */ public class MethodUtilsTest { private static interface PrivateInterface {} static class TestBeanWithInterfaces implements PrivateInterface { public String foo() { return "foo()"; } } public static class TestBean { public static String bar() { return "bar()"; } public static String bar(final int i) { return "bar(int)"; } public static String bar(final Integer i) { return "bar(Integer)"; } public static String bar(final double d) { return "bar(double)"; } public static String bar(final String s) { return "bar(String)"; } public static String bar(final Object o) { return "bar(Object)"; } public static void oneParameterStatic(final String s) { // empty } @SuppressWarnings("unused") private void privateStuff() { } public String foo() { return "foo()"; } public String foo(final int i) { return "foo(int)"; } public String foo(final Integer i) { return "foo(Integer)"; } public String foo(final double d) { return "foo(double)"; } public String foo(final String s) { return "foo(String)"; } public String foo(final Object o) { return "foo(Object)"; } public void oneParameter(final String s) { // empty } } private static class TestMutable implements Mutable<Object> { @Override public Object getValue() { return null; } @Override public void setValue(final Object value) { } } private TestBean testBean; private final Map<Class<?>, Class<?>[]> classCache = new HashMap<Class<?>, Class<?>[]>(); @Before public void setUp() throws Exception { testBean = new TestBean(); classCache.clear(); } @Test public void testConstructor() throws Exception { assertNotNull(MethodUtils.class.newInstance()); } @Test public void testInvokeMethod() throws Exception { assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", (Object[]) null)); assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo", (Object[]) null, (Class<?>[]) null)); assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo", "")); assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", new Object())); assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo", Boolean.TRUE)); assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo", NumberUtils.INTEGER_ONE)); assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo", NumberUtils.BYTE_ONE)); assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", NumberUtils.LONG_ONE)); assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo", NumberUtils.DOUBLE_ONE)); } @Test public void testInvokeExactMethod() throws Exception { assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", (Object[]) null)); assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo", (Object[]) null, (Class<?>[]) null)); assertEquals("foo(String)", MethodUtils.invokeExactMethod(testBean, "foo", "")); assertEquals("foo(Object)", MethodUtils.invokeExactMethod(testBean, "foo", new Object())); assertEquals("foo(Integer)", MethodUtils.invokeExactMethod(testBean, "foo", NumberUtils.INTEGER_ONE)); assertEquals("foo(double)", MethodUtils.invokeExactMethod(testBean, "foo", new Object[] { NumberUtils.DOUBLE_ONE }, new Class[] { Double.TYPE })); try { MethodUtils .invokeExactMethod(testBean, "foo", NumberUtils.BYTE_ONE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } try { MethodUtils .invokeExactMethod(testBean, "foo", NumberUtils.LONG_ONE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } try { MethodUtils.invokeExactMethod(testBean, "foo", Boolean.TRUE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } } @Test public void testInvokeStaticMethod() throws Exception { assertEquals("bar()", MethodUtils.invokeStaticMethod(TestBean.class, "bar", (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); assertEquals("bar()", MethodUtils.invokeStaticMethod(TestBean.class, "bar", (Object[]) null)); assertEquals("bar()", MethodUtils.invokeStaticMethod(TestBean.class, "bar", (Object[]) null, (Class<?>[]) null)); assertEquals("bar(String)", MethodUtils.invokeStaticMethod( TestBean.class, "bar", "")); assertEquals("bar(Object)", MethodUtils.invokeStaticMethod( TestBean.class, "bar", new Object())); assertEquals("bar(Object)", MethodUtils.invokeStaticMethod( TestBean.class, "bar", Boolean.TRUE)); assertEquals("bar(Integer)", MethodUtils.invokeStaticMethod( TestBean.class, "bar", NumberUtils.INTEGER_ONE)); assertEquals("bar(int)", MethodUtils.invokeStaticMethod(TestBean.class, "bar", NumberUtils.BYTE_ONE)); assertEquals("bar(double)", MethodUtils.invokeStaticMethod( TestBean.class, "bar", NumberUtils.LONG_ONE)); assertEquals("bar(double)", MethodUtils.invokeStaticMethod( TestBean.class, "bar", NumberUtils.DOUBLE_ONE)); try { MethodUtils.invokeStaticMethod(TestBean.class, "does_not_exist"); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } } @Test public void testInvokeExactStaticMethod() throws Exception { assertEquals("bar()", MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY)); assertEquals("bar()", MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", (Object[]) null)); assertEquals("bar()", MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", (Object[]) null, (Class<?>[]) null)); assertEquals("bar(String)", MethodUtils.invokeExactStaticMethod( TestBean.class, "bar", "")); assertEquals("bar(Object)", MethodUtils.invokeExactStaticMethod( TestBean.class, "bar", new Object())); assertEquals("bar(Integer)", MethodUtils.invokeExactStaticMethod( TestBean.class, "bar", NumberUtils.INTEGER_ONE)); assertEquals("bar(double)", MethodUtils.invokeExactStaticMethod( TestBean.class, "bar", new Object[] { NumberUtils.DOUBLE_ONE }, new Class[] { Double.TYPE })); try { MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", NumberUtils.BYTE_ONE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } try { MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", NumberUtils.LONG_ONE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } try { MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", Boolean.TRUE); fail("should throw NoSuchMethodException"); } catch (final NoSuchMethodException e) { } } @Test public void testGetAccessibleInterfaceMethod() throws Exception { final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; for (final Class<?>[] element : p) { final Method method = TestMutable.class.getMethod("getValue", element); final Method accessibleMethod = MethodUtils.getAccessibleMethod(method); assertNotSame(accessibleMethod, method); assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); } } @Test public void testGetAccessibleMethodPrivateInterface() throws Exception { final Method expected = TestBeanWithInterfaces.class.getMethod("foo"); assertNotNull(expected); final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo"); assertNull(actual); } @Test public void testGetAccessibleInterfaceMethodFromDescription() throws Exception { final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null }; for (final Class<?>[] element : p) { final Method accessibleMethod = MethodUtils.getAccessibleMethod( TestMutable.class, "getValue", element); assertSame(Mutable.class, accessibleMethod.getDeclaringClass()); } } @Test public void testGetAccessiblePublicMethod() throws Exception { assertSame(MutableObject.class, MethodUtils.getAccessibleMethod( MutableObject.class.getMethod("getValue", ArrayUtils.EMPTY_CLASS_ARRAY)).getDeclaringClass()); } @Test public void testGetAccessiblePublicMethodFromDescription() throws Exception { assertSame(MutableObject.class, MethodUtils.getAccessibleMethod( MutableObject.class, "getValue", ArrayUtils.EMPTY_CLASS_ARRAY) .getDeclaringClass()); } @Test public void testGetAccessibleMethodInaccessible() throws Exception { final Method expected = TestBean.class.getDeclaredMethod("privateStuff"); final Method actual = MethodUtils.getAccessibleMethod(expected); assertNull(actual); } @Test public void testGetMatchingAccessibleMethod() throws Exception { expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", null, ArrayUtils.EMPTY_CLASS_ARRAY); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(String.class), singletonArray(String.class)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Object.class), singletonArray(Object.class)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Boolean.class), singletonArray(Object.class)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Byte.class), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Byte.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Short.class), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Short.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Character.class), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Character.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Integer.class), singletonArray(Integer.class)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Integer.TYPE), singletonArray(Integer.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Long.class), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Long.TYPE), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Float.class), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Float.TYPE), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Double.class), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Double.TYPE), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo", singletonArray(Double.TYPE), singletonArray(Double.TYPE)); expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne", singletonArray(ParentObject.class), singletonArray(ParentObject.class)); expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne", singletonArray(ChildObject.class), singletonArray(ParentObject.class)); expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo", singletonArray(ParentObject.class), singletonArray(GrandParentObject.class)); expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo", singletonArray(ChildObject.class), singletonArray(ChildInterface.class)); } @Test public void testNullArgument() { expectMatchingAccessibleMethodParameterTypes(TestBean.class, "oneParameter", singletonArray(null), singletonArray(String.class)); } private void expectMatchingAccessibleMethodParameterTypes(final Class<?> cls, final String methodName, final Class<?>[] requestTypes, final Class<?>[] actualTypes) { final Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName, requestTypes); assertTrue(toString(m.getParameterTypes()) + " not equals " + toString(actualTypes), Arrays.equals(actualTypes, m .getParameterTypes())); } private String toString(final Class<?>[] c) { return Arrays.asList(c).toString(); } private Class<?>[] singletonArray(final Class<?> c) { Class<?>[] result = classCache.get(c); if (result == null) { result = new Class[] { c }; classCache.put(c, result); } return result; } public static class InheritanceBean { public void testOne(final Object obj) {} public void testOne(final GrandParentObject obj) {} public void testOne(final ParentObject obj) {} public void testTwo(final Object obj) {} public void testTwo(final GrandParentObject obj) {} public void testTwo(final ChildInterface obj) {} } interface ChildInterface {} public static class GrandParentObject {} public static class ParentObject extends GrandParentObject {} public static class ChildObject extends ParentObject implements ChildInterface {} }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.reflect; import java.io.Serializable; import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.net.URI; import java.util.Arrays; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.TreeSet; import org.apache.commons.lang3.StringEscapeUtils; import org.apache.commons.lang3.reflect.testbed.Foo; import org.apache.commons.lang3.reflect.testbed.GenericParent; import org.apache.commons.lang3.reflect.testbed.GenericTypeHolder; import org.apache.commons.lang3.reflect.testbed.StringParameterizedChild; import org.junit.Assert; import org.junit.Test; /** * Test TypeUtils * @version $Id$ */ @SuppressWarnings({ "unchecked", "unused" , "rawtypes", "null"}) //raw types, where used, are used purposely public class TypeUtilsTest<B> { public interface This<K, V> { } public class That<K, V> implements This<K, V> { } public interface And<K, V> extends This<Number, Number> { } public class The<K, V> extends That<Number, Number> implements And<String, String> { } public class Other<T> implements This<String, T> { } public class Thing<Q> extends Other<B> { } public class Tester implements This<String, B> { } public This<String, String> dis; public That<String, String> dat; public The<String, String> da; public Other<String> uhder; public Thing ding; public TypeUtilsTest<String>.Tester tester; public Tester tester2; public TypeUtilsTest<String>.That<String, String> dat2; public TypeUtilsTest<Number>.That<String, String> dat3; public Comparable<? extends Integer>[] intWildcardComparable; public static Comparable<String> stringComparable; public static Comparable<URI> uriComparable; public static Comparable<Integer> intComparable; public static Comparable<Long> longComparable; public static URI uri; public void dummyMethod(final List list0, final List<Object> list1, final List<?> list2, final List<? super Object> list3, final List<String> list4, final List<? extends String> list5, final List<? super String> list6, final List[] list7, final List<Object>[] list8, final List<?>[] list9, final List<? super Object>[] list10, final List<String>[] list11, final List<? extends String>[] list12, final List<? super String>[] list13) { } @SuppressWarnings("boxing") // deliberately used here @Test public void testIsAssignable() throws SecurityException, NoSuchMethodException, NoSuchFieldException { List list0 = null; List<Object> list1 = null; List<?> list2 = null; List<? super Object> list3 = null; List<String> list4 = null; List<? extends String> list5 = null; List<? super String> list6 = null; List[] list7 = null; List<Object>[] list8 = null; List<?>[] list9 = null; List<? super Object>[] list10 = null; List<String>[] list11 = null; List<? extends String>[] list12 = null; List<? super String>[] list13; final Class<?> clazz = getClass(); final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class, List.class, List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); final Type[] types = method.getGenericParameterTypes(); // list0 = list0; delegateBooleanAssertion(types, 0, 0, true); list1 = list0; delegateBooleanAssertion(types, 0, 1, true); list0 = list1; delegateBooleanAssertion(types, 1, 0, true); list2 = list0; delegateBooleanAssertion(types, 0, 2, true); list0 = list2; delegateBooleanAssertion(types, 2, 0, true); list3 = list0; delegateBooleanAssertion(types, 0, 3, true); list0 = list3; delegateBooleanAssertion(types, 3, 0, true); list4 = list0; delegateBooleanAssertion(types, 0, 4, true); list0 = list4; delegateBooleanAssertion(types, 4, 0, true); list5 = list0; delegateBooleanAssertion(types, 0, 5, true); list0 = list5; delegateBooleanAssertion(types, 5, 0, true); list6 = list0; delegateBooleanAssertion(types, 0, 6, true); list0 = list6; delegateBooleanAssertion(types, 6, 0, true); // list1 = list1; delegateBooleanAssertion(types, 1, 1, true); list2 = list1; delegateBooleanAssertion(types, 1, 2, true); list1 = (List<Object>) list2; delegateBooleanAssertion(types, 2, 1, false); list3 = list1; delegateBooleanAssertion(types, 1, 3, true); list1 = (List<Object>) list3; delegateBooleanAssertion(types, 3, 1, false); // list4 = list1; delegateBooleanAssertion(types, 1, 4, false); // list1 = list4; delegateBooleanAssertion(types, 4, 1, false); // list5 = list1; delegateBooleanAssertion(types, 1, 5, false); // list1 = list5; delegateBooleanAssertion(types, 5, 1, false); list6 = list1; delegateBooleanAssertion(types, 1, 6, true); list1 = (List<Object>) list6; delegateBooleanAssertion(types, 6, 1, false); // list2 = list2; delegateBooleanAssertion(types, 2, 2, true); list2 = list3; delegateBooleanAssertion(types, 2, 3, false); list2 = list4; delegateBooleanAssertion(types, 3, 2, true); list3 = (List<? super Object>) list2; delegateBooleanAssertion(types, 2, 4, false); list2 = list5; delegateBooleanAssertion(types, 4, 2, true); list4 = (List<String>) list2; delegateBooleanAssertion(types, 2, 5, false); list2 = list6; delegateBooleanAssertion(types, 5, 2, true); list5 = (List<? extends String>) list2; delegateBooleanAssertion(types, 2, 6, false); // list3 = list3; delegateBooleanAssertion(types, 6, 2, true); list6 = (List<? super String>) list2; delegateBooleanAssertion(types, 3, 3, true); // list4 = list3; delegateBooleanAssertion(types, 3, 4, false); // list3 = list4; delegateBooleanAssertion(types, 4, 3, false); // list5 = list3; delegateBooleanAssertion(types, 3, 5, false); // list3 = list5; delegateBooleanAssertion(types, 5, 3, false); list6 = list3; delegateBooleanAssertion(types, 3, 6, true); list3 = (List<? super Object>) list6; delegateBooleanAssertion(types, 6, 3, false); // list4 = list4; delegateBooleanAssertion(types, 4, 4, true); list5 = list4; delegateBooleanAssertion(types, 4, 5, true); list4 = (List<String>) list5; delegateBooleanAssertion(types, 5, 4, false); list6 = list4; delegateBooleanAssertion(types, 4, 6, true); list4 = (List<String>) list6; delegateBooleanAssertion(types, 6, 4, false); // list5 = list5; delegateBooleanAssertion(types, 5, 5, true); list6 = (List<? super String>) list5; delegateBooleanAssertion(types, 5, 6, false); list5 = (List<? extends String>) list6; delegateBooleanAssertion(types, 6, 5, false); // list6 = list6; delegateBooleanAssertion(types, 6, 6, true); // list7 = list7; delegateBooleanAssertion(types, 7, 7, true); list8 = list7; delegateBooleanAssertion(types, 7, 8, true); list7 = list8; delegateBooleanAssertion(types, 8, 7, true); list9 = list7; delegateBooleanAssertion(types, 7, 9, true); list7 = list9; delegateBooleanAssertion(types, 9, 7, true); list10 = list7; delegateBooleanAssertion(types, 7, 10, true); list7 = list10; delegateBooleanAssertion(types, 10, 7, true); list11 = list7; delegateBooleanAssertion(types, 7, 11, true); list7 = list11; delegateBooleanAssertion(types, 11, 7, true); list12 = list7; delegateBooleanAssertion(types, 7, 12, true); list7 = list12; delegateBooleanAssertion(types, 12, 7, true); list13 = list7; delegateBooleanAssertion(types, 7, 13, true); list7 = list13; delegateBooleanAssertion(types, 13, 7, true); // list8 = list8; delegateBooleanAssertion(types, 8, 8, true); list9 = list8; delegateBooleanAssertion(types, 8, 9, true); list8 = (List<Object>[]) list9; delegateBooleanAssertion(types, 9, 8, false); list10 = list8; delegateBooleanAssertion(types, 8, 10, true); list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse delegateBooleanAssertion(types, 10, 8, false); // list11 = list8; delegateBooleanAssertion(types, 8, 11, false); // list8 = list11; delegateBooleanAssertion(types, 11, 8, false); // list12 = list8; delegateBooleanAssertion(types, 8, 12, false); // list8 = list12; delegateBooleanAssertion(types, 12, 8, false); list13 = list8; delegateBooleanAssertion(types, 8, 13, true); list8 = (List<Object>[]) list13; delegateBooleanAssertion(types, 13, 8, false); // list9 = list9; delegateBooleanAssertion(types, 9, 9, true); list10 = (List<? super Object>[]) list9; delegateBooleanAssertion(types, 9, 10, false); list9 = list10; delegateBooleanAssertion(types, 10, 9, true); list11 = (List<String>[]) list9; delegateBooleanAssertion(types, 9, 11, false); list9 = list11; delegateBooleanAssertion(types, 11, 9, true); list12 = (List<? extends String>[]) list9; delegateBooleanAssertion(types, 9, 12, false); list9 = list12; delegateBooleanAssertion(types, 12, 9, true); list13 = (List<? super String>[]) list9; delegateBooleanAssertion(types, 9, 13, false); list9 = list13; delegateBooleanAssertion(types, 13, 9, true); // list10 = list10; delegateBooleanAssertion(types, 10, 10, true); // list11 = list10; delegateBooleanAssertion(types, 10, 11, false); // list10 = list11; delegateBooleanAssertion(types, 11, 10, false); // list12 = list10; delegateBooleanAssertion(types, 10, 12, false); // list10 = list12; delegateBooleanAssertion(types, 12, 10, false); list13 = list10; delegateBooleanAssertion(types, 10, 13, true); list10 = (List<? super Object>[]) list13; delegateBooleanAssertion(types, 13, 10, false); // list11 = list11; delegateBooleanAssertion(types, 11, 11, true); list12 = list11; delegateBooleanAssertion(types, 11, 12, true); list11 = (List<String>[]) list12; delegateBooleanAssertion(types, 12, 11, false); list13 = list11; delegateBooleanAssertion(types, 11, 13, true); list11 = (List<String>[]) list13; delegateBooleanAssertion(types, 13, 11, false); // list12 = list12; delegateBooleanAssertion(types, 12, 12, true); list13 = (List<? super String>[]) list12; delegateBooleanAssertion(types, 12, 13, false); list12 = (List<? extends String>[]) list13; delegateBooleanAssertion(types, 13, 12, false); // list13 = list13; delegateBooleanAssertion(types, 13, 13, true); final Type disType = getClass().getField("dis").getGenericType(); // Reporter.log( ( ( ParameterizedType ) disType // ).getOwnerType().getClass().toString() ); final Type datType = getClass().getField("dat").getGenericType(); final Type daType = getClass().getField("da").getGenericType(); final Type uhderType = getClass().getField("uhder").getGenericType(); final Type dingType = getClass().getField("ding").getGenericType(); final Type testerType = getClass().getField("tester").getGenericType(); final Type tester2Type = getClass().getField("tester2").getGenericType(); final Type dat2Type = getClass().getField("dat2").getGenericType(); final Type dat3Type = getClass().getField("dat3").getGenericType(); dis = dat; Assert.assertTrue(TypeUtils.isAssignable(datType, disType)); // dis = da; Assert.assertFalse(TypeUtils.isAssignable(daType, disType)); dis = uhder; Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType)); dis = ding; Assert.assertFalse(String.format("type %s not assignable to %s!", dingType, disType), TypeUtils.isAssignable(dingType, disType)); dis = tester; Assert.assertTrue(TypeUtils.isAssignable(testerType, disType)); // dis = tester2; Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType)); // dat = dat2; Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType)); // dat2 = dat; Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type)); // dat = dat3; Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType)); final char ch = 0; final boolean bo = false; final byte by = 0; final short sh = 0; int in = 0; long lo = 0; final float fl = 0; double du = 0; du = ch; Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class)); du = by; Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class)); du = sh; Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class)); du = in; Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class)); du = lo; Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class)); du = fl; Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class)); lo = in; Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class)); lo = Integer.valueOf(0); Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class)); // Long lngW = 1; Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class)); // lngW = Integer.valueOf( 0 ); Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class)); in = Integer.valueOf(0); Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class)); final Integer inte = in; Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class)); Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class)); Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class)); final Type intComparableType = getClass().getField("intComparable").getGenericType(); intComparable = 1; Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType)); Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class)); final Serializable ser = 1; Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class)); final Type longComparableType = getClass().getField("longComparable").getGenericType(); // longComparable = 1; Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType)); // longComparable = Integer.valueOf( 0 ); Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType)); // int[] ia; // long[] la = ia; Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class)); final Integer[] ia = null; final Type caType = getClass().getField("intWildcardComparable").getGenericType(); intWildcardComparable = ia; Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType)); // int[] ina = ia; Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class)); final int[] ina = null; Object[] oa; // oa = ina; Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class)); oa = new Integer[0]; Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class)); final Type bClassType = AClass.class.getField("bClass").getGenericType(); final Type cClassType = AClass.class.getField("cClass").getGenericType(); final Type dClassType = AClass.class.getField("dClass").getGenericType(); final Type eClassType = AClass.class.getField("eClass").getGenericType(); final Type fClassType = AClass.class.getField("fClass").getGenericType(); final AClass aClass = new AClass(new AAClass<String>()); aClass.bClass = aClass.cClass; Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType)); aClass.bClass = aClass.dClass; Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType)); aClass.bClass = aClass.eClass; Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType)); aClass.bClass = aClass.fClass; Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType)); aClass.cClass = aClass.dClass; Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType)); aClass.cClass = aClass.eClass; Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType)); aClass.cClass = aClass.fClass; Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType)); aClass.dClass = aClass.eClass; Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType)); aClass.dClass = aClass.fClass; Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType)); aClass.eClass = aClass.fClass; Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType)); } public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) { final Type type1 = types[i1]; final Type type2 = types[i2]; final boolean isAssignable = TypeUtils.isAssignable(type2, type1); if (expected) { Assert.assertTrue("[" + i1 + ", " + i2 + "]: From " + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); } else { Assert.assertFalse("[" + i1 + ", " + i2 + "]: From " + StringEscapeUtils.escapeHtml4(String.valueOf(type2)) + " to " + StringEscapeUtils.escapeHtml4(String.valueOf(type1)), isAssignable); } } @SuppressWarnings("boxing") // boxing is deliberate here @Test public void testIsInstance() throws SecurityException, NoSuchFieldException { final Type intComparableType = getClass().getField("intComparable").getGenericType(); final Type uriComparableType = getClass().getField("uriComparable").getGenericType(); intComparable = 1; Assert.assertTrue(TypeUtils.isInstance(1, intComparableType)); // uriComparable = 1; Assert.assertFalse(TypeUtils.isInstance(1, uriComparableType)); } @Test public void testGetTypeArguments() { Map<TypeVariable<?>, Type> typeVarAssigns; TypeVariable<?> treeSetTypeVar; Type typeArg; typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class); treeSetTypeVar = Comparable.class.getTypeParameters()[0]; Assert.assertTrue("Type var assigns for Comparable from Integer: " + typeVarAssigns, typeVarAssigns.containsKey(treeSetTypeVar)); typeArg = typeVarAssigns.get(treeSetTypeVar); Assert.assertEquals("Type argument of Comparable from Integer: " + typeArg, Integer.class, typeVarAssigns.get(treeSetTypeVar)); typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class); treeSetTypeVar = Comparable.class.getTypeParameters()[0]; Assert.assertTrue("Type var assigns for Comparable from int: " + typeVarAssigns, typeVarAssigns.containsKey(treeSetTypeVar)); typeArg = typeVarAssigns.get(treeSetTypeVar); Assert.assertEquals("Type argument of Comparable from int: " + typeArg, Integer.class, typeVarAssigns.get(treeSetTypeVar)); final Collection<Integer> col = Arrays.asList(new Integer[0]); typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class); treeSetTypeVar = Comparable.class.getTypeParameters()[0]; Assert.assertFalse("Type var assigns for Collection from List: " + typeVarAssigns, typeVarAssigns.containsKey(treeSetTypeVar)); typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class); Assert.assertTrue(typeVarAssigns.size() == 2); Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0])); Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0])); typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); Assert.assertEquals(2, typeVarAssigns.size()); Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1])); typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class); Assert.assertEquals(2, typeVarAssigns.size()); Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); Assert.assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1])); typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class); Assert.assertEquals(2, typeVarAssigns.size()); Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0])); Assert.assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0])); } @Test public void testTypesSatisfyVariables() throws SecurityException, NoSuchFieldException, NoSuchMethodException { final Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<TypeVariable<?>, Type>(); final Integer max = TypeUtilsTest.stub(); typeVarAssigns.put(getClass().getMethod("stub").getTypeParameters()[0], Integer.class); Assert.assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns)); typeVarAssigns.clear(); typeVarAssigns.put(getClass().getMethod("stub2").getTypeParameters()[0], Integer.class); Assert.assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns)); typeVarAssigns.clear(); typeVarAssigns.put(getClass().getMethod("stub3").getTypeParameters()[0], Integer.class); Assert.assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns)); } @Test public void testDetermineTypeVariableAssignments() throws SecurityException, NoSuchFieldException, NoSuchMethodException { final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable") .getGenericType(); final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class, iterableType); final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0]; Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar)); Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns .get(treeSetTypeVar)); } @Test public void testGetRawType() throws SecurityException, NoSuchFieldException { final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent") .getGenericType(); final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent") .getGenericType(); final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType(); final Type genericParentT = GenericParent.class.getTypeParameters()[0]; Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null)); Assert .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, null)); Assert.assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null)); Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, StringParameterizedChild.class)); Assert.assertEquals(String.class, TypeUtils.getRawType(genericParentT, stringParentFieldType)); Assert.assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], foosFieldType)); Assert.assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], foosFieldType)); Assert.assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class)); Assert.assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class .getDeclaredField("barParents").getGenericType(), null)); } @Test public void testIsArrayTypeClasses() { Assert.assertTrue(TypeUtils.isArrayType(boolean[].class)); Assert.assertTrue(TypeUtils.isArrayType(byte[].class)); Assert.assertTrue(TypeUtils.isArrayType(short[].class)); Assert.assertTrue(TypeUtils.isArrayType(int[].class)); Assert.assertTrue(TypeUtils.isArrayType(char[].class)); Assert.assertTrue(TypeUtils.isArrayType(long[].class)); Assert.assertTrue(TypeUtils.isArrayType(float[].class)); Assert.assertTrue(TypeUtils.isArrayType(double[].class)); Assert.assertTrue(TypeUtils.isArrayType(Object[].class)); Assert.assertTrue(TypeUtils.isArrayType(String[].class)); Assert.assertFalse(TypeUtils.isArrayType(boolean.class)); Assert.assertFalse(TypeUtils.isArrayType(byte.class)); Assert.assertFalse(TypeUtils.isArrayType(short.class)); Assert.assertFalse(TypeUtils.isArrayType(int.class)); Assert.assertFalse(TypeUtils.isArrayType(char.class)); Assert.assertFalse(TypeUtils.isArrayType(long.class)); Assert.assertFalse(TypeUtils.isArrayType(float.class)); Assert.assertFalse(TypeUtils.isArrayType(double.class)); Assert.assertFalse(TypeUtils.isArrayType(Object.class)); Assert.assertFalse(TypeUtils.isArrayType(String.class)); } @Test public void testIsArrayGenericTypes() throws Exception { final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List.class, List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); final Type[] types = method.getGenericParameterTypes(); Assert.assertFalse(TypeUtils.isArrayType(types[0])); Assert.assertFalse(TypeUtils.isArrayType(types[1])); Assert.assertFalse(TypeUtils.isArrayType(types[2])); Assert.assertFalse(TypeUtils.isArrayType(types[3])); Assert.assertFalse(TypeUtils.isArrayType(types[4])); Assert.assertFalse(TypeUtils.isArrayType(types[5])); Assert.assertFalse(TypeUtils.isArrayType(types[6])); Assert.assertTrue(TypeUtils.isArrayType(types[7])); Assert.assertTrue(TypeUtils.isArrayType(types[8])); Assert.assertTrue(TypeUtils.isArrayType(types[9])); Assert.assertTrue(TypeUtils.isArrayType(types[10])); Assert.assertTrue(TypeUtils.isArrayType(types[11])); Assert.assertTrue(TypeUtils.isArrayType(types[12])); Assert.assertTrue(TypeUtils.isArrayType(types[13])); } @Test public void testGetPrimitiveArrayComponentType() throws Exception { Assert.assertEquals(boolean.class, TypeUtils.getArrayComponentType(boolean[].class)); Assert.assertEquals(byte.class, TypeUtils.getArrayComponentType(byte[].class)); Assert.assertEquals(short.class, TypeUtils.getArrayComponentType(short[].class)); Assert.assertEquals(int.class, TypeUtils.getArrayComponentType(int[].class)); Assert.assertEquals(char.class, TypeUtils.getArrayComponentType(char[].class)); Assert.assertEquals(long.class, TypeUtils.getArrayComponentType(long[].class)); Assert.assertEquals(float.class, TypeUtils.getArrayComponentType(float[].class)); Assert.assertEquals(double.class, TypeUtils.getArrayComponentType(double[].class)); Assert.assertNull(TypeUtils.getArrayComponentType(boolean.class)); Assert.assertNull(TypeUtils.getArrayComponentType(byte.class)); Assert.assertNull(TypeUtils.getArrayComponentType(short.class)); Assert.assertNull(TypeUtils.getArrayComponentType(int.class)); Assert.assertNull(TypeUtils.getArrayComponentType(char.class)); Assert.assertNull(TypeUtils.getArrayComponentType(long.class)); Assert.assertNull(TypeUtils.getArrayComponentType(float.class)); Assert.assertNull(TypeUtils.getArrayComponentType(double.class)); } @Test public void testGetArrayComponentType() throws Exception { final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class, List.class, List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class); final Type[] types = method.getGenericParameterTypes(); Assert.assertNull(TypeUtils.getArrayComponentType(types[0])); Assert.assertNull(TypeUtils.getArrayComponentType(types[1])); Assert.assertNull(TypeUtils.getArrayComponentType(types[2])); Assert.assertNull(TypeUtils.getArrayComponentType(types[3])); Assert.assertNull(TypeUtils.getArrayComponentType(types[4])); Assert.assertNull(TypeUtils.getArrayComponentType(types[5])); Assert.assertNull(TypeUtils.getArrayComponentType(types[6])); Assert.assertEquals(types[0], TypeUtils.getArrayComponentType(types[7])); Assert.assertEquals(types[1], TypeUtils.getArrayComponentType(types[8])); Assert.assertEquals(types[2], TypeUtils.getArrayComponentType(types[9])); Assert.assertEquals(types[3], TypeUtils.getArrayComponentType(types[10])); Assert.assertEquals(types[4], TypeUtils.getArrayComponentType(types[11])); Assert.assertEquals(types[5], TypeUtils.getArrayComponentType(types[12])); Assert.assertEquals(types[6], TypeUtils.getArrayComponentType(types[13])); } @Test public void testLang820() throws Exception { final Type[] typeArray = {String.class, String.class}; final Type[] expectedArray = {String.class}; Assert.assertArrayEquals(expectedArray, TypeUtils.normalizeUpperBounds(typeArray)); } public Iterable<? extends Map<Integer, ? extends Collection<?>>> iterable; public static <G extends Comparable<G>> G stub() { return null; } public static <G extends Comparable<? super G>> G stub2() { return null; } public static <T extends Comparable<? extends T>> T stub3() { return null; } } class AAClass<T> { public class BBClass<S> { } } class AAAClass extends AAClass<String> { public class BBBClass extends BBClass<String> { } } @SuppressWarnings("rawtypes") //raw types, where used, are used purposely class AClass extends AAClass<String>.BBClass<Number> { public AClass(final AAClass<String> enclosingInstance) { enclosingInstance.super(); } public class BClass<T> { } public class CClass<T> extends BClass { } public class DClass<T> extends CClass<T> { } public class EClass<T> extends DClass { } public class FClass extends EClass<String> { } public class GClass<T extends BClass<? extends T> & AInterface<AInterface<? super T>>> { } public BClass<Number> bClass; public CClass<? extends String> cClass; public DClass<String> dClass; public EClass<String> eClass; public FClass fClass; public GClass gClass; public interface AInterface<T> { } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import org.junit.Test; import org.junit.Before; import static org.junit.Assert.*; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import java.text.ChoiceFormat; import java.text.DateFormat; import java.text.FieldPosition; import java.text.Format; import java.text.MessageFormat; import java.text.NumberFormat; import java.text.ParsePosition; import java.util.Arrays; import java.util.Calendar; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.Locale; import java.util.Map; import org.apache.commons.lang3.SystemUtils; /** * Test case for {@link ExtendedMessageFormat}. * * @since 2.4 * @version $Id$ */ public class ExtendedMessageFormatTest { private final Map<String, FormatFactory> registry = new HashMap<String, FormatFactory>(); @Before public void setUp() throws Exception { registry.put("lower", new LowerCaseFormatFactory()); registry.put("upper", new UpperCaseFormatFactory()); } /** * Test extended formats. */ @Test public void testExtendedFormats() { final String pattern = "Lower: {0,lower} Upper: {1,upper}"; final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); assertPatternsEqual("TOPATTERN", pattern, emf.toPattern()); assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] {"foo", "bar"})); assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] {"Foo", "Bar"})); assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] {"FOO", "BAR"})); assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] {"FOO", "bar"})); assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] {"foo", "BAR"})); } /** * Test Bug LANG-477 - out of memory error with escaped quote */ @Test public void testEscapedQuote_LANG_477() { final String pattern = "it''s a {0,lower} 'test'!"; final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"})); } /** * Test extended and built in formats. */ @Test public void testExtendedAndBuiltInFormats() { final Calendar cal = Calendar.getInstance(); cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")}; final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; final String extendedPattern = "Name: {0,upper} "; final String pattern = extendedPattern + builtinsPattern; final HashSet<Locale> testLocales = new HashSet<Locale>(); testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); testLocales.add(null); for (final Locale locale : testLocales) { final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); final String expectedPattern = extendedPattern + builtins.toPattern(); DateFormat df = null; NumberFormat nf = null; ExtendedMessageFormat emf = null; if (locale == null) { df = DateFormat.getDateInstance(DateFormat.SHORT); nf = NumberFormat.getCurrencyInstance(); emf = new ExtendedMessageFormat(pattern, registry); } else { df = DateFormat.getDateInstance(DateFormat.SHORT, locale); nf = NumberFormat.getCurrencyInstance(locale); emf = new ExtendedMessageFormat(pattern, locale, registry); } final StringBuilder expected = new StringBuilder(); expected.append("Name: "); expected.append(args[0].toString().toUpperCase()); expected.append(" DOB: "); expected.append(df.format(args[1])); expected.append(" Salary: "); expected.append(nf.format(args[2])); assertPatternsEqual("pattern comparison for locale " + locale, expectedPattern, emf.toPattern()); assertEquals(String.valueOf(locale), expected.toString(), emf.format(args)); } } // /** // * Test extended formats with choice format. // * // * NOTE: FAILING - currently sub-formats not supported // */ // public void testExtendedWithChoiceFormat() { // String pattern = "Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}"; // ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); // assertPatterns(null, pattern, emf.toPattern()); // try { // assertEquals("one", emf.format(new Object[] {Integer.valueOf(1), "ONE"})); // assertEquals("TWO", emf.format(new Object[] {Integer.valueOf(2), "two"})); // } catch (IllegalArgumentException e) { // // currently sub-formats not supported // } // } // /** // * Test mixed extended and built-in formats with choice format. // * // * NOTE: FAILING - currently sub-formats not supported // */ // public void testExtendedAndBuiltInWithChoiceFormat() { // String pattern = "Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}"; // Object[] lowArgs = new Object[] {Integer.valueOf(1), "Low", Double.valueOf("1234.56")}; // Object[] highArgs = new Object[] {Integer.valueOf(2), "High", Double.valueOf("9876.54")}; // Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); // Locale[] testLocales = new Locale[availableLocales.length + 1]; // testLocales[0] = null; // System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length); // for (int i = 0; i < testLocales.length; i++) { // NumberFormat nf = null; // NumberFormat cf = null; // ExtendedMessageFormat emf = null; // if (testLocales[i] == null) { // nf = NumberFormat.getNumberInstance(); // cf = NumberFormat.getCurrencyInstance(); // emf = new ExtendedMessageFormat(pattern, registry); // } else { // nf = NumberFormat.getNumberInstance(testLocales[i]); // cf = NumberFormat.getCurrencyInstance(testLocales[i]); // emf = new ExtendedMessageFormat(pattern, testLocales[i], registry); // } // assertPatterns(null, pattern, emf.toPattern()); // try { // String lowExpected = lowArgs[0] + " low " + nf.format(lowArgs[2]); // String highExpected = highArgs[0] + " HIGH " + cf.format(highArgs[2]); // assertEquals(lowExpected, emf.format(lowArgs)); // assertEquals(highExpected, emf.format(highArgs)); // } catch (IllegalArgumentException e) { // // currently sub-formats not supported // } // } // } /** * Test the built in choice format. */ @Test public void testBuiltInChoiceFormat() { final Object[] values = new Number[] {Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5")}; String choicePattern = null; final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; for (final Object value : values) { checkBuiltInFormat(value + ": " + choicePattern, new Object[] {value}, availableLocales); } choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; for (final Object value : values) { checkBuiltInFormat(value + ": " + choicePattern, new Object[] {value}, availableLocales); } } /** * Test the built in date/time formats */ @Test public void testBuiltInDateTimeFormat() { final Calendar cal = Calendar.getInstance(); cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); final Object[] args = new Object[] {cal.getTime()}; final Locale[] availableLocales = DateFormat.getAvailableLocales(); checkBuiltInFormat("1: {0,date,short}", args, availableLocales); checkBuiltInFormat("2: {0,date,medium}", args, availableLocales); checkBuiltInFormat("3: {0,date,long}", args, availableLocales); checkBuiltInFormat("4: {0,date,full}", args, availableLocales); checkBuiltInFormat("5: {0,date,d MMM yy}", args, availableLocales); checkBuiltInFormat("6: {0,time,short}", args, availableLocales); checkBuiltInFormat("7: {0,time,medium}", args, availableLocales); checkBuiltInFormat("8: {0,time,long}", args, availableLocales); checkBuiltInFormat("9: {0,time,full}", args, availableLocales); checkBuiltInFormat("10: {0,time,HH:mm}", args, availableLocales); checkBuiltInFormat("11: {0,date}", args, availableLocales); checkBuiltInFormat("12: {0,time}", args, availableLocales); } @Test public void testOverriddenBuiltinFormat() { final Calendar cal = Calendar.getInstance(); cal.set(2007, Calendar.JANUARY, 23); final Object[] args = new Object[] {cal.getTime()}; final Locale[] availableLocales = DateFormat.getAvailableLocales(); final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); //check the non-overridden builtins: checkBuiltInFormat("1: {0,date}", registry, args, availableLocales); checkBuiltInFormat("2: {0,date,medium}", registry, args, availableLocales); checkBuiltInFormat("3: {0,date,long}", registry, args, availableLocales); checkBuiltInFormat("4: {0,date,full}", registry, args, availableLocales); checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); //check the overridden format: for (int i = -1; i < availableLocales.length; i++) { final Locale locale = i < 0 ? null : availableLocales[i]; final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); final String pattern = "{0,date,short}"; final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); } } /** * Test the built in number formats. */ @Test public void testBuiltInNumberFormat() { final Object[] args = new Object[] {Double.valueOf("6543.21")}; final Locale[] availableLocales = NumberFormat.getAvailableLocales(); checkBuiltInFormat("1: {0,number}", args, availableLocales); checkBuiltInFormat("2: {0,number,integer}", args, availableLocales); checkBuiltInFormat("3: {0,number,currency}", args, availableLocales); checkBuiltInFormat("4: {0,number,percent}", args, availableLocales); checkBuiltInFormat("5: {0,number,00000.000}", args, availableLocales); } /** * Test equals() and hashcode. */ @Test public void testEqualsHashcode() { final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); final String pattern = "Pattern: {0,testfmt}"; final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); ExtendedMessageFormat other = null; // Same object assertTrue("same, equals()", emf.equals(emf)); assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); // Equal Object other = new ExtendedMessageFormat(pattern, Locale.US, registry); assertTrue("equal, equals()", emf.equals(other)); assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); // Different Class other = new OtherExtendedMessageFormat(pattern, Locale.US, registry); assertFalse("class, equals()", emf.equals(other)); assertTrue("class, hashcode()", emf.hashCode() == other.hashCode()); // same hashcode // Different pattern other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); assertFalse("pattern, equals()", emf.equals(other)); assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); // Different registry other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); assertFalse("registry, equals()", emf.equals(other)); assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); // Different Locale other = new ExtendedMessageFormat(pattern, Locale.FRANCE, registry); assertFalse("locale, equals()", emf.equals(other)); assertTrue("locale, hashcode()", emf.hashCode() == other.hashCode()); // same hashcode } /** * Test a built in format for the specified Locales, plus <code>null</code> Locale. * @param pattern MessageFormat pattern * @param args MessageFormat arguments * @param locales to test */ private void checkBuiltInFormat(final String pattern, final Object[] args, final Locale[] locales) { checkBuiltInFormat(pattern, null, args, locales); } /** * Test a built in format for the specified Locales, plus <code>null</code> Locale. * @param pattern MessageFormat pattern * @param registry FormatFactory registry to use * @param args MessageFormat arguments * @param locales to test */ private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale[] locales) { checkBuiltInFormat(pattern, registry, args, (Locale) null); for (final Locale locale : locales) { checkBuiltInFormat(pattern, registry, args, locale); } } /** * Create an ExtendedMessageFormat for the specified pattern and locale and check the * formated output matches the expected result for the parameters. * @param pattern string * @param registry map * @param args Object[] * @param locale Locale */ private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale locale) { final StringBuilder buffer = new StringBuilder(); buffer.append("Pattern=["); buffer.append(pattern); buffer.append("], locale=["); buffer.append(locale); buffer.append("]"); final MessageFormat mf = createMessageFormat(pattern, locale); // System.out.println(buffer + ", result=[" + mf.format(args) +"]"); ExtendedMessageFormat emf = null; if (locale == null) { emf = new ExtendedMessageFormat(pattern); } else { emf = new ExtendedMessageFormat(pattern, locale); } assertEquals("format " + buffer.toString(), mf.format(args), emf.format(args)); assertPatternsEqual("toPattern " + buffer.toString(), mf.toPattern(), emf.toPattern()); } //can't trust what MessageFormat does with toPattern() pre 1.4: private void assertPatternsEqual(final String message, final String expected, final String actual) { if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { assertEquals(message, expected, actual); } } /** * Replace MessageFormat(String, Locale) constructor (not available until JDK 1.4). * @param pattern string * @param locale Locale * @return MessageFormat */ private MessageFormat createMessageFormat(final String pattern, final Locale locale) { final MessageFormat result = new MessageFormat(pattern); if (locale != null) { result.setLocale(locale); result.applyPattern(pattern); } return result; } // ------------------------ Test Formats ------------------------ /** * {@link Format} implementation which converts to lower case. */ private static class LowerCaseFormat extends Format { @Override public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { return toAppendTo.append(((String)obj).toLowerCase()); } @Override public Object parseObject(final String source, final ParsePosition pos) {throw new UnsupportedOperationException();} } /** * {@link Format} implementation which converts to upper case. */ private static class UpperCaseFormat extends Format { @Override public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { return toAppendTo.append(((String)obj).toUpperCase()); } @Override public Object parseObject(final String source, final ParsePosition pos) {throw new UnsupportedOperationException();} } // ------------------------ Test Format Factories --------------- /** * {@link FormatFactory} implementation for lower case format. */ private static class LowerCaseFormatFactory implements FormatFactory { private static final Format LOWER_INSTANCE = new LowerCaseFormat(); @Override public Format getFormat(final String name, final String arguments, final Locale locale) { return LOWER_INSTANCE; } } /** * {@link FormatFactory} implementation for upper case format. */ private static class UpperCaseFormatFactory implements FormatFactory { private static final Format UPPER_INSTANCE = new UpperCaseFormat(); @Override public Format getFormat(final String name, final String arguments, final Locale locale) { return UPPER_INSTANCE; } } /** * {@link FormatFactory} implementation to override date format "short" to "default". */ private static class OverrideShortDateFormatFactory implements FormatFactory { @Override public Format getFormat(final String name, final String arguments, final Locale locale) { return !"short".equals(arguments) ? null : locale == null ? DateFormat .getDateInstance(DateFormat.DEFAULT) : DateFormat .getDateInstance(DateFormat.DEFAULT, locale); } } /** * Alternative ExtendedMessageFormat impl. */ private static class OtherExtendedMessageFormat extends ExtendedMessageFormat { public OtherExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) { super(pattern, locale, registry); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import static java.util.FormattableFlags.LEFT_JUSTIFY; import static org.junit.Assert.assertEquals; import java.util.Formatter; import org.junit.Test; /** * Unit tests {@link FormattableUtils}. * * @version $Id$ */ public class FormattableUtilsTest { @Test public void testDefaultAppend() { assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1).toString()); assertEquals("fo", FormattableUtils.append("foo", new Formatter(), 0, -1, 2).toString()); assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1).toString()); assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1).toString()); assertEquals(" fo", FormattableUtils.append("foo", new Formatter(), 0, 3, 2).toString()); assertEquals(" fo", FormattableUtils.append("foo", new Formatter(), 0, 5, 2).toString()); assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1).toString()); assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1).toString()); assertEquals("fo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2).toString()); assertEquals("fo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2).toString()); } @Test public void testAlternatePadCharacter() { final char pad='_'; assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, pad).toString()); assertEquals("fo", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, pad).toString()); assertEquals("_foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, pad).toString()); assertEquals("___foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, pad).toString()); assertEquals("_fo", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, pad).toString()); assertEquals("___fo", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, pad).toString()); assertEquals("foo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, pad).toString()); assertEquals("foo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, pad).toString()); assertEquals("fo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, pad).toString()); assertEquals("fo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, pad).toString()); } @Test public void testEllipsis() { assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, "*").toString()); assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, "*").toString()); assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, "*").toString()); assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, "*").toString()); assertEquals(" f*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, "*").toString()); assertEquals(" f*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, "*").toString()); assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, "*").toString()); assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, "*").toString()); assertEquals("f* ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, "*").toString()); assertEquals("f* ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, "*").toString()); assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, "+*").toString()); assertEquals("+*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, "+*").toString()); assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, "+*").toString()); assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, "+*").toString()); assertEquals(" +*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, "+*").toString()); assertEquals(" +*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, "+*").toString()); assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, "+*").toString()); assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, "+*").toString()); assertEquals("+* ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, "+*").toString()); assertEquals("+* ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, "+*").toString()); } @Test(expected=IllegalArgumentException.class) public void testIllegalEllipsis() { FormattableUtils.append("foo", new Formatter(), 0, -1, 1, "xx"); } @Test public void testAlternatePadCharAndEllipsis() { assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '_', "*").toString()); assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, '_', "*").toString()); assertEquals("_foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, '_', "*").toString()); assertEquals("___foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, '_', "*").toString()); assertEquals("_f*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, '_', "*").toString()); assertEquals("___f*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, '_', "*").toString()); assertEquals("foo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, '_', "*").toString()); assertEquals("foo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, '_', "*").toString()); assertEquals("f*_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, '_', "*").toString()); assertEquals("f*___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, '_', "*").toString()); assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '_', "+*").toString()); assertEquals("+*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, '_', "+*").toString()); assertEquals("_foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, '_', "+*").toString()); assertEquals("___foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, '_', "+*").toString()); assertEquals("_+*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, '_', "+*").toString()); assertEquals("___+*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, '_', "+*").toString()); assertEquals("foo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, '_', "+*").toString()); assertEquals("foo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, '_', "+*").toString()); assertEquals("+*_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, '_', "+*").toString()); assertEquals("+*___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, '_', "+*").toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import org.junit.Test; import static org.junit.Assert.*; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Iterator; import org.apache.commons.lang3.SystemUtils; /** * Unit tests for {@link org.apache.commons.lang3.text.StrBuilder}. * * @version $Id$ */ public class StrBuilderAppendInsertTest { /** The system line separator. */ private static final String SEP = SystemUtils.LINE_SEPARATOR; /** Test subclass of Object, with a toString method. */ private static final Object FOO = new Object() { @Override public String toString() { return "foo"; } }; //----------------------------------------------------------------------- @Test public void testAppendNewLine() { StrBuilder sb = new StrBuilder("---"); sb.appendNewLine().append("+++"); assertEquals("---" + SEP + "+++", sb.toString()); sb = new StrBuilder("---"); sb.setNewLineText("#").appendNewLine().setNewLineText(null).appendNewLine(); assertEquals("---#" + SEP, sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendWithNullText() { final StrBuilder sb = new StrBuilder(); sb.setNullText("NULL"); assertEquals("", sb.toString()); sb.appendNull(); assertEquals("NULL", sb.toString()); sb.append((Object) null); assertEquals("NULLNULL", sb.toString()); sb.append(FOO); assertEquals("NULLNULLfoo", sb.toString()); sb.append((String) null); assertEquals("NULLNULLfooNULL", sb.toString()); sb.append(""); assertEquals("NULLNULLfooNULL", sb.toString()); sb.append("bar"); assertEquals("NULLNULLfooNULLbar", sb.toString()); sb.append((StringBuffer) null); assertEquals("NULLNULLfooNULLbarNULL", sb.toString()); sb.append(new StringBuffer("baz")); assertEquals("NULLNULLfooNULLbarNULLbaz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_Object() { final StrBuilder sb = new StrBuilder(); sb.appendNull(); assertEquals("", sb.toString()); sb.append((Object) null); assertEquals("", sb.toString()); sb.append(FOO); assertEquals("foo", sb.toString()); sb.append((StringBuffer) null); assertEquals("foo", sb.toString()); sb.append(new StringBuffer("baz")); assertEquals("foobaz", sb.toString()); sb.append(new StrBuilder("yes")); assertEquals("foobazyes", sb.toString()); sb.append((CharSequence) "Seq"); assertEquals("foobazyesSeq", sb.toString()); sb.append(new StringBuilder("bld")); // Check it supports StringBuilder assertEquals("foobazyesSeqbld", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_StringBuilder() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((String) null); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new StringBuilder("foo")); assertEquals("foo", sb.toString()); sb.append(new StringBuilder("")); assertEquals("foo", sb.toString()); sb.append(new StringBuilder("bar")); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_String() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((String) null); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append("foo"); assertEquals("foo", sb.toString()); sb.append(""); assertEquals("foo", sb.toString()); sb.append("bar"); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_String_int_int() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((String) null, 0, 1); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append("foo", 0, 3); assertEquals("foo", sb.toString()); try { sb.append("bar", -1, 1); fail("append(char[], -1,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append("bar", 3, 1); fail("append(char[], 3,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append("bar", 1, -1); fail("append(char[],, -1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append("bar", 1, 3); fail("append(char[], 1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append("bar", -1, 3); fail("append(char[], -1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append("bar", 4, 0); fail("append(char[], 4, 0) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append("bar", 3, 0); assertEquals("foo", sb.toString()); sb.append("abcbardef", 3, 3); assertEquals("foobar", sb.toString()); sb.append( (CharSequence)"abcbardef", 4, 3); assertEquals("foobarard", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_StringBuilder_int_int() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((String) null, 0, 1); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new StringBuilder("foo"), 0, 3); assertEquals("foo", sb.toString()); try { sb.append(new StringBuilder("bar"), -1, 1); fail("append(StringBuilder, -1,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuilder("bar"), 3, 1); fail("append(StringBuilder, 3,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuilder("bar"), 1, -1); fail("append(StringBuilder,, -1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuilder("bar"), 1, 3); fail("append(StringBuilder, 1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuilder("bar"), -1, 3); fail("append(StringBuilder, -1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuilder("bar"), 4, 0); fail("append(StringBuilder, 4, 0) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append(new StringBuilder("bar"), 3, 0); assertEquals("foo", sb.toString()); sb.append(new StringBuilder("abcbardef"), 3, 3); assertEquals("foobar", sb.toString()); sb.append( new StringBuilder("abcbardef"), 4, 3); assertEquals("foobarard", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_StringBuffer() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((StringBuffer) null); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new StringBuffer("foo")); assertEquals("foo", sb.toString()); sb.append(new StringBuffer("")); assertEquals("foo", sb.toString()); sb.append(new StringBuffer("bar")); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_StringBuffer_int_int() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((StringBuffer) null, 0, 1); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new StringBuffer("foo"), 0, 3); assertEquals("foo", sb.toString()); try { sb.append(new StringBuffer("bar"), -1, 1); fail("append(char[], -1,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuffer("bar"), 3, 1); fail("append(char[], 3,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuffer("bar"), 1, -1); fail("append(char[],, -1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuffer("bar"), 1, 3); fail("append(char[], 1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuffer("bar"), -1, 3); fail("append(char[], -1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StringBuffer("bar"), 4, 0); fail("append(char[], 4, 0) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append(new StringBuffer("bar"), 3, 0); assertEquals("foo", sb.toString()); sb.append(new StringBuffer("abcbardef"), 3, 3); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_StrBuilder() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((StrBuilder) null); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new StrBuilder("foo")); assertEquals("foo", sb.toString()); sb.append(new StrBuilder("")); assertEquals("foo", sb.toString()); sb.append(new StrBuilder("bar")); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_StrBuilder_int_int() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((StrBuilder) null, 0, 1); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new StrBuilder("foo"), 0, 3); assertEquals("foo", sb.toString()); try { sb.append(new StrBuilder("bar"), -1, 1); fail("append(char[], -1,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StrBuilder("bar"), 3, 1); fail("append(char[], 3,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StrBuilder("bar"), 1, -1); fail("append(char[],, -1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StrBuilder("bar"), 1, 3); fail("append(char[], 1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StrBuilder("bar"), -1, 3); fail("append(char[], -1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new StrBuilder("bar"), 4, 0); fail("append(char[], 4, 0) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append(new StrBuilder("bar"), 3, 0); assertEquals("foo", sb.toString()); sb.append(new StrBuilder("abcbardef"), 3, 3); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_CharArray() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((char[]) null); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new char[0]); assertEquals("", sb.toString()); sb.append(new char[]{'f', 'o', 'o'}); assertEquals("foo", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_CharArray_int_int() { StrBuilder sb = new StrBuilder(); sb.setNullText("NULL").append((char[]) null, 0, 1); assertEquals("NULL", sb.toString()); sb = new StrBuilder(); sb.append(new char[]{'f', 'o', 'o'}, 0, 3); assertEquals("foo", sb.toString()); try { sb.append(new char[]{'b', 'a', 'r'}, -1, 1); fail("append(char[], -1,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new char[]{'b', 'a', 'r'}, 3, 1); fail("append(char[], 3,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new char[]{'b', 'a', 'r'}, 1, -1); fail("append(char[],, -1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new char[]{'b', 'a', 'r'}, 1, 3); fail("append(char[], 1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new char[]{'b', 'a', 'r'}, -1, 3); fail("append(char[], -1, 3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.append(new char[]{'b', 'a', 'r'}, 4, 0); fail("append(char[], 4, 0) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append(new char[]{'b', 'a', 'r'}, 3, 0); assertEquals("foo", sb.toString()); sb.append(new char[]{'a', 'b', 'c', 'b', 'a', 'r', 'd', 'e', 'f'}, 3, 3); assertEquals("foobar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_Boolean() { final StrBuilder sb = new StrBuilder(); sb.append(true); assertEquals("true", sb.toString()); sb.append(false); assertEquals("truefalse", sb.toString()); sb.append('!'); assertEquals("truefalse!", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_PrimitiveNumber() { final StrBuilder sb = new StrBuilder(); sb.append(0); assertEquals("0", sb.toString()); sb.append(1L); assertEquals("01", sb.toString()); sb.append(2.3f); assertEquals("012.3", sb.toString()); sb.append(4.5d); assertEquals("012.34.5", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendln_FormattedString() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final String str) { count[0]++; return super.append(str); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln("Hello %s", "Alice"); assertEquals("Hello Alice" + SEP, sb.toString()); assertEquals(2, count[0]); // appendNewLine() calls append(String) assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_Object() { final StrBuilder sb = new StrBuilder(); sb.appendln((Object) null); assertEquals("" + SEP, sb.toString()); sb.appendln(FOO); assertEquals(SEP + "foo" + SEP, sb.toString()); sb.appendln(Integer.valueOf(6)); assertEquals(SEP + "foo" + SEP + "6" + SEP, sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendln_String() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final String str) { count[0]++; return super.append(str); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln("foo"); assertEquals("foo" + SEP, sb.toString()); assertEquals(2, count[0]); // appendNewLine() calls append(String) assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_String_int_int() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final String str, final int startIndex, final int length) { count[0]++; return super.append(str, startIndex, length); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln("foo", 0, 3); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_StringBuffer() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final StringBuffer str) { count[0]++; return super.append(str); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln(new StringBuffer("foo")); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_StringBuilder() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final StringBuilder str) { count[0]++; return super.append(str); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln(new StringBuilder("foo")); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_StringBuffer_int_int() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final StringBuffer str, final int startIndex, final int length) { count[0]++; return super.append(str, startIndex, length); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln(new StringBuffer("foo"), 0, 3); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_StringBuilder_int_int() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { count[0]++; return super.append(str, startIndex, length); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln(new StringBuilder("foo"), 0, 3); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_StrBuilder() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final StrBuilder str) { count[0]++; return super.append(str); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln(new StrBuilder("foo")); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_StrBuilder_int_int() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { count[0]++; return super.append(str, startIndex, length); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln(new StrBuilder("foo"), 0, 3); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_CharArray() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final char[] str) { count[0]++; return super.append(str); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln("foo".toCharArray()); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_CharArray_int_int() { final int[] count = new int[2]; final StrBuilder sb = new StrBuilder() { @Override public StrBuilder append(final char[] str, final int startIndex, final int length) { count[0]++; return super.append(str, startIndex, length); } @Override public StrBuilder appendNewLine() { count[1]++; return super.appendNewLine(); } }; sb.appendln("foo".toCharArray(), 0, 3); assertEquals("foo" + SEP, sb.toString()); assertEquals(1, count[0]); assertEquals(1, count[1]); } //----------------------------------------------------------------------- @Test public void testAppendln_Boolean() { final StrBuilder sb = new StrBuilder(); sb.appendln(true); assertEquals("true" + SEP, sb.toString()); sb.clear(); sb.appendln(false); assertEquals("false" + SEP, sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendln_PrimitiveNumber() { final StrBuilder sb = new StrBuilder(); sb.appendln(0); assertEquals("0" + SEP, sb.toString()); sb.clear(); sb.appendln(1L); assertEquals("1" + SEP, sb.toString()); sb.clear(); sb.appendln(2.3f); assertEquals("2.3" + SEP, sb.toString()); sb.clear(); sb.appendln(4.5d); assertEquals("4.5" + SEP, sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendPadding() { final StrBuilder sb = new StrBuilder(); sb.append("foo"); assertEquals("foo", sb.toString()); sb.appendPadding(-1, '-'); assertEquals("foo", sb.toString()); sb.appendPadding(0, '-'); assertEquals("foo", sb.toString()); sb.appendPadding(1, '-'); assertEquals("foo-", sb.toString()); sb.appendPadding(16, '-'); assertEquals(20, sb.length()); // 12345678901234567890 assertEquals("foo-----------------", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendFixedWidthPadLeft() { final StrBuilder sb = new StrBuilder(); sb.appendFixedWidthPadLeft("foo", -1, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft("foo", 0, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft("foo", 1, '-'); assertEquals("o", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft("foo", 2, '-'); assertEquals("oo", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft("foo", 3, '-'); assertEquals("foo", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft("foo", 4, '-'); assertEquals("-foo", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft("foo", 10, '-'); assertEquals(10, sb.length()); // 1234567890 assertEquals("-------foo", sb.toString()); sb.clear(); sb.setNullText("null"); sb.appendFixedWidthPadLeft(null, 5, '-'); assertEquals("-null", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendFixedWidthPadLeft_int() { final StrBuilder sb = new StrBuilder(); sb.appendFixedWidthPadLeft(123, -1, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft(123, 0, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft(123, 1, '-'); assertEquals("3", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft(123, 2, '-'); assertEquals("23", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft(123, 3, '-'); assertEquals("123", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft(123, 4, '-'); assertEquals("-123", sb.toString()); sb.clear(); sb.appendFixedWidthPadLeft(123, 10, '-'); assertEquals(10, sb.length()); // 1234567890 assertEquals("-------123", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendFixedWidthPadRight() { final StrBuilder sb = new StrBuilder(); sb.appendFixedWidthPadRight("foo", -1, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight("foo", 0, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight("foo", 1, '-'); assertEquals("f", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight("foo", 2, '-'); assertEquals("fo", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight("foo", 3, '-'); assertEquals("foo", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight("foo", 4, '-'); assertEquals("foo-", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight("foo", 10, '-'); assertEquals(10, sb.length()); // 1234567890 assertEquals("foo-------", sb.toString()); sb.clear(); sb.setNullText("null"); sb.appendFixedWidthPadRight(null, 5, '-'); assertEquals("null-", sb.toString()); } // See: http://issues.apache.org/jira/browse/LANG-299 @Test public void testLang299() { final StrBuilder sb = new StrBuilder(1); sb.appendFixedWidthPadRight("foo", 1, '-'); assertEquals("f", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendFixedWidthPadRight_int() { final StrBuilder sb = new StrBuilder(); sb.appendFixedWidthPadRight(123, -1, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight(123, 0, '-'); assertEquals("", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight(123, 1, '-'); assertEquals("1", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight(123, 2, '-'); assertEquals("12", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight(123, 3, '-'); assertEquals("123", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight(123, 4, '-'); assertEquals("123-", sb.toString()); sb.clear(); sb.appendFixedWidthPadRight(123, 10, '-'); assertEquals(10, sb.length()); // 1234567890 assertEquals("123-------", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppend_FormattedString() { StrBuilder sb; sb = new StrBuilder(); sb.append("Hi", (Object[]) null); assertEquals("Hi", sb.toString()); sb = new StrBuilder(); sb.append("Hi", "Alice"); assertEquals("Hi", sb.toString()); sb = new StrBuilder(); sb.append("Hi %s", "Alice"); assertEquals("Hi Alice", sb.toString()); sb = new StrBuilder(); sb.append("Hi %s %,d", "Alice", 5000); assertEquals("Hi Alice 5,000", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendAll_Array() { final StrBuilder sb = new StrBuilder(); sb.appendAll((Object[]) null); assertEquals("", sb.toString()); sb.clear(); sb.appendAll(new Object[0]); assertEquals("", sb.toString()); sb.clear(); sb.appendAll(new Object[]{"foo", "bar", "baz"}); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.appendAll("foo", "bar", "baz"); assertEquals("foobarbaz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendAll_Collection() { final StrBuilder sb = new StrBuilder(); sb.appendAll((Collection<?>) null); assertEquals("", sb.toString()); sb.clear(); sb.appendAll(Collections.EMPTY_LIST); assertEquals("", sb.toString()); sb.clear(); sb.appendAll(Arrays.asList(new Object[]{"foo", "bar", "baz"})); assertEquals("foobarbaz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendAll_Iterator() { final StrBuilder sb = new StrBuilder(); sb.appendAll((Iterator<?>) null); assertEquals("", sb.toString()); sb.clear(); sb.appendAll(Collections.EMPTY_LIST.iterator()); assertEquals("", sb.toString()); sb.clear(); sb.appendAll(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator()); assertEquals("foobarbaz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendWithSeparators_Array() { final StrBuilder sb = new StrBuilder(); sb.appendWithSeparators((Object[]) null, ","); assertEquals("", sb.toString()); sb.clear(); sb.appendWithSeparators(new Object[0], ","); assertEquals("", sb.toString()); sb.clear(); sb.appendWithSeparators(new Object[]{"foo", "bar", "baz"}, ","); assertEquals("foo,bar,baz", sb.toString()); sb.clear(); sb.appendWithSeparators(new Object[]{"foo", "bar", "baz"}, null); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.appendWithSeparators(new Object[]{"foo", null, "baz"}, ","); assertEquals("foo,,baz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendWithSeparators_Collection() { final StrBuilder sb = new StrBuilder(); sb.appendWithSeparators((Collection<?>) null, ","); assertEquals("", sb.toString()); sb.clear(); sb.appendWithSeparators(Collections.EMPTY_LIST, ","); assertEquals("", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}), ","); assertEquals("foo,bar,baz", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}), null); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}), ","); assertEquals("foo,,baz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendWithSeparators_Iterator() { final StrBuilder sb = new StrBuilder(); sb.appendWithSeparators((Iterator<?>) null, ","); assertEquals("", sb.toString()); sb.clear(); sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ","); assertEquals("", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), ","); assertEquals("foo,bar,baz", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), null); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}).iterator(), ","); assertEquals("foo,,baz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendWithSeparatorsWithNullText() { final StrBuilder sb = new StrBuilder(); sb.setNullText("null"); sb.appendWithSeparators(new Object[]{"foo", null, "baz"}, ","); assertEquals("foo,null,baz", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}), ","); assertEquals("foo,null,baz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendSeparator_String() { final StrBuilder sb = new StrBuilder(); sb.appendSeparator(","); // no effect assertEquals("", sb.toString()); sb.append("foo"); assertEquals("foo", sb.toString()); sb.appendSeparator(","); assertEquals("foo,", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendSeparator_String_String() { final StrBuilder sb = new StrBuilder(); final String startSeparator = "order by "; final String standardSeparator = ","; final String foo = "foo"; sb.appendSeparator(null, null); assertEquals("", sb.toString()); sb.appendSeparator(standardSeparator, null); assertEquals("", sb.toString()); sb.appendSeparator(standardSeparator, startSeparator); assertEquals(startSeparator, sb.toString()); sb.appendSeparator(null, null); assertEquals(startSeparator, sb.toString()); sb.appendSeparator(null, startSeparator); assertEquals(startSeparator, sb.toString()); sb.append(foo); assertEquals(startSeparator + foo, sb.toString()); sb.appendSeparator(standardSeparator, startSeparator); assertEquals(startSeparator + foo + standardSeparator, sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendSeparator_char() { final StrBuilder sb = new StrBuilder(); sb.appendSeparator(','); // no effect assertEquals("", sb.toString()); sb.append("foo"); assertEquals("foo", sb.toString()); sb.appendSeparator(','); assertEquals("foo,", sb.toString()); } @Test public void testAppendSeparator_char_char() { final StrBuilder sb = new StrBuilder(); final char startSeparator = ':'; final char standardSeparator = ','; final String foo = "foo"; sb.appendSeparator(standardSeparator, startSeparator); // no effect assertEquals(String.valueOf(startSeparator), sb.toString()); sb.append(foo); assertEquals(String.valueOf(startSeparator) + foo, sb.toString()); sb.appendSeparator(standardSeparator, startSeparator); assertEquals(String.valueOf(startSeparator) + foo + standardSeparator, sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendSeparator_String_int() { final StrBuilder sb = new StrBuilder(); sb.appendSeparator(",", 0); // no effect assertEquals("", sb.toString()); sb.append("foo"); assertEquals("foo", sb.toString()); sb.appendSeparator(",", 1); assertEquals("foo,", sb.toString()); sb.appendSeparator(",", -1); // no effect assertEquals("foo,", sb.toString()); } //----------------------------------------------------------------------- @Test public void testAppendSeparator_char_int() { final StrBuilder sb = new StrBuilder(); sb.appendSeparator(',', 0); // no effect assertEquals("", sb.toString()); sb.append("foo"); assertEquals("foo", sb.toString()); sb.appendSeparator(',', 1); assertEquals("foo,", sb.toString()); sb.appendSeparator(',', -1); // no effect assertEquals("foo,", sb.toString()); } //----------------------------------------------------------------------- @Test public void testInsert() { final StrBuilder sb = new StrBuilder(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, FOO); fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, FOO); fail("insert(7, Object) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, (Object) null); assertEquals("barbaz", sb.toString()); sb.insert(0, FOO); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, "foo"); fail("insert(-1, String) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, "foo"); fail("insert(7, String) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, (String) null); assertEquals("barbaz", sb.toString()); sb.insert(0, "foo"); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, new char[]{'f', 'o', 'o'}); fail("insert(-1, char[]) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, new char[]{'f', 'o', 'o'}); fail("insert(7, char[]) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, (char[]) null); assertEquals("barbaz", sb.toString()); sb.insert(0, new char[0]); assertEquals("barbaz", sb.toString()); sb.insert(0, new char[]{'f', 'o', 'o'}); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, (char[]) null, 0, 0); assertEquals("barbaz", sb.toString()); sb.insert(0, new char[0], 0, 0); assertEquals("barbaz", sb.toString()); try { sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3); fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3); fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1); fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10); fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0); assertEquals("barbaz", sb.toString()); sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3); assertEquals("foobarbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, true); fail("insert(-1, boolean) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, true); fail("insert(7, boolean) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, true); assertEquals("truebarbaz", sb.toString()); sb.insert(0, false); assertEquals("falsetruebarbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, '!'); fail("insert(-1, char) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, '!'); fail("insert(7, char) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, '!'); assertEquals("!barbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, 0); fail("insert(-1, int) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, 0); fail("insert(7, int) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, '0'); assertEquals("0barbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, 1L); fail("insert(-1, long) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, 1L); fail("insert(7, long) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, 1L); assertEquals("1barbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, 2.3F); fail("insert(-1, float) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, 2.3F); fail("insert(7, float) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, 2.3F); assertEquals("2.3barbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, 4.5D); fail("insert(-1, double) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, 4.5D); fail("insert(7, double) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, 4.5D); assertEquals("4.5barbaz", sb.toString()); } //----------------------------------------------------------------------- @Test public void testInsertWithNullText() { final StrBuilder sb = new StrBuilder(); sb.setNullText("null"); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, FOO); fail("insert(-1, Object) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, FOO); fail("insert(7, Object) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, (Object) null); assertEquals("nullbarbaz", sb.toString()); sb.insert(0, FOO); assertEquals("foonullbarbaz", sb.toString()); sb.clear(); sb.append("barbaz"); assertEquals("barbaz", sb.toString()); try { sb.insert(-1, "foo"); fail("insert(-1, String) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.insert(7, "foo"); fail("insert(7, String) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.insert(0, (String) null); assertEquals("nullbarbaz", sb.toString()); sb.insert(0, "foo"); assertEquals("foonullbarbaz", sb.toString()); sb.insert(0, (char[]) null); assertEquals("nullfoonullbarbaz", sb.toString()); sb.insert(0, (char[]) null, 0, 0); assertEquals("nullnullfoonullbarbaz", sb.toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import org.junit.Test; import static org.junit.Assert.*; import java.io.Reader; import java.io.Writer; import java.util.Arrays; import org.apache.commons.lang3.ArrayUtils; /** * Unit tests for {@link org.apache.commons.lang3.text.StrBuilder}. * * @version $Id$ */ public class StrBuilderTest { //----------------------------------------------------------------------- @Test public void testConstructors() { final StrBuilder sb0 = new StrBuilder(); assertEquals(32, sb0.capacity()); assertEquals(0, sb0.length()); assertEquals(0, sb0.size()); final StrBuilder sb1 = new StrBuilder(32); assertEquals(32, sb1.capacity()); assertEquals(0, sb1.length()); assertEquals(0, sb1.size()); final StrBuilder sb2 = new StrBuilder(0); assertEquals(32, sb2.capacity()); assertEquals(0, sb2.length()); assertEquals(0, sb2.size()); final StrBuilder sb3 = new StrBuilder(-1); assertEquals(32, sb3.capacity()); assertEquals(0, sb3.length()); assertEquals(0, sb3.size()); final StrBuilder sb4 = new StrBuilder(1); assertEquals(1, sb4.capacity()); assertEquals(0, sb4.length()); assertEquals(0, sb4.size()); final StrBuilder sb5 = new StrBuilder((String) null); assertEquals(32, sb5.capacity()); assertEquals(0, sb5.length()); assertEquals(0, sb5.size()); final StrBuilder sb6 = new StrBuilder(""); assertEquals(32, sb6.capacity()); assertEquals(0, sb6.length()); assertEquals(0, sb6.size()); final StrBuilder sb7 = new StrBuilder("foo"); assertEquals(35, sb7.capacity()); assertEquals(3, sb7.length()); assertEquals(3, sb7.size()); } //----------------------------------------------------------------------- @Test public void testChaining() { final StrBuilder sb = new StrBuilder(); assertSame(sb, sb.setNewLineText(null)); assertSame(sb, sb.setNullText(null)); assertSame(sb, sb.setLength(1)); assertSame(sb, sb.setCharAt(0, 'a')); assertSame(sb, sb.ensureCapacity(0)); assertSame(sb, sb.minimizeCapacity()); assertSame(sb, sb.clear()); assertSame(sb, sb.reverse()); assertSame(sb, sb.trim()); } //----------------------------------------------------------------------- @Test public void testGetSetNewLineText() { final StrBuilder sb = new StrBuilder(); assertEquals(null, sb.getNewLineText()); sb.setNewLineText("#"); assertEquals("#", sb.getNewLineText()); sb.setNewLineText(""); assertEquals("", sb.getNewLineText()); sb.setNewLineText((String) null); assertEquals(null, sb.getNewLineText()); } //----------------------------------------------------------------------- @Test public void testGetSetNullText() { final StrBuilder sb = new StrBuilder(); assertEquals(null, sb.getNullText()); sb.setNullText("null"); assertEquals("null", sb.getNullText()); sb.setNullText(""); assertEquals(null, sb.getNullText()); sb.setNullText("NULL"); assertEquals("NULL", sb.getNullText()); sb.setNullText((String) null); assertEquals(null, sb.getNullText()); } //----------------------------------------------------------------------- @Test public void testCapacityAndLength() { final StrBuilder sb = new StrBuilder(); assertEquals(32, sb.capacity()); assertEquals(0, sb.length()); assertEquals(0, sb.size()); assertTrue(sb.isEmpty()); sb.minimizeCapacity(); assertEquals(0, sb.capacity()); assertEquals(0, sb.length()); assertEquals(0, sb.size()); assertTrue(sb.isEmpty()); sb.ensureCapacity(32); assertTrue(sb.capacity() >= 32); assertEquals(0, sb.length()); assertEquals(0, sb.size()); assertTrue(sb.isEmpty()); sb.append("foo"); assertTrue(sb.capacity() >= 32); assertEquals(3, sb.length()); assertEquals(3, sb.size()); assertTrue(sb.isEmpty() == false); sb.clear(); assertTrue(sb.capacity() >= 32); assertEquals(0, sb.length()); assertEquals(0, sb.size()); assertTrue(sb.isEmpty()); sb.append("123456789012345678901234567890123"); assertTrue(sb.capacity() > 32); assertEquals(33, sb.length()); assertEquals(33, sb.size()); assertTrue(sb.isEmpty() == false); sb.ensureCapacity(16); assertTrue(sb.capacity() > 16); assertEquals(33, sb.length()); assertEquals(33, sb.size()); assertTrue(sb.isEmpty() == false); sb.minimizeCapacity(); assertEquals(33, sb.capacity()); assertEquals(33, sb.length()); assertEquals(33, sb.size()); assertTrue(sb.isEmpty() == false); try { sb.setLength(-1); fail("setLength(-1) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.setLength(33); assertEquals(33, sb.capacity()); assertEquals(33, sb.length()); assertEquals(33, sb.size()); assertTrue(sb.isEmpty() == false); sb.setLength(16); assertTrue(sb.capacity() >= 16); assertEquals(16, sb.length()); assertEquals(16, sb.size()); assertEquals("1234567890123456", sb.toString()); assertTrue(sb.isEmpty() == false); sb.setLength(32); assertTrue(sb.capacity() >= 32); assertEquals(32, sb.length()); assertEquals(32, sb.size()); assertEquals("1234567890123456\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", sb.toString()); assertTrue(sb.isEmpty() == false); sb.setLength(0); assertTrue(sb.capacity() >= 32); assertEquals(0, sb.length()); assertEquals(0, sb.size()); assertTrue(sb.isEmpty()); } //----------------------------------------------------------------------- @Test public void testLength() { final StrBuilder sb = new StrBuilder(); assertEquals(0, sb.length()); sb.append("Hello"); assertEquals(5, sb.length()); } @Test public void testSetLength() { final StrBuilder sb = new StrBuilder(); sb.append("Hello"); sb.setLength(2); // shorten assertEquals("He", sb.toString()); sb.setLength(2); // no change assertEquals("He", sb.toString()); sb.setLength(3); // lengthen assertEquals("He\0", sb.toString()); try { sb.setLength(-1); fail("setLength(-1) expected StringIndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } } //----------------------------------------------------------------------- @Test public void testCapacity() { final StrBuilder sb = new StrBuilder(); assertEquals(sb.buffer.length, sb.capacity()); sb.append("HelloWorldHelloWorldHelloWorldHelloWorld"); assertEquals(sb.buffer.length, sb.capacity()); } @Test public void testEnsureCapacity() { final StrBuilder sb = new StrBuilder(); sb.ensureCapacity(2); assertTrue(sb.capacity() >= 2); sb.ensureCapacity(-1); assertTrue(sb.capacity() >= 0); sb.append("HelloWorld"); sb.ensureCapacity(40); assertTrue(sb.capacity() >= 40); } @Test public void testMinimizeCapacity() { final StrBuilder sb = new StrBuilder(); sb.minimizeCapacity(); assertEquals(0, sb.capacity()); sb.append("HelloWorld"); sb.minimizeCapacity(); assertEquals(10, sb.capacity()); } //----------------------------------------------------------------------- @Test public void testSize() { final StrBuilder sb = new StrBuilder(); assertEquals(0, sb.size()); sb.append("Hello"); assertEquals(5, sb.size()); } @Test public void testIsEmpty() { final StrBuilder sb = new StrBuilder(); assertTrue(sb.isEmpty()); sb.append("Hello"); assertFalse(sb.isEmpty()); sb.clear(); assertTrue(sb.isEmpty()); } @Test public void testClear() { final StrBuilder sb = new StrBuilder(); sb.append("Hello"); sb.clear(); assertEquals(0, sb.length()); assertTrue(sb.buffer.length >= 5); } //----------------------------------------------------------------------- @Test public void testCharAt() { final StrBuilder sb = new StrBuilder(); try { sb.charAt(0); fail("charAt(0) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.charAt(-1); fail("charAt(-1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append("foo"); assertEquals('f', sb.charAt(0)); assertEquals('o', sb.charAt(1)); assertEquals('o', sb.charAt(2)); try { sb.charAt(-1); fail("charAt(-1) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.charAt(3); fail("charAt(3) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } } //----------------------------------------------------------------------- @Test public void testSetCharAt() { final StrBuilder sb = new StrBuilder(); try { sb.setCharAt(0, 'f'); fail("setCharAt(0,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } try { sb.setCharAt(-1, 'f'); fail("setCharAt(-1,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } sb.append("foo"); sb.setCharAt(0, 'b'); sb.setCharAt(1, 'a'); sb.setCharAt(2, 'r'); try { sb.setCharAt(3, '!'); fail("setCharAt(3,) expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { // expected } assertEquals("bar", sb.toString()); } //----------------------------------------------------------------------- @Test public void testDeleteCharAt() { final StrBuilder sb = new StrBuilder("abc"); sb.deleteCharAt(0); assertEquals("bc", sb.toString()); try { sb.deleteCharAt(1000); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} } //----------------------------------------------------------------------- @Test public void testToCharArray() { final StrBuilder sb = new StrBuilder(); assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray()); char[] a = sb.toCharArray(); assertNotNull("toCharArray() result is null", a); assertEquals("toCharArray() result is too large", 0, a.length); sb.append("junit"); a = sb.toCharArray(); assertEquals("toCharArray() result incorrect length", 5, a.length); assertTrue("toCharArray() result does not match", Arrays.equals("junit".toCharArray(), a)); } @Test public void testToCharArrayIntInt() { final StrBuilder sb = new StrBuilder(); assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0)); sb.append("junit"); char[] a = sb.toCharArray(0, 20); // too large test assertEquals("toCharArray(int,int) result incorrect length", 5, a.length); assertTrue("toCharArray(int,int) result does not match", Arrays.equals("junit".toCharArray(), a)); a = sb.toCharArray(0, 4); assertEquals("toCharArray(int,int) result incorrect length", 4, a.length); assertTrue("toCharArray(int,int) result does not match", Arrays.equals("juni".toCharArray(), a)); a = sb.toCharArray(0, 4); assertEquals("toCharArray(int,int) result incorrect length", 4, a.length); assertTrue("toCharArray(int,int) result does not match", Arrays.equals("juni".toCharArray(), a)); a = sb.toCharArray(0, 1); assertNotNull("toCharArray(int,int) result is null", a); try { sb.toCharArray(-1, 5); fail("no string index out of bound on -1"); } catch (final IndexOutOfBoundsException e) { } try { sb.toCharArray(6, 5); fail("no string index out of bound on -1"); } catch (final IndexOutOfBoundsException e) { } } @Test public void testGetChars ( ) { final StrBuilder sb = new StrBuilder(); char[] input = new char[10]; char[] a = sb.getChars(input); assertSame (input, a); assertTrue(Arrays.equals(new char[10], a)); sb.append("junit"); a = sb.getChars(input); assertSame(input, a); assertTrue(Arrays.equals(new char[] {'j','u','n','i','t',0,0,0,0,0},a)); a = sb.getChars(null); assertNotSame(input,a); assertEquals(5,a.length); assertTrue(Arrays.equals("junit".toCharArray(),a)); input = new char[5]; a = sb.getChars(input); assertSame(input, a); input = new char[4]; a = sb.getChars(input); assertNotSame(input, a); } @Test public void testGetCharsIntIntCharArrayInt( ) { final StrBuilder sb = new StrBuilder(); sb.append("junit"); char[] a = new char[5]; sb.getChars(0,5,a,0); assertTrue(Arrays.equals(new char[] {'j','u','n','i','t'},a)); a = new char[5]; sb.getChars(0,2,a,3); assertTrue(Arrays.equals(new char[] {0,0,0,'j','u'},a)); try { sb.getChars(-1,0,a,0); fail("no exception"); } catch (final IndexOutOfBoundsException e) { } try { sb.getChars(0,-1,a,0); fail("no exception"); } catch (final IndexOutOfBoundsException e) { } try { sb.getChars(0,20,a,0); fail("no exception"); } catch (final IndexOutOfBoundsException e) { } try { sb.getChars(4,2,a,0); fail("no exception"); } catch (final IndexOutOfBoundsException e) { } } //----------------------------------------------------------------------- @Test public void testDeleteIntInt() { StrBuilder sb = new StrBuilder("abc"); sb.delete(0, 1); assertEquals("bc", sb.toString()); sb.delete(1, 2); assertEquals("b", sb.toString()); sb.delete(0, 1); assertEquals("", sb.toString()); sb.delete(0, 1000); assertEquals("", sb.toString()); try { sb.delete(1, 2); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} try { sb.delete(-1, 1); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} sb = new StrBuilder("anything"); try { sb.delete(2, 1); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} } //----------------------------------------------------------------------- @Test public void testDeleteAll_char() { StrBuilder sb = new StrBuilder("abcbccba"); sb.deleteAll('X'); assertEquals("abcbccba", sb.toString()); sb.deleteAll('a'); assertEquals("bcbccb", sb.toString()); sb.deleteAll('c'); assertEquals("bbb", sb.toString()); sb.deleteAll('b'); assertEquals("", sb.toString()); sb = new StrBuilder(""); sb.deleteAll('b'); assertEquals("", sb.toString()); } @Test public void testDeleteFirst_char() { StrBuilder sb = new StrBuilder("abcba"); sb.deleteFirst('X'); assertEquals("abcba", sb.toString()); sb.deleteFirst('a'); assertEquals("bcba", sb.toString()); sb.deleteFirst('c'); assertEquals("bba", sb.toString()); sb.deleteFirst('b'); assertEquals("ba", sb.toString()); sb = new StrBuilder(""); sb.deleteFirst('b'); assertEquals("", sb.toString()); } // ----------------------------------------------------------------------- @Test public void testDeleteAll_String() { StrBuilder sb = new StrBuilder("abcbccba"); sb.deleteAll((String) null); assertEquals("abcbccba", sb.toString()); sb.deleteAll(""); assertEquals("abcbccba", sb.toString()); sb.deleteAll("X"); assertEquals("abcbccba", sb.toString()); sb.deleteAll("a"); assertEquals("bcbccb", sb.toString()); sb.deleteAll("c"); assertEquals("bbb", sb.toString()); sb.deleteAll("b"); assertEquals("", sb.toString()); sb = new StrBuilder("abcbccba"); sb.deleteAll("bc"); assertEquals("acba", sb.toString()); sb = new StrBuilder(""); sb.deleteAll("bc"); assertEquals("", sb.toString()); } @Test public void testDeleteFirst_String() { StrBuilder sb = new StrBuilder("abcbccba"); sb.deleteFirst((String) null); assertEquals("abcbccba", sb.toString()); sb.deleteFirst(""); assertEquals("abcbccba", sb.toString()); sb.deleteFirst("X"); assertEquals("abcbccba", sb.toString()); sb.deleteFirst("a"); assertEquals("bcbccba", sb.toString()); sb.deleteFirst("c"); assertEquals("bbccba", sb.toString()); sb.deleteFirst("b"); assertEquals("bccba", sb.toString()); sb = new StrBuilder("abcbccba"); sb.deleteFirst("bc"); assertEquals("abccba", sb.toString()); sb = new StrBuilder(""); sb.deleteFirst("bc"); assertEquals("", sb.toString()); } // ----------------------------------------------------------------------- @Test public void testDeleteAll_StrMatcher() { StrBuilder sb = new StrBuilder("A0xA1A2yA3"); sb.deleteAll((StrMatcher) null); assertEquals("A0xA1A2yA3", sb.toString()); sb.deleteAll(A_NUMBER_MATCHER); assertEquals("xy", sb.toString()); sb = new StrBuilder("Ax1"); sb.deleteAll(A_NUMBER_MATCHER); assertEquals("Ax1", sb.toString()); sb = new StrBuilder(""); sb.deleteAll(A_NUMBER_MATCHER); assertEquals("", sb.toString()); } @Test public void testDeleteFirst_StrMatcher() { StrBuilder sb = new StrBuilder("A0xA1A2yA3"); sb.deleteFirst((StrMatcher) null); assertEquals("A0xA1A2yA3", sb.toString()); sb.deleteFirst(A_NUMBER_MATCHER); assertEquals("xA1A2yA3", sb.toString()); sb = new StrBuilder("Ax1"); sb.deleteFirst(A_NUMBER_MATCHER); assertEquals("Ax1", sb.toString()); sb = new StrBuilder(""); sb.deleteFirst(A_NUMBER_MATCHER); assertEquals("", sb.toString()); } // ----------------------------------------------------------------------- @Test public void testReplace_int_int_String() { StrBuilder sb = new StrBuilder("abc"); sb.replace(0, 1, "d"); assertEquals("dbc", sb.toString()); sb.replace(0, 1, "aaa"); assertEquals("aaabc", sb.toString()); sb.replace(0, 3, ""); assertEquals("bc", sb.toString()); sb.replace(1, 2, (String) null); assertEquals("b", sb.toString()); sb.replace(1, 1000, "text"); assertEquals("btext", sb.toString()); sb.replace(0, 1000, "text"); assertEquals("text", sb.toString()); sb = new StrBuilder("atext"); sb.replace(1, 1, "ny"); assertEquals("anytext", sb.toString()); try { sb.replace(2, 1, "anything"); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} sb = new StrBuilder(); try { sb.replace(1, 2, "anything"); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} try { sb.replace(-1, 1, "anything"); fail("Expected IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) {} } //----------------------------------------------------------------------- @Test public void testReplaceAll_char_char() { final StrBuilder sb = new StrBuilder("abcbccba"); sb.replaceAll('x', 'y'); assertEquals("abcbccba", sb.toString()); sb.replaceAll('a', 'd'); assertEquals("dbcbccbd", sb.toString()); sb.replaceAll('b', 'e'); assertEquals("dececced", sb.toString()); sb.replaceAll('c', 'f'); assertEquals("defeffed", sb.toString()); sb.replaceAll('d', 'd'); assertEquals("defeffed", sb.toString()); } //----------------------------------------------------------------------- @Test public void testReplaceFirst_char_char() { final StrBuilder sb = new StrBuilder("abcbccba"); sb.replaceFirst('x', 'y'); assertEquals("abcbccba", sb.toString()); sb.replaceFirst('a', 'd'); assertEquals("dbcbccba", sb.toString()); sb.replaceFirst('b', 'e'); assertEquals("decbccba", sb.toString()); sb.replaceFirst('c', 'f'); assertEquals("defbccba", sb.toString()); sb.replaceFirst('d', 'd'); assertEquals("defbccba", sb.toString()); } //----------------------------------------------------------------------- @Test public void testReplaceAll_String_String() { StrBuilder sb = new StrBuilder("abcbccba"); sb.replaceAll((String) null, null); assertEquals("abcbccba", sb.toString()); sb.replaceAll((String) null, "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceAll("", null); assertEquals("abcbccba", sb.toString()); sb.replaceAll("", "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceAll("x", "y"); assertEquals("abcbccba", sb.toString()); sb.replaceAll("a", "d"); assertEquals("dbcbccbd", sb.toString()); sb.replaceAll("d", null); assertEquals("bcbccb", sb.toString()); sb.replaceAll("cb", "-"); assertEquals("b-c-", sb.toString()); sb = new StrBuilder("abcba"); sb.replaceAll("b", "xbx"); assertEquals("axbxcxbxa", sb.toString()); sb = new StrBuilder("bb"); sb.replaceAll("b", "xbx"); assertEquals("xbxxbx", sb.toString()); } @Test public void testReplaceFirst_String_String() { StrBuilder sb = new StrBuilder("abcbccba"); sb.replaceFirst((String) null, null); assertEquals("abcbccba", sb.toString()); sb.replaceFirst((String) null, "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceFirst("", null); assertEquals("abcbccba", sb.toString()); sb.replaceFirst("", "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceFirst("x", "y"); assertEquals("abcbccba", sb.toString()); sb.replaceFirst("a", "d"); assertEquals("dbcbccba", sb.toString()); sb.replaceFirst("d", null); assertEquals("bcbccba", sb.toString()); sb.replaceFirst("cb", "-"); assertEquals("b-ccba", sb.toString()); sb = new StrBuilder("abcba"); sb.replaceFirst("b", "xbx"); assertEquals("axbxcba", sb.toString()); sb = new StrBuilder("bb"); sb.replaceFirst("b", "xbx"); assertEquals("xbxb", sb.toString()); } //----------------------------------------------------------------------- @Test public void testReplaceAll_StrMatcher_String() { StrBuilder sb = new StrBuilder("abcbccba"); sb.replaceAll((StrMatcher) null, null); assertEquals("abcbccba", sb.toString()); sb.replaceAll((StrMatcher) null, "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceAll(StrMatcher.noneMatcher(), null); assertEquals("abcbccba", sb.toString()); sb.replaceAll(StrMatcher.noneMatcher(), "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceAll(StrMatcher.charMatcher('x'), "y"); assertEquals("abcbccba", sb.toString()); sb.replaceAll(StrMatcher.charMatcher('a'), "d"); assertEquals("dbcbccbd", sb.toString()); sb.replaceAll(StrMatcher.charMatcher('d'), null); assertEquals("bcbccb", sb.toString()); sb.replaceAll(StrMatcher.stringMatcher("cb"), "-"); assertEquals("b-c-", sb.toString()); sb = new StrBuilder("abcba"); sb.replaceAll(StrMatcher.charMatcher('b'), "xbx"); assertEquals("axbxcxbxa", sb.toString()); sb = new StrBuilder("bb"); sb.replaceAll(StrMatcher.charMatcher('b'), "xbx"); assertEquals("xbxxbx", sb.toString()); sb = new StrBuilder("A1-A2A3-A4"); sb.replaceAll(A_NUMBER_MATCHER, "***"); assertEquals("***-******-***", sb.toString()); } @Test public void testReplaceFirst_StrMatcher_String() { StrBuilder sb = new StrBuilder("abcbccba"); sb.replaceFirst((StrMatcher) null, null); assertEquals("abcbccba", sb.toString()); sb.replaceFirst((StrMatcher) null, "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceFirst(StrMatcher.noneMatcher(), null); assertEquals("abcbccba", sb.toString()); sb.replaceFirst(StrMatcher.noneMatcher(), "anything"); assertEquals("abcbccba", sb.toString()); sb.replaceFirst(StrMatcher.charMatcher('x'), "y"); assertEquals("abcbccba", sb.toString()); sb.replaceFirst(StrMatcher.charMatcher('a'), "d"); assertEquals("dbcbccba", sb.toString()); sb.replaceFirst(StrMatcher.charMatcher('d'), null); assertEquals("bcbccba", sb.toString()); sb.replaceFirst(StrMatcher.stringMatcher("cb"), "-"); assertEquals("b-ccba", sb.toString()); sb = new StrBuilder("abcba"); sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); assertEquals("axbxcba", sb.toString()); sb = new StrBuilder("bb"); sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx"); assertEquals("xbxb", sb.toString()); sb = new StrBuilder("A1-A2A3-A4"); sb.replaceFirst(A_NUMBER_MATCHER, "***"); assertEquals("***-A2A3-A4", sb.toString()); } //----------------------------------------------------------------------- @Test public void testReplace_StrMatcher_String_int_int_int_VaryMatcher() { StrBuilder sb = new StrBuilder("abcbccba"); sb.replace((StrMatcher) null, "x", 0, sb.length(), -1); assertEquals("abcbccba", sb.toString()); sb.replace(StrMatcher.charMatcher('a'), "x", 0, sb.length(), -1); assertEquals("xbcbccbx", sb.toString()); sb.replace(StrMatcher.stringMatcher("cb"), "x", 0, sb.length(), -1); assertEquals("xbxcxx", sb.toString()); sb = new StrBuilder("A1-A2A3-A4"); sb.replace(A_NUMBER_MATCHER, "***", 0, sb.length(), -1); assertEquals("***-******-***", sb.toString()); sb = new StrBuilder(); sb.replace(A_NUMBER_MATCHER, "***", 0, sb.length(), -1); assertEquals("", sb.toString()); } @Test public void testReplace_StrMatcher_String_int_int_int_VaryReplace() { StrBuilder sb = new StrBuilder("abcbccba"); sb.replace(StrMatcher.stringMatcher("cb"), "cb", 0, sb.length(), -1); assertEquals("abcbccba", sb.toString()); sb = new StrBuilder("abcbccba"); sb.replace(StrMatcher.stringMatcher("cb"), "-", 0, sb.length(), -1); assertEquals("ab-c-a", sb.toString()); sb = new StrBuilder("abcbccba"); sb.replace(StrMatcher.stringMatcher("cb"), "+++", 0, sb.length(), -1); assertEquals("ab+++c+++a", sb.toString()); sb = new StrBuilder("abcbccba"); sb.replace(StrMatcher.stringMatcher("cb"), "", 0, sb.length(), -1); assertEquals("abca", sb.toString()); sb = new StrBuilder("abcbccba"); sb.replace(StrMatcher.stringMatcher("cb"), null, 0, sb.length(), -1); assertEquals("abca", sb.toString()); } @Test public void testReplace_StrMatcher_String_int_int_int_VaryStartIndex() { StrBuilder sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, sb.length(), -1); assertEquals("-x--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 1, sb.length(), -1); assertEquals("aax--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 2, sb.length(), -1); assertEquals("aax--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 3, sb.length(), -1); assertEquals("aax--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 4, sb.length(), -1); assertEquals("aaxa-ay-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 5, sb.length(), -1); assertEquals("aaxaa-y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 6, sb.length(), -1); assertEquals("aaxaaaay-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 7, sb.length(), -1); assertEquals("aaxaaaay-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 8, sb.length(), -1); assertEquals("aaxaaaay-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 9, sb.length(), -1); assertEquals("aaxaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 10, sb.length(), -1); assertEquals("aaxaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); try { sb.replace(StrMatcher.stringMatcher("aa"), "-", 11, sb.length(), -1); fail(); } catch (final IndexOutOfBoundsException ex) {} assertEquals("aaxaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); try { sb.replace(StrMatcher.stringMatcher("aa"), "-", -1, sb.length(), -1); fail(); } catch (final IndexOutOfBoundsException ex) {} assertEquals("aaxaaaayaa", sb.toString()); } @Test public void testReplace_StrMatcher_String_int_int_int_VaryEndIndex() { StrBuilder sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 0, -1); assertEquals("aaxaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 2, -1); assertEquals("-xaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 3, -1); assertEquals("-xaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 4, -1); assertEquals("-xaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 5, -1); assertEquals("-x-aayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 6, -1); assertEquals("-x-aayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 7, -1); assertEquals("-x--yaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 8, -1); assertEquals("-x--yaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 9, -1); assertEquals("-x--yaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, -1); assertEquals("-x--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 1000, -1); assertEquals("-x--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); try { sb.replace(StrMatcher.stringMatcher("aa"), "-", 2, 1, -1); fail(); } catch (final IndexOutOfBoundsException ex) {} assertEquals("aaxaaaayaa", sb.toString()); } @Test public void testReplace_StrMatcher_String_int_int_int_VaryCount() { StrBuilder sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, -1); assertEquals("-x--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 0); assertEquals("aaxaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 1); assertEquals("-xaaaayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 2); assertEquals("-x-aayaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 3); assertEquals("-x--yaa", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 4); assertEquals("-x--y-", sb.toString()); sb = new StrBuilder("aaxaaaayaa"); sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 5); assertEquals("-x--y-", sb.toString()); } //----------------------------------------------------------------------- @Test public void testReverse() { final StrBuilder sb = new StrBuilder(); assertEquals("", sb.reverse().toString()); sb.clear().append(true); assertEquals("eurt", sb.reverse().toString()); assertEquals("true", sb.reverse().toString()); } //----------------------------------------------------------------------- @Test public void testTrim() { final StrBuilder sb = new StrBuilder(); assertEquals("", sb.reverse().toString()); sb.clear().append(" \u0000 "); assertEquals("", sb.trim().toString()); sb.clear().append(" \u0000 a b c"); assertEquals("a b c", sb.trim().toString()); sb.clear().append("a b c \u0000 "); assertEquals("a b c", sb.trim().toString()); sb.clear().append(" \u0000 a b c \u0000 "); assertEquals("a b c", sb.trim().toString()); sb.clear().append("a b c"); assertEquals("a b c", sb.trim().toString()); } //----------------------------------------------------------------------- @Test public void testStartsWith() { final StrBuilder sb = new StrBuilder(); assertFalse(sb.startsWith("a")); assertFalse(sb.startsWith(null)); assertTrue(sb.startsWith("")); sb.append("abc"); assertTrue(sb.startsWith("a")); assertTrue(sb.startsWith("ab")); assertTrue(sb.startsWith("abc")); assertFalse(sb.startsWith("cba")); } @Test public void testEndsWith() { final StrBuilder sb = new StrBuilder(); assertFalse(sb.endsWith("a")); assertFalse(sb.endsWith("c")); assertTrue(sb.endsWith("")); assertFalse(sb.endsWith(null)); sb.append("abc"); assertTrue(sb.endsWith("c")); assertTrue(sb.endsWith("bc")); assertTrue(sb.endsWith("abc")); assertFalse(sb.endsWith("cba")); assertFalse(sb.endsWith("abcd")); assertFalse(sb.endsWith(" abc")); assertFalse(sb.endsWith("abc ")); } //----------------------------------------------------------------------- @Test public void testSubSequenceIntInt() { final StrBuilder sb = new StrBuilder ("hello goodbye"); // Start index is negative try { sb.subSequence(-1, 5); fail(); } catch (final IndexOutOfBoundsException e) {} // End index is negative try { sb.subSequence(2, -1); fail(); } catch (final IndexOutOfBoundsException e) {} // End index greater than length() try { sb.subSequence(2, sb.length() + 1); fail(); } catch (final IndexOutOfBoundsException e) {} // Start index greater then end index try { sb.subSequence(3, 2); fail(); } catch (final IndexOutOfBoundsException e) {} // Normal cases assertEquals ("hello", sb.subSequence(0, 5)); assertEquals ("hello goodbye".subSequence(0, 6), sb.subSequence(0, 6)); assertEquals ("goodbye", sb.subSequence(6, 13)); assertEquals ("hello goodbye".subSequence(6,13), sb.subSequence(6, 13)); } @Test public void testSubstringInt() { final StrBuilder sb = new StrBuilder ("hello goodbye"); assertEquals ("goodbye", sb.substring(6)); assertEquals ("hello goodbye".substring(6), sb.substring(6)); assertEquals ("hello goodbye", sb.substring(0)); assertEquals ("hello goodbye".substring(0), sb.substring(0)); try { sb.substring(-1); fail (); } catch (final IndexOutOfBoundsException e) {} try { sb.substring(15); fail (); } catch (final IndexOutOfBoundsException e) {} } @Test public void testSubstringIntInt() { final StrBuilder sb = new StrBuilder ("hello goodbye"); assertEquals ("hello", sb.substring(0, 5)); assertEquals ("hello goodbye".substring(0, 6), sb.substring(0, 6)); assertEquals ("goodbye", sb.substring(6, 13)); assertEquals ("hello goodbye".substring(6,13), sb.substring(6, 13)); assertEquals ("goodbye", sb.substring(6, 20)); try { sb.substring(-1, 5); fail(); } catch (final IndexOutOfBoundsException e) {} try { sb.substring(15, 20); fail(); } catch (final IndexOutOfBoundsException e) {} } // ----------------------------------------------------------------------- @Test public void testMidString() { final StrBuilder sb = new StrBuilder("hello goodbye hello"); assertEquals("goodbye", sb.midString(6, 7)); assertEquals("hello", sb.midString(0, 5)); assertEquals("hello", sb.midString(-5, 5)); assertEquals("", sb.midString(0, -1)); assertEquals("", sb.midString(20, 2)); assertEquals("hello", sb.midString(14, 22)); } @Test public void testRightString() { final StrBuilder sb = new StrBuilder("left right"); assertEquals("right", sb.rightString(5)); assertEquals("", sb.rightString(0)); assertEquals("", sb.rightString(-5)); assertEquals("left right", sb.rightString(15)); } @Test public void testLeftString() { final StrBuilder sb = new StrBuilder("left right"); assertEquals("left", sb.leftString(4)); assertEquals("", sb.leftString(0)); assertEquals("", sb.leftString(-5)); assertEquals("left right", sb.leftString(15)); } // ----------------------------------------------------------------------- @Test public void testContains_char() { final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); assertTrue(sb.contains('a')); assertTrue(sb.contains('o')); assertTrue(sb.contains('z')); assertFalse(sb.contains('1')); } @Test public void testContains_String() { final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); assertTrue(sb.contains("a")); assertTrue(sb.contains("pq")); assertTrue(sb.contains("z")); assertFalse(sb.contains("zyx")); assertFalse(sb.contains((String) null)); } @Test public void testContains_StrMatcher() { StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz"); assertTrue(sb.contains(StrMatcher.charMatcher('a'))); assertTrue(sb.contains(StrMatcher.stringMatcher("pq"))); assertTrue(sb.contains(StrMatcher.charMatcher('z'))); assertFalse(sb.contains(StrMatcher.stringMatcher("zy"))); assertFalse(sb.contains((StrMatcher) null)); sb = new StrBuilder(); assertFalse(sb.contains(A_NUMBER_MATCHER)); sb.append("B A1 C"); assertTrue(sb.contains(A_NUMBER_MATCHER)); } // ----------------------------------------------------------------------- @Test public void testIndexOf_char() { final StrBuilder sb = new StrBuilder("abab"); assertEquals(0, sb.indexOf('a')); // should work like String#indexOf assertEquals("abab".indexOf('a'), sb.indexOf('a')); assertEquals(1, sb.indexOf('b')); assertEquals("abab".indexOf('b'), sb.indexOf('b')); assertEquals(-1, sb.indexOf('z')); } @Test public void testIndexOf_char_int() { StrBuilder sb = new StrBuilder("abab"); assertEquals(0, sb.indexOf('a', -1)); assertEquals(0, sb.indexOf('a', 0)); assertEquals(2, sb.indexOf('a', 1)); assertEquals(-1, sb.indexOf('a', 4)); assertEquals(-1, sb.indexOf('a', 5)); // should work like String#indexOf assertEquals("abab".indexOf('a', 1), sb.indexOf('a', 1)); assertEquals(3, sb.indexOf('b', 2)); assertEquals("abab".indexOf('b', 2), sb.indexOf('b', 2)); assertEquals(-1, sb.indexOf('z', 2)); sb = new StrBuilder("xyzabc"); assertEquals(2, sb.indexOf('z', 0)); assertEquals(-1, sb.indexOf('z', 3)); } @Test public void testLastIndexOf_char() { final StrBuilder sb = new StrBuilder("abab"); assertEquals (2, sb.lastIndexOf('a')); //should work like String#lastIndexOf assertEquals ("abab".lastIndexOf('a'), sb.lastIndexOf('a')); assertEquals(3, sb.lastIndexOf('b')); assertEquals ("abab".lastIndexOf('b'), sb.lastIndexOf('b')); assertEquals (-1, sb.lastIndexOf('z')); } @Test public void testLastIndexOf_char_int() { StrBuilder sb = new StrBuilder("abab"); assertEquals(-1, sb.lastIndexOf('a', -1)); assertEquals(0, sb.lastIndexOf('a', 0)); assertEquals(0, sb.lastIndexOf('a', 1)); // should work like String#lastIndexOf assertEquals("abab".lastIndexOf('a', 1), sb.lastIndexOf('a', 1)); assertEquals(1, sb.lastIndexOf('b', 2)); assertEquals("abab".lastIndexOf('b', 2), sb.lastIndexOf('b', 2)); assertEquals(-1, sb.lastIndexOf('z', 2)); sb = new StrBuilder("xyzabc"); assertEquals(2, sb.lastIndexOf('z', sb.length())); assertEquals(-1, sb.lastIndexOf('z', 1)); } // ----------------------------------------------------------------------- @Test public void testIndexOf_String() { final StrBuilder sb = new StrBuilder("abab"); assertEquals(0, sb.indexOf("a")); //should work like String#indexOf assertEquals("abab".indexOf("a"), sb.indexOf("a")); assertEquals(0, sb.indexOf("ab")); //should work like String#indexOf assertEquals("abab".indexOf("ab"), sb.indexOf("ab")); assertEquals(1, sb.indexOf("b")); assertEquals("abab".indexOf("b"), sb.indexOf("b")); assertEquals(1, sb.indexOf("ba")); assertEquals("abab".indexOf("ba"), sb.indexOf("ba")); assertEquals(-1, sb.indexOf("z")); assertEquals(-1, sb.indexOf((String) null)); } @Test public void testIndexOf_String_int() { StrBuilder sb = new StrBuilder("abab"); assertEquals(0, sb.indexOf("a", -1)); assertEquals(0, sb.indexOf("a", 0)); assertEquals(2, sb.indexOf("a", 1)); assertEquals(2, sb.indexOf("a", 2)); assertEquals(-1, sb.indexOf("a", 3)); assertEquals(-1, sb.indexOf("a", 4)); assertEquals(-1, sb.indexOf("a", 5)); assertEquals(-1, sb.indexOf("abcdef", 0)); assertEquals(0, sb.indexOf("", 0)); assertEquals(1, sb.indexOf("", 1)); //should work like String#indexOf assertEquals ("abab".indexOf("a", 1), sb.indexOf("a", 1)); assertEquals(2, sb.indexOf("ab", 1)); //should work like String#indexOf assertEquals("abab".indexOf("ab", 1), sb.indexOf("ab", 1)); assertEquals(3, sb.indexOf("b", 2)); assertEquals("abab".indexOf("b", 2), sb.indexOf("b", 2)); assertEquals(1, sb.indexOf("ba", 1)); assertEquals("abab".indexOf("ba", 2), sb.indexOf("ba", 2)); assertEquals(-1, sb.indexOf("z", 2)); sb = new StrBuilder("xyzabc"); assertEquals(2, sb.indexOf("za", 0)); assertEquals(-1, sb.indexOf("za", 3)); assertEquals(-1, sb.indexOf((String) null, 2)); } @Test public void testLastIndexOf_String() { final StrBuilder sb = new StrBuilder("abab"); assertEquals(2, sb.lastIndexOf("a")); //should work like String#lastIndexOf assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a")); assertEquals(2, sb.lastIndexOf("ab")); //should work like String#lastIndexOf assertEquals("abab".lastIndexOf("ab"), sb.lastIndexOf("ab")); assertEquals(3, sb.lastIndexOf("b")); assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b")); assertEquals(1, sb.lastIndexOf("ba")); assertEquals("abab".lastIndexOf("ba"), sb.lastIndexOf("ba")); assertEquals(-1, sb.lastIndexOf("z")); assertEquals(-1, sb.lastIndexOf((String) null)); } @Test public void testLastIndexOf_String_int() { StrBuilder sb = new StrBuilder("abab"); assertEquals(-1, sb.lastIndexOf("a", -1)); assertEquals(0, sb.lastIndexOf("a", 0)); assertEquals(0, sb.lastIndexOf("a", 1)); assertEquals(2, sb.lastIndexOf("a", 2)); assertEquals(2, sb.lastIndexOf("a", 3)); assertEquals(2, sb.lastIndexOf("a", 4)); assertEquals(2, sb.lastIndexOf("a", 5)); assertEquals(-1, sb.lastIndexOf("abcdef", 3)); assertEquals("abab".lastIndexOf("", 3), sb.lastIndexOf("", 3)); assertEquals("abab".lastIndexOf("", 1), sb.lastIndexOf("", 1)); //should work like String#lastIndexOf assertEquals("abab".lastIndexOf("a", 1), sb.lastIndexOf("a", 1)); assertEquals(0, sb.lastIndexOf("ab", 1)); //should work like String#lastIndexOf assertEquals("abab".lastIndexOf("ab", 1), sb.lastIndexOf("ab", 1)); assertEquals(1, sb.lastIndexOf("b", 2)); assertEquals("abab".lastIndexOf("b", 2), sb.lastIndexOf("b", 2)); assertEquals(1, sb.lastIndexOf("ba", 2)); assertEquals("abab".lastIndexOf("ba", 2), sb.lastIndexOf("ba", 2)); assertEquals(-1, sb.lastIndexOf("z", 2)); sb = new StrBuilder("xyzabc"); assertEquals(2, sb.lastIndexOf("za", sb.length())); assertEquals(-1, sb.lastIndexOf("za", 1)); assertEquals(-1, sb.lastIndexOf((String) null, 2)); } // ----------------------------------------------------------------------- @Test public void testIndexOf_StrMatcher() { final StrBuilder sb = new StrBuilder(); assertEquals(-1, sb.indexOf((StrMatcher) null)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'))); sb.append("ab bd"); assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'))); assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'))); assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher())); assertEquals(4, sb.indexOf(StrMatcher.charMatcher('d'))); assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher())); assertEquals(-1, sb.indexOf((StrMatcher) null)); sb.append(" A1 junction"); assertEquals(6, sb.indexOf(A_NUMBER_MATCHER)); } @Test public void testIndexOf_StrMatcher_int() { final StrBuilder sb = new StrBuilder(); assertEquals(-1, sb.indexOf((StrMatcher) null, 2)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 0)); sb.append("ab bd"); assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), -2)); assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), 0)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 20)); assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), -1)); assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 0)); assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 1)); assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 2)); assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 3)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 4)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 5)); assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 6)); assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), -2)); assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 0)); assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 2)); assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 4)); assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 20)); assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher(), 0)); assertEquals(-1, sb.indexOf((StrMatcher) null, 0)); sb.append(" A1 junction with A2"); assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 5)); assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 6)); assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 7)); assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 22)); assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 23)); assertEquals(-1, sb.indexOf(A_NUMBER_MATCHER, 24)); } @Test public void testLastIndexOf_StrMatcher() { final StrBuilder sb = new StrBuilder(); assertEquals(-1, sb.lastIndexOf((StrMatcher) null)); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'))); sb.append("ab bd"); assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'))); assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'))); assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher())); assertEquals(4, sb.lastIndexOf(StrMatcher.charMatcher('d'))); assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher())); assertEquals(-1, sb.lastIndexOf((StrMatcher) null)); sb.append(" A1 junction"); assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER)); } @Test public void testLastIndexOf_StrMatcher_int() { final StrBuilder sb = new StrBuilder(); assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 2)); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2)); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0)); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -1)); sb.append("ab bd"); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -2)); assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0)); assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2)); assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 20)); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), -1)); assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 0)); assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 1)); assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 2)); assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 3)); assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 4)); assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 5)); assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 6)); assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), -2)); assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), 0)); assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 2)); assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 4)); assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 20)); assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher(), 0)); assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 0)); sb.append(" A1 junction with A2"); assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 5)); assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 6)); // A matches, 1 is outside bounds assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 7)); assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 22)); assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 23)); // A matches, 2 is outside bounds assertEquals(23, sb.lastIndexOf(A_NUMBER_MATCHER, 24)); } static final StrMatcher A_NUMBER_MATCHER = new StrMatcher() { @Override public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) { if (buffer[pos] == 'A') { pos++; if (pos < bufferEnd && buffer[pos] >= '0' && buffer[pos] <= '9') { return 2; } } return 0; } }; //----------------------------------------------------------------------- @Test public void testAsTokenizer() throws Exception { // from Javadoc final StrBuilder b = new StrBuilder(); b.append("a b "); final StrTokenizer t = b.asTokenizer(); final String[] tokens1 = t.getTokenArray(); assertEquals(2, tokens1.length); assertEquals("a", tokens1[0]); assertEquals("b", tokens1[1]); assertEquals(2, t.size()); b.append("c d "); final String[] tokens2 = t.getTokenArray(); assertEquals(2, tokens2.length); assertEquals("a", tokens2[0]); assertEquals("b", tokens2[1]); assertEquals(2, t.size()); assertEquals("a", t.next()); assertEquals("b", t.next()); t.reset(); final String[] tokens3 = t.getTokenArray(); assertEquals(4, tokens3.length); assertEquals("a", tokens3[0]); assertEquals("b", tokens3[1]); assertEquals("c", tokens3[2]); assertEquals("d", tokens3[3]); assertEquals(4, t.size()); assertEquals("a", t.next()); assertEquals("b", t.next()); assertEquals("c", t.next()); assertEquals("d", t.next()); assertEquals("a b c d ", t.getContent()); } // ----------------------------------------------------------------------- @Test public void testAsReader() throws Exception { final StrBuilder sb = new StrBuilder("some text"); Reader reader = sb.asReader(); assertTrue(reader.ready()); final char[] buf = new char[40]; assertEquals(9, reader.read(buf)); assertEquals("some text", new String(buf, 0, 9)); assertEquals(-1, reader.read()); assertFalse(reader.ready()); assertEquals(0, reader.skip(2)); assertEquals(0, reader.skip(-1)); assertTrue(reader.markSupported()); reader = sb.asReader(); assertEquals('s', reader.read()); reader.mark(-1); char[] array = new char[3]; assertEquals(3, reader.read(array, 0, 3)); assertEquals('o', array[0]); assertEquals('m', array[1]); assertEquals('e', array[2]); reader.reset(); assertEquals(1, reader.read(array, 1, 1)); assertEquals('o', array[0]); assertEquals('o', array[1]); assertEquals('e', array[2]); assertEquals(2, reader.skip(2)); assertEquals(' ', reader.read()); assertTrue(reader.ready()); reader.close(); assertTrue(reader.ready()); reader = sb.asReader(); array = new char[3]; try { reader.read(array, -1, 0); fail(); } catch (final IndexOutOfBoundsException ex) {} try { reader.read(array, 0, -1); fail(); } catch (final IndexOutOfBoundsException ex) {} try { reader.read(array, 100, 1); fail(); } catch (final IndexOutOfBoundsException ex) {} try { reader.read(array, 0, 100); fail(); } catch (final IndexOutOfBoundsException ex) {} try { reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE); fail(); } catch (final IndexOutOfBoundsException ex) {} assertEquals(0, reader.read(array, 0, 0)); assertEquals(0, array[0]); assertEquals(0, array[1]); assertEquals(0, array[2]); reader.skip(9); assertEquals(-1, reader.read(array, 0, 1)); reader.reset(); array = new char[30]; assertEquals(9, reader.read(array, 0, 30)); } //----------------------------------------------------------------------- @Test public void testAsWriter() throws Exception { final StrBuilder sb = new StrBuilder("base"); final Writer writer = sb.asWriter(); writer.write('l'); assertEquals("basel", sb.toString()); writer.write(new char[] {'i', 'n'}); assertEquals("baselin", sb.toString()); writer.write(new char[] {'n', 'e', 'r'}, 1, 2); assertEquals("baseliner", sb.toString()); writer.write(" rout"); assertEquals("baseliner rout", sb.toString()); writer.write("ping that server", 1, 3); assertEquals("baseliner routing", sb.toString()); writer.flush(); // no effect assertEquals("baseliner routing", sb.toString()); writer.close(); // no effect assertEquals("baseliner routing", sb.toString()); writer.write(" hi"); // works after close assertEquals("baseliner routing hi", sb.toString()); sb.setLength(4); // mix and match writer.write('d'); assertEquals("based", sb.toString()); } //----------------------------------------------------------------------- @Test public void testEqualsIgnoreCase() { final StrBuilder sb1 = new StrBuilder(); final StrBuilder sb2 = new StrBuilder(); assertTrue(sb1.equalsIgnoreCase(sb1)); assertTrue(sb1.equalsIgnoreCase(sb2)); assertTrue(sb2.equalsIgnoreCase(sb2)); sb1.append("abc"); assertFalse(sb1.equalsIgnoreCase(sb2)); sb2.append("ABC"); assertTrue(sb1.equalsIgnoreCase(sb2)); sb2.clear().append("abc"); assertTrue(sb1.equalsIgnoreCase(sb2)); assertTrue(sb1.equalsIgnoreCase(sb1)); assertTrue(sb2.equalsIgnoreCase(sb2)); sb2.clear().append("aBc"); assertTrue(sb1.equalsIgnoreCase(sb2)); } //----------------------------------------------------------------------- @Test public void testEquals() { final StrBuilder sb1 = new StrBuilder(); final StrBuilder sb2 = new StrBuilder(); assertTrue(sb1.equals(sb2)); assertTrue(sb1.equals(sb1)); assertTrue(sb2.equals(sb2)); assertTrue(sb1.equals((Object) sb2)); sb1.append("abc"); assertFalse(sb1.equals(sb2)); assertFalse(sb1.equals((Object) sb2)); sb2.append("ABC"); assertFalse(sb1.equals(sb2)); assertFalse(sb1.equals((Object) sb2)); sb2.clear().append("abc"); assertTrue(sb1.equals(sb2)); assertTrue(sb1.equals((Object) sb2)); assertFalse(sb1.equals(Integer.valueOf(1))); assertFalse(sb1.equals("abc")); } //----------------------------------------------------------------------- @Test public void testHashCode() { final StrBuilder sb = new StrBuilder(); final int hc1a = sb.hashCode(); final int hc1b = sb.hashCode(); assertEquals(0, hc1a); assertEquals(hc1a, hc1b); sb.append("abc"); final int hc2a = sb.hashCode(); final int hc2b = sb.hashCode(); assertTrue(hc2a != 0); assertEquals(hc2a, hc2b); } //----------------------------------------------------------------------- @Test public void testToString() { final StrBuilder sb = new StrBuilder("abc"); assertEquals("abc", sb.toString()); } //----------------------------------------------------------------------- @Test public void testToStringBuffer() { final StrBuilder sb = new StrBuilder(); assertEquals(new StringBuffer().toString(), sb.toStringBuffer().toString()); sb.append("junit"); assertEquals(new StringBuffer("junit").toString(), sb.toStringBuffer().toString()); } //----------------------------------------------------------------------- @Test public void testToStringBuilder() { final StrBuilder sb = new StrBuilder(); assertEquals(new StringBuilder().toString(), sb.toStringBuilder().toString()); sb.append("junit"); assertEquals(new StringBuilder("junit").toString(), sb.toStringBuilder().toString()); } //----------------------------------------------------------------------- @Test public void testLang294() { final StrBuilder sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n"); sb.deleteAll("\n%BLAH%"); assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); } @Test public void testIndexOfLang294() { final StrBuilder sb = new StrBuilder("onetwothree"); sb.deleteFirst("three"); assertEquals(-1, sb.indexOf("three")); } //----------------------------------------------------------------------- @Test public void testLang295() { final StrBuilder sb = new StrBuilder("onetwothree"); sb.deleteFirst("three"); assertFalse( "The contains(char) method is looking beyond the end of the string", sb.contains('h')); assertEquals( "The indexOf(char) method is looking beyond the end of the string", -1, sb.indexOf('h')); } //----------------------------------------------------------------------- @Test public void testLang412Right() { final StrBuilder sb = new StrBuilder(); sb.appendFixedWidthPadRight(null, 10, '*'); assertEquals( "Failed to invoke appendFixedWidthPadRight correctly", "**********", sb.toString()); } @Test public void testLang412Left() { final StrBuilder sb = new StrBuilder(); sb.appendFixedWidthPadLeft(null, 10, '*'); assertEquals( "Failed to invoke appendFixedWidthPadLeft correctly", "**********", sb.toString()); } @Test public void testAsBuilder() { final StrBuilder sb = new StrBuilder().appendAll("Lorem", " ", "ipsum", " ", "dolor"); assertEquals(sb.toString(), sb.build()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import java.util.HashMap; import java.util.Map; import org.junit.Test; /** * Test class for StrLookup. * * @version $Id$ */ public class StrLookupTest { //----------------------------------------------------------------------- @Test public void testNoneLookup() { assertEquals(null, StrLookup.noneLookup().lookup(null)); assertEquals(null, StrLookup.noneLookup().lookup("")); assertEquals(null, StrLookup.noneLookup().lookup("any")); } @Test public void testSystemProperiesLookup() { assertEquals(System.getProperty("os.name"), StrLookup.systemPropertiesLookup().lookup("os.name")); assertEquals(null, StrLookup.systemPropertiesLookup().lookup("")); assertEquals(null, StrLookup.systemPropertiesLookup().lookup("other")); try { StrLookup.systemPropertiesLookup().lookup(null); fail(); } catch (final NullPointerException ex) { // expected } } @Test public void testMapLookup() { final Map<String, Object> map = new HashMap<String, Object>(); map.put("key", "value"); map.put("number", Integer.valueOf(2)); assertEquals("value", StrLookup.mapLookup(map).lookup("key")); assertEquals("2", StrLookup.mapLookup(map).lookup("number")); assertEquals(null, StrLookup.mapLookup(map).lookup(null)); assertEquals(null, StrLookup.mapLookup(map).lookup("")); assertEquals(null, StrLookup.mapLookup(map).lookup("other")); } @Test public void testMapLookup_nullMap() { final Map<String, ?> map = null; assertEquals(null, StrLookup.mapLookup(map).lookup(null)); assertEquals(null, StrLookup.mapLookup(map).lookup("")); assertEquals(null, StrLookup.mapLookup(map).lookup("any")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.StrMatcher}. * * @version $Id$ */ public class StrMatcherTest { private static final char[] BUFFER1 = "0,1\t2 3\n\r\f\u0000'\"".toCharArray(); private static final char[] BUFFER2 = "abcdef".toCharArray(); //----------------------------------------------------------------------- @Test public void testCommaMatcher() { final StrMatcher matcher = StrMatcher.commaMatcher(); assertSame(matcher, StrMatcher.commaMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 0)); assertEquals(1, matcher.isMatch(BUFFER1, 1)); assertEquals(0, matcher.isMatch(BUFFER1, 2)); } //----------------------------------------------------------------------- @Test public void testTabMatcher() { final StrMatcher matcher = StrMatcher.tabMatcher(); assertSame(matcher, StrMatcher.tabMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 2)); assertEquals(1, matcher.isMatch(BUFFER1, 3)); assertEquals(0, matcher.isMatch(BUFFER1, 4)); } //----------------------------------------------------------------------- @Test public void testSpaceMatcher() { final StrMatcher matcher = StrMatcher.spaceMatcher(); assertSame(matcher, StrMatcher.spaceMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 4)); assertEquals(1, matcher.isMatch(BUFFER1, 5)); assertEquals(0, matcher.isMatch(BUFFER1, 6)); } //----------------------------------------------------------------------- @Test public void testSplitMatcher() { final StrMatcher matcher = StrMatcher.splitMatcher(); assertSame(matcher, StrMatcher.splitMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 2)); assertEquals(1, matcher.isMatch(BUFFER1, 3)); assertEquals(0, matcher.isMatch(BUFFER1, 4)); assertEquals(1, matcher.isMatch(BUFFER1, 5)); assertEquals(0, matcher.isMatch(BUFFER1, 6)); assertEquals(1, matcher.isMatch(BUFFER1, 7)); assertEquals(1, matcher.isMatch(BUFFER1, 8)); assertEquals(1, matcher.isMatch(BUFFER1, 9)); assertEquals(0, matcher.isMatch(BUFFER1, 10)); } //----------------------------------------------------------------------- @Test public void testTrimMatcher() { final StrMatcher matcher = StrMatcher.trimMatcher(); assertSame(matcher, StrMatcher.trimMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 2)); assertEquals(1, matcher.isMatch(BUFFER1, 3)); assertEquals(0, matcher.isMatch(BUFFER1, 4)); assertEquals(1, matcher.isMatch(BUFFER1, 5)); assertEquals(0, matcher.isMatch(BUFFER1, 6)); assertEquals(1, matcher.isMatch(BUFFER1, 7)); assertEquals(1, matcher.isMatch(BUFFER1, 8)); assertEquals(1, matcher.isMatch(BUFFER1, 9)); assertEquals(1, matcher.isMatch(BUFFER1, 10)); } //----------------------------------------------------------------------- @Test public void testSingleQuoteMatcher() { final StrMatcher matcher = StrMatcher.singleQuoteMatcher(); assertSame(matcher, StrMatcher.singleQuoteMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 10)); assertEquals(1, matcher.isMatch(BUFFER1, 11)); assertEquals(0, matcher.isMatch(BUFFER1, 12)); } //----------------------------------------------------------------------- @Test public void testDoubleQuoteMatcher() { final StrMatcher matcher = StrMatcher.doubleQuoteMatcher(); assertSame(matcher, StrMatcher.doubleQuoteMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 11)); assertEquals(1, matcher.isMatch(BUFFER1, 12)); } //----------------------------------------------------------------------- @Test public void testQuoteMatcher() { final StrMatcher matcher = StrMatcher.quoteMatcher(); assertSame(matcher, StrMatcher.quoteMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 10)); assertEquals(1, matcher.isMatch(BUFFER1, 11)); assertEquals(1, matcher.isMatch(BUFFER1, 12)); } //----------------------------------------------------------------------- @Test public void testNoneMatcher() { final StrMatcher matcher = StrMatcher.noneMatcher(); assertSame(matcher, StrMatcher.noneMatcher()); assertEquals(0, matcher.isMatch(BUFFER1, 0)); assertEquals(0, matcher.isMatch(BUFFER1, 1)); assertEquals(0, matcher.isMatch(BUFFER1, 2)); assertEquals(0, matcher.isMatch(BUFFER1, 3)); assertEquals(0, matcher.isMatch(BUFFER1, 4)); assertEquals(0, matcher.isMatch(BUFFER1, 5)); assertEquals(0, matcher.isMatch(BUFFER1, 6)); assertEquals(0, matcher.isMatch(BUFFER1, 7)); assertEquals(0, matcher.isMatch(BUFFER1, 8)); assertEquals(0, matcher.isMatch(BUFFER1, 9)); assertEquals(0, matcher.isMatch(BUFFER1, 10)); assertEquals(0, matcher.isMatch(BUFFER1, 11)); assertEquals(0, matcher.isMatch(BUFFER1, 12)); } //----------------------------------------------------------------------- @Test public void testCharMatcher_char() { final StrMatcher matcher = StrMatcher.charMatcher('c'); assertEquals(0, matcher.isMatch(BUFFER2, 0)); assertEquals(0, matcher.isMatch(BUFFER2, 1)); assertEquals(1, matcher.isMatch(BUFFER2, 2)); assertEquals(0, matcher.isMatch(BUFFER2, 3)); assertEquals(0, matcher.isMatch(BUFFER2, 4)); assertEquals(0, matcher.isMatch(BUFFER2, 5)); } //----------------------------------------------------------------------- @Test public void testCharSetMatcher_String() { final StrMatcher matcher = StrMatcher.charSetMatcher("ace"); assertEquals(1, matcher.isMatch(BUFFER2, 0)); assertEquals(0, matcher.isMatch(BUFFER2, 1)); assertEquals(1, matcher.isMatch(BUFFER2, 2)); assertEquals(0, matcher.isMatch(BUFFER2, 3)); assertEquals(1, matcher.isMatch(BUFFER2, 4)); assertEquals(0, matcher.isMatch(BUFFER2, 5)); assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher("")); assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null)); assertTrue(StrMatcher.charSetMatcher("a") instanceof StrMatcher.CharMatcher); } //----------------------------------------------------------------------- @Test public void testCharSetMatcher_charArray() { final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray()); assertEquals(1, matcher.isMatch(BUFFER2, 0)); assertEquals(0, matcher.isMatch(BUFFER2, 1)); assertEquals(1, matcher.isMatch(BUFFER2, 2)); assertEquals(0, matcher.isMatch(BUFFER2, 3)); assertEquals(1, matcher.isMatch(BUFFER2, 4)); assertEquals(0, matcher.isMatch(BUFFER2, 5)); assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0])); assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((char[]) null)); assertTrue(StrMatcher.charSetMatcher("a".toCharArray()) instanceof StrMatcher.CharMatcher); } //----------------------------------------------------------------------- @Test public void testStringMatcher_String() { final StrMatcher matcher = StrMatcher.stringMatcher("bc"); assertEquals(0, matcher.isMatch(BUFFER2, 0)); assertEquals(2, matcher.isMatch(BUFFER2, 1)); assertEquals(0, matcher.isMatch(BUFFER2, 2)); assertEquals(0, matcher.isMatch(BUFFER2, 3)); assertEquals(0, matcher.isMatch(BUFFER2, 4)); assertEquals(0, matcher.isMatch(BUFFER2, 5)); assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher("")); assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher((String) null)); } //----------------------------------------------------------------------- @Test public void testMatcherIndices() { // remember that the API contract is tight for the isMatch() method // all the onus is on the caller, so invalid inputs are not // the concern of StrMatcher, and are not bugs final StrMatcher matcher = StrMatcher.stringMatcher("bc"); assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length)); assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3)); assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import org.junit.After; import org.junit.Test; import org.junit.Before; import static org.junit.Assert.*; import java.util.HashMap; import java.util.Map; import java.util.Properties; import org.apache.commons.lang3.mutable.MutableObject; /** * Test class for StrSubstitutor. * * @version $Id$ */ public class StrSubstitutorTest { private Map<String, String> values; @Before public void setUp() throws Exception { values = new HashMap<String, String>(); values.put("animal", "quick brown fox"); values.put("target", "lazy dog"); } @After public void tearDown() throws Exception { values = null; } //----------------------------------------------------------------------- /** * Tests simple key replace. */ @Test public void testReplaceSimple() { doTestReplace("The quick brown fox jumps over the lazy dog.", "The ${animal} jumps over the ${target}.", true); } /** * Tests simple key replace. */ @Test public void testReplaceSolo() { doTestReplace("quick brown fox", "${animal}", false); } /** * Tests replace with no variables. */ @Test public void testReplaceNoVariables() { doTestNoReplace("The balloon arrived."); } /** * Tests replace with null. */ @Test public void testReplaceNull() { doTestNoReplace(null); } /** * Tests replace with null. */ @Test public void testReplaceEmpty() { doTestNoReplace(""); } /** * Tests key replace changing map after initialization (not recommended). */ @Test public void testReplaceChangedMap() { final StrSubstitutor sub = new StrSubstitutor(values); values.put("target", "moon"); assertEquals("The quick brown fox jumps over the moon.", sub.replace("The ${animal} jumps over the ${target}.")); } /** * Tests unknown key replace. */ @Test public void testReplaceUnknownKey() { doTestReplace("The ${person} jumps over the lazy dog.", "The ${person} jumps over the ${target}.", true); } /** * Tests adjacent keys. */ @Test public void testReplaceAdjacentAtStart() { values.put("code", "GBP"); values.put("amount", "12.50"); final StrSubstitutor sub = new StrSubstitutor(values); assertEquals("GBP12.50 charged", sub.replace("${code}${amount} charged")); } /** * Tests adjacent keys. */ @Test public void testReplaceAdjacentAtEnd() { values.put("code", "GBP"); values.put("amount", "12.50"); final StrSubstitutor sub = new StrSubstitutor(values); assertEquals("Amount is GBP12.50", sub.replace("Amount is ${code}${amount}")); } /** * Tests simple recursive replace. */ @Test public void testReplaceRecursive() { values.put("animal", "${critter}"); values.put("target", "${pet}"); values.put("pet", "${petCharacteristic} dog"); values.put("petCharacteristic", "lazy"); values.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); values.put("critterSpeed", "quick"); values.put("critterColor", "brown"); values.put("critterType", "fox"); doTestReplace("The quick brown fox jumps over the lazy dog.", "The ${animal} jumps over the ${target}.", true); } /** * Tests escaping. */ @Test public void testReplaceEscaping() { doTestReplace("The ${animal} jumps over the lazy dog.", "The $${animal} jumps over the ${target}.", true); } /** * Tests escaping. */ @Test public void testReplaceSoloEscaping() { doTestReplace("${animal}", "$${animal}", false); } /** * Tests complex escaping. */ @Test public void testReplaceComplexEscaping() { doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true); } /** * Tests when no prefix or suffix. */ @Test public void testReplaceNoPrefixNoSuffix() { doTestReplace("The animal jumps over the lazy dog.", "The animal jumps over the ${target}.", true); } /** * Tests when no incomplete prefix. */ @Test public void testReplaceIncompletePrefix() { doTestReplace("The {animal} jumps over the lazy dog.", "The {animal} jumps over the ${target}.", true); } /** * Tests when prefix but no suffix. */ @Test public void testReplacePrefixNoSuffix() { doTestReplace("The ${animal jumps over the ${target} lazy dog.", "The ${animal jumps over the ${target} ${target}.", true); } /** * Tests when suffix but no prefix. */ @Test public void testReplaceNoPrefixSuffix() { doTestReplace("The animal} jumps over the lazy dog.", "The animal} jumps over the ${target}.", true); } /** * Tests when no variable name. */ @Test public void testReplaceEmptyKeys() { doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true); } /** * Tests replace creates output same as input. */ @Test public void testReplaceToIdentical() { values.put("animal", "$${${thing}}"); values.put("thing", "animal"); doTestReplace("The ${animal} jumps.", "The ${animal} jumps.", true); } /** * Tests a cyclic replace operation. * The cycle should be detected and cause an exception to be thrown. */ @Test public void testCyclicReplacement() { final Map<String, String> map = new HashMap<String, String>(); map.put("animal", "${critter}"); map.put("target", "${pet}"); map.put("pet", "${petCharacteristic} dog"); map.put("petCharacteristic", "lazy"); map.put("critter", "${critterSpeed} ${critterColor} ${critterType}"); map.put("critterSpeed", "quick"); map.put("critterColor", "brown"); map.put("critterType", "${animal}"); final StrSubstitutor sub = new StrSubstitutor(map); try { sub.replace("The ${animal} jumps over the ${target}."); fail("Cyclic replacement was not detected!"); } catch (final IllegalStateException ex) { // expected } } /** * Tests interpolation with weird boundary patterns. */ @Test public void testReplaceWeirdPattens() { doTestNoReplace(""); doTestNoReplace("${}"); doTestNoReplace("${ }"); doTestNoReplace("${\t}"); doTestNoReplace("${\n}"); doTestNoReplace("${\b}"); doTestNoReplace("${"); doTestNoReplace("$}"); doTestNoReplace("}"); doTestNoReplace("${}$"); doTestNoReplace("${${"); doTestNoReplace("${${}}"); doTestNoReplace("${$${}}"); doTestNoReplace("${$$${}}"); doTestNoReplace("${$$${$}}"); doTestNoReplace("${${}}"); doTestNoReplace("${${ }}"); } /** * Tests simple key replace. */ @Test public void testReplacePartialString_noReplace() { final StrSubstitutor sub = new StrSubstitutor(); assertEquals("${animal} jumps", sub.replace("The ${animal} jumps over the ${target}.", 4, 15)); } /** * Tests whether a variable can be replaced in a variable name. */ @Test public void testReplaceInVariable() { values.put("animal.1", "fox"); values.put("animal.2", "mouse"); values.put("species", "2"); final StrSubstitutor sub = new StrSubstitutor(values); sub.setEnableSubstitutionInVariables(true); assertEquals( "Wrong result (1)", "The mouse jumps over the lazy dog.", sub.replace("The ${animal.${species}} jumps over the ${target}.")); values.put("species", "1"); assertEquals( "Wrong result (2)", "The fox jumps over the lazy dog.", sub.replace("The ${animal.${species}} jumps over the ${target}.")); } /** * Tests whether substitution in variable names is disabled per default. */ @Test public void testReplaceInVariableDisabled() { values.put("animal.1", "fox"); values.put("animal.2", "mouse"); values.put("species", "2"); final StrSubstitutor sub = new StrSubstitutor(values); assertEquals( "Wrong result", "The ${animal.${species}} jumps over the lazy dog.", sub.replace("The ${animal.${species}} jumps over the ${target}.")); } /** * Tests complex and recursive substitution in variable names. */ @Test public void testReplaceInVariableRecursive() { values.put("animal.2", "brown fox"); values.put("animal.1", "white mouse"); values.put("color", "white"); values.put("species.white", "1"); values.put("species.brown", "2"); final StrSubstitutor sub = new StrSubstitutor(values); sub.setEnableSubstitutionInVariables(true); assertEquals( "Wrong result", "The white mouse jumps over the lazy dog.", sub.replace("The ${animal.${species.${color}}} jumps over the ${target}.")); } //----------------------------------------------------------------------- /** * Tests protected. */ @Test public void testResolveVariable() { final StrBuilder builder = new StrBuilder("Hi ${name}!"); final Map<String, String> map = new HashMap<String, String>(); map.put("name", "commons"); final StrSubstitutor sub = new StrSubstitutor(map) { @Override protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { assertEquals("name", variableName); assertSame(builder, buf); assertEquals(3, startPos); assertEquals(10, endPos); return "jakarta"; } }; sub.replaceIn(builder); assertEquals("Hi jakarta!", builder.toString()); } //----------------------------------------------------------------------- /** * Tests constructor. */ @Test public void testConstructorNoArgs() { final StrSubstitutor sub = new StrSubstitutor(); assertEquals("Hi ${name}", sub.replace("Hi ${name}")); } /** * Tests constructor. */ @Test public void testConstructorMapPrefixSuffix() { final Map<String, String> map = new HashMap<String, String>(); map.put("name", "commons"); final StrSubstitutor sub = new StrSubstitutor(map, "<", ">"); assertEquals("Hi < commons", sub.replace("Hi $< <name>")); } /** * Tests constructor. */ @Test public void testConstructorMapFull() { final Map<String, String> map = new HashMap<String, String>(); map.put("name", "commons"); final StrSubstitutor sub = new StrSubstitutor(map, "<", ">", '!'); assertEquals("Hi < commons", sub.replace("Hi !< <name>")); } //----------------------------------------------------------------------- /** * Tests get set. */ @Test public void testGetSetEscape() { final StrSubstitutor sub = new StrSubstitutor(); assertEquals('$', sub.getEscapeChar()); sub.setEscapeChar('<'); assertEquals('<', sub.getEscapeChar()); } /** * Tests get set. */ @Test public void testGetSetPrefix() { final StrSubstitutor sub = new StrSubstitutor(); assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); sub.setVariablePrefix('<'); assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher); sub.setVariablePrefix("<<"); assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); try { sub.setVariablePrefix((String) null); fail(); } catch (final IllegalArgumentException ex) { // expected } assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher); final StrMatcher matcher = StrMatcher.commaMatcher(); sub.setVariablePrefixMatcher(matcher); assertSame(matcher, sub.getVariablePrefixMatcher()); try { sub.setVariablePrefixMatcher((StrMatcher) null); fail(); } catch (final IllegalArgumentException ex) { // expected } assertSame(matcher, sub.getVariablePrefixMatcher()); } /** * Tests get set. */ @Test public void testGetSetSuffix() { final StrSubstitutor sub = new StrSubstitutor(); assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); sub.setVariableSuffix('<'); assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher); sub.setVariableSuffix("<<"); assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); try { sub.setVariableSuffix((String) null); fail(); } catch (final IllegalArgumentException ex) { // expected } assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher); final StrMatcher matcher = StrMatcher.commaMatcher(); sub.setVariableSuffixMatcher(matcher); assertSame(matcher, sub.getVariableSuffixMatcher()); try { sub.setVariableSuffixMatcher((StrMatcher) null); fail(); } catch (final IllegalArgumentException ex) { // expected } assertSame(matcher, sub.getVariableSuffixMatcher()); } //----------------------------------------------------------------------- /** * Tests static. */ @Test public void testStaticReplace() { final Map<String, String> map = new HashMap<String, String>(); map.put("name", "commons"); assertEquals("Hi commons!", StrSubstitutor.replace("Hi ${name}!", map)); } /** * Tests static. */ @Test public void testStaticReplacePrefixSuffix() { final Map<String, String> map = new HashMap<String, String>(); map.put("name", "commons"); assertEquals("Hi commons!", StrSubstitutor.replace("Hi <name>!", map, "<", ">")); } /** * Tests interpolation with system properties. */ @Test public void testStaticReplaceSystemProperties() { final StrBuilder buf = new StrBuilder(); buf.append("Hi ").append(System.getProperty("user.name")); buf.append(", you are working with "); buf.append(System.getProperty("os.name")); buf.append(", your home directory is "); buf.append(System.getProperty("user.home")).append('.'); assertEquals(buf.toString(), StrSubstitutor.replaceSystemProperties("Hi ${user.name}, you are " + "working with ${os.name}, your home " + "directory is ${user.home}.")); } /** * Test the replace of a properties object */ @Test public void testSubstituteDefaultProperties(){ final String org = "${doesnotwork}"; System.setProperty("doesnotwork", "It works!"); // create a new Properties object with the System.getProperties as default final Properties props = new Properties(System.getProperties()); assertEquals("It works!", StrSubstitutor.replace(org, props)); } @Test public void testSamePrefixAndSuffix() { final Map<String, String> map = new HashMap<String, String>(); map.put("greeting", "Hello"); map.put(" there ", "XXX"); map.put("name", "commons"); assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@")); assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@")); } //----------------------------------------------------------------------- private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) { final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1); final StrSubstitutor sub = new StrSubstitutor(values); // replace using String assertEquals(expectedResult, sub.replace(replaceTemplate)); if (substring) { assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2)); } // replace using char[] final char[] chars = replaceTemplate.toCharArray(); assertEquals(expectedResult, sub.replace(chars)); if (substring) { assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2)); } // replace using StringBuffer StringBuffer buf = new StringBuffer(replaceTemplate); assertEquals(expectedResult, sub.replace(buf)); if (substring) { assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2)); } // replace using StringBuilder StringBuilder builder = new StringBuilder(replaceTemplate); assertEquals(expectedResult, sub.replace(builder)); if (substring) { assertEquals(expectedShortResult, sub.replace(builder, 1, builder.length() - 2)); } // replace using StrBuilder StrBuilder bld = new StrBuilder(replaceTemplate); assertEquals(expectedResult, sub.replace(bld)); if (substring) { assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2)); } // replace using object final MutableObject<String> obj = new MutableObject<String>(replaceTemplate); // toString returns template assertEquals(expectedResult, sub.replace(obj)); // replace in StringBuffer buf = new StringBuffer(replaceTemplate); assertTrue(sub.replaceIn(buf)); assertEquals(expectedResult, buf.toString()); if (substring) { buf = new StringBuffer(replaceTemplate); assertTrue(sub.replaceIn(buf, 1, buf.length() - 2)); assertEquals(expectedResult, buf.toString()); // expect full result as remainder is untouched } // replace in StringBuilder builder = new StringBuilder(replaceTemplate); assertTrue(sub.replaceIn(builder)); assertEquals(expectedResult, builder.toString()); if (substring) { builder = new StringBuilder(replaceTemplate); assertTrue(sub.replaceIn(builder, 1, builder.length() - 2)); assertEquals(expectedResult, builder.toString()); // expect full result as remainder is untouched } // replace in StrBuilder bld = new StrBuilder(replaceTemplate); assertTrue(sub.replaceIn(bld)); assertEquals(expectedResult, bld.toString()); if (substring) { bld = new StrBuilder(replaceTemplate); assertTrue(sub.replaceIn(bld, 1, bld.length() - 2)); assertEquals(expectedResult, bld.toString()); // expect full result as remainder is untouched } } private void doTestNoReplace(final String replaceTemplate) { final StrSubstitutor sub = new StrSubstitutor(values); if (replaceTemplate == null) { assertEquals(null, sub.replace((String) null)); assertEquals(null, sub.replace((String) null, 0, 100)); assertEquals(null, sub.replace((char[]) null)); assertEquals(null, sub.replace((char[]) null, 0, 100)); assertEquals(null, sub.replace((StringBuffer) null)); assertEquals(null, sub.replace((StringBuffer) null, 0, 100)); assertEquals(null, sub.replace((StrBuilder) null)); assertEquals(null, sub.replace((StrBuilder) null, 0, 100)); assertEquals(null, sub.replace((Object) null)); assertFalse(sub.replaceIn((StringBuffer) null)); assertFalse(sub.replaceIn((StringBuffer) null, 0, 100)); assertFalse(sub.replaceIn((StrBuilder) null)); assertFalse(sub.replaceIn((StrBuilder) null, 0, 100)); } else { assertEquals(replaceTemplate, sub.replace(replaceTemplate)); final StrBuilder bld = new StrBuilder(replaceTemplate); assertFalse(sub.replaceIn(bld)); assertEquals(replaceTemplate, bld.toString()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import org.junit.Test; import static org.junit.Assert.*; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.NoSuchElementException; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.ObjectUtils; /** * Unit test for Tokenizer. * */ public class StrTokenizerTest { private static final String CSV_SIMPLE_FIXTURE = "A,b,c"; private static final String TSV_SIMPLE_FIXTURE = "A\tb\tc"; private void checkClone(final StrTokenizer tokenizer) { assertFalse(StrTokenizer.getCSVInstance() == tokenizer); assertFalse(StrTokenizer.getTSVInstance() == tokenizer); } // ----------------------------------------------------------------------- @Test public void test1() { final String input = "a;b;c;\"d;\"\"e\";f; ; ; "; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterChar(';'); tok.setQuoteChar('"'); tok.setIgnoredMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", "", "", "",}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void test2() { final String input = "a;b;c ;\"d;\"\"e\";f; ; ;"; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterChar(';'); tok.setQuoteChar('"'); tok.setIgnoredMatcher(StrMatcher.noneMatcher()); tok.setIgnoreEmptyTokens(false); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", "c ", "d;\"e", "f", " ", " ", "",}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void test3() { final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterChar(';'); tok.setQuoteChar('"'); tok.setIgnoredMatcher(StrMatcher.noneMatcher()); tok.setIgnoreEmptyTokens(false); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", " c", "d;\"e", "f", " ", " ", "",}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void test4() { final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterChar(';'); tok.setQuoteChar('"'); tok.setIgnoredMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(true); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f",}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void test5() { final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterChar(';'); tok.setQuoteChar('"'); tok.setIgnoredMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null,}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void test6() { final String input = "a;b; c;\"d;\"\"e\";f; ; ;"; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterChar(';'); tok.setQuoteChar('"'); tok.setIgnoredMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); // tok.setTreatingEmptyAsNull(true); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", " c", "d;\"e", "f", null, null, null,}; int nextCount = 0; while (tok.hasNext()) { tok.next(); nextCount++; } int prevCount = 0; while (tok.hasPrevious()) { tok.previous(); prevCount++; } assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); assertTrue("could not cycle through entire token list" + " using the 'hasNext' and 'next' methods", nextCount == expected.length); assertTrue("could not cycle through entire token list" + " using the 'hasPrevious' and 'previous' methods", prevCount == expected.length); } @Test public void test7() { final String input = "a b c \"d e\" f "; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterMatcher(StrMatcher.spaceMatcher()); tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher()); tok.setIgnoredMatcher(StrMatcher.noneMatcher()); tok.setIgnoreEmptyTokens(false); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "", "", "b", "c", "d e", "f", "",}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void test8() { final String input = "a b c \"d e\" f "; final StrTokenizer tok = new StrTokenizer(input); tok.setDelimiterMatcher(StrMatcher.spaceMatcher()); tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher()); tok.setIgnoredMatcher(StrMatcher.noneMatcher()); tok.setIgnoreEmptyTokens(true); final String tokens[] = tok.getTokenArray(); final String expected[] = new String[]{"a", "b", "c", "d e", "f",}; assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length); for (int i = 0; i < expected.length; i++) { assertTrue("token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'", ObjectUtils.equals(expected[i], tokens[i])); } } @Test public void testBasic1() { final String input = "a b c"; final StrTokenizer tok = new StrTokenizer(input); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasic2() { final String input = "a \nb\fc"; final StrTokenizer tok = new StrTokenizer(input); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasic3() { final String input = "a \nb\u0001\fc"; final StrTokenizer tok = new StrTokenizer(input); assertEquals("a", tok.next()); assertEquals("b\u0001", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasic4() { final String input = "a \"b\" c"; final StrTokenizer tok = new StrTokenizer(input); assertEquals("a", tok.next()); assertEquals("\"b\"", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasic5() { final String input = "a:b':c"; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); assertEquals("a", tok.next()); assertEquals("b'", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicDelim1() { final String input = "a:b:c"; final StrTokenizer tok = new StrTokenizer(input, ':'); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicDelim2() { final String input = "a:b:c"; final StrTokenizer tok = new StrTokenizer(input, ','); assertEquals("a:b:c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicEmpty1() { final String input = "a b c"; final StrTokenizer tok = new StrTokenizer(input); tok.setIgnoreEmptyTokens(false); assertEquals("a", tok.next()); assertEquals("", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicEmpty2() { final String input = "a b c"; final StrTokenizer tok = new StrTokenizer(input); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals(null, tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted1() { final String input = "a 'b' c"; final StrTokenizer tok = new StrTokenizer(input, ' ', '\''); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted2() { final String input = "a:'b':"; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted3() { final String input = "a:'b''c'"; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("b'c", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted4() { final String input = "a: 'b' 'c' :d"; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("b c", tok.next()); assertEquals("d", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted5() { final String input = "a: 'b'x'c' :d"; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("bxc", tok.next()); assertEquals("d", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted6() { final String input = "a:'b'\"c':d"; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setQuoteMatcher(StrMatcher.quoteMatcher()); assertEquals("a", tok.next()); assertEquals("b\"c:d", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuoted7() { final String input = "a:\"There's a reason here\":b"; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setQuoteMatcher(StrMatcher.quoteMatcher()); assertEquals("a", tok.next()); assertEquals("There's a reason here", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicQuotedTrimmed1() { final String input = "a: 'b' :"; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicTrimmed1() { final String input = "a: b : "; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicTrimmed2() { final String input = "a: b :"; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setTrimmerMatcher(StrMatcher.stringMatcher(" ")); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicIgnoreTrimmed1() { final String input = "a: bIGNOREc : "; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("bc", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicIgnoreTrimmed2() { final String input = "IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE "; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("bc", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicIgnoreTrimmed3() { final String input = "IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE "; final StrTokenizer tok = new StrTokenizer(input, ':'); tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals(" bc ", tok.next()); assertEquals(" ", tok.next()); assertFalse(tok.hasNext()); } @Test public void testBasicIgnoreTrimmed4() { final String input = "IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE "; final StrTokenizer tok = new StrTokenizer(input, ':', '\''); tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE")); tok.setTrimmerMatcher(StrMatcher.trimMatcher()); tok.setIgnoreEmptyTokens(false); tok.setEmptyTokenAsNull(true); assertEquals("a", tok.next()); assertEquals("bIGNOREcd", tok.next()); assertEquals(null, tok.next()); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testListArray() { final String input = "a b c"; final StrTokenizer tok = new StrTokenizer(input); final String[] array = tok.getTokenArray(); final List<?> list = tok.getTokenList(); assertEquals(Arrays.asList(array), list); assertEquals(3, list.size()); } //----------------------------------------------------------------------- private void testCSV(final String data) { this.testXSVAbc(StrTokenizer.getCSVInstance(data)); this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray())); } @Test public void testCSVEmpty() { this.testEmpty(StrTokenizer.getCSVInstance()); this.testEmpty(StrTokenizer.getCSVInstance("")); } @Test public void testCSVSimple() { this.testCSV(CSV_SIMPLE_FIXTURE); } @Test public void testCSVSimpleNeedsTrim() { this.testCSV(" " + CSV_SIMPLE_FIXTURE); this.testCSV(" \n\t " + CSV_SIMPLE_FIXTURE); this.testCSV(" \n " + CSV_SIMPLE_FIXTURE + "\n\n\r"); } void testEmpty(final StrTokenizer tokenizer) { this.checkClone(tokenizer); assertFalse(tokenizer.hasNext()); assertFalse(tokenizer.hasPrevious()); assertEquals(null, tokenizer.nextToken()); assertEquals(0, tokenizer.size()); try { tokenizer.next(); fail(); } catch (final NoSuchElementException ex) {} } @Test public void testGetContent() { final String input = "a b c \"d e\" f "; StrTokenizer tok = new StrTokenizer(input); assertEquals(input, tok.getContent()); tok = new StrTokenizer(input.toCharArray()); assertEquals(input, tok.getContent()); tok = new StrTokenizer(); assertEquals(null, tok.getContent()); } //----------------------------------------------------------------------- @Test public void testChaining() { final StrTokenizer tok = new StrTokenizer(); assertEquals(tok, tok.reset()); assertEquals(tok, tok.reset("")); assertEquals(tok, tok.reset(new char[0])); assertEquals(tok, tok.setDelimiterChar(' ')); assertEquals(tok, tok.setDelimiterString(" ")); assertEquals(tok, tok.setDelimiterMatcher(null)); assertEquals(tok, tok.setQuoteChar(' ')); assertEquals(tok, tok.setQuoteMatcher(null)); assertEquals(tok, tok.setIgnoredChar(' ')); assertEquals(tok, tok.setIgnoredMatcher(null)); assertEquals(tok, tok.setTrimmerMatcher(null)); assertEquals(tok, tok.setEmptyTokenAsNull(false)); assertEquals(tok, tok.setIgnoreEmptyTokens(false)); } /** * Tests that the {@link StrTokenizer#clone()} clone method catches {@link CloneNotSupportedException} and returns * <code>null</code>. */ @Test public void testCloneNotSupportedException() { final Object notCloned = new StrTokenizer() { @Override Object cloneReset() throws CloneNotSupportedException { throw new CloneNotSupportedException("test"); } }.clone(); assertNull(notCloned); } @Test public void testCloneNull() { final StrTokenizer tokenizer = new StrTokenizer((char[]) null); // Start sanity check assertEquals(null, tokenizer.nextToken()); tokenizer.reset(); assertEquals(null, tokenizer.nextToken()); // End sanity check final StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone(); tokenizer.reset(); assertEquals(null, tokenizer.nextToken()); assertEquals(null, clonedTokenizer.nextToken()); } @Test public void testCloneReset() { final char[] input = new char[]{'a'}; final StrTokenizer tokenizer = new StrTokenizer(input); // Start sanity check assertEquals("a", tokenizer.nextToken()); tokenizer.reset(input); assertEquals("a", tokenizer.nextToken()); // End sanity check final StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone(); input[0] = 'b'; tokenizer.reset(input); assertEquals("b", tokenizer.nextToken()); assertEquals("a", clonedTokenizer.nextToken()); } // ----------------------------------------------------------------------- @Test public void testConstructor_String() { StrTokenizer tok = new StrTokenizer("a b"); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); tok = new StrTokenizer(""); assertFalse(tok.hasNext()); tok = new StrTokenizer((String) null); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testConstructor_String_char() { StrTokenizer tok = new StrTokenizer("a b", ' '); assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1)); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); tok = new StrTokenizer("", ' '); assertFalse(tok.hasNext()); tok = new StrTokenizer((String) null, ' '); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testConstructor_String_char_char() { StrTokenizer tok = new StrTokenizer("a b", ' ', '"'); assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1)); assertEquals(1, tok.getQuoteMatcher().isMatch("\"".toCharArray(), 0, 0, 1)); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); tok = new StrTokenizer("", ' ', '"'); assertFalse(tok.hasNext()); tok = new StrTokenizer((String) null, ' ', '"'); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testConstructor_charArray() { StrTokenizer tok = new StrTokenizer("a b".toCharArray()); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); tok = new StrTokenizer(new char[0]); assertFalse(tok.hasNext()); tok = new StrTokenizer((char[]) null); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testConstructor_charArray_char() { StrTokenizer tok = new StrTokenizer("a b".toCharArray(), ' '); assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1)); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); tok = new StrTokenizer(new char[0], ' '); assertFalse(tok.hasNext()); tok = new StrTokenizer((char[]) null, ' '); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testConstructor_charArray_char_char() { StrTokenizer tok = new StrTokenizer("a b".toCharArray(), ' ', '"'); assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1)); assertEquals(1, tok.getQuoteMatcher().isMatch("\"".toCharArray(), 0, 0, 1)); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertFalse(tok.hasNext()); tok = new StrTokenizer(new char[0], ' ', '"'); assertFalse(tok.hasNext()); tok = new StrTokenizer((char[]) null, ' ', '"'); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testReset() { final StrTokenizer tok = new StrTokenizer("a b c"); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); tok.reset(); assertEquals("a", tok.next()); assertEquals("b", tok.next()); assertEquals("c", tok.next()); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testReset_String() { final StrTokenizer tok = new StrTokenizer("x x x"); tok.reset("d e"); assertEquals("d", tok.next()); assertEquals("e", tok.next()); assertFalse(tok.hasNext()); tok.reset((String) null); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testReset_charArray() { final StrTokenizer tok = new StrTokenizer("x x x"); final char[] array = new char[] {'a', 'b', 'c'}; tok.reset(array); assertEquals("abc", tok.next()); assertFalse(tok.hasNext()); tok.reset((char[]) null); assertFalse(tok.hasNext()); } //----------------------------------------------------------------------- @Test public void testTSV() { this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE)); this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray())); } @Test public void testTSVEmpty() { this.testEmpty(StrTokenizer.getCSVInstance()); this.testEmpty(StrTokenizer.getCSVInstance("")); } void testXSVAbc(final StrTokenizer tokenizer) { this.checkClone(tokenizer); assertEquals(-1, tokenizer.previousIndex()); assertEquals(0, tokenizer.nextIndex()); assertEquals(null, tokenizer.previousToken()); assertEquals("A", tokenizer.nextToken()); assertEquals(1, tokenizer.nextIndex()); assertEquals("b", tokenizer.nextToken()); assertEquals(2, tokenizer.nextIndex()); assertEquals("c", tokenizer.nextToken()); assertEquals(3, tokenizer.nextIndex()); assertEquals(null, tokenizer.nextToken()); assertEquals(3, tokenizer.nextIndex()); assertEquals("c", tokenizer.previousToken()); assertEquals(2, tokenizer.nextIndex()); assertEquals("b", tokenizer.previousToken()); assertEquals(1, tokenizer.nextIndex()); assertEquals("A", tokenizer.previousToken()); assertEquals(0, tokenizer.nextIndex()); assertEquals(null, tokenizer.previousToken()); assertEquals(0, tokenizer.nextIndex()); assertEquals(-1, tokenizer.previousIndex()); assertEquals(3, tokenizer.size()); } @Test public void testIteration() { final StrTokenizer tkn = new StrTokenizer("a b c"); assertFalse(tkn.hasPrevious()); try { tkn.previous(); fail(); } catch (final NoSuchElementException ex) {} assertTrue(tkn.hasNext()); assertEquals("a", tkn.next()); try { tkn.remove(); fail(); } catch (final UnsupportedOperationException ex) {} try { tkn.set("x"); fail(); } catch (final UnsupportedOperationException ex) {} try { tkn.add("y"); fail(); } catch (final UnsupportedOperationException ex) {} assertTrue(tkn.hasPrevious()); assertTrue(tkn.hasNext()); assertEquals("b", tkn.next()); assertTrue(tkn.hasPrevious()); assertTrue(tkn.hasNext()); assertEquals("c", tkn.next()); assertTrue(tkn.hasPrevious()); assertFalse(tkn.hasNext()); try { tkn.next(); fail(); } catch (final NoSuchElementException ex) {} assertTrue(tkn.hasPrevious()); assertFalse(tkn.hasNext()); } //----------------------------------------------------------------------- @Test public void testTokenizeSubclassInputChange() { final StrTokenizer tkn = new StrTokenizer("a b c d e") { @Override protected List<String> tokenize(final char[] chars, final int offset, final int count) { return super.tokenize("w x y z".toCharArray(), 2, 5); } }; assertEquals("x", tkn.next()); assertEquals("y", tkn.next()); } //----------------------------------------------------------------------- @Test public void testTokenizeSubclassOutputChange() { final StrTokenizer tkn = new StrTokenizer("a b c") { @Override protected List<String> tokenize(final char[] chars, final int offset, final int count) { final List<String> list = super.tokenize(chars, offset, count); Collections.reverse(list); return list; } }; assertEquals("c", tkn.next()); assertEquals("b", tkn.next()); assertEquals("a", tkn.next()); } //----------------------------------------------------------------------- @Test public void testToString() { final StrTokenizer tkn = new StrTokenizer("a b c d e"); assertEquals("StrTokenizer[not tokenized yet]", tkn.toString()); tkn.next(); assertEquals("StrTokenizer[a, b, c, d, e]", tkn.toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import org.junit.Test; /** * Unit tests for WordUtils class. * * @version $Id$ */ public class WordUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new WordUtils()); final Constructor<?>[] cons = WordUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(WordUtils.class.getModifiers())); assertFalse(Modifier.isFinal(WordUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testWrap_StringInt() { assertEquals(null, WordUtils.wrap(null, 20)); assertEquals(null, WordUtils.wrap(null, -1)); assertEquals("", WordUtils.wrap("", 20)); assertEquals("", WordUtils.wrap("", -1)); // normal final String systemNewLine = System.getProperty("line.separator"); String input = "Here is one line of text that is going to be wrapped after 20 columns."; String expected = "Here is one line of" + systemNewLine + "text that is going" + systemNewLine + "to be wrapped after" + systemNewLine + "20 columns."; assertEquals(expected, WordUtils.wrap(input, 20)); // long word at end input = "Click here to jump to the jakarta website - http://jakarta.apache.org"; expected = "Click here to jump" + systemNewLine + "to the jakarta" + systemNewLine + "website -" + systemNewLine + "http://jakarta.apache.org"; assertEquals(expected, WordUtils.wrap(input, 20)); // long word in middle input = "Click here, http://jakarta.apache.org, to jump to the jakarta website"; expected = "Click here," + systemNewLine + "http://jakarta.apache.org," + systemNewLine + "to jump to the" + systemNewLine + "jakarta website"; assertEquals(expected, WordUtils.wrap(input, 20)); } @Test public void testWrap_StringIntStringBoolean() { assertEquals(null, WordUtils.wrap(null, 20, "\n", false)); assertEquals(null, WordUtils.wrap(null, 20, "\n", true)); assertEquals(null, WordUtils.wrap(null, 20, null, true)); assertEquals(null, WordUtils.wrap(null, 20, null, false)); assertEquals(null, WordUtils.wrap(null, -1, null, true)); assertEquals(null, WordUtils.wrap(null, -1, null, false)); assertEquals("", WordUtils.wrap("", 20, "\n", false)); assertEquals("", WordUtils.wrap("", 20, "\n", true)); assertEquals("", WordUtils.wrap("", 20, null, false)); assertEquals("", WordUtils.wrap("", 20, null, true)); assertEquals("", WordUtils.wrap("", -1, null, false)); assertEquals("", WordUtils.wrap("", -1, null, true)); // normal String input = "Here is one line of text that is going to be wrapped after 20 columns."; String expected = "Here is one line of\ntext that is going\nto be wrapped after\n20 columns."; assertEquals(expected, WordUtils.wrap(input, 20, "\n", false)); assertEquals(expected, WordUtils.wrap(input, 20, "\n", true)); // unusual newline char input = "Here is one line of text that is going to be wrapped after 20 columns."; expected = "Here is one line of<br />text that is going<br />to be wrapped after<br />20 columns."; assertEquals(expected, WordUtils.wrap(input, 20, "<br />", false)); assertEquals(expected, WordUtils.wrap(input, 20, "<br />", true)); // short line length input = "Here is one line"; expected = "Here\nis one\nline"; assertEquals(expected, WordUtils.wrap(input, 6, "\n", false)); expected = "Here\nis\none\nline"; assertEquals(expected, WordUtils.wrap(input, 2, "\n", false)); assertEquals(expected, WordUtils.wrap(input, -1, "\n", false)); // system newline char final String systemNewLine = System.getProperty("line.separator"); input = "Here is one line of text that is going to be wrapped after 20 columns."; expected = "Here is one line of" + systemNewLine + "text that is going" + systemNewLine + "to be wrapped after" + systemNewLine + "20 columns."; assertEquals(expected, WordUtils.wrap(input, 20, null, false)); assertEquals(expected, WordUtils.wrap(input, 20, null, true)); // with extra spaces input = " Here: is one line of text that is going to be wrapped after 20 columns."; expected = "Here: is one line\nof text that is \ngoing to be \nwrapped after 20 \ncolumns."; assertEquals(expected, WordUtils.wrap(input, 20, "\n", false)); assertEquals(expected, WordUtils.wrap(input, 20, "\n", true)); // with tab input = "Here is\tone line of text that is going to be wrapped after 20 columns."; expected = "Here is\tone line of\ntext that is going\nto be wrapped after\n20 columns."; assertEquals(expected, WordUtils.wrap(input, 20, "\n", false)); assertEquals(expected, WordUtils.wrap(input, 20, "\n", true)); // with tab at wrapColumn input = "Here is one line of\ttext that is going to be wrapped after 20 columns."; expected = "Here is one line\nof\ttext that is\ngoing to be wrapped\nafter 20 columns."; assertEquals(expected, WordUtils.wrap(input, 20, "\n", false)); assertEquals(expected, WordUtils.wrap(input, 20, "\n", true)); // difference because of long word input = "Click here to jump to the jakarta website - http://jakarta.apache.org"; expected = "Click here to jump\nto the jakarta\nwebsite -\nhttp://jakarta.apache.org"; assertEquals(expected, WordUtils.wrap(input, 20, "\n", false)); expected = "Click here to jump\nto the jakarta\nwebsite -\nhttp://jakarta.apach\ne.org"; assertEquals(expected, WordUtils.wrap(input, 20, "\n", true)); // difference because of long word in middle input = "Click here, http://jakarta.apache.org, to jump to the jakarta website"; expected = "Click here,\nhttp://jakarta.apache.org,\nto jump to the\njakarta website"; assertEquals(expected, WordUtils.wrap(input, 20, "\n", false)); expected = "Click here,\nhttp://jakarta.apach\ne.org, to jump to\nthe jakarta website"; assertEquals(expected, WordUtils.wrap(input, 20, "\n", true)); // System.err.println(expected); // System.err.println(WordUtils.wrap(input, 20, "\n", false)); } //----------------------------------------------------------------------- @Test public void testCapitalize_String() { assertEquals(null, WordUtils.capitalize(null)); assertEquals("", WordUtils.capitalize("")); assertEquals(" ", WordUtils.capitalize(" ")); assertEquals("I", WordUtils.capitalize("I") ); assertEquals("I", WordUtils.capitalize("i") ); assertEquals("I Am Here 123", WordUtils.capitalize("i am here 123") ); assertEquals("I Am Here 123", WordUtils.capitalize("I Am Here 123") ); assertEquals("I Am HERE 123", WordUtils.capitalize("i am HERE 123") ); assertEquals("I AM HERE 123", WordUtils.capitalize("I AM HERE 123") ); } @Test public void testCapitalizeWithDelimiters_String() { assertEquals(null, WordUtils.capitalize(null, null)); assertEquals("", WordUtils.capitalize("", new char[0])); assertEquals(" ", WordUtils.capitalize(" ", new char[0])); char[] chars = new char[] { '-', '+', ' ', '@' }; assertEquals("I", WordUtils.capitalize("I", chars) ); assertEquals("I", WordUtils.capitalize("i", chars) ); assertEquals("I-Am Here+123", WordUtils.capitalize("i-am here+123", chars) ); assertEquals("I Am+Here-123", WordUtils.capitalize("I Am+Here-123", chars) ); assertEquals("I+Am-HERE 123", WordUtils.capitalize("i+am-HERE 123", chars) ); assertEquals("I-AM HERE+123", WordUtils.capitalize("I-AM HERE+123", chars) ); chars = new char[] {'.'}; assertEquals("I aM.Fine", WordUtils.capitalize("i aM.fine", chars) ); assertEquals("I Am.fine", WordUtils.capitalize("i am.fine", null) ); } @Test public void testCapitalizeFully_String() { assertEquals(null, WordUtils.capitalizeFully(null)); assertEquals("", WordUtils.capitalizeFully("")); assertEquals(" ", WordUtils.capitalizeFully(" ")); assertEquals("I", WordUtils.capitalizeFully("I") ); assertEquals("I", WordUtils.capitalizeFully("i") ); assertEquals("I Am Here 123", WordUtils.capitalizeFully("i am here 123") ); assertEquals("I Am Here 123", WordUtils.capitalizeFully("I Am Here 123") ); assertEquals("I Am Here 123", WordUtils.capitalizeFully("i am HERE 123") ); assertEquals("I Am Here 123", WordUtils.capitalizeFully("I AM HERE 123") ); } @Test public void testCapitalizeFullyWithDelimiters_String() { assertEquals(null, WordUtils.capitalizeFully(null, null)); assertEquals("", WordUtils.capitalizeFully("", new char[0])); assertEquals(" ", WordUtils.capitalizeFully(" ", new char[0])); char[] chars = new char[] { '-', '+', ' ', '@' }; assertEquals("I", WordUtils.capitalizeFully("I", chars) ); assertEquals("I", WordUtils.capitalizeFully("i", chars) ); assertEquals("I-Am Here+123", WordUtils.capitalizeFully("i-am here+123", chars) ); assertEquals("I Am+Here-123", WordUtils.capitalizeFully("I Am+Here-123", chars) ); assertEquals("I+Am-Here 123", WordUtils.capitalizeFully("i+am-HERE 123", chars) ); assertEquals("I-Am Here+123", WordUtils.capitalizeFully("I-AM HERE+123", chars) ); chars = new char[] {'.'}; assertEquals("I am.Fine", WordUtils.capitalizeFully("i aM.fine", chars) ); assertEquals("I Am.fine", WordUtils.capitalizeFully("i am.fine", null) ); } @Test public void testUncapitalize_String() { assertEquals(null, WordUtils.uncapitalize(null)); assertEquals("", WordUtils.uncapitalize("")); assertEquals(" ", WordUtils.uncapitalize(" ")); assertEquals("i", WordUtils.uncapitalize("I") ); assertEquals("i", WordUtils.uncapitalize("i") ); assertEquals("i am here 123", WordUtils.uncapitalize("i am here 123") ); assertEquals("i am here 123", WordUtils.uncapitalize("I Am Here 123") ); assertEquals("i am hERE 123", WordUtils.uncapitalize("i am HERE 123") ); assertEquals("i aM hERE 123", WordUtils.uncapitalize("I AM HERE 123") ); } @Test public void testUncapitalizeWithDelimiters_String() { assertEquals(null, WordUtils.uncapitalize(null, null)); assertEquals("", WordUtils.uncapitalize("", new char[0])); assertEquals(" ", WordUtils.uncapitalize(" ", new char[0])); char[] chars = new char[] { '-', '+', ' ', '@' }; assertEquals("i", WordUtils.uncapitalize("I", chars) ); assertEquals("i", WordUtils.uncapitalize("i", chars) ); assertEquals("i am-here+123", WordUtils.uncapitalize("i am-here+123", chars) ); assertEquals("i+am here-123", WordUtils.uncapitalize("I+Am Here-123", chars) ); assertEquals("i-am+hERE 123", WordUtils.uncapitalize("i-am+HERE 123", chars) ); assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) ); chars = new char[] {'.'}; assertEquals("i AM.fINE", WordUtils.uncapitalize("I AM.FINE", chars) ); assertEquals("i aM.FINE", WordUtils.uncapitalize("I AM.FINE", null) ); } //----------------------------------------------------------------------- @Test public void testInitials_String() { assertEquals(null, WordUtils.initials(null)); assertEquals("", WordUtils.initials("")); assertEquals("", WordUtils.initials(" ")); assertEquals("I", WordUtils.initials("I")); assertEquals("i", WordUtils.initials("i")); assertEquals("BJL", WordUtils.initials("Ben John Lee")); assertEquals("BJ", WordUtils.initials("Ben J.Lee")); assertEquals("BJ.L", WordUtils.initials(" Ben John . Lee")); assertEquals("iah1", WordUtils.initials("i am here 123")); } // ----------------------------------------------------------------------- @Test public void testInitials_String_charArray() { char[] array = null; assertEquals(null, WordUtils.initials(null, array)); assertEquals("", WordUtils.initials("", array)); assertEquals("", WordUtils.initials(" ", array)); assertEquals("I", WordUtils.initials("I", array)); assertEquals("i", WordUtils.initials("i", array)); assertEquals("S", WordUtils.initials("SJC", array)); assertEquals("BJL", WordUtils.initials("Ben John Lee", array)); assertEquals("BJ", WordUtils.initials("Ben J.Lee", array)); assertEquals("BJ.L", WordUtils.initials(" Ben John . Lee", array)); assertEquals("KO", WordUtils.initials("Kay O'Murphy", array)); assertEquals("iah1", WordUtils.initials("i am here 123", array)); array = new char[0]; assertEquals(null, WordUtils.initials(null, array)); assertEquals("", WordUtils.initials("", array)); assertEquals("", WordUtils.initials(" ", array)); assertEquals("", WordUtils.initials("I", array)); assertEquals("", WordUtils.initials("i", array)); assertEquals("", WordUtils.initials("SJC", array)); assertEquals("", WordUtils.initials("Ben John Lee", array)); assertEquals("", WordUtils.initials("Ben J.Lee", array)); assertEquals("", WordUtils.initials(" Ben John . Lee", array)); assertEquals("", WordUtils.initials("Kay O'Murphy", array)); assertEquals("", WordUtils.initials("i am here 123", array)); array = " ".toCharArray(); assertEquals(null, WordUtils.initials(null, array)); assertEquals("", WordUtils.initials("", array)); assertEquals("", WordUtils.initials(" ", array)); assertEquals("I", WordUtils.initials("I", array)); assertEquals("i", WordUtils.initials("i", array)); assertEquals("S", WordUtils.initials("SJC", array)); assertEquals("BJL", WordUtils.initials("Ben John Lee", array)); assertEquals("BJ", WordUtils.initials("Ben J.Lee", array)); assertEquals("BJ.L", WordUtils.initials(" Ben John . Lee", array)); assertEquals("KO", WordUtils.initials("Kay O'Murphy", array)); assertEquals("iah1", WordUtils.initials("i am here 123", array)); array = " .".toCharArray(); assertEquals(null, WordUtils.initials(null, array)); assertEquals("", WordUtils.initials("", array)); assertEquals("", WordUtils.initials(" ", array)); assertEquals("I", WordUtils.initials("I", array)); assertEquals("i", WordUtils.initials("i", array)); assertEquals("S", WordUtils.initials("SJC", array)); assertEquals("BJL", WordUtils.initials("Ben John Lee", array)); assertEquals("BJL", WordUtils.initials("Ben J.Lee", array)); assertEquals("BJL", WordUtils.initials(" Ben John . Lee", array)); assertEquals("KO", WordUtils.initials("Kay O'Murphy", array)); assertEquals("iah1", WordUtils.initials("i am here 123", array)); array = " .'".toCharArray(); assertEquals(null, WordUtils.initials(null, array)); assertEquals("", WordUtils.initials("", array)); assertEquals("", WordUtils.initials(" ", array)); assertEquals("I", WordUtils.initials("I", array)); assertEquals("i", WordUtils.initials("i", array)); assertEquals("S", WordUtils.initials("SJC", array)); assertEquals("BJL", WordUtils.initials("Ben John Lee", array)); assertEquals("BJL", WordUtils.initials("Ben J.Lee", array)); assertEquals("BJL", WordUtils.initials(" Ben John . Lee", array)); assertEquals("KOM", WordUtils.initials("Kay O'Murphy", array)); assertEquals("iah1", WordUtils.initials("i am here 123", array)); array = "SIJo1".toCharArray(); assertEquals(null, WordUtils.initials(null, array)); assertEquals("", WordUtils.initials("", array)); assertEquals(" ", WordUtils.initials(" ", array)); assertEquals("", WordUtils.initials("I", array)); assertEquals("i", WordUtils.initials("i", array)); assertEquals("C", WordUtils.initials("SJC", array)); assertEquals("Bh", WordUtils.initials("Ben John Lee", array)); assertEquals("B.", WordUtils.initials("Ben J.Lee", array)); assertEquals(" h", WordUtils.initials(" Ben John . Lee", array)); assertEquals("K", WordUtils.initials("Kay O'Murphy", array)); assertEquals("i2", WordUtils.initials("i am here 123", array)); } // ----------------------------------------------------------------------- @Test public void testSwapCase_String() { assertEquals(null, WordUtils.swapCase(null)); assertEquals("", WordUtils.swapCase("")); assertEquals(" ", WordUtils.swapCase(" ")); assertEquals("i", WordUtils.swapCase("I") ); assertEquals("I", WordUtils.swapCase("i") ); assertEquals("I AM HERE 123", WordUtils.swapCase("i am here 123") ); assertEquals("i aM hERE 123", WordUtils.swapCase("I Am Here 123") ); assertEquals("I AM here 123", WordUtils.swapCase("i am HERE 123") ); assertEquals("i am here 123", WordUtils.swapCase("I AM HERE 123") ); final String test = "This String contains a TitleCase character: \u01C8"; final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9"; assertEquals(expect, WordUtils.swapCase(test)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import static org.junit.Assert.assertTrue; import java.util.HashSet; import java.util.Set; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.EntityArrays}. * @version $Id$ */ public class EntityArraysTest { @Test public void testConstructorExists() { new EntityArrays(); } // LANG-659 - check arrays for duplicate entries @Test public void testHTML40_EXTENDED_ESCAPE(){ final Set<String> col0 = new HashSet<String>(); final Set<String> col1 = new HashSet<String>(); final String [][] sa = EntityArrays.HTML40_EXTENDED_ESCAPE(); for(int i =0; i <sa.length; i++){ assertTrue("Already added entry 0: "+i+" "+sa[i][0],col0.add(sa[i][0])); assertTrue("Already added entry 1: "+i+" "+sa[i][1],col1.add(sa[i][1])); } } // LANG-658 - check arrays for duplicate entries @Test public void testISO8859_1_ESCAPE(){ final Set<String> col0 = new HashSet<String>(); final Set<String> col1 = new HashSet<String>(); final String [][] sa = EntityArrays.ISO8859_1_ESCAPE(); boolean success = true; for(int i =0; i <sa.length; i++){ final boolean add0 = col0.add(sa[i][0]); final boolean add1 = col1.add(sa[i][1]); if (!add0) { success = false; System.out.println("Already added entry 0: "+i+" "+sa[i][0]+" "+sa[i][1]); } if (!add1) { success = false; System.out.println("Already added entry 1: "+i+" "+sa[i][0]+" "+sa[i][1]); } } assertTrue("One or more errors detected",success); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import static org.junit.Assert.assertEquals; import java.io.IOException; import java.io.StringWriter; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.LookupTranslator}. * @version $Id$ */ public class LookupTranslatorTest { @Test public void testBasicLookup() throws IOException { final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { "one", "two" } }); final StringWriter out = new StringWriter(); final int result = lt.translate("one", 0, out); assertEquals("Incorrect codepoint consumption", 3, result); assertEquals("Incorrect value", "two", out.toString()); } // Tests: https://issues.apache.org/jira/browse/LANG-882 @Test public void testLang882() throws IOException { final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer("one"), new StringBuffer("two") } }); final StringWriter out = new StringWriter(); final int result = lt.translate(new StringBuffer("one"), 0, out); assertEquals("Incorrect codepoint consumption", 3, result); assertEquals("Incorrect value", "two", out.toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import static org.junit.Assert.assertEquals; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.NumericEntityEscaper}. * @version $Id$ */ public class NumericEntityEscaperTest { @Test public void testBelow() { final NumericEntityEscaper nee = NumericEntityEscaper.below('F'); final String input = "ADFGZ"; final String result = nee.translate(input); assertEquals("Failed to escape numeric entities via the below method", "&#65;&#68;FGZ", result); } @Test public void testBetween() { final NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L'); final String input = "ADFGZ"; final String result = nee.translate(input); assertEquals("Failed to escape numeric entities via the between method", "AD&#70;&#71;Z", result); } @Test public void testAbove() { final NumericEntityEscaper nee = NumericEntityEscaper.above('F'); final String input = "ADFGZ"; final String result = nee.translate(input); assertEquals("Failed to escape numeric entities via the above method", "ADF&#71;&#90;", result); } // See LANG-617 @Test public void testSupplementary() { final NumericEntityEscaper nee = new NumericEntityEscaper(); final String input = "\uD803\uDC22"; final String expected = "&#68642;"; final String result = nee.translate(input); assertEquals("Failed to escape numeric entities supplementary characters", expected, result); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.NumericEntityUnescaper}. * @version $Id$ */ public class NumericEntityUnescaperTest { @Test public void testSupplementaryUnescaping() { final NumericEntityUnescaper neu = new NumericEntityUnescaper(); final String input = "&#68642;"; final String expected = "\uD803\uDC22"; final String result = neu.translate(input); assertEquals("Failed to unescape numeric entities supplementary characters", expected, result); } @Test public void testOutOfBounds() { final NumericEntityUnescaper neu = new NumericEntityUnescaper(); assertEquals("Failed to ignore when last character is &", "Test &", neu.translate("Test &")); assertEquals("Failed to ignore when last character is &", "Test &#", neu.translate("Test &#")); assertEquals("Failed to ignore when last character is &", "Test &#x", neu.translate("Test &#x")); assertEquals("Failed to ignore when last character is &", "Test &#X", neu.translate("Test &#X")); } @Test public void testUnfinishedEntity() { // parse it NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional); String input = "Test &#x30 not test"; String expected = "Test \u0030 not test"; String result = neu.translate(input); assertEquals("Failed to support unfinished entities (i.e. missing semi-colon)", expected, result); // ignore it neu = new NumericEntityUnescaper(); input = "Test &#x30 not test"; expected = input; result = neu.translate(input); assertEquals("Failed to ignore unfinished entities (i.e. missing semi-colon)", expected, result); // fail it neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon); input = "Test &#x30 not test"; try { result = neu.translate(input); fail("IllegalArgumentException expected"); } catch(final IllegalArgumentException iae) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import org.junit.Test; import static org.junit.Assert.*; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.OctalUnescaper}. * @version $Id: OctalUnescaperTest.java 979392 2010-07-26 18:09:52Z mbenson $ */ public class OctalUnescaperTest { @Test public void testBetween() { final OctalUnescaper oue = new OctalUnescaper(); //.between("1", "377"); String input = "\\45"; String result = oue.translate(input); assertEquals("Failed to unescape octal characters via the between method", "\45", result); input = "\\377"; result = oue.translate(input); assertEquals("Failed to unescape octal characters via the between method", "\377", result); input = "\\377 and"; result = oue.translate(input); assertEquals("Failed to unescape octal characters via the between method", "\377 and", result); input = "\\378 and"; result = oue.translate(input); assertEquals("Failed to unescape octal characters via the between method", "\378 and", result); input = "\\378"; result = oue.translate(input); assertEquals("Failed to unescape octal characters via the between method", "\378", result); input = "\\1"; result = oue.translate(input); assertEquals("Failed to unescape octal characters via the between method", "\1", result); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import static org.junit.Assert.assertEquals; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.UnicodeEscaper}. * @version $Id$ */ public class UnicodeEscaperTest { @Test public void testBelow() { final UnicodeEscaper ue = UnicodeEscaper.below('F'); final String input = "ADFGZ"; final String result = ue.translate(input); assertEquals("Failed to escape Unicode characters via the below method", "\\u0041\\u0044FGZ", result); } @Test public void testBetween() { final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L'); final String input = "ADFGZ"; final String result = ue.translate(input); assertEquals("Failed to escape Unicode characters via the between method", "AD\\u0046\\u0047Z", result); } @Test public void testAbove() { final UnicodeEscaper ue = UnicodeEscaper.above('F'); final String input = "ADFGZ"; final String result = ue.translate(input); assertEquals("Failed to escape Unicode characters via the above method", "ADF\\u0047\\u005A", result); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.text.translate; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import org.junit.Test; /** * Unit tests for {@link org.apache.commons.lang3.text.translate.UnicodeEscaper}. * @version $Id$ */ public class UnicodeUnescaperTest { // Requested in LANG-507 @Test public void testUPlus() { final UnicodeUnescaper uu = new UnicodeUnescaper(); final String input = "\\u+0047"; assertEquals("Failed to unescape Unicode characters with 'u+' notation", "G", uu.translate(input)); } @Test public void testUuuuu() { final UnicodeUnescaper uu = new UnicodeUnescaper(); final String input = "\\uuuuuuuu0047"; final String result = uu.translate(input); assertEquals("Failed to unescape Unicode characters with many 'u' characters", "G", result); } @Test public void testLessThanFour() { final UnicodeUnescaper uu = new UnicodeUnescaper(); final String input = "\\0047\\u006"; try { uu.translate(input); fail("A lack of digits in a Unicode escape sequence failed to throw an exception"); } catch(final IllegalArgumentException iae) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import org.junit.Test; import static org.junit.Assert.*; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Calendar; import java.util.Locale; import java.util.TimeZone; /** * TestCase for DateFormatUtils. * */ public class DateFormatUtilsTest { //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new DateFormatUtils()); final Constructor<?>[] cons = DateFormatUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(DateFormatUtils.class.getModifiers())); assertFalse(Modifier.isFinal(DateFormatUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testFormat() { final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); c.set(2005,0,1,12,0,0); c.setTimeZone(TimeZone.getDefault()); final StringBuilder buffer = new StringBuilder (); final int year = c.get(Calendar.YEAR); final int month = c.get(Calendar.MONTH) + 1; final int day = c.get(Calendar.DAY_OF_MONTH); final int hour = c.get(Calendar.HOUR_OF_DAY); buffer.append (year); buffer.append(month); buffer.append(day); buffer.append(hour); assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH")); assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), "yyyyMdH")); assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH", Locale.US)); assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), "yyyyMdH", Locale.US)); } //----------------------------------------------------------------------- @Test public void testFormatCalendar() { final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); c.set(2005,0,1,12,0,0); c.setTimeZone(TimeZone.getDefault()); final StringBuilder buffer = new StringBuilder (); final int year = c.get(Calendar.YEAR); final int month = c.get(Calendar.MONTH) + 1; final int day = c.get(Calendar.DAY_OF_MONTH); final int hour = c.get(Calendar.HOUR_OF_DAY); buffer.append (year); buffer.append(month); buffer.append(day); buffer.append(hour); assertEquals(buffer.toString(), DateFormatUtils.format(c, "yyyyMdH")); assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH")); assertEquals(buffer.toString(), DateFormatUtils.format(c, "yyyyMdH", Locale.US)); assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH", Locale.US)); } @Test public void testFormatUTC() { final Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); c.set(2005,0,1,12,0,0); assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern())); assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US)); } @Test public void testDateTimeISO(){ final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); final Calendar cal = Calendar.getInstance(timeZone); cal.set(2002,1,23,9,11,12); String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23T09:11:12", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23T09:11:12", text); text = DateFormatUtils.ISO_DATETIME_FORMAT.format(cal); assertEquals("2002-02-23T09:11:12", text); text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23T09:11:12-03:00", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23T09:11:12-03:00", text); text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); assertEquals("2002-02-23T09:11:12-03:00", text); } @Test public void testDateISO(){ final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); final Calendar cal = Calendar.getInstance(timeZone); cal.set(2002,1,23,10,11,12); String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23", text); text = DateFormatUtils.ISO_DATE_FORMAT.format(cal); assertEquals("2002-02-23", text); text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23-03:00", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("2002-02-23-03:00", text); text = DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.format(cal); assertEquals("2002-02-23-03:00", text); } @Test public void testTimeISO(){ final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); final Calendar cal = Calendar.getInstance(timeZone); cal.set(2002,1,23,10,11,12); String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone); assertEquals("T10:11:12", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone); assertEquals("T10:11:12", text); text = DateFormatUtils.ISO_TIME_FORMAT.format(cal); assertEquals("T10:11:12", text); text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("T10:11:12-03:00", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("T10:11:12-03:00", text); text = DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.format(cal); assertEquals("T10:11:12-03:00", text); } @Test public void testTimeNoTISO(){ final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); final Calendar cal = Calendar.getInstance(timeZone); cal.set(2002,1,23,10,11,12); String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone); assertEquals("10:11:12", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone); assertEquals("10:11:12", text); text = DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(cal); assertEquals("10:11:12", text); text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("10:11:12-03:00", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern(), timeZone); assertEquals("10:11:12-03:00", text); text = DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.format(cal); assertEquals("10:11:12-03:00", text); } @Test public void testSMTP(){ final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); final Calendar cal = Calendar.getInstance(timeZone); cal.set(2003,5,8,10,11,12); String text = DateFormatUtils.format(cal.getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); text = DateFormatUtils.format(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone, DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal); assertEquals("Sun, 08 Jun 2003 10:11:12 -0300", text); // format UTC text = DateFormatUtils.formatUTC(cal.getTime().getTime(), DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale()); assertEquals("Sun, 08 Jun 2003 13:11:12 +0000", text); } /* public void testLang312() { String pattern = "dd/MM/yyyy"; String expected = "19/04/1948"; TimeZone timeZone = TimeZone.getTimeZone("CET"); Locale locale = Locale.GERMANY; // show Calendar is good Calendar cal = Calendar.getInstance(timeZone, locale); cal.set(1948, 3, 19); assertEquals(expected, DateFormatUtils.format( cal.getTime(), pattern, timeZone, locale ) ); Date date = new Date(48, 3, 19); // test JDK java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(pattern, locale); sdf.setTimeZone(timeZone); // There's nothing we can do if the JDK fails, so just going to pring a warning in this case // assertEquals(expected, sdf.format( date ) ); if( ! expected.equals( sdf.format( date ) ) ) { System.out.println("WARNING: JDK test failed - testLang312()"); } // test Commons assertEquals(expected, DateFormatUtils.format( date, pattern, timeZone, locale ) ); } */ }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import org.junit.Test; import org.junit.Before; import static org.junit.Assert.*; import java.util.Calendar; import java.util.Date; public class DateUtilsFragmentTest { private static final int months = 7; // second final prime before 12 private static final int days = 23; // second final prime before 31 (and valid) private static final int hours = 19; // second final prime before 24 private static final int minutes = 53; // second final prime before 60 private static final int seconds = 47; // third final prime before 60 private static final int millis = 991; // second final prime before 1000 private Date aDate; private Calendar aCalendar; @Before public void setUp() { aCalendar = Calendar.getInstance(); aCalendar.set(2005, months, days, hours, minutes, seconds); aCalendar.set(Calendar.MILLISECOND, millis); aDate = aCalendar.getTime(); } @Test public void testNullDate() { try { DateUtils.getFragmentInMilliseconds((Date) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInSeconds((Date) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInMinutes((Date) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInHours((Date) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInDays((Date) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} } @Test public void testNullCalendar() { try { DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInSeconds((Calendar) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND); fail(); } catch(final IllegalArgumentException iae) {} } @Test public void testInvalidFragmentWithDate() { try { DateUtils.getFragmentInMilliseconds(aDate, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInSeconds(aDate, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInMinutes(aDate, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInHours(aDate, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInDays(aDate, 0); fail(); } catch(final IllegalArgumentException iae) {} } @Test public void testInvalidFragmentWithCalendar() { try { DateUtils.getFragmentInMilliseconds(aCalendar, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInSeconds(aCalendar, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInMinutes(aCalendar, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInHours(aCalendar, 0); fail(); } catch(final IllegalArgumentException iae) {} try { DateUtils.getFragmentInDays(aCalendar, 0); fail(); } catch(final IllegalArgumentException iae) {} } @Test public void testMillisecondFragmentInLargerUnitWithDate() { assertEquals(0, DateUtils.getFragmentInMilliseconds(aDate, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MILLISECOND)); } @Test public void testMillisecondFragmentInLargerUnitWithCalendar() { assertEquals(0, DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MILLISECOND)); assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MILLISECOND)); } @Test public void testSecondFragmentInLargerUnitWithDate() { assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.SECOND)); assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.SECOND)); assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.SECOND)); assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.SECOND)); } @Test public void testSecondFragmentInLargerUnitWithCalendar() { assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.SECOND)); assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.SECOND)); assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.SECOND)); assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.SECOND)); } @Test public void testMinuteFragmentInLargerUnitWithDate() { assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MINUTE)); assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MINUTE)); assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MINUTE)); } @Test public void testMinuteFragmentInLargerUnitWithCalendar() { assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MINUTE)); assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MINUTE)); assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MINUTE)); } @Test public void testHourOfDayFragmentInLargerUnitWithDate() { assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.HOUR_OF_DAY)); assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.HOUR_OF_DAY)); } @Test public void testHourOfDayFragmentInLargerUnitWithCalendar() { assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.HOUR_OF_DAY)); assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.HOUR_OF_DAY)); } @Test public void testDayOfYearFragmentInLargerUnitWithDate() { assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DAY_OF_YEAR)); } @Test public void testDayOfYearFragmentInLargerUnitWithCalendar() { assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DAY_OF_YEAR)); } @Test public void testDateFragmentInLargerUnitWithDate() { assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DATE)); } @Test public void testDateFragmentInLargerUnitWithCalendar() { assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DATE)); } //Calendar.SECOND as useful fragment @Test public void testMillisecondsOfSecondWithDate() { final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND); assertEquals(millis, testResult); } @Test public void testMillisecondsOfSecondWithCalendar() { final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND); assertEquals(millis, testResult); assertEquals(aCalendar.get(Calendar.MILLISECOND), testResult); } //Calendar.MINUTE as useful fragment @Test public void testMillisecondsOfMinuteWithDate() { final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult); } @Test public void testMillisecondsOfMinuteWithCalender() { final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult); } @Test public void testSecondsofMinuteWithDate() { final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE); assertEquals(seconds, testResult); } @Test public void testSecondsofMinuteWithCalendar() { final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE); assertEquals(seconds, testResult); assertEquals(aCalendar.get(Calendar.SECOND), testResult); } //Calendar.HOUR_OF_DAY as useful fragment @Test public void testMillisecondsOfHourWithDate() { final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult); } @Test public void testMillisecondsOfHourWithCalendar() { final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult); } @Test public void testSecondsofHourWithDate() { final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY); assertEquals( seconds + (minutes * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND), testResult); } @Test public void testSecondsofHourWithCalendar() { final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY); assertEquals( seconds + (minutes * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND), testResult); } @Test public void testMinutesOfHourWithDate() { final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY); assertEquals(minutes, testResult); } @Test public void testMinutesOfHourWithCalendar() { final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY); assertEquals(minutes, testResult); } //Calendar.DATE and Calendar.DAY_OF_YEAR as useful fragment @Test public void testMillisecondsOfDayWithDate() { long testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE); final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); assertEquals(expectedValue, testresult); testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR); assertEquals(expectedValue, testresult); } @Test public void testMillisecondsOfDayWithCalendar() { long testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DATE); final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); assertEquals(expectedValue, testresult); testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DAY_OF_YEAR); assertEquals(expectedValue, testresult); } @Test public void testSecondsOfDayWithDate() { long testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DATE); final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND; assertEquals(expectedValue, testresult); testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DAY_OF_YEAR); assertEquals(expectedValue, testresult); } @Test public void testSecondsOfDayWithCalendar() { long testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DATE); final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND; assertEquals(expectedValue, testresult); testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DAY_OF_YEAR); assertEquals(expectedValue, testresult); } @Test public void testMinutesOfDayWithDate() { long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE); final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; assertEquals(expectedValue,testResult); testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR); assertEquals(expectedValue,testResult); } @Test public void testMinutesOfDayWithCalendar() { long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DATE); final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; assertEquals(expectedValue, testResult); testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DAY_OF_YEAR); assertEquals(expectedValue, testResult); } @Test public void testHoursOfDayWithDate() { long testResult = DateUtils.getFragmentInHours(aDate, Calendar.DATE); final long expectedValue = hours; assertEquals(expectedValue,testResult); testResult = DateUtils.getFragmentInHours(aDate, Calendar.DAY_OF_YEAR); assertEquals(expectedValue,testResult); } @Test public void testHoursOfDayWithCalendar() { long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DATE); final long expectedValue = hours; assertEquals(expectedValue, testResult); testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DAY_OF_YEAR); assertEquals(expectedValue, testResult); } //Calendar.MONTH as useful fragment @Test public void testMillisecondsOfMonthWithDate() { final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY), testResult); } @Test public void testMillisecondsOfMonthWithCalendar() { final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY), testResult); } @Test public void testSecondsOfMonthWithDate() { final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH); assertEquals( seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_SECOND, testResult); } @Test public void testSecondsOfMonthWithCalendar() { final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH); assertEquals( seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_SECOND, testResult); } @Test public void testMinutesOfMonthWithDate() { final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH); assertEquals(minutes + ((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_MINUTE, testResult); } @Test public void testMinutesOfMonthWithCalendar() { final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH); assertEquals( minutes +((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_MINUTE, testResult); } @Test public void testHoursOfMonthWithDate() { final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH); assertEquals(hours + ((days * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_HOUR, testResult); } @Test public void testHoursOfMonthWithCalendar() { final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH); assertEquals( hours +((days * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_HOUR, testResult); } //Calendar.YEAR as useful fragment @Test public void testMillisecondsOfYearWithDate() { final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR); final Calendar cal = Calendar.getInstance(); cal.setTime(aDate); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY), testResult); } @Test public void testMillisecondsOfYearWithCalendar() { final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR); assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY), testResult); } @Test public void testSecondsOfYearWithDate() { final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.YEAR); final Calendar cal = Calendar.getInstance(); cal.setTime(aDate); assertEquals( seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_SECOND, testResult); } @Test public void testSecondsOfYearWithCalendar() { final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.YEAR); assertEquals( seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_SECOND, testResult); } @Test public void testMinutesOfYearWithDate() { final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.YEAR); final Calendar cal = Calendar.getInstance(); cal.setTime(aDate); assertEquals(minutes + ((hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_MINUTE, testResult); } @Test public void testMinutesOfYearWithCalendar() { final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.YEAR); assertEquals( minutes +((hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_MINUTE, testResult); } @Test public void testHoursOfYearWithDate() { final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.YEAR); final Calendar cal = Calendar.getInstance(); cal.setTime(aDate); assertEquals(hours + ((cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_HOUR, testResult); } @Test public void testHoursOfYearWithCalendar() { final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.YEAR); assertEquals( hours +((aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY)) / DateUtils.MILLIS_PER_HOUR, testResult); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import org.junit.Test; import org.junit.Before; import static org.junit.Assert.*; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.Locale; /** * These Unit-tests will check all possible extremes when using some rounding-methods of DateUtils. * The extremes are tested at the switch-point in milliseconds * * According to the implementation SEMI_MONTH will either round/truncate to the 1st or 16th * When rounding Calendar.MONTH it depends on the number of days within that month. * A month with 28 days will be rounded up from the 15th * A month with 29 or 30 days will be rounded up from the 16th * A month with 31 days will be rounded up from the 17th * * @since 3.0 * @version $Id$ */ public class DateUtilsRoundingTest { DateFormat dateTimeParser; Date januaryOneDate; Date targetYearDate; //No targetMonths, these must be tested for every type of month(28-31 days) Date targetDateDate, targetDayOfMonthDate, targetAmDate, targetPmDate; Date targetHourOfDayDate, targetHourDate; Date targetMinuteDate; Date targetSecondDate; Date targetMilliSecondDate; Calendar januaryOneCalendar; FastDateFormat fdf = DateFormatUtils.ISO_DATETIME_FORMAT; @Before public void setUp() throws Exception { dateTimeParser = new SimpleDateFormat("MMM dd, yyyy H:mm:ss.SSS", Locale.ENGLISH); targetYearDate = dateTimeParser.parse("January 1, 2007 0:00:00.000"); targetDateDate = targetDayOfMonthDate = dateTimeParser.parse("June 1, 2008 0:00:00.000"); targetAmDate = dateTimeParser.parse("June 1, 2008 0:00:00.000"); targetPmDate = dateTimeParser.parse("June 1, 2008 12:00:00.000"); targetHourDate = dateTimeParser.parse("June 1, 2008 8:00:00.000"); targetHourOfDayDate = dateTimeParser.parse("June 1, 2008 8:00:00.000"); targetMinuteDate = dateTimeParser.parse("June 1, 2008 8:15:00.000"); targetSecondDate = dateTimeParser.parse("June 1, 2008 8:15:14.000"); targetMilliSecondDate = dateTimeParser.parse("June 1, 2008 8:15:14.231"); januaryOneDate = dateTimeParser.parse("January 1, 2008 0:00:00.000"); januaryOneCalendar = Calendar.getInstance(); januaryOneCalendar.setTime(januaryOneDate); } /** * Tests DateUtils.round()-method with Calendar.Year * * @throws Exception * @since 3.0 */ @Test public void testRoundYear() throws Exception { final int calendarField = Calendar.YEAR; final Date roundedUpDate = dateTimeParser.parse("January 1, 2008 0:00:00.000"); final Date roundedDownDate = targetYearDate; final Date lastRoundedDownDate = dateTimeParser.parse("June 30, 2007 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.MONTH * Includes rounding months with 28, 29, 30 and 31 days * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundMonth() throws Exception { final int calendarField = Calendar.MONTH; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; //month with 28 days roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000"); roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("February 14, 2007 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 29 days roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 30 days roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("April 1, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("April 15, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 31 days roundedUpDate = dateTimeParser.parse("June 1, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("May 16, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 17, 2007 00:00:00.000"); maxDate = dateTimeParser.parse("January 16, 2008 23:59:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with DateUtils.SEMI_MONTH * Includes rounding months with 28, 29, 30 and 31 days, each with first and second half * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundSemiMonth() throws Exception { final int calendarField = DateUtils.SEMI_MONTH; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; //month with 28 days (1) roundedUpDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("February 8, 2007 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 28 days (2) roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000"); roundedDownDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("February 23, 2007 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 29 days (1) roundedUpDate = dateTimeParser.parse("February 16, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("February 8, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 29 days (2) roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("February 16, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("February 23, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 30 days (1) roundedUpDate = dateTimeParser.parse("April 16, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("April 1, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("April 8, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 30 days (2) roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("April 16, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("April 23, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 31 days (1) roundedUpDate = dateTimeParser.parse("May 16, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("May 1, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("May 8, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //month with 31 days (2) roundedUpDate = dateTimeParser.parse("June 1, 2008 0:00:00.000"); roundedDownDate = dateTimeParser.parse("May 16, 2008 0:00:00.000"); lastRoundedDownDate = dateTimeParser.parse("May 23, 2008 23:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 24, 2007 00:00:00.000"); maxDate = dateTimeParser.parse("January 8, 2008 23:59:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.DATE * Includes rounding the extremes of one day * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundDate() throws Exception { final int calendarField = Calendar.DATE; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); roundedDownDate = targetDateDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 12:00:00.000"); maxDate = dateTimeParser.parse("January 1, 2008 11:59:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.DAY_OF_MONTH * Includes rounding the extremes of one day * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundDayOfMonth() throws Exception { final int calendarField = Calendar.DAY_OF_MONTH; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); roundedDownDate = targetDayOfMonthDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 12:00:00.000"); maxDate = dateTimeParser.parse("January 1, 2008 11:59:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.AM_PM * Includes rounding the extremes of both AM and PM of one day * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundAmPm() throws Exception { final int calendarField = Calendar.AM_PM; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; //AM roundedUpDate = dateTimeParser.parse("June 1, 2008 12:00:00.000"); roundedDownDate = targetAmDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 5:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //PM roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000"); roundedDownDate = targetPmDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 17:59:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 18:00:00.000"); maxDate = dateTimeParser.parse("January 1, 2008 5:59:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY * Includes rounding the extremes of one hour * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundHourOfDay() throws Exception { final int calendarField = Calendar.HOUR_OF_DAY; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedUpDate = dateTimeParser.parse("June 1, 2008 9:00:00.000"); roundedDownDate = targetHourOfDayDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:29:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 23:30:00.000"); maxDate = dateTimeParser.parse("January 1, 2008 0:29:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.HOUR * Includes rounding the extremes of one hour * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundHour() throws Exception { final int calendarField = Calendar.HOUR; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedUpDate = dateTimeParser.parse("June 1, 2008 9:00:00.000"); roundedDownDate = targetHourDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:29:59.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 23:30:00.000"); maxDate = dateTimeParser.parse("January 1, 2008 0:29:59.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.MINUTE * Includes rounding the extremes of one minute * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundMinute() throws Exception { final int calendarField = Calendar.MINUTE; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedUpDate = dateTimeParser.parse("June 1, 2008 8:16:00.000"); roundedDownDate = targetMinuteDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:15:29.999"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 23:59:30.000"); maxDate = dateTimeParser.parse("January 1, 2008 0:00:29.999"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.SECOND * Includes rounding the extremes of one second * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundSecond() throws Exception { final int calendarField = Calendar.SECOND; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedUpDate = dateTimeParser.parse("June 1, 2008 8:15:15.000"); roundedDownDate = targetSecondDate; lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:15:14.499"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = dateTimeParser.parse("December 31, 2007 23:59:59.500"); maxDate = dateTimeParser.parse("January 1, 2008 0:00:00.499"); roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Tests DateUtils.round()-method with Calendar.MILLISECOND * Includes rounding the extremes of one second * Includes rounding to January 1 * * @throws Exception * @since 3.0 */ @Test public void testRoundMilliSecond() throws Exception { final int calendarField = Calendar.MILLISECOND; Date roundedUpDate, roundedDownDate, lastRoundedDownDate; Date minDate, maxDate; roundedDownDate = lastRoundedDownDate = targetMilliSecondDate; roundedUpDate = dateTimeParser.parse("June 1, 2008 8:15:14.232"); baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate, calendarField); //round to January 1 minDate = maxDate = januaryOneDate; roundToJanuaryFirst(minDate, maxDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.YEAR * * @throws Exception * @since 3.0 */ @Test public void testTruncateYear() throws Exception { final int calendarField = Calendar.YEAR; final Date lastTruncateDate = dateTimeParser.parse("December 31, 2007 23:59:59.999"); baseTruncateTest(targetYearDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.MONTH * * @throws Exception * @since 3.0 */ @Test public void testTruncateMonth() throws Exception { final int calendarField = Calendar.MONTH; final Date truncatedDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); final Date lastTruncateDate = dateTimeParser.parse("March 31, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with DateUtils.SEMI_MONTH * Includes truncating months with 28, 29, 30 and 31 days, each with first and second half * * @throws Exception * @since 3.0 */ @Test public void testTruncateSemiMonth() throws Exception { final int calendarField = DateUtils.SEMI_MONTH; Date truncatedDate, lastTruncateDate; //month with 28 days (1) truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 28 days (2) truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 29 days (1) truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 29 days (2) truncatedDate = dateTimeParser.parse("February 16, 2008 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 30 days (1) truncatedDate = dateTimeParser.parse("April 1, 2008 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("April 15, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 30 days (2) truncatedDate = dateTimeParser.parse("April 16, 2008 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("April 30, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 31 days (1) truncatedDate = dateTimeParser.parse("March 1, 2008 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("March 15, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); //month with 31 days (2) truncatedDate = dateTimeParser.parse("March 16, 2008 0:00:00.000"); lastTruncateDate = dateTimeParser.parse("March 31, 2008 23:59:59.999"); baseTruncateTest(truncatedDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.DATE * * @throws Exception * @since 3.0 */ @Test public void testTruncateDate() throws Exception { final int calendarField = Calendar.DATE; final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); baseTruncateTest(targetDateDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.DAY_OF_MONTH * * @throws Exception * @since 3.0 */ @Test public void testTruncateDayOfMonth() throws Exception { final int calendarField = Calendar.DAY_OF_MONTH; final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); baseTruncateTest(targetDayOfMonthDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.AM_PM * Includes truncating the extremes of both AM and PM of one day * * @throws Exception * @since 3.0 */ @Test public void testTruncateAmPm() throws Exception { final int calendarField = Calendar.AM_PM; //AM Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999"); baseTruncateTest(targetAmDate, lastTruncateDate, calendarField); //PM lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999"); baseTruncateTest(targetPmDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.HOUR * * @throws Exception * @since 3.0 */ @Test public void testTruncateHour() throws Exception { final int calendarField = Calendar.HOUR; final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:59:59.999"); baseTruncateTest(targetHourDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.HOUR_OF_DAY * * @throws Exception * @since 3.0 */ @Test public void testTruncateHourOfDay() throws Exception { final int calendarField = Calendar.HOUR_OF_DAY; final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:59:59.999"); baseTruncateTest(targetHourOfDayDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.MINUTE * * @throws Exception * @since 3.0 */ @Test public void testTruncateMinute() throws Exception { final int calendarField = Calendar.MINUTE; final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:59.999"); baseTruncateTest(targetMinuteDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.SECOND * * @throws Exception * @since 3.0 */ @Test public void testTruncateSecond() throws Exception { final int calendarField = Calendar.SECOND; final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999"); baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField); } /** * Test DateUtils.truncate()-method with Calendar.SECOND * * @throws Exception * @since 3.0 */ @Test public void testTruncateMilliSecond() throws Exception { final int calendarField = Calendar.MILLISECOND; baseTruncateTest(targetMilliSecondDate, targetMilliSecondDate, calendarField); } /** * When using this basetest all extremes are tested.<br> * It will test the Date, Calendar and Object-implementation<br> * lastRoundDownDate should round down to roundedDownDate<br> * lastRoundDownDate + 1 millisecond should round up to roundedUpDate * * @param roundedUpDate the next rounded date after <strong>roundedDownDate</strong> when using <strong>calendarField</strong> * @param roundedDownDate the result if <strong>lastRoundDownDate</strong> was rounded with <strong>calendarField</strong> * @param lastRoundDownDate rounding this value with <strong>calendarField</strong> will result in <strong>roundedDownDate</strong> * @param calendarField * @since 3.0 */ protected void baseRoundTest(final Date roundedUpDate, final Date roundedDownDate, final Date lastRoundDownDate, final int calendarField) { final Date firstRoundUpDate = DateUtils.addMilliseconds(lastRoundDownDate, 1); //Date-comparison assertEquals(roundedDownDate, DateUtils.round(roundedDownDate, calendarField)); assertEquals(roundedUpDate, DateUtils.round(roundedUpDate, calendarField)); assertEquals(roundedDownDate, DateUtils.round(lastRoundDownDate, calendarField)); assertEquals(roundedUpDate, DateUtils.round(firstRoundUpDate, calendarField)); //Calendar-initiations Calendar roundedUpCalendar, roundedDownCalendar, lastRoundDownCalendar, firstRoundUpCalendar; roundedDownCalendar = Calendar.getInstance(); roundedUpCalendar = Calendar.getInstance(); lastRoundDownCalendar = Calendar.getInstance(); firstRoundUpCalendar = Calendar.getInstance(); roundedDownCalendar.setTime(roundedDownDate); roundedUpCalendar.setTime(roundedUpDate); lastRoundDownCalendar.setTime(lastRoundDownDate); firstRoundUpCalendar.setTime(firstRoundUpDate); //Calendar-comparison assertEquals(roundedDownCalendar, DateUtils.round(roundedDownCalendar, calendarField)); assertEquals(roundedUpCalendar, DateUtils.round(roundedUpCalendar, calendarField)); assertEquals(roundedDownCalendar, DateUtils.round(lastRoundDownCalendar, calendarField)); assertEquals(roundedUpCalendar, DateUtils.round(firstRoundUpCalendar, calendarField)); //Object-comparison assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownDate, calendarField)); assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpDate, calendarField)); assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField)); assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField)); assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownCalendar, calendarField)); assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpCalendar, calendarField)); assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField)); assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField)); } /** * When using this basetest all extremes are tested.<br> * It will test the Date, Calendar and Object-implementation<br> * lastTruncateDate should round down to truncatedDate<br> * lastTruncateDate + 1 millisecond should never round down to truncatedDate * * @param truncatedDate expected Date when <strong>lastTruncateDate</strong> is truncated with <strong>calendarField</strong> * @param lastTruncateDate the last possible Date which will truncate to <strong>truncatedDate</strong> with <strong>calendarField</strong> * @param calendarField a Calendar.field value * @since 3.0 */ protected void baseTruncateTest(final Date truncatedDate, final Date lastTruncateDate, final int calendarField) { final Date nextTruncateDate = DateUtils.addMilliseconds(lastTruncateDate, 1); //Date-comparison assertEquals("Truncating "+ fdf.format(truncatedDate) +" as Date with CalendarField-value "+ calendarField +" must return itself", truncatedDate, DateUtils.truncate(truncatedDate, calendarField)); assertEquals(truncatedDate, DateUtils.truncate(lastTruncateDate, calendarField)); assertFalse(fdf.format(lastTruncateDate) +" is not an extreme when truncating as Date with CalendarField-value "+ calendarField, truncatedDate.equals(DateUtils.truncate(nextTruncateDate, calendarField))); //Calendar-initiations Calendar truncatedCalendar, lastTruncateCalendar, nextTruncateCalendar; truncatedCalendar = Calendar.getInstance(); lastTruncateCalendar = Calendar.getInstance(); nextTruncateCalendar = Calendar.getInstance(); truncatedCalendar.setTime(truncatedDate); lastTruncateCalendar.setTime(lastTruncateDate); nextTruncateCalendar.setTime(nextTruncateDate); //Calendar-comparison assertEquals("Truncating "+ fdf.format(truncatedCalendar) +" as Calendar with CalendarField-value "+ calendarField +" must return itself", truncatedCalendar, DateUtils.truncate(truncatedCalendar, calendarField)); assertEquals(truncatedCalendar, DateUtils.truncate(lastTruncateCalendar, calendarField)); assertFalse(fdf.format(lastTruncateCalendar) +" is not an extreme when truncating as Calendar with CalendarField-value "+ calendarField, truncatedCalendar.equals(DateUtils.truncate(nextTruncateCalendar, calendarField))); //Object-comparison assertEquals("Truncating "+ fdf.format(truncatedDate) +" as Date cast to Object with CalendarField-value "+ calendarField +" must return itself as Date", truncatedDate, DateUtils.truncate((Object) truncatedDate, calendarField)); assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateDate, calendarField)); assertFalse(fdf.format(lastTruncateDate) +" is not an extreme when truncating as Date cast to Object with CalendarField-value "+ calendarField, truncatedDate.equals(DateUtils.truncate((Object) nextTruncateDate, calendarField))); assertEquals("Truncating "+ fdf.format(truncatedCalendar) +" as Calendar cast to Object with CalendarField-value "+ calendarField +" must return itself as Date", truncatedDate, DateUtils.truncate((Object) truncatedCalendar, calendarField)); assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateCalendar, calendarField)); assertFalse(fdf.format(lastTruncateCalendar) +" is not an extreme when truncating as Calendar cast to Object with CalendarField-value "+ calendarField, truncatedDate.equals(DateUtils.truncate((Object) nextTruncateCalendar, calendarField))); } /** * * Any January 1 could be considered as the ultimate extreme. * Instead of comparing the results if the input has a difference of 1 millisecond we check the output to be exactly January first. * * @param minDate * @param maxDate * @param calendarField * @since 3.0 */ protected void roundToJanuaryFirst(final Date minDate, final Date maxDate, final int calendarField) { assertEquals("Rounding "+ fdf.format(januaryOneDate) +" as Date with CalendarField-value "+ calendarField +" must return itself", januaryOneDate, DateUtils.round(januaryOneDate, calendarField)); assertEquals(januaryOneDate, DateUtils.round(minDate, calendarField)); assertEquals(januaryOneDate, DateUtils.round(maxDate, calendarField)); final Calendar minCalendar = Calendar.getInstance(); minCalendar.setTime(minDate); final Calendar maxCalendar = Calendar.getInstance(); maxCalendar.setTime(maxDate); assertEquals("Rounding "+ fdf.format(januaryOneCalendar) +" as Date with CalendarField-value "+ calendarField +" must return itself", januaryOneCalendar, DateUtils.round(januaryOneCalendar, calendarField)); assertEquals(januaryOneCalendar, DateUtils.round(minCalendar, calendarField)); assertEquals(januaryOneCalendar, DateUtils.round(maxCalendar, calendarField)); final Date toPrevRoundDate = DateUtils.addMilliseconds(minDate, -1); final Date toNextRoundDate = DateUtils.addMilliseconds(maxDate, 1); assertFalse(fdf.format(minDate) +" is not an lower-extreme when rounding as Date with CalendarField-value "+ calendarField, januaryOneDate.equals(DateUtils.round(toPrevRoundDate, calendarField))); assertFalse(fdf.format(maxDate) +" is not an upper-extreme when rounding as Date with CalendarField-value "+ calendarField, januaryOneDate.equals(DateUtils.round(toNextRoundDate, calendarField))); final Calendar toPrevRoundCalendar = Calendar.getInstance(); toPrevRoundCalendar.setTime(toPrevRoundDate); final Calendar toNextRoundCalendar = Calendar.getInstance(); toNextRoundCalendar.setTime(toNextRoundDate); assertFalse(fdf.format(minCalendar) +" is not an lower-extreme when rounding as Date with CalendarField-value "+ calendarField, januaryOneDate.equals(DateUtils.round(toPrevRoundDate, calendarField))); assertFalse(fdf.format(maxCalendar) +" is not an upper-extreme when rounding as Date with CalendarField-value "+ calendarField, januaryOneDate.equals(DateUtils.round(toNextRoundDate, calendarField))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Iterator; import java.util.Locale; import java.util.NoSuchElementException; import java.util.TimeZone; import junit.framework.AssertionFailedError; import org.apache.commons.lang3.SystemUtils; import org.junit.Before; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.time.DateUtils}. * */ public class DateUtilsTest { private static final long MILLIS_TEST; static { final GregorianCalendar cal = new GregorianCalendar(2000, 6, 5, 4, 3, 2); cal.set(Calendar.MILLISECOND, 1); MILLIS_TEST = cal.getTime().getTime(); System.out.println("DateUtilsTest: Default Locale="+Locale.getDefault()); } DateFormat dateParser = null; DateFormat dateTimeParser = null; DateFormat timeZoneDateParser = null; Date dateAmPm1 = null; Date dateAmPm2 = null; Date dateAmPm3 = null; Date dateAmPm4 = null; Date date0 = null; Date date1 = null; Date date2 = null; Date date3 = null; Date date4 = null; Date date5 = null; Date date6 = null; Date date7 = null; Date date8 = null; Calendar calAmPm1 = null; Calendar calAmPm2 = null; Calendar calAmPm3 = null; Calendar calAmPm4 = null; Calendar cal1 = null; Calendar cal2 = null; Calendar cal3 = null; Calendar cal4 = null; Calendar cal5 = null; Calendar cal6 = null; Calendar cal7 = null; Calendar cal8 = null; TimeZone zone = null; TimeZone defaultZone = null; @Before public void setUp() throws Exception { dateParser = new SimpleDateFormat("MMM dd, yyyy", Locale.ENGLISH); dateTimeParser = new SimpleDateFormat("MMM dd, yyyy H:mm:ss.SSS", Locale.ENGLISH); dateAmPm1 = dateTimeParser.parse("February 3, 2002 01:10:00.000"); dateAmPm2 = dateTimeParser.parse("February 3, 2002 11:10:00.000"); dateAmPm3 = dateTimeParser.parse("February 3, 2002 13:10:00.000"); dateAmPm4 = dateTimeParser.parse("February 3, 2002 19:10:00.000"); date0 = dateTimeParser.parse("February 3, 2002 12:34:56.789"); date1 = dateTimeParser.parse("February 12, 2002 12:34:56.789"); date2 = dateTimeParser.parse("November 18, 2001 1:23:11.321"); defaultZone = TimeZone.getDefault(); zone = TimeZone.getTimeZone("MET"); TimeZone.setDefault(zone); dateTimeParser.setTimeZone(zone); date3 = dateTimeParser.parse("March 30, 2003 05:30:45.000"); date4 = dateTimeParser.parse("March 30, 2003 01:10:00.000"); date5 = dateTimeParser.parse("March 30, 2003 01:40:00.000"); date6 = dateTimeParser.parse("March 30, 2003 02:10:00.000"); date7 = dateTimeParser.parse("March 30, 2003 02:40:00.000"); date8 = dateTimeParser.parse("October 26, 2003 05:30:45.000"); dateTimeParser.setTimeZone(defaultZone); TimeZone.setDefault(defaultZone); calAmPm1 = Calendar.getInstance(); calAmPm1.setTime(dateAmPm1); calAmPm2 = Calendar.getInstance(); calAmPm2.setTime(dateAmPm2); calAmPm3 = Calendar.getInstance(); calAmPm3.setTime(dateAmPm3); calAmPm4 = Calendar.getInstance(); calAmPm4.setTime(dateAmPm4); cal1 = Calendar.getInstance(); cal1.setTime(date1); cal2 = Calendar.getInstance(); cal2.setTime(date2); TimeZone.setDefault(zone); cal3 = Calendar.getInstance(); cal3.setTime(date3); cal4 = Calendar.getInstance(); cal4.setTime(date4); cal5 = Calendar.getInstance(); cal5.setTime(date5); cal6 = Calendar.getInstance(); cal6.setTime(date6); cal7 = Calendar.getInstance(); cal7.setTime(date7); cal8 = Calendar.getInstance(); cal8.setTime(date8); TimeZone.setDefault(defaultZone); } //----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new DateUtils()); final Constructor<?>[] cons = DateUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(DateUtils.class.getModifiers())); assertFalse(Modifier.isFinal(DateUtils.class.getModifiers())); } //----------------------------------------------------------------------- @Test public void testIsSameDay_Date() { Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); assertTrue(DateUtils.isSameDay(date1, date2)); date2 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); assertFalse(DateUtils.isSameDay(date1, date2)); date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); assertTrue(DateUtils.isSameDay(date1, date2)); date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); assertFalse(DateUtils.isSameDay(date1, date2)); try { DateUtils.isSameDay((Date) null, (Date) null); fail(); } catch (final IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @Test public void testIsSameDay_Cal() { final GregorianCalendar cal1 = new GregorianCalendar(2004, 6, 9, 13, 45); final GregorianCalendar cal2 = new GregorianCalendar(2004, 6, 9, 13, 45); assertTrue(DateUtils.isSameDay(cal1, cal2)); cal2.add(Calendar.DAY_OF_YEAR, 1); assertFalse(DateUtils.isSameDay(cal1, cal2)); cal1.add(Calendar.DAY_OF_YEAR, 1); assertTrue(DateUtils.isSameDay(cal1, cal2)); cal2.add(Calendar.YEAR, 1); assertFalse(DateUtils.isSameDay(cal1, cal2)); try { DateUtils.isSameDay((Calendar) null, (Calendar) null); fail(); } catch (final IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @Test public void testIsSameInstant_Date() { Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime(); assertTrue(DateUtils.isSameInstant(date1, date2)); date2 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); assertFalse(DateUtils.isSameInstant(date1, date2)); date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime(); assertTrue(DateUtils.isSameInstant(date1, date2)); date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime(); assertFalse(DateUtils.isSameInstant(date1, date2)); try { DateUtils.isSameInstant((Date) null, (Date) null); fail(); } catch (final IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @Test public void testIsSameInstant_Cal() { final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); cal1.set(2004, 6, 9, 13, 45, 0); cal1.set(Calendar.MILLISECOND, 0); cal2.set(2004, 6, 9, 13, 45, 0); cal2.set(Calendar.MILLISECOND, 0); assertFalse(DateUtils.isSameInstant(cal1, cal2)); cal2.set(2004, 6, 9, 11, 45, 0); assertTrue(DateUtils.isSameInstant(cal1, cal2)); try { DateUtils.isSameInstant((Calendar) null, (Calendar) null); fail(); } catch (final IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @Test public void testIsSameLocalTime_Cal() { final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); cal1.set(2004, 6, 9, 13, 45, 0); cal1.set(Calendar.MILLISECOND, 0); cal2.set(2004, 6, 9, 13, 45, 0); cal2.set(Calendar.MILLISECOND, 0); assertTrue(DateUtils.isSameLocalTime(cal1, cal2)); final Calendar cal3 = Calendar.getInstance(); final Calendar cal4 = Calendar.getInstance(); cal3.set(2004, 6, 9, 4, 0, 0); cal4.set(2004, 6, 9, 16, 0, 0); cal3.set(Calendar.MILLISECOND, 0); cal4.set(Calendar.MILLISECOND, 0); assertFalse("LANG-677", DateUtils.isSameLocalTime(cal3, cal4)); cal2.set(2004, 6, 9, 11, 45, 0); assertFalse(DateUtils.isSameLocalTime(cal1, cal2)); try { DateUtils.isSameLocalTime((Calendar) null, (Calendar) null); fail(); } catch (final IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @Test public void testParseDate() throws Exception { final GregorianCalendar cal = new GregorianCalendar(1972, 11, 3); String dateStr = "1972-12-03"; final String[] parsers = new String[] {"yyyy'-'DDD", "yyyy'-'MM'-'dd", "yyyyMMdd"}; Date date = DateUtils.parseDate(dateStr, parsers); assertEquals(cal.getTime(), date); dateStr = "1972-338"; date = DateUtils.parseDate(dateStr, parsers); assertEquals(cal.getTime(), date); dateStr = "19721203"; date = DateUtils.parseDate(dateStr, parsers); assertEquals(cal.getTime(), date); try { DateUtils.parseDate("PURPLE", parsers); fail(); } catch (final ParseException ex) {} try { DateUtils.parseDate("197212AB", parsers); fail(); } catch (final ParseException ex) {} try { DateUtils.parseDate(null, parsers); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.parseDate(dateStr, (String[]) null); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.parseDate(dateStr, new String[0]); fail(); } catch (final ParseException ex) {} } // LANG-486 @Test public void testParseDateWithLeniency() throws Exception { final GregorianCalendar cal = new GregorianCalendar(1998, 6, 30); final String dateStr = "02 942, 1996"; final String[] parsers = new String[] {"MM DDD, yyyy"}; Date date = DateUtils.parseDate(dateStr, parsers); assertEquals(cal.getTime(), date); try { date = DateUtils.parseDateStrictly(dateStr, parsers); fail(); } catch (final ParseException ex) {} } //----------------------------------------------------------------------- @Test public void testAddYears() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addYears(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addYears(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2001, 6, 5, 4, 3, 2, 1); result = DateUtils.addYears(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 1999, 6, 5, 4, 3, 2, 1); } //----------------------------------------------------------------------- @Test public void testAddMonths() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addMonths(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addMonths(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 7, 5, 4, 3, 2, 1); result = DateUtils.addMonths(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 5, 5, 4, 3, 2, 1); } //----------------------------------------------------------------------- @Test public void testAddWeeks() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addWeeks(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addWeeks(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 12, 4, 3, 2, 1); result = DateUtils.addWeeks(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); // july assertDate(result, 2000, 5, 28, 4, 3, 2, 1); // june } //----------------------------------------------------------------------- @Test public void testAddDays() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addDays(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addDays(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 6, 4, 3, 2, 1); result = DateUtils.addDays(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 4, 4, 3, 2, 1); } //----------------------------------------------------------------------- @Test public void testAddHours() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addHours(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addHours(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 5, 3, 2, 1); result = DateUtils.addHours(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 3, 3, 2, 1); } //----------------------------------------------------------------------- @Test public void testAddMinutes() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addMinutes(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addMinutes(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 4, 2, 1); result = DateUtils.addMinutes(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 2, 2, 1); } //----------------------------------------------------------------------- @Test public void testAddSeconds() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addSeconds(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addSeconds(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 3, 1); result = DateUtils.addSeconds(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 1, 1); } //----------------------------------------------------------------------- @Test public void testAddMilliseconds() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.addMilliseconds(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.addMilliseconds(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 2); result = DateUtils.addMilliseconds(base, -1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 0); } // ----------------------------------------------------------------------- @Test public void testSetYears() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setYears(base, 2000); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 1); result = DateUtils.setYears(base, 2008); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2008, 6, 5, 4, 3, 2, 1); result = DateUtils.setYears(base, 2005); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2005, 6, 5, 4, 3, 2, 1); } // ----------------------------------------------------------------------- @Test public void testSetMonths() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setMonths(base, 5); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 5, 5, 4, 3, 2, 1); result = DateUtils.setMonths(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 1, 5, 4, 3, 2, 1); try { result = DateUtils.setMonths(base, 12); fail("DateUtils.setMonths did not throw an expected IllegalArguementException."); } catch (final IllegalArgumentException e) { } } // ----------------------------------------------------------------------- @Test public void testSetDays() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setDays(base, 1); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 1, 4, 3, 2, 1); result = DateUtils.setDays(base, 29); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 29, 4, 3, 2, 1); try { result = DateUtils.setDays(base, 32); fail("DateUtils.setDays did not throw an expected IllegalArguementException."); } catch (final IllegalArgumentException e) { } } // ----------------------------------------------------------------------- @Test public void testSetHours() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setHours(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 0, 3, 2, 1); result = DateUtils.setHours(base, 23); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 23, 3, 2, 1); try { result = DateUtils.setHours(base, 24); fail("DateUtils.setHours did not throw an expected IllegalArguementException."); } catch (final IllegalArgumentException e) { } } // ----------------------------------------------------------------------- @Test public void testSetMinutes() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setMinutes(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 0, 2, 1); result = DateUtils.setMinutes(base, 59); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 59, 2, 1); try { result = DateUtils.setMinutes(base, 60); fail("DateUtils.setMinutes did not throw an expected IllegalArguementException."); } catch (final IllegalArgumentException e) { } } // ----------------------------------------------------------------------- @Test public void testSetSeconds() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setSeconds(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 0, 1); result = DateUtils.setSeconds(base, 59); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 59, 1); try { result = DateUtils.setSeconds(base, 60); fail("DateUtils.setSeconds did not throw an expected IllegalArguementException."); } catch (final IllegalArgumentException e) { } } // ----------------------------------------------------------------------- @Test public void testSetMilliseconds() throws Exception { final Date base = new Date(MILLIS_TEST); Date result = DateUtils.setMilliseconds(base, 0); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 0); result = DateUtils.setMilliseconds(base, 999); assertNotSame(base, result); assertDate(base, 2000, 6, 5, 4, 3, 2, 1); assertDate(result, 2000, 6, 5, 4, 3, 2, 999); try { result = DateUtils.setMilliseconds(base, 1000); fail("DateUtils.setMilliseconds did not throw an expected IllegalArguementException."); } catch (final IllegalArgumentException e) { } } //----------------------------------------------------------------------- private void assertDate(final Date date, final int year, final int month, final int day, final int hour, final int min, final int sec, final int mil) throws Exception { final GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); assertEquals(year, cal.get(Calendar.YEAR)); assertEquals(month, cal.get(Calendar.MONTH)); assertEquals(day, cal.get(Calendar.DAY_OF_MONTH)); assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY)); assertEquals(min, cal.get(Calendar.MINUTE)); assertEquals(sec, cal.get(Calendar.SECOND)); assertEquals(mil, cal.get(Calendar.MILLISECOND)); } //----------------------------------------------------------------------- @Test public void testToCalendar() { assertEquals("Failed to convert to a Calendar and back", date1, DateUtils.toCalendar(date1).getTime()); try { DateUtils.toCalendar(null); fail("Expected NullPointerException to be thrown"); } catch(final NullPointerException npe) { // expected } } //----------------------------------------------------------------------- /** * Tests various values with the round method */ @Test public void testRound() throws Exception { // tests for public static Date round(Date date, int field) assertEquals("round year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.round(date1, Calendar.YEAR)); assertEquals("round year-2 failed", dateParser.parse("January 1, 2002"), DateUtils.round(date2, Calendar.YEAR)); assertEquals("round month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.round(date1, Calendar.MONTH)); assertEquals("round month-2 failed", dateParser.parse("December 1, 2001"), DateUtils.round(date2, Calendar.MONTH)); assertEquals("round semimonth-0 failed", dateParser.parse("February 1, 2002"), DateUtils.round(date0, DateUtils.SEMI_MONTH)); assertEquals("round semimonth-1 failed", dateParser.parse("February 16, 2002"), DateUtils.round(date1, DateUtils.SEMI_MONTH)); assertEquals("round semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.round(date2, DateUtils.SEMI_MONTH)); assertEquals("round date-1 failed", dateParser.parse("February 13, 2002"), DateUtils.round(date1, Calendar.DATE)); assertEquals("round date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.round(date2, Calendar.DATE)); assertEquals("round hour-1 failed", dateTimeParser.parse("February 12, 2002 13:00:00.000"), DateUtils.round(date1, Calendar.HOUR)); assertEquals("round hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.round(date2, Calendar.HOUR)); assertEquals("round minute-1 failed", dateTimeParser.parse("February 12, 2002 12:35:00.000"), DateUtils.round(date1, Calendar.MINUTE)); assertEquals("round minute-2 failed", dateTimeParser.parse("November 18, 2001 1:23:00.000"), DateUtils.round(date2, Calendar.MINUTE)); assertEquals("round second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:57.000"), DateUtils.round(date1, Calendar.SECOND)); assertEquals("round second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:11.000"), DateUtils.round(date2, Calendar.SECOND)); assertEquals("round ampm-1 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.round(dateAmPm1, Calendar.AM_PM)); assertEquals("round ampm-2 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.round(dateAmPm2, Calendar.AM_PM)); assertEquals("round ampm-3 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.round(dateAmPm3, Calendar.AM_PM)); assertEquals("round ampm-4 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.round(dateAmPm4, Calendar.AM_PM)); // tests for public static Date round(Object date, int field) assertEquals("round year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.round((Object) date1, Calendar.YEAR)); assertEquals("round year-2 failed", dateParser.parse("January 1, 2002"), DateUtils.round((Object) date2, Calendar.YEAR)); assertEquals("round month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.round((Object) date1, Calendar.MONTH)); assertEquals("round month-2 failed", dateParser.parse("December 1, 2001"), DateUtils.round((Object) date2, Calendar.MONTH)); assertEquals("round semimonth-1 failed", dateParser.parse("February 16, 2002"), DateUtils.round((Object) date1, DateUtils.SEMI_MONTH)); assertEquals("round semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.round((Object) date2, DateUtils.SEMI_MONTH)); assertEquals("round date-1 failed", dateParser.parse("February 13, 2002"), DateUtils.round((Object) date1, Calendar.DATE)); assertEquals("round date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.round((Object) date2, Calendar.DATE)); assertEquals("round hour-1 failed", dateTimeParser.parse("February 12, 2002 13:00:00.000"), DateUtils.round((Object) date1, Calendar.HOUR)); assertEquals("round hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.round((Object) date2, Calendar.HOUR)); assertEquals("round minute-1 failed", dateTimeParser.parse("February 12, 2002 12:35:00.000"), DateUtils.round((Object) date1, Calendar.MINUTE)); assertEquals("round minute-2 failed", dateTimeParser.parse("November 18, 2001 1:23:00.000"), DateUtils.round((Object) date2, Calendar.MINUTE)); assertEquals("round second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:57.000"), DateUtils.round((Object) date1, Calendar.SECOND)); assertEquals("round second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:11.000"), DateUtils.round((Object) date2, Calendar.SECOND)); assertEquals("round calendar second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:57.000"), DateUtils.round((Object) cal1, Calendar.SECOND)); assertEquals("round calendar second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:11.000"), DateUtils.round((Object) cal2, Calendar.SECOND)); assertEquals("round ampm-1 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.round((Object) dateAmPm1, Calendar.AM_PM)); assertEquals("round ampm-2 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.round((Object) dateAmPm2, Calendar.AM_PM)); assertEquals("round ampm-3 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.round((Object) dateAmPm3, Calendar.AM_PM)); assertEquals("round ampm-4 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.round((Object) dateAmPm4, Calendar.AM_PM)); try { DateUtils.round((Date) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.round((Calendar) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.round((Object) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.round("", Calendar.SECOND); fail(); } catch (final ClassCastException ex) {} try { DateUtils.round(date1, -9999); fail(); } catch(final IllegalArgumentException ex) {} assertEquals("round ampm-1 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.round((Object) calAmPm1, Calendar.AM_PM)); assertEquals("round ampm-2 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.round((Object) calAmPm2, Calendar.AM_PM)); assertEquals("round ampm-3 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.round((Object) calAmPm3, Calendar.AM_PM)); assertEquals("round ampm-4 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.round((Object) calAmPm4, Calendar.AM_PM)); // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 / LANG-13 // Test rounding across the beginning of daylight saving time TimeZone.setDefault(zone); dateTimeParser.setTimeZone(zone); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round(date4, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round((Object) cal4, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round(date5, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round((Object) cal5, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round(date6, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round((Object) cal6, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round(date7, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.round((Object) cal7, Calendar.DATE)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 01:00:00.000"), DateUtils.round(date4, Calendar.HOUR_OF_DAY)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 01:00:00.000"), DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY)); if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.round(date5, Calendar.HOUR_OF_DAY)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.round(date6, Calendar.HOUR_OF_DAY)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 04:00:00.000"), DateUtils.round(date7, Calendar.HOUR_OF_DAY)); assertEquals("round MET date across DST change-over", dateTimeParser.parse("March 30, 2003 04:00:00.000"), DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY)); } else { this.warn("WARNING: Some date rounding tests not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); } TimeZone.setDefault(defaultZone); dateTimeParser.setTimeZone(defaultZone); } /** * Tests the Changes Made by LANG-346 to the DateUtils.modify() private method invoked * by DateUtils.round(). */ @Test public void testRoundLang346() throws Exception { TimeZone.setDefault(defaultZone); dateTimeParser.setTimeZone(defaultZone); final Calendar testCalendar = Calendar.getInstance(); testCalendar.set(2007, 6, 2, 8, 8, 50); Date date = testCalendar.getTime(); assertEquals("Minute Round Up Failed", dateTimeParser.parse("July 2, 2007 08:09:00.000"), DateUtils.round(date, Calendar.MINUTE)); testCalendar.set(2007, 6, 2, 8, 8, 20); date = testCalendar.getTime(); assertEquals("Minute No Round Failed", dateTimeParser.parse("July 2, 2007 08:08:00.000"), DateUtils.round(date, Calendar.MINUTE)); testCalendar.set(2007, 6, 2, 8, 8, 50); testCalendar.set(Calendar.MILLISECOND, 600); date = testCalendar.getTime(); assertEquals("Second Round Up with 600 Milli Seconds Failed", dateTimeParser.parse("July 2, 2007 08:08:51.000"), DateUtils.round(date, Calendar.SECOND)); testCalendar.set(2007, 6, 2, 8, 8, 50); testCalendar.set(Calendar.MILLISECOND, 200); date = testCalendar.getTime(); assertEquals("Second Round Down with 200 Milli Seconds Failed", dateTimeParser.parse("July 2, 2007 08:08:50.000"), DateUtils.round(date, Calendar.SECOND)); testCalendar.set(2007, 6, 2, 8, 8, 20); testCalendar.set(Calendar.MILLISECOND, 600); date = testCalendar.getTime(); assertEquals("Second Round Up with 200 Milli Seconds Failed", dateTimeParser.parse("July 2, 2007 08:08:21.000"), DateUtils.round(date, Calendar.SECOND)); testCalendar.set(2007, 6, 2, 8, 8, 20); testCalendar.set(Calendar.MILLISECOND, 200); date = testCalendar.getTime(); assertEquals("Second Round Down with 200 Milli Seconds Failed", dateTimeParser.parse("July 2, 2007 08:08:20.000"), DateUtils.round(date, Calendar.SECOND)); testCalendar.set(2007, 6, 2, 8, 8, 50); date = testCalendar.getTime(); assertEquals("Hour Round Down Failed", dateTimeParser.parse("July 2, 2007 08:00:00.000"), DateUtils.round(date, Calendar.HOUR)); testCalendar.set(2007, 6, 2, 8, 31, 50); date = testCalendar.getTime(); assertEquals("Hour Round Up Failed", dateTimeParser.parse("July 2, 2007 09:00:00.000"), DateUtils.round(date, Calendar.HOUR)); } /** * Tests various values with the trunc method */ @Test public void testTruncate() throws Exception { // tests public static Date truncate(Date date, int field) assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate(date1, Calendar.YEAR)); assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate(date2, Calendar.YEAR)); assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, Calendar.MONTH)); assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate(date2, Calendar.MONTH)); assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate(date1, Calendar.DATE)); assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate(date2, Calendar.DATE)); assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate(date1, Calendar.HOUR)); assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate(date2, Calendar.HOUR)); assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate(date1, Calendar.MINUTE)); assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18, 2001 1:23:00.000"), DateUtils.truncate(date2, Calendar.MINUTE)); assertEquals("truncate second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:56.000"), DateUtils.truncate(date1, Calendar.SECOND)); assertEquals("truncate second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:11.000"), DateUtils.truncate(date2, Calendar.SECOND)); assertEquals("truncate ampm-1 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.truncate(dateAmPm1, Calendar.AM_PM)); assertEquals("truncate ampm-2 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.truncate(dateAmPm2, Calendar.AM_PM)); assertEquals("truncate ampm-3 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.truncate(dateAmPm3, Calendar.AM_PM)); assertEquals("truncate ampm-4 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.truncate(dateAmPm4, Calendar.AM_PM)); // tests public static Date truncate(Object date, int field) assertEquals("truncate year-1 failed", dateParser.parse("January 1, 2002"), DateUtils.truncate((Object) date1, Calendar.YEAR)); assertEquals("truncate year-2 failed", dateParser.parse("January 1, 2001"), DateUtils.truncate((Object) date2, Calendar.YEAR)); assertEquals("truncate month-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate((Object) date1, Calendar.MONTH)); assertEquals("truncate month-2 failed", dateParser.parse("November 1, 2001"), DateUtils.truncate((Object) date2, Calendar.MONTH)); assertEquals("truncate semimonth-1 failed", dateParser.parse("February 1, 2002"), DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH)); assertEquals("truncate semimonth-2 failed", dateParser.parse("November 16, 2001"), DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH)); assertEquals("truncate date-1 failed", dateParser.parse("February 12, 2002"), DateUtils.truncate((Object) date1, Calendar.DATE)); assertEquals("truncate date-2 failed", dateParser.parse("November 18, 2001"), DateUtils.truncate((Object) date2, Calendar.DATE)); assertEquals("truncate hour-1 failed", dateTimeParser.parse("February 12, 2002 12:00:00.000"), DateUtils.truncate((Object) date1, Calendar.HOUR)); assertEquals("truncate hour-2 failed", dateTimeParser.parse("November 18, 2001 1:00:00.000"), DateUtils.truncate((Object) date2, Calendar.HOUR)); assertEquals("truncate minute-1 failed", dateTimeParser.parse("February 12, 2002 12:34:00.000"), DateUtils.truncate((Object) date1, Calendar.MINUTE)); assertEquals("truncate minute-2 failed", dateTimeParser.parse("November 18, 2001 1:23:00.000"), DateUtils.truncate((Object) date2, Calendar.MINUTE)); assertEquals("truncate second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:56.000"), DateUtils.truncate((Object) date1, Calendar.SECOND)); assertEquals("truncate second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:11.000"), DateUtils.truncate((Object) date2, Calendar.SECOND)); assertEquals("truncate ampm-1 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM)); assertEquals("truncate ampm-2 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM)); assertEquals("truncate ampm-3 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM)); assertEquals("truncate ampm-4 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM)); assertEquals("truncate calendar second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:56.000"), DateUtils.truncate((Object) cal1, Calendar.SECOND)); assertEquals("truncate calendar second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:11.000"), DateUtils.truncate((Object) cal2, Calendar.SECOND)); assertEquals("truncate ampm-1 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM)); assertEquals("truncate ampm-2 failed", dateTimeParser.parse("February 3, 2002 00:00:00.000"), DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM)); assertEquals("truncate ampm-3 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM)); assertEquals("truncate ampm-4 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM)); try { DateUtils.truncate((Date) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.truncate((Calendar) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.truncate((Object) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.truncate("", Calendar.SECOND); fail(); } catch (final ClassCastException ex) {} // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 // Test truncate across beginning of daylight saving time TimeZone.setDefault(zone); dateTimeParser.setTimeZone(zone); assertEquals("truncate MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.truncate(date3, Calendar.DATE)); assertEquals("truncate MET date across DST change-over", dateTimeParser.parse("March 30, 2003 00:00:00.000"), DateUtils.truncate((Object) cal3, Calendar.DATE)); // Test truncate across end of daylight saving time assertEquals("truncate MET date across DST change-over", dateTimeParser.parse("October 26, 2003 00:00:00.000"), DateUtils.truncate(date8, Calendar.DATE)); assertEquals("truncate MET date across DST change-over", dateTimeParser.parse("October 26, 2003 00:00:00.000"), DateUtils.truncate((Object) cal8, Calendar.DATE)); TimeZone.setDefault(defaultZone); dateTimeParser.setTimeZone(defaultZone); // Bug 31395, large dates final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis final GregorianCalendar endCal = new GregorianCalendar(); endCal.setTime(endOfTime); try { DateUtils.truncate(endCal, Calendar.DATE); fail(); } catch (final ArithmeticException ex) {} endCal.set(Calendar.YEAR, 280000001); try { DateUtils.truncate(endCal, Calendar.DATE); fail(); } catch (final ArithmeticException ex) {} endCal.set(Calendar.YEAR, 280000000); final Calendar cal = DateUtils.truncate(endCal, Calendar.DATE); assertEquals(0, cal.get(Calendar.HOUR)); } /** * Tests for LANG-59 * * see http://issues.apache.org/jira/browse/LANG-59 */ @Test public void testTruncateLang59() throws Exception { if (!SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { this.warn("WARNING: Test for LANG-59 not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); return; } // Set TimeZone to Mountain Time final TimeZone MST_MDT = TimeZone.getTimeZone("MST7MDT"); TimeZone.setDefault(MST_MDT); final DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS z"); format.setTimeZone(MST_MDT); final Date oct31_01MDT = new Date(1099206000000L); final Date oct31MDT = new Date(oct31_01MDT.getTime() - 3600000L); // - 1 hour final Date oct31_01_02MDT = new Date(oct31_01MDT.getTime() + 120000L); // + 2 minutes final Date oct31_01_02_03MDT = new Date(oct31_01_02MDT.getTime() + 3000L); // + 3 seconds final Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L); // + 4 milliseconds assertEquals("Check 00:00:00.000", "2004-10-31 00:00:00.000 MDT", format.format(oct31MDT)); assertEquals("Check 01:00:00.000", "2004-10-31 01:00:00.000 MDT", format.format(oct31_01MDT)); assertEquals("Check 01:02:00.000", "2004-10-31 01:02:00.000 MDT", format.format(oct31_01_02MDT)); assertEquals("Check 01:02:03.000", "2004-10-31 01:02:03.000 MDT", format.format(oct31_01_02_03MDT)); assertEquals("Check 01:02:03.004", "2004-10-31 01:02:03.004 MDT", format.format(oct31_01_02_03_04MDT)); // ------- Demonstrate Problem ------- final Calendar gval = Calendar.getInstance(); gval.setTime(new Date(oct31_01MDT.getTime())); gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value assertEquals("Demonstrate Problem", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L); // ---------- Test Truncate ---------- assertEquals("Truncate Calendar.MILLISECOND", oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND)); assertEquals("Truncate Calendar.SECOND", oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND)); assertEquals("Truncate Calendar.MINUTE", oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE)); assertEquals("Truncate Calendar.HOUR_OF_DAY", oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY)); assertEquals("Truncate Calendar.HOUR", oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR)); assertEquals("Truncate Calendar.DATE", oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE)); // ---------- Test Round (down) ---------- assertEquals("Round Calendar.MILLISECOND", oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND)); assertEquals("Round Calendar.SECOND", oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND)); assertEquals("Round Calendar.MINUTE", oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE)); assertEquals("Round Calendar.HOUR_OF_DAY", oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY)); assertEquals("Round Calendar.HOUR", oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR)); assertEquals("Round Calendar.DATE", oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE)); // restore default time zone TimeZone.setDefault(defaultZone); } // http://issues.apache.org/jira/browse/LANG-530 @Test public void testLang530() throws ParseException { final Date d = new Date(); final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d); final Date d2 = DateUtils.parseDate(isoDateStr, new String[] { DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern() }); // the format loses milliseconds so have to reintroduce them assertEquals("Date not equal to itself ISO formatted and parsed", d.getTime(), d2.getTime() + d.getTime() % 1000); } /** * Tests various values with the ceiling method */ @Test public void testCeil() throws Exception { // test javadoc assertEquals("ceiling javadoc-1 failed", dateTimeParser.parse("March 28, 2002 14:00:00.000"), DateUtils.ceiling( dateTimeParser.parse("March 28, 2002 13:45:01.231"), Calendar.HOUR)); assertEquals("ceiling javadoc-2 failed", dateTimeParser.parse("April 1, 2002 00:00:00.000"), DateUtils.ceiling( dateTimeParser.parse("March 28, 2002 13:45:01.231"), Calendar.MONTH)); // tests public static Date ceiling(Date date, int field) assertEquals("ceiling year-1 failed", dateParser.parse("January 1, 2003"), DateUtils.ceiling(date1, Calendar.YEAR)); assertEquals("ceiling year-2 failed", dateParser.parse("January 1, 2002"), DateUtils.ceiling(date2, Calendar.YEAR)); assertEquals("ceiling month-1 failed", dateParser.parse("March 1, 2002"), DateUtils.ceiling(date1, Calendar.MONTH)); assertEquals("ceiling month-2 failed", dateParser.parse("December 1, 2001"), DateUtils.ceiling(date2, Calendar.MONTH)); assertEquals("ceiling semimonth-1 failed", dateParser.parse("February 16, 2002"), DateUtils.ceiling(date1, DateUtils.SEMI_MONTH)); assertEquals("ceiling semimonth-2 failed", dateParser.parse("December 1, 2001"), DateUtils.ceiling(date2, DateUtils.SEMI_MONTH)); assertEquals("ceiling date-1 failed", dateParser.parse("February 13, 2002"), DateUtils.ceiling(date1, Calendar.DATE)); assertEquals("ceiling date-2 failed", dateParser.parse("November 19, 2001"), DateUtils.ceiling(date2, Calendar.DATE)); assertEquals("ceiling hour-1 failed", dateTimeParser.parse("February 12, 2002 13:00:00.000"), DateUtils.ceiling(date1, Calendar.HOUR)); assertEquals("ceiling hour-2 failed", dateTimeParser.parse("November 18, 2001 2:00:00.000"), DateUtils.ceiling(date2, Calendar.HOUR)); assertEquals("ceiling minute-1 failed", dateTimeParser.parse("February 12, 2002 12:35:00.000"), DateUtils.ceiling(date1, Calendar.MINUTE)); assertEquals("ceiling minute-2 failed", dateTimeParser.parse("November 18, 2001 1:24:00.000"), DateUtils.ceiling(date2, Calendar.MINUTE)); assertEquals("ceiling second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:57.000"), DateUtils.ceiling(date1, Calendar.SECOND)); assertEquals("ceiling second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:12.000"), DateUtils.ceiling(date2, Calendar.SECOND)); assertEquals("ceiling ampm-1 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.ceiling(dateAmPm1, Calendar.AM_PM)); assertEquals("ceiling ampm-2 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.ceiling(dateAmPm2, Calendar.AM_PM)); assertEquals("ceiling ampm-3 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.ceiling(dateAmPm3, Calendar.AM_PM)); assertEquals("ceiling ampm-4 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.ceiling(dateAmPm4, Calendar.AM_PM)); // tests public static Date ceiling(Object date, int field) assertEquals("ceiling year-1 failed", dateParser.parse("January 1, 2003"), DateUtils.ceiling((Object) date1, Calendar.YEAR)); assertEquals("ceiling year-2 failed", dateParser.parse("January 1, 2002"), DateUtils.ceiling((Object) date2, Calendar.YEAR)); assertEquals("ceiling month-1 failed", dateParser.parse("March 1, 2002"), DateUtils.ceiling((Object) date1, Calendar.MONTH)); assertEquals("ceiling month-2 failed", dateParser.parse("December 1, 2001"), DateUtils.ceiling((Object) date2, Calendar.MONTH)); assertEquals("ceiling semimonth-1 failed", dateParser.parse("February 16, 2002"), DateUtils.ceiling((Object) date1, DateUtils.SEMI_MONTH)); assertEquals("ceiling semimonth-2 failed", dateParser.parse("December 1, 2001"), DateUtils.ceiling((Object) date2, DateUtils.SEMI_MONTH)); assertEquals("ceiling date-1 failed", dateParser.parse("February 13, 2002"), DateUtils.ceiling((Object) date1, Calendar.DATE)); assertEquals("ceiling date-2 failed", dateParser.parse("November 19, 2001"), DateUtils.ceiling((Object) date2, Calendar.DATE)); assertEquals("ceiling hour-1 failed", dateTimeParser.parse("February 12, 2002 13:00:00.000"), DateUtils.ceiling((Object) date1, Calendar.HOUR)); assertEquals("ceiling hour-2 failed", dateTimeParser.parse("November 18, 2001 2:00:00.000"), DateUtils.ceiling((Object) date2, Calendar.HOUR)); assertEquals("ceiling minute-1 failed", dateTimeParser.parse("February 12, 2002 12:35:00.000"), DateUtils.ceiling((Object) date1, Calendar.MINUTE)); assertEquals("ceiling minute-2 failed", dateTimeParser.parse("November 18, 2001 1:24:00.000"), DateUtils.ceiling((Object) date2, Calendar.MINUTE)); assertEquals("ceiling second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:57.000"), DateUtils.ceiling((Object) date1, Calendar.SECOND)); assertEquals("ceiling second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:12.000"), DateUtils.ceiling((Object) date2, Calendar.SECOND)); assertEquals("ceiling ampm-1 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.ceiling((Object) dateAmPm1, Calendar.AM_PM)); assertEquals("ceiling ampm-2 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.ceiling((Object) dateAmPm2, Calendar.AM_PM)); assertEquals("ceiling ampm-3 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.ceiling((Object) dateAmPm3, Calendar.AM_PM)); assertEquals("ceiling ampm-4 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.ceiling((Object) dateAmPm4, Calendar.AM_PM)); assertEquals("ceiling calendar second-1 failed", dateTimeParser.parse("February 12, 2002 12:34:57.000"), DateUtils.ceiling((Object) cal1, Calendar.SECOND)); assertEquals("ceiling calendar second-2 failed", dateTimeParser.parse("November 18, 2001 1:23:12.000"), DateUtils.ceiling((Object) cal2, Calendar.SECOND)); assertEquals("ceiling ampm-1 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.ceiling((Object) calAmPm1, Calendar.AM_PM)); assertEquals("ceiling ampm-2 failed", dateTimeParser.parse("February 3, 2002 12:00:00.000"), DateUtils.ceiling((Object) calAmPm2, Calendar.AM_PM)); assertEquals("ceiling ampm-3 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.ceiling((Object) calAmPm3, Calendar.AM_PM)); assertEquals("ceiling ampm-4 failed", dateTimeParser.parse("February 4, 2002 00:00:00.000"), DateUtils.ceiling((Object) calAmPm4, Calendar.AM_PM)); try { DateUtils.ceiling((Date) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.ceiling((Calendar) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.ceiling((Object) null, Calendar.SECOND); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.ceiling("", Calendar.SECOND); fail(); } catch (final ClassCastException ex) {} try { DateUtils.ceiling(date1, -9999); fail(); } catch(final IllegalArgumentException ex) {} // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 // Test ceiling across the beginning of daylight saving time TimeZone.setDefault(zone); dateTimeParser.setTimeZone(zone); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling(date4, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling((Object) cal4, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling(date5, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling((Object) cal5, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling(date6, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling((Object) cal6, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling(date7, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 31, 2003 00:00:00.000"), DateUtils.ceiling((Object) cal7, Calendar.DATE)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.ceiling(date4, Calendar.HOUR_OF_DAY)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.ceiling((Object) cal4, Calendar.HOUR_OF_DAY)); if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.ceiling(date5, Calendar.HOUR_OF_DAY)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 03:00:00.000"), DateUtils.ceiling((Object) cal5, Calendar.HOUR_OF_DAY)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 04:00:00.000"), DateUtils.ceiling(date6, Calendar.HOUR_OF_DAY)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 04:00:00.000"), DateUtils.ceiling((Object) cal6, Calendar.HOUR_OF_DAY)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 04:00:00.000"), DateUtils.ceiling(date7, Calendar.HOUR_OF_DAY)); assertEquals("ceiling MET date across DST change-over", dateTimeParser.parse("March 30, 2003 04:00:00.000"), DateUtils.ceiling((Object) cal7, Calendar.HOUR_OF_DAY)); } else { this.warn("WARNING: Some date ceiling tests not run since the current version is " + SystemUtils.JAVA_SPECIFICATION_VERSION); } TimeZone.setDefault(defaultZone); dateTimeParser.setTimeZone(defaultZone); // Bug 31395, large dates final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis final GregorianCalendar endCal = new GregorianCalendar(); endCal.setTime(endOfTime); try { DateUtils.ceiling(endCal, Calendar.DATE); fail(); } catch (final ArithmeticException ex) {} endCal.set(Calendar.YEAR, 280000001); try { DateUtils.ceiling(endCal, Calendar.DATE); fail(); } catch (final ArithmeticException ex) {} endCal.set(Calendar.YEAR, 280000000); final Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE); assertEquals(0, cal.get(Calendar.HOUR)); } /** * Tests the iterator exceptions */ @Test public void testIteratorEx() throws Exception { try { DateUtils.iterator(Calendar.getInstance(), -9999); } catch (final IllegalArgumentException ex) {} try { DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER); fail(); } catch (final IllegalArgumentException ex) {} try { DateUtils.iterator("", DateUtils.RANGE_WEEK_CENTER); fail(); } catch (final ClassCastException ex) {} } /** * Tests the calendar iterator for week ranges */ @Test public void testWeekIterator() throws Exception { final Calendar now = Calendar.getInstance(); for (int i = 0; i< 7; i++) { final Calendar today = DateUtils.truncate(now, Calendar.DATE); final Calendar sunday = DateUtils.truncate(now, Calendar.DATE); sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK)); final Calendar monday = DateUtils.truncate(now, Calendar.DATE); if (monday.get(Calendar.DAY_OF_WEEK) == 1) { //This is sunday... roll back 6 days monday.add(Calendar.DATE, -6); } else { monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK)); } final Calendar centered = DateUtils.truncate(now, Calendar.DATE); centered.add(Calendar.DATE, -3); Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY); assertWeekIterator(it, sunday); it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY); assertWeekIterator(it, monday); it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE); assertWeekIterator(it, today); it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); assertWeekIterator(it, centered); it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER); assertWeekIterator(it, centered); it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER); assertWeekIterator(it, centered); try { it.next(); fail(); } catch (final NoSuchElementException ex) {} it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER); it.next(); try { it.remove(); } catch( final UnsupportedOperationException ex) {} now.add(Calendar.DATE,1); } } /** * Tests the calendar iterator for month-based ranges */ @Test public void testMonthIterator() throws Exception { Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY); assertWeekIterator(it, dateParser.parse("January 27, 2002"), dateParser.parse("March 2, 2002")); it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY); assertWeekIterator(it, dateParser.parse("January 28, 2002"), dateParser.parse("March 3, 2002")); it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY); assertWeekIterator(it, dateParser.parse("October 28, 2001"), dateParser.parse("December 1, 2001")); it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY); assertWeekIterator(it, dateParser.parse("October 29, 2001"), dateParser.parse("December 2, 2001")); } @Test public void testLANG799_EN_OK() throws ParseException { final Locale dflt = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); try { DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"); DateUtils.parseDateStrictly("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"); } finally { Locale.setDefault(dflt); } } // Parse German date with English Locale @Test(expected=ParseException.class) public void testLANG799_EN_FAIL() throws ParseException { final Locale dflt = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); try { DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"); } finally { Locale.setDefault(dflt); } } @Test public void testLANG799_DE_OK() throws ParseException { final Locale dflt = Locale.getDefault(); Locale.setDefault(Locale.GERMAN); try { DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"); DateUtils.parseDateStrictly("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"); } finally { Locale.setDefault(dflt); } } // Parse English date with German Locale @Test(expected=ParseException.class) public void testLANG799_DE_FAIL() throws ParseException { final Locale dflt = Locale.getDefault(); Locale.setDefault(Locale.GERMAN); try { DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"); } finally { Locale.setDefault(dflt); } } // Parse German date with English Locale, specifying German Locale override @Test public void testLANG799_EN_WITH_DE_LOCALE() throws ParseException { final Locale dflt = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); try { DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", Locale.GERMAN, "EEE, dd MMM yyyy HH:mm:ss zzz"); } finally { Locale.setDefault(dflt); } } /** * This checks that this is a 7 element iterator of Calendar objects * that are dates (no time), and exactly 1 day spaced after each other. */ private static void assertWeekIterator(final Iterator<?> it, final Calendar start) { final Calendar end = (Calendar) start.clone(); end.add(Calendar.DATE, 6); assertWeekIterator(it, start, end); } /** * Convenience method for when working with Date objects */ private static void assertWeekIterator(final Iterator<?> it, final Date start, final Date end) { final Calendar calStart = Calendar.getInstance(); calStart.setTime(start); final Calendar calEnd = Calendar.getInstance(); calEnd.setTime(end); assertWeekIterator(it, calStart, calEnd); } /** * This checks that this is a 7 divisble iterator of Calendar objects * that are dates (no time), and exactly 1 day spaced after each other * (in addition to the proper start and stop dates) */ private static void assertWeekIterator(final Iterator<?> it, final Calendar start, final Calendar end) { Calendar cal = (Calendar) it.next(); assertCalendarsEquals("", start, cal, 0); Calendar last = null; int count = 1; while (it.hasNext()) { //Check this is just a date (no time component) assertCalendarsEquals("", cal, DateUtils.truncate(cal, Calendar.DATE), 0); last = cal; cal = (Calendar) it.next(); count++; //Check that this is one day more than the last date last.add(Calendar.DATE, 1); assertCalendarsEquals("", last, cal, 0); } if (count % 7 != 0) { throw new AssertionFailedError("There were " + count + " days in this iterator"); } assertCalendarsEquals("", end, cal, 0); } /** * Used to check that Calendar objects are close enough * delta is in milliseconds */ private static void assertCalendarsEquals(final String message, final Calendar cal1, final Calendar cal2, final long delta) { if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) { throw new AssertionFailedError( message + " expected " + cal1.getTime() + " but got " + cal2.getTime()); } } void warn(final String msg) { System.err.println(msg); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import org.junit.Test; import static org.junit.Assert.*; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Calendar; import java.util.TimeZone; /** * TestCase for DurationFormatUtils. * */ public class DurationFormatUtilsTest { // ----------------------------------------------------------------------- @Test public void testConstructor() { assertNotNull(new DurationFormatUtils()); final Constructor<?>[] cons = DurationFormatUtils.class.getDeclaredConstructors(); assertEquals(1, cons.length); assertTrue(Modifier.isPublic(cons[0].getModifiers())); assertTrue(Modifier.isPublic(DurationFormatUtils.class.getModifiers())); assertFalse(Modifier.isFinal(DurationFormatUtils.class.getModifiers())); } // ----------------------------------------------------------------------- @Test public void testFormatDurationWords() { String text = null; text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false); assertEquals("50 seconds", text); text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false); assertEquals("1 minute 5 seconds", text); text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false); assertEquals("2 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false); assertEquals("2 minutes 1 second", text); text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false); assertEquals("1 hour 12 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false); assertEquals("1 day 0 hours 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true); assertEquals("50 seconds", text); text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true); assertEquals("1 minute 5 seconds", text); text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true); assertEquals("2 minutes", text); text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true); assertEquals("2 minutes 1 second", text); text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true); assertEquals("1 hour 12 minutes", text); text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true); assertEquals("1 day", text); text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true); assertEquals("0 days 0 hours 0 minutes 50 seconds", text); text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true); assertEquals("0 days 0 hours 1 minute 5 seconds", text); text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true); assertEquals("0 days 0 hours 2 minutes", text); text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true); assertEquals("0 days 0 hours 2 minutes 1 second", text); text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true); assertEquals("0 days 1 hour 12 minutes", text); text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true); assertEquals("1 day", text); text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false); assertEquals("0 days 0 hours 0 minutes 50 seconds", text); text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false); assertEquals("0 days 0 hours 1 minute 5 seconds", text); text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false); assertEquals("0 days 0 hours 2 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false); assertEquals("0 days 0 hours 2 minutes 1 second", text); text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false); assertEquals("0 days 1 hour 12 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); assertEquals("1 day 1 hour 12 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false); assertEquals("2 days 1 hour 12 minutes 0 seconds", text); for (int i = 2; i < 31; i++) { text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false); // assertEquals(i + " days 0 hours 0 minutes 0 seconds", text); // // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours // -2 minutes -47...> // at junit.framework.Assert.assertEquals(Assert.java:81) // at junit.framework.Assert.assertEquals(Assert.java:87) // at // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124) // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) // at java.lang.reflect.Method.invoke(Method.java:324) // at junit.framework.TestCase.runTest(TestCase.java:154) // at junit.framework.TestCase.runBare(TestCase.java:127) // at junit.framework.TestResult$1.protect(TestResult.java:106) // at junit.framework.TestResult.runProtected(TestResult.java:124) // at junit.framework.TestResult.run(TestResult.java:109) // at junit.framework.TestCase.run(TestCase.java:118) // at junit.framework.TestSuite.runTest(TestSuite.java:208) // at junit.framework.TestSuite.run(TestSuite.java:203) // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) } } /** * Tests that "1 <unit>s" gets converted to "1 <unit>" but that "11 <unit>s" is left alone. */ @Test public void testFormatDurationPluralWords() { final long oneSecond = 1000; final long oneMinute = oneSecond * 60; final long oneHour = oneMinute * 60; final long oneDay = oneHour * 24; String text = null; text = DurationFormatUtils.formatDurationWords(oneSecond, false, false); assertEquals("0 days 0 hours 0 minutes 1 second", text); text = DurationFormatUtils.formatDurationWords(oneSecond * 2, false, false); assertEquals("0 days 0 hours 0 minutes 2 seconds", text); text = DurationFormatUtils.formatDurationWords(oneSecond * 11, false, false); assertEquals("0 days 0 hours 0 minutes 11 seconds", text); text = DurationFormatUtils.formatDurationWords(oneMinute, false, false); assertEquals("0 days 0 hours 1 minute 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneMinute * 2, false, false); assertEquals("0 days 0 hours 2 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneMinute * 11, false, false); assertEquals("0 days 0 hours 11 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneMinute + oneSecond, false, false); assertEquals("0 days 0 hours 1 minute 1 second", text); text = DurationFormatUtils.formatDurationWords(oneHour, false, false); assertEquals("0 days 1 hour 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneHour * 2, false, false); assertEquals("0 days 2 hours 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneHour * 11, false, false); assertEquals("0 days 11 hours 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneHour + oneMinute + oneSecond, false, false); assertEquals("0 days 1 hour 1 minute 1 second", text); text = DurationFormatUtils.formatDurationWords(oneDay, false, false); assertEquals("1 day 0 hours 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneDay * 2, false, false); assertEquals("2 days 0 hours 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneDay * 11, false, false); assertEquals("11 days 0 hours 0 minutes 0 seconds", text); text = DurationFormatUtils.formatDurationWords(oneDay + oneHour + oneMinute + oneSecond, false, false); assertEquals("1 day 1 hour 1 minute 1 second", text); } @Test public void testFormatDurationHMS() { long time = 0; assertEquals("0:00:00.000", DurationFormatUtils.formatDurationHMS(time)); time = 1; assertEquals("0:00:00.001", DurationFormatUtils.formatDurationHMS(time)); time = 15; assertEquals("0:00:00.015", DurationFormatUtils.formatDurationHMS(time)); time = 165; assertEquals("0:00:00.165", DurationFormatUtils.formatDurationHMS(time)); time = 1675; assertEquals("0:00:01.675", DurationFormatUtils.formatDurationHMS(time)); time = 13465; assertEquals("0:00:13.465", DurationFormatUtils.formatDurationHMS(time)); time = 72789; assertEquals("0:01:12.789", DurationFormatUtils.formatDurationHMS(time)); time = 12789 + 32 * 60000; assertEquals("0:32:12.789", DurationFormatUtils.formatDurationHMS(time)); time = 12789 + 62 * 60000; assertEquals("1:02:12.789", DurationFormatUtils.formatDurationHMS(time)); } @Test public void testFormatDurationISO() { assertEquals("P0Y0M0DT0H0M0.000S", DurationFormatUtils.formatDurationISO(0L)); assertEquals("P0Y0M0DT0H0M0.001S", DurationFormatUtils.formatDurationISO(1L)); assertEquals("P0Y0M0DT0H0M0.010S", DurationFormatUtils.formatDurationISO(10L)); assertEquals("P0Y0M0DT0H0M0.100S", DurationFormatUtils.formatDurationISO(100L)); assertEquals("P0Y0M0DT0H1M15.321S", DurationFormatUtils.formatDurationISO(75321L)); } @Test public void testFormatDuration() { long duration = 0; assertEquals("0", DurationFormatUtils.formatDuration(duration, "y")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "M")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "d")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "H")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "m")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "s")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "S")); assertEquals("0000", DurationFormatUtils.formatDuration(duration, "SSSS")); assertEquals("0000", DurationFormatUtils.formatDuration(duration, "yyyy")); assertEquals("0000", DurationFormatUtils.formatDuration(duration, "yyMM")); duration = 60 * 1000; assertEquals("0", DurationFormatUtils.formatDuration(duration, "y")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "M")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "d")); assertEquals("0", DurationFormatUtils.formatDuration(duration, "H")); assertEquals("1", DurationFormatUtils.formatDuration(duration, "m")); assertEquals("60", DurationFormatUtils.formatDuration(duration, "s")); assertEquals("60000", DurationFormatUtils.formatDuration(duration, "S")); assertEquals("01:00", DurationFormatUtils.formatDuration(duration, "mm:ss")); final Calendar base = Calendar.getInstance(); base.set(2000, 0, 1, 0, 0, 0); base.set(Calendar.MILLISECOND, 0); final Calendar cal = Calendar.getInstance(); cal.set(2003, 1, 1, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); duration = cal.getTime().getTime() - base.getTime().getTime(); // duration from 2000-01-01 to cal // don't use 1970 in test as time zones were less reliable in 1970 than now // remember that duration formatting ignores time zones, working on strict hour lengths final int days = 366 + 365 + 365 + 31; assertEquals("0 0 " + days, DurationFormatUtils.formatDuration(duration, "y M d")); } @Test public void testFormatPeriodISO() { final TimeZone timeZone = TimeZone.getTimeZone("GMT-3"); final Calendar base = Calendar.getInstance(timeZone); base.set(1970, 0, 1, 0, 0, 0); base.set(Calendar.MILLISECOND, 0); final Calendar cal = Calendar.getInstance(timeZone); cal.set(2002, 1, 23, 9, 11, 12); cal.set(Calendar.MILLISECOND, 1); String text; // repeat a test from testDateTimeISO to compare extended and not extended. text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal); assertEquals("2002-02-23T09:11:12-03:00", text); // test fixture is the same as above, but now with extended format. text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); assertEquals("P32Y1M22DT9H11M12.001S", text); // test fixture from example in http://www.w3.org/TR/xmlschema-2/#duration cal.set(1971, 1, 3, 10, 30, 0); cal.set(Calendar.MILLISECOND, 0); text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone); assertEquals("P1Y1M2DT10H30M0.000S", text); // want a way to say 'don't print the seconds in format()' or other fields for that matter: // assertEquals("P1Y2M3DT10H30M", text); } @Test public void testFormatPeriod() { final Calendar cal1970 = Calendar.getInstance(); cal1970.set(1970, 0, 1, 0, 0, 0); cal1970.set(Calendar.MILLISECOND, 0); final long time1970 = cal1970.getTime().getTime(); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "y")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "M")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "d")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "H")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "m")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "s")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "S")); assertEquals("0000", DurationFormatUtils.formatPeriod(time1970, time1970, "SSSS")); assertEquals("0000", DurationFormatUtils.formatPeriod(time1970, time1970, "yyyy")); assertEquals("0000", DurationFormatUtils.formatPeriod(time1970, time1970, "yyMM")); long time = time1970 + 60 * 1000; assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "y")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "M")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "d")); assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "H")); assertEquals("1", DurationFormatUtils.formatPeriod(time1970, time, "m")); assertEquals("60", DurationFormatUtils.formatPeriod(time1970, time, "s")); assertEquals("60000", DurationFormatUtils.formatPeriod(time1970, time, "S")); assertEquals("01:00", DurationFormatUtils.formatPeriod(time1970, time, "mm:ss")); final Calendar cal = Calendar.getInstance(); cal.set(1973, 6, 1, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); time = cal.getTime().getTime(); assertEquals("36", DurationFormatUtils.formatPeriod(time1970, time, "yM")); assertEquals("3 years 6 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'")); assertEquals("03/06", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM")); cal.set(1973, 10, 1, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); time = cal.getTime().getTime(); assertEquals("310", DurationFormatUtils.formatPeriod(time1970, time, "yM")); assertEquals("3 years 10 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'")); assertEquals("03/10", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM")); cal.set(1974, 0, 1, 0, 0, 0); cal.set(Calendar.MILLISECOND, 0); time = cal.getTime().getTime(); assertEquals("40", DurationFormatUtils.formatPeriod(time1970, time, "yM")); assertEquals("4 years 0 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'")); assertEquals("04/00", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM")); assertEquals("48", DurationFormatUtils.formatPeriod(time1970, time, "M")); assertEquals("48", DurationFormatUtils.formatPeriod(time1970, time, "MM")); assertEquals("048", DurationFormatUtils.formatPeriod(time1970, time, "MMM")); } @Test public void testLexx() { // tests each constant assertArrayEquals(new DurationFormatUtils.Token[]{ new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS")); // tests the ISO8601-like assertArrayEquals(new DurationFormatUtils.Token[]{ new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(":"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("H:mm:ss.SSS")); // test the iso extended format assertArrayEquals(new DurationFormatUtils.Token[]{ new DurationFormatUtils.Token(new StringBuilder("P"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder("Y"), 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(new StringBuilder("DT"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder("H"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(new StringBuilder("M"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(new StringBuilder("."), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1), new DurationFormatUtils.Token(new StringBuilder("S"), 1)}, DurationFormatUtils .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN)); // test failures in equals final DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4); assertFalse("Token equal to non-Token class. ", token.equals(new Object())); assertFalse("Token equal to Token with wrong value class. ", token.equals(new DurationFormatUtils.Token( new Object()))); assertFalse("Token equal to Token with different count. ", token.equals(new DurationFormatUtils.Token( DurationFormatUtils.y, 1))); final DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4); assertTrue("Token with Number value not equal to itself. ", numToken.equals(numToken)); } // http://issues.apache.org/bugzilla/show_bug.cgi?id=38401 @Test public void testBugzilla38401() { assertEqualDuration( "0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 }, new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS"); } // https://issues.apache.org/jira/browse/LANG-281 @Test public void testJiraLang281() { assertEqualDuration( "09", new int[] { 2005, 11, 31, 0, 0, 0 }, new int[] { 2006, 9, 6, 0, 0, 0 }, "MM"); } @Test public void testLANG815() { final Calendar calendar = Calendar.getInstance(); calendar.set(2012, 6, 30, 0, 0, 0); final long startMillis = calendar.getTimeInMillis(); calendar.set(2012, 8, 8); final long endMillis = calendar.getTimeInMillis(); assertEquals("1 9", DurationFormatUtils.formatPeriod(startMillis, endMillis, "M d")); } // Testing the under a day range in DurationFormatUtils.formatPeriod @Test public void testLowDurations() { for(int hr=0; hr < 24; hr++) { for(int min=0; min < 60; min++) { for(int sec=0; sec < 60; sec++) { assertEqualDuration( hr + ":" + min + ":" + sec, new int[] { 2000, 0, 1, 0, 0, 0, 0 }, new int[] { 2000, 0, 1, hr, min, sec }, "H:m:s" ); } } } } // Attempting to test edge cases in DurationFormatUtils.formatPeriod @Test public void testEdgeDurations() { assertEqualDuration( "01", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM"); assertEqualDuration( "12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 15, 0, 0, 0 }, "MM"); assertEqualDuration( "12", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 16, 0, 0, 0 }, "MM"); assertEqualDuration( "11", new int[] { 2005, 0, 15, 0, 0, 0 }, new int[] { 2006, 0, 14, 0, 0, 0 }, "MM"); assertEqualDuration( "01 26", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "MM dd"); assertEqualDuration( "54", new int[] { 2006, 0, 15, 0, 0, 0 }, new int[] { 2006, 2, 10, 0, 0, 0 }, "dd"); assertEqualDuration( "09 12", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "MM dd"); assertEqualDuration( "287", new int[] { 2006, 1, 20, 0, 0, 0 }, new int[] { 2006, 11, 4, 0, 0, 0 }, "dd"); assertEqualDuration( "11 30", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM dd"); assertEqualDuration( "364", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "12 00", new int[] { 2006, 0, 1, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "MM dd"); assertEqualDuration( "365", new int[] { 2006, 0, 1, 0, 0, 0 }, new int[] { 2007, 0, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "31", new int[] { 2006, 0, 1, 0, 0, 0 }, new int[] { 2006, 1, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "92", new int[] { 2005, 9, 1, 0, 0, 0 }, new int[] { 2006, 0, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "77", new int[] { 2005, 9, 16, 0, 0, 0 }, new int[] { 2006, 0, 1, 0, 0, 0 }, "dd"); // test month larger in start than end assertEqualDuration( "136", new int[] { 2005, 9, 16, 0, 0, 0 }, new int[] { 2006, 2, 1, 0, 0, 0 }, "dd"); // test when start in leap year assertEqualDuration( "136", new int[] { 2004, 9, 16, 0, 0, 0 }, new int[] { 2005, 2, 1, 0, 0, 0 }, "dd"); // test when end in leap year assertEqualDuration( "137", new int[] { 2003, 9, 16, 0, 0, 0 }, new int[] { 2004, 2, 1, 0, 0, 0 }, "dd"); // test when end in leap year but less than end of feb assertEqualDuration( "135", new int[] { 2003, 9, 16, 0, 0, 0 }, new int[] { 2004, 1, 28, 0, 0, 0 }, "dd"); assertEqualDuration( "364", new int[] { 2007, 0, 2, 0, 0, 0 }, new int[] { 2008, 0, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "729", new int[] { 2006, 0, 2, 0, 0, 0 }, new int[] { 2008, 0, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "365", new int[] { 2007, 2, 2, 0, 0, 0 }, new int[] { 2008, 2, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "333", new int[] { 2007, 1, 2, 0, 0, 0 }, new int[] { 2008, 0, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "28", new int[] { 2008, 1, 2, 0, 0, 0 }, new int[] { 2008, 2, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "393", new int[] { 2007, 1, 2, 0, 0, 0 }, new int[] { 2008, 2, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "369", new int[] { 2004, 0, 29, 0, 0, 0 }, new int[] { 2005, 1, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "338", new int[] { 2004, 1, 29, 0, 0, 0 }, new int[] { 2005, 1, 1, 0, 0, 0 }, "dd"); assertEqualDuration( "28", new int[] { 2004, 2, 8, 0, 0, 0 }, new int[] { 2004, 3, 5, 0, 0, 0 }, "dd"); assertEqualDuration( "48", new int[] { 1992, 1, 29, 0, 0, 0 }, new int[] { 1996, 1, 29, 0, 0, 0 }, "M"); // this seems odd - and will fail if I throw it in as a brute force // below as it expects the answer to be 12. It's a tricky edge case assertEqualDuration( "11", new int[] { 1996, 1, 29, 0, 0, 0 }, new int[] { 1997, 1, 28, 0, 0, 0 }, "M"); // again - this seems odd assertEqualDuration( "11 28", new int[] { 1996, 1, 29, 0, 0, 0 }, new int[] { 1997, 1, 28, 0, 0, 0 }, "M d"); } @Test public void testDurationsByBruteForce() { bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH); bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH); bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH); bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH); bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH); bruteForce(1969, 1, 28, "M", Calendar.MONTH); // tests for 48 years //bruteForce(1996, 1, 29, "M", Calendar.MONTH); // this will fail } private static final int FOUR_YEARS = 365 * 3 + 366; // Takes a minute to run, so generally turned off // public void testBrutally() { // Calendar c = Calendar.getInstance(); // c.set(2004, 0, 1, 0, 0, 0); // for (int i=0; i < FOUR_YEARS; i++) { // bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); // c.add(Calendar.DAY_OF_MONTH, 1); // } // } private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) { final String msg = year + "-" + month + "-" + day + " to "; final Calendar c = Calendar.getInstance(); c.set(year, month, day, 0, 0, 0); final int[] array1 = new int[] { year, month, day, 0, 0, 0 }; final int[] array2 = new int[] { year, month, day, 0, 0, 0 }; for (int i=0; i < FOUR_YEARS; i++) { array2[0] = c.get(Calendar.YEAR); array2[1] = c.get(Calendar.MONTH); array2[2] = c.get(Calendar.DAY_OF_MONTH); final String tmpMsg = msg + array2[0] + "-" + array2[1] + "-" + array2[2] + " at "; assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format ); c.add(calendarType, 1); } } private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) { assertEqualDuration(null, expected, start, end, format); } private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) { final Calendar cal1 = Calendar.getInstance(); cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]); cal1.set(Calendar.MILLISECOND, 0); final Calendar cal2 = Calendar.getInstance(); cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]); cal2.set(Calendar.MILLISECOND, 0); final long milli1 = cal1.getTime().getTime(); final long milli2 = cal2.getTime().getTime(); final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format); if (message == null) { assertEquals(expected, result); } else { assertEquals(message, expected, result); } } private void assertArrayEquals(final DurationFormatUtils.Token[] obj1, final DurationFormatUtils.Token[] obj2) { assertEquals("Arrays are unequal length. ", obj1.length, obj2.length); for (int i = 0; i < obj1.length; i++) { assertTrue("Index " + i + " not equal, " + obj1[i] + " vs " + obj2[i], obj1[i].equals(obj2[i])); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import java.text.Format; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; import java.util.TimeZone; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.time.FastDateFormat}. * * @since 2.0 * @version $Id$ */ public class FastDateFormatTest { /* * Only the cache methods need to be tested here. * The print methods are tested by {@link FastDateFormat_PrinterTest} * and the parse methods are tested by {@link FastDateFormat_ParserTest} */ @Test public void test_getInstance() { final FastDateFormat format1 = FastDateFormat.getInstance(); final FastDateFormat format2 = FastDateFormat.getInstance(); assertSame(format1, format2); } @Test public void test_getInstance_String() { final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy"); final FastDateFormat format2 = FastDateFormat.getInstance("MM-DD-yyyy"); final FastDateFormat format3 = FastDateFormat.getInstance("MM-DD-yyyy"); assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); assertSame(format2, format3); assertEquals("MM/DD/yyyy", format1.getPattern()); assertEquals(TimeZone.getDefault(), format1.getTimeZone()); assertEquals(TimeZone.getDefault(), format2.getTimeZone()); } @Test public void test_getInstance_String_TimeZone() { final Locale realDefaultLocale = Locale.getDefault(); final TimeZone realDefaultZone = TimeZone.getDefault(); try { Locale.setDefault(Locale.US); TimeZone.setDefault(TimeZone.getTimeZone("America/New_York")); final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getTimeZone("Atlantic/Reykjavik")); final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy"); final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault()); final FastDateFormat format4 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault()); final FastDateFormat format5 = FastDateFormat.getInstance("MM-DD-yyyy", TimeZone.getDefault()); final FastDateFormat format6 = FastDateFormat.getInstance("MM-DD-yyyy"); assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone()); assertEquals(TimeZone.getDefault(), format2.getTimeZone()); assertSame(format3, format4); assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5); assertTrue(format4 != format6); // -- junit 3.8 version -- assertFalse(format3 == format5); } finally { Locale.setDefault(realDefaultLocale); TimeZone.setDefault(realDefaultZone); } } @Test public void test_getInstance_String_Locale() { final Locale realDefaultLocale = Locale.getDefault(); try { Locale.setDefault(Locale.US); final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy"); final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); assertSame(format1, format3); assertEquals(Locale.GERMANY, format1.getLocale()); } finally { Locale.setDefault(realDefaultLocale); } } @Test public void test_changeDefault_Locale_DateInstance() { final Locale realDefaultLocale = Locale.getDefault(); try { Locale.setDefault(Locale.US); final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY); final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL); Locale.setDefault(Locale.GERMANY); final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL); assertSame(Locale.GERMANY, format1.getLocale()); assertSame(Locale.US, format2.getLocale()); assertSame(Locale.GERMANY, format3.getLocale()); assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); assertTrue(format2 != format3); } finally { Locale.setDefault(realDefaultLocale); } } @Test public void test_changeDefault_Locale_DateTimeInstance() { final Locale realDefaultLocale = Locale.getDefault(); try { Locale.setDefault(Locale.US); final FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY); final FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL); Locale.setDefault(Locale.GERMANY); final FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL); assertSame(Locale.GERMANY, format1.getLocale()); assertSame(Locale.US, format2.getLocale()); assertSame(Locale.GERMANY, format3.getLocale()); assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2); assertTrue(format2 != format3); } finally { Locale.setDefault(realDefaultLocale); } } @Test public void test_getInstance_String_TimeZone_Locale() { final Locale realDefaultLocale = Locale.getDefault(); final TimeZone realDefaultZone = TimeZone.getDefault(); try { Locale.setDefault(Locale.US); TimeZone.setDefault(TimeZone.getTimeZone("America/New_York")); final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getTimeZone("Atlantic/Reykjavik"), Locale.GERMANY); final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY); final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault(), Locale.GERMANY); assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2); assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone()); assertEquals(TimeZone.getDefault(), format2.getTimeZone()); assertEquals(TimeZone.getDefault(), format3.getTimeZone()); assertEquals(Locale.GERMANY, format1.getLocale()); assertEquals(Locale.GERMANY, format2.getLocale()); assertEquals(Locale.GERMANY, format3.getLocale()); } finally { Locale.setDefault(realDefaultLocale); TimeZone.setDefault(realDefaultZone); } } @Test public void testCheckDefaults() { final FastDateFormat format = FastDateFormat.getInstance(); final FastDateFormat medium = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT); assertEquals(medium, format); final SimpleDateFormat sdf = new SimpleDateFormat(); assertEquals(sdf.toPattern(), format.getPattern()); assertEquals(Locale.getDefault(), format.getLocale()); assertEquals(TimeZone.getDefault(), format.getTimeZone()); } @Test public void testCheckDifferingStyles() { final FastDateFormat shortShort = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, Locale.US); final FastDateFormat shortLong = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, Locale.US); final FastDateFormat longShort = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, Locale.US); final FastDateFormat longLong = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, Locale.US); assertFalse(shortShort.equals(shortLong)); assertFalse(shortShort.equals(longShort)); assertFalse(shortShort.equals(longLong)); assertFalse(shortLong.equals(longShort)); assertFalse(shortLong.equals(longLong)); assertFalse(longShort.equals(longLong)); } @Test public void testDateDefaults() { assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA), FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG), FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); } @Test public void testTimeDefaults() { assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA), FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA)); assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG), FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault())); } @Test public void testTimeDateDefaults() { assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA)); assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault())); assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM), FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault())); } @Test public void testParseSync() throws InterruptedException { final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; final FastDateFormat formatter= FastDateFormat.getInstance(pattern); final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) { private static final long serialVersionUID = 1L; // because SimpleDateFormat is serializable @Override public Object parseObject(final String formattedDate) throws ParseException { synchronized(this) { return super.parse(formattedDate); } } }); final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern)); final String times= ">>FastDateFormatTest: FastDateParser:"+fdfTime+" SimpleDateFormat:"+sdfTime; System.out.println(times); } final static private int NTHREADS= 10; final static private int NROUNDS= 10000; private long measureTime(final Format formatter, final Format parser) throws InterruptedException { final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS); final AtomicInteger failures= new AtomicInteger(0); final AtomicLong totalElapsed= new AtomicLong(0); for(int i= 0; i<NTHREADS; ++i) { pool.submit(new Runnable() { @Override public void run() { for(int i= 0; i<NROUNDS; ++i) { try { final Date date= new Date(); final String formattedDate= formatter.format(date); final long start= System.currentTimeMillis(); final Object pd= parser.parseObject(formattedDate); totalElapsed.addAndGet(System.currentTimeMillis()-start); if(!date.equals(pd)) { failures.incrementAndGet(); } } catch (final Exception e) { failures.incrementAndGet(); e.printStackTrace(); } } } }); } pool.shutdown(); if(!pool.awaitTermination(20, TimeUnit.SECONDS)) { pool.shutdownNow(); fail("did not complete tasks"); } assertEquals(0, failures.get()); return totalElapsed.get(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import java.util.Locale; import java.util.TimeZone; /** * Unit tests for the parse methods of FastDateFormat * * @since 3.2 */ public class FastDateFormat_ParserTest extends FastDateParserTest { @Override protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) { return FastDateFormat.getInstance(format, timeZone, locale); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import java.util.Locale; import java.util.TimeZone; /** * Unit tests for the print methods of FastDateFormat * * @since 3.2 */ public class FastDateFormat_PrinterTest extends FastDatePrinterTest { @Override protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) { return FastDateFormat.getInstance(format, timeZone, locale); } public void testCalendarTimezoneRespected() {} // Fails in super class }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional inparserion regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import java.io.Serializable; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.TimeZone; import org.junit.Assert; import org.apache.commons.lang3.SerializationUtils; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.time.FastDateParser}. * * @since 3.2 */ public class FastDateParserTest { private static final String SHORT_FORMAT_NOERA = "y/M/d/h/a/m/E/Z"; private static final String LONG_FORMAT_NOERA = "yyyy/MMMM/dddd/hhhh/mmmm/aaaa/EEEE/ZZZZ"; private static final String SHORT_FORMAT = "G/" + SHORT_FORMAT_NOERA; private static final String LONG_FORMAT = "GGGG/" + LONG_FORMAT_NOERA; private static final String yMdHmsSZ = "yyyy-MM-dd'T'HH:mm:ss.SSS Z"; private static final String DMY_DOT = "dd.MM.yyyy"; private static final String YMD_SLASH = "yyyy/MM/dd"; private static final String MDY_DASH = "MM-DD-yyyy"; private static final String MDY_SLASH = "MM/DD/yyyy"; private static final TimeZone REYKJAVIK = TimeZone.getTimeZone("Atlantic/Reykjavik"); private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York"); private static final TimeZone GMT = TimeZone.getTimeZone("GMT"); private static final Locale SWEDEN = new Locale("sv", "SE"); DateParser getInstance(final String format) { return getInstance(format, TimeZone.getDefault(), Locale.getDefault()); } private DateParser getDateInstance(final int dateStyle, final Locale locale) { return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault()); } private DateParser getInstance(final String format, final Locale locale) { return getInstance(format, TimeZone.getDefault(), locale); } private DateParser getInstance(final String format, final TimeZone timeZone) { return getInstance(format, timeZone, Locale.getDefault()); } /** * Override this method in derived tests to change the construction of instances */ protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) { return new FastDateParser(format, timeZone, locale); } @Test public void test_Equality_Hash() { final DateParser[] parsers= { getInstance(yMdHmsSZ, NEW_YORK, Locale.US), getInstance(DMY_DOT, NEW_YORK, Locale.US), getInstance(YMD_SLASH, NEW_YORK, Locale.US), getInstance(MDY_DASH, NEW_YORK, Locale.US), getInstance(MDY_SLASH, NEW_YORK, Locale.US), getInstance(MDY_SLASH, REYKJAVIK, Locale.US), getInstance(MDY_SLASH, REYKJAVIK, SWEDEN) }; final Map<DateParser,Integer> map= new HashMap<DateParser,Integer>(); int i= 0; for(final DateParser parser:parsers) { map.put(parser, Integer.valueOf(i++)); } i= 0; for(final DateParser parser:parsers) { assertEquals(i++, map.get(parser).intValue()); } } @Test public void testParseZone() throws ParseException { final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); cal.clear(); cal.set(2003, 6, 10, 16, 33, 20); final DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US); assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 -0500")); assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 GMT-05:00")); assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 Eastern Daylight Time")); assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 EDT")); cal.setTimeZone(TimeZone.getTimeZone("GMT-3")); cal.set(2003, 1, 10, 9, 0, 0); assertEquals(cal.getTime(), fdf.parse("2003-02-10T09:00:00.000 -0300")); cal.setTimeZone(TimeZone.getTimeZone("GMT+5")); cal.set(2003, 1, 10, 15, 5, 6); assertEquals(cal.getTime(), fdf.parse("2003-02-10T15:05:06.000 +0500")); } @Test public void testParseLongShort() throws ParseException { final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); cal.clear(); cal.set(2003, 1, 10, 15, 33, 20); cal.set(Calendar.MILLISECOND, 989); cal.setTimeZone(NEW_YORK); DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US); assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00")); cal.set(Calendar.ERA, GregorianCalendar.BC); final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00"); assertEquals(cal.getTime(), parse); fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US); assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500")); cal.set(Calendar.ERA, GregorianCalendar.AD); assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500")); } @Test public void testAmPm() throws ParseException { final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); cal.clear(); final DateParser h = getInstance("yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US); final DateParser K = getInstance("yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US); final DateParser k = getInstance("yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US); final DateParser H = getInstance("yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US); cal.set(2010, 7, 1, 0, 33, 20); assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20")); assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20")); assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20")); assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20")); cal.set(2010, 7, 1, 3, 33, 20); assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20")); assertEquals(cal.getTime(), K.parse("2010-08-01 3 AM 33:20")); assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20")); assertEquals(cal.getTime(), H.parse("2010-08-01 03:33:20")); cal.set(2010, 7, 1, 15, 33, 20); assertEquals(cal.getTime(), h.parse("2010-08-01 3 PM 33:20")); assertEquals(cal.getTime(), K.parse("2010-08-01 3 PM 33:20")); assertEquals(cal.getTime(), k.parse("2010-08-01 15:33:20")); assertEquals(cal.getTime(), H.parse("2010-08-01 15:33:20")); cal.set(2010, 7, 1, 12, 33, 20); assertEquals(cal.getTime(), h.parse("2010-08-01 12 PM 33:20")); assertEquals(cal.getTime(), K.parse("2010-08-01 0 PM 33:20")); assertEquals(cal.getTime(), k.parse("2010-08-01 12:33:20")); assertEquals(cal.getTime(), H.parse("2010-08-01 12:33:20")); } @Test // Check that all Locales can parse the formats we use public void testParses() throws Exception { for(final Locale locale : Locale.getAvailableLocales()) { for(final TimeZone tz : new TimeZone[]{NEW_YORK, GMT}) { final Calendar cal = Calendar.getInstance(tz); for(final int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) { // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html if (year < 1868 && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) { continue; // Japanese imperial calendar does not support eras before 1868 } cal.clear(); if (year < 0) { cal.set(-year, 1, 10); cal.set(Calendar.ERA, GregorianCalendar.BC); } else { cal.set(year, 1, 10); } final Date in = cal.getTime(); for(final String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) { final SimpleDateFormat sdf = new SimpleDateFormat(format, locale); if (format.equals(SHORT_FORMAT)) { if (year < 1930) { sdf.set2DigitYearStart(cal.getTime()); } } final String fmt = sdf.format(in); try { final Date out = sdf.parse(fmt); assertEquals(locale.toString()+" "+year+" "+ format+ " "+tz.getID(), in, out); } catch (final ParseException pe) { System.out.println(fmt+" "+locale.toString()+" "+year+" "+ format+ " "+tz.getID()); throw pe; } } } } } } @Test public void testLocales_Long_AD() throws Exception { testLocales(LONG_FORMAT, false); } @Test public void testLocales_Long_BC() throws Exception { testLocales(LONG_FORMAT, true); } @Test public void testLocales_Short_AD() throws Exception { testLocales(SHORT_FORMAT, false); } @Test public void testLocales_Short_BC() throws Exception { testLocales(SHORT_FORMAT, true); } @Test public void testLocales_LongNoEra_AD() throws Exception { testLocales(LONG_FORMAT_NOERA, false); } @Test public void testLocales_LongNoEra_BC() throws Exception { testLocales(LONG_FORMAT_NOERA, true); } @Test public void testLocales_ShortNoEra_AD() throws Exception { testLocales(SHORT_FORMAT_NOERA, false); } @Test public void testLocales_ShortNoEra_BC() throws Exception { testLocales(SHORT_FORMAT_NOERA, true); } private void testLocales(final String format, final boolean eraBC) throws Exception { final Calendar cal= Calendar.getInstance(GMT); cal.clear(); cal.set(2003, 1, 10); if (eraBC) { cal.set(Calendar.ERA, GregorianCalendar.BC); } for(final Locale locale : Locale.getAvailableLocales()) { // ja_JP_JP cannot handle dates before 1868 properly if (eraBC && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) { continue; } final SimpleDateFormat sdf = new SimpleDateFormat(format, locale); final DateParser fdf = getInstance(format, locale); try { checkParse(locale, cal, sdf, fdf); } catch(final ParseException ex) { Assert.fail("Locale "+locale+ " failed with "+format+" era "+(eraBC?"BC":"AD")+"\n" + trimMessage(ex.toString())); } } } private String trimMessage(final String msg) { if (msg.length() < 100) { return msg; } final int gmt = msg.indexOf("(GMT"); if (gmt > 0) { return msg.substring(0, gmt+4)+"...)"; } return msg.substring(0, 100)+"..."; } private void checkParse(final Locale locale, final Calendar cal, final SimpleDateFormat sdf, final DateParser fdf) throws ParseException { final String formattedDate= sdf.format(cal.getTime()); final Date expectedTime = sdf.parse(formattedDate); final Date actualTime = fdf.parse(formattedDate); assertEquals(locale.toString()+" "+formattedDate +"\n",expectedTime, actualTime); } @Test public void testParseNumerics() throws ParseException { final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); cal.clear(); cal.set(2003, 1, 10, 15, 33, 20); cal.set(Calendar.MILLISECOND, 989); final DateParser fdf = getInstance("yyyyMMddHHmmssSSS", NEW_YORK, Locale.US); assertEquals(cal.getTime(), fdf.parse("20030210153320989")); } @Test public void testQuotes() throws ParseException { final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); cal.clear(); cal.set(2003, 1, 10, 15, 33, 20); cal.set(Calendar.MILLISECOND, 989); final DateParser fdf = getInstance("''yyyyMMdd'A''B'HHmmssSSS''", NEW_YORK, Locale.US); assertEquals(cal.getTime(), fdf.parse("'20030210A'B153320989'")); } @Test public void testSpecialCharacters() throws Exception { testSdfAndFdp("q" ,"", true); // bad pattern character (at present) testSdfAndFdp("Q" ,"", true); // bad pattern character testSdfAndFdp("$" ,"$", false); // OK testSdfAndFdp("?.d" ,"?.12", false); // OK testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK } @Test public void testLANG_832() throws Exception { testSdfAndFdp("'d'd" ,"d3", false); // OK testSdfAndFdp("'d'd'","d3", true); // should fail (unterminated quote) } @Test public void testLANG_831() throws Exception { testSdfAndFdp("M E","3 Tue", true); } private void testSdfAndFdp(final String format, final String date, final boolean shouldFail) throws Exception { final boolean debug = false; Date dfdp = null; Date dsdf = null; Throwable f = null; Throwable s = null; try { final SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US); sdf.setTimeZone(NEW_YORK); dsdf = sdf.parse(date); if (shouldFail) { Assert.fail("Expected SDF failure, but got " + dsdf + " for ["+format+","+date+"]"); } } catch (final Exception e) { s = e; if (!shouldFail) { throw e; } if (debug) { System.out.println("sdf:"+format+"/"+date+"=>"+e); } } try { final DateParser fdp = getInstance(format, NEW_YORK, Locale.US); dfdp = fdp.parse(date); if (shouldFail) { Assert.fail("Expected FDF failure, but got " + dfdp + " for ["+format+","+date+"] using "+((FastDateParser)fdp).getParsePattern()); } } catch (final Exception e) { f = e; if (!shouldFail) { throw e; } if (debug) { System.out.println("fdf:"+format+"/"+date+"=>"+e); } } // SDF and FDF should produce equivalent results assertTrue("Should both or neither throw Exceptions", (f==null)==(s==null)); assertEquals("Parsed dates should be equal", dsdf, dfdp); if (debug) { System.out.println(format + "," + date + " => " + dsdf); } } @Test public void testDayOf() throws ParseException { final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US); cal.clear(); cal.set(2003, 1, 10); final DateParser fdf = getInstance("W w F D y", NEW_YORK, Locale.US); assertEquals(cal.getTime(), fdf.parse("3 7 2 41 03")); } /** * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. * @throws ParseException */ @Test public void testShortDateStyleWithLocales() throws ParseException { DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US); final Calendar cal = Calendar.getInstance(); cal.clear(); cal.set(2004, 1, 3); assertEquals(cal.getTime(), fdf.parse("2/3/04")); fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN); assertEquals(cal.getTime(), fdf.parse("2004-02-03")); } /** * Tests that pre-1000AD years get padded with yyyy * @throws ParseException */ @Test public void testLowYearPadding() throws ParseException { final DateParser parser = getInstance(YMD_SLASH); final Calendar cal = Calendar.getInstance(); cal.clear(); cal.set(1,0,1); assertEquals(cal.getTime(), parser.parse("0001/01/01")); cal.set(10,0,1); assertEquals(cal.getTime(), parser.parse("0010/01/01")); cal.set(100,0,1); assertEquals(cal.getTime(), parser.parse("0100/01/01")); cal.set(999,0,1); assertEquals(cal.getTime(), parser.parse("0999/01/01")); } /** * @throws ParseException */ @Test public void testMilleniumBug() throws ParseException { final DateParser parser = getInstance(DMY_DOT); final Calendar cal = Calendar.getInstance(); cal.clear(); cal.set(1000,0,1); assertEquals(cal.getTime(), parser.parse("01.01.1000")); } @Test public void testLang303() throws ParseException { DateParser parser = getInstance(YMD_SLASH); final Calendar cal = Calendar.getInstance(); cal.set(2004, 11, 31); final Date date = parser.parse("2004/11/31"); parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser)); assertEquals(date, parser.parse("2004/11/31")); } @Test public void testLang538() throws ParseException { final DateParser parser = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", GMT); final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT-8")); cal.clear(); cal.set(2009, 9, 16, 8, 42, 16); assertEquals(cal.getTime(), parser.parse("2009-10-16T16:42:16.000Z")); } @Test public void testEquals() { final DateParser parser1= getInstance(YMD_SLASH); final DateParser parser2= getInstance(YMD_SLASH); assertEquals(parser1, parser2); assertEquals(parser1.hashCode(), parser2.hashCode()); assertFalse(parser1.equals(new Object())); } @Test public void testToStringContainsName() { final DateParser parser= getInstance(YMD_SLASH); assertTrue(parser.toString().startsWith("FastDate")); } @Test public void testPatternMatches() { final DateParser parser= getInstance(yMdHmsSZ); assertEquals(yMdHmsSZ, parser.getPattern()); } @Test public void testLocaleMatches() { final DateParser parser= getInstance(yMdHmsSZ, SWEDEN); assertEquals(SWEDEN, parser.getLocale()); } @Test public void testTimeZoneMatches() { final DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK); assertEquals(REYKJAVIK, parser.getTimeZone()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import java.io.Serializable; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import org.apache.commons.lang3.SerializationUtils; import org.junit.Test; /** * Unit tests {@link org.apache.commons.lang3.time.FastDatePrinter}. * * @since 3.0 */ public class FastDatePrinterTest { private static final String YYYY_MM_DD = "yyyy/MM/dd"; private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York"); private static final Locale SWEDEN = new Locale("sv", "SE"); DatePrinter getInstance(final String format) { return getInstance(format, TimeZone.getDefault(), Locale.getDefault()); } private DatePrinter getDateInstance(final int dateStyle, final Locale locale) { return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault()); } private DatePrinter getInstance(final String format, final Locale locale) { return getInstance(format, TimeZone.getDefault(), locale); } private DatePrinter getInstance(final String format, final TimeZone timeZone) { return getInstance(format, timeZone, Locale.getDefault()); } /** * Override this method in derived tests to change the construction of instances * @param format * @param timeZone * @param locale * @return */ protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) { return new FastDatePrinter(format, timeZone, locale); } @Test public void testFormat() { final Locale realDefaultLocale = Locale.getDefault(); final TimeZone realDefaultZone = TimeZone.getDefault(); try { Locale.setDefault(Locale.US); TimeZone.setDefault(NEW_YORK); final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20); final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00); final Date date1 = cal1.getTime(); final Date date2 = cal2.getTime(); final long millis1 = date1.getTime(); final long millis2 = date2.getTime(); DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); assertEquals(sdf.format(date1), fdf.format(date1)); assertEquals("2003-01-10T15:33:20", fdf.format(date1)); assertEquals("2003-01-10T15:33:20", fdf.format(cal1)); assertEquals("2003-01-10T15:33:20", fdf.format(millis1)); assertEquals("2003-07-10T09:00:00", fdf.format(date2)); assertEquals("2003-07-10T09:00:00", fdf.format(cal2)); assertEquals("2003-07-10T09:00:00", fdf.format(millis2)); fdf = getInstance("Z"); assertEquals("-0500", fdf.format(date1)); assertEquals("-0500", fdf.format(cal1)); assertEquals("-0500", fdf.format(millis1)); assertEquals("-0400", fdf.format(date2)); assertEquals("-0400", fdf.format(cal2)); assertEquals("-0400", fdf.format(millis2)); fdf = getInstance("ZZ"); assertEquals("-05:00", fdf.format(date1)); assertEquals("-05:00", fdf.format(cal1)); assertEquals("-05:00", fdf.format(millis1)); assertEquals("-04:00", fdf.format(date2)); assertEquals("-04:00", fdf.format(cal2)); assertEquals("-04:00", fdf.format(millis2)); final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" + " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z"; fdf = getInstance(pattern); sdf = new SimpleDateFormat(pattern); // SDF bug fix starting with Java 7 assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1)); assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2)); } finally { Locale.setDefault(realDefaultLocale); TimeZone.setDefault(realDefaultZone); } } /** * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}. */ @Test public void testShortDateStyleWithLocales() { final Locale usLocale = Locale.US; final Locale swedishLocale = new Locale("sv", "SE"); final Calendar cal = Calendar.getInstance(); cal.set(2004, 1, 3); DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale); assertEquals("2/3/04", fdf.format(cal)); fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale); assertEquals("2004-02-03", fdf.format(cal)); } /** * Tests that pre-1000AD years get padded with yyyy */ @Test public void testLowYearPadding() { final Calendar cal = Calendar.getInstance(); final DatePrinter format = getInstance(YYYY_MM_DD); cal.set(1,0,1); assertEquals("0001/01/01", format.format(cal)); cal.set(10,0,1); assertEquals("0010/01/01", format.format(cal)); cal.set(100,0,1); assertEquals("0100/01/01", format.format(cal)); cal.set(999,0,1); assertEquals("0999/01/01", format.format(cal)); } /** * Show Bug #39410 is solved */ @Test public void testMilleniumBug() { final Calendar cal = Calendar.getInstance(); final DatePrinter format = getInstance("dd.MM.yyyy"); cal.set(1000,0,1); assertEquals("01.01.1000", format.format(cal)); } /** * testLowYearPadding showed that the date was buggy * This test confirms it, getting 366 back as a date */ @Test public void testSimpleDate() { final Calendar cal = Calendar.getInstance(); final DatePrinter format = getInstance(YYYY_MM_DD); cal.set(2004,11,31); assertEquals("2004/12/31", format.format(cal)); cal.set(999,11,31); assertEquals("0999/12/31", format.format(cal)); cal.set(1,2,2); assertEquals("0001/03/02", format.format(cal)); } @Test public void testLang303() { final Calendar cal = Calendar.getInstance(); cal.set(2004, 11, 31); DatePrinter format = getInstance(YYYY_MM_DD); final String output = format.format(cal); format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format)); assertEquals(output, format.format(cal)); } @Test public void testLang538() { // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16) // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); cal.clear(); cal.set(2009, 9, 16, 8, 42, 16); final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime())); assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal)); } @Test public void testLang645() { final Locale locale = new Locale("sv", "SE"); final Calendar cal = Calendar.getInstance(); cal.set(2010, 0, 1, 12, 0, 0); final Date d = cal.getTime(); final DatePrinter fdf = getInstance("EEEE', week 'ww", locale); assertEquals("fredag, week 53", fdf.format(d)); } @Test public void testEquals() { final DatePrinter printer1= getInstance(YYYY_MM_DD); final DatePrinter printer2= getInstance(YYYY_MM_DD); assertEquals(printer1, printer2); assertEquals(printer1.hashCode(), printer2.hashCode()); assertFalse(printer1.equals(new Object())); } @Test public void testToStringContainsName() { final DatePrinter printer= getInstance(YYYY_MM_DD); assertTrue(printer.toString().startsWith("FastDate")); } @Test public void testPatternMatches() { final DatePrinter printer= getInstance(YYYY_MM_DD); assertEquals(YYYY_MM_DD, printer.getPattern()); } @Test public void testLocaleMatches() { final DatePrinter printer= getInstance(YYYY_MM_DD, SWEDEN); assertEquals(SWEDEN, printer.getLocale()); } @Test public void testTimeZoneMatches() { final DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK); assertEquals(NEW_YORK, printer.getTimeZone()); } @Test public void testCalendarTimezoneRespected() {} // Defects4J: flaky method // @Test // public void testCalendarTimezoneRespected() { // final String[] availableZones = TimeZone.getAvailableIDs(); // final TimeZone currentZone = TimeZone.getDefault(); // // TimeZone anotherZone = null; // for (final String zone : availableZones) { // if (!zone.equals(currentZone.getID())) { // anotherZone = TimeZone.getTimeZone(zone); // } // } // // assertNotNull("Cannot find another timezone", anotherZone); // // final String pattern = "h:mma z"; // final Calendar cal = Calendar.getInstance(anotherZone); // // final SimpleDateFormat sdf = new SimpleDateFormat(pattern); // sdf.setTimeZone(anotherZone); // final String expectedValue = sdf.format(cal.getTime()); // final String actualValue = FastDateFormat.getInstance(pattern).format(cal); // assertEquals(expectedValue, actualValue); // } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.time; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import org.junit.Assert; import org.junit.Test; /** * TestCase for StopWatch. * * @version $Id$ */ public class StopWatchTest { //----------------------------------------------------------------------- @Test public void testStopWatchSimple(){ final StopWatch watch = new StopWatch(); watch.start(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.stop(); final long time = watch.getTime(); assertEquals(time, watch.getTime()); assertTrue(time >= 500); assertTrue(time < 700); watch.reset(); assertEquals(0, watch.getTime()); } @Test public void testStopWatchSimpleGet(){ final StopWatch watch = new StopWatch(); assertEquals(0, watch.getTime()); assertEquals("0:00:00.000", watch.toString()); watch.start(); try {Thread.sleep(500);} catch (final InterruptedException ex) {} assertTrue(watch.getTime() < 2000); } @Test public void testStopWatchSplit(){ final StopWatch watch = new StopWatch(); watch.start(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.split(); final long splitTime = watch.getSplitTime(); final String splitStr = watch.toSplitString(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.unsplit(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.stop(); final long totalTime = watch.getTime(); assertEquals("Formatted split string not the correct length", splitStr.length(), 11); assertTrue(splitTime >= 500); assertTrue(splitTime < 700); assertTrue(totalTime >= 1500); assertTrue(totalTime < 1900); } @Test public void testStopWatchSuspend(){ final StopWatch watch = new StopWatch(); watch.start(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.suspend(); final long suspendTime = watch.getTime(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.resume(); try {Thread.sleep(550);} catch (final InterruptedException ex) {} watch.stop(); final long totalTime = watch.getTime(); assertTrue(suspendTime >= 500); assertTrue(suspendTime < 700); assertTrue(totalTime >= 1000); assertTrue(totalTime < 1300); } @Test public void testLang315() { final StopWatch watch = new StopWatch(); watch.start(); try {Thread.sleep(200);} catch (final InterruptedException ex) {} watch.suspend(); final long suspendTime = watch.getTime(); try {Thread.sleep(200);} catch (final InterruptedException ex) {} watch.stop(); final long totalTime = watch.getTime(); assertTrue( suspendTime == totalTime ); } // test bad states @Test public void testBadStates() { final StopWatch watch = new StopWatch(); try { watch.stop(); fail("Calling stop on an unstarted StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.stop(); fail("Calling stop on an unstarted StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.suspend(); fail("Calling suspend on an unstarted StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.split(); fail("Calling split on a non-running StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.unsplit(); fail("Calling unsplit on an unsplit StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.resume(); fail("Calling resume on an unsuspended StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } watch.start(); try { watch.start(); fail("Calling start on a started StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.unsplit(); fail("Calling unsplit on an unsplit StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.getSplitTime(); fail("Calling getSplitTime on an unsplit StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } try { watch.resume(); fail("Calling resume on an unsuspended StopWatch should throw an exception. "); } catch(final IllegalStateException ise) { // expected } watch.stop(); try { watch.start(); fail("Calling start on a stopped StopWatch should throw an exception as it needs to be reset. "); } catch(final IllegalStateException ise) { // expected } } @Test public void testGetStartTime() { final long beforeStopWatch = System.currentTimeMillis(); final StopWatch watch = new StopWatch(); try { watch.getStartTime(); fail("Calling getStartTime on an unstarted StopWatch should throw an exception"); } catch (final IllegalStateException expected) { // expected } watch.start(); try { watch.getStartTime(); Assert.assertTrue(watch.getStartTime() >= beforeStopWatch); } catch (final IllegalStateException ex) { fail("Start time should be available: " + ex.getMessage()); } watch.reset(); try { watch.getStartTime(); fail("Calling getStartTime on a reset, but unstarted StopWatch should throw an exception"); } catch (final IllegalStateException expected) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.tuple; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import org.junit.Test; /** * Test the Pair class. * @version $Id$ */ public class ImmutablePairTest { @Test public void testBasic() throws Exception { final ImmutablePair<Integer, String> pair = new ImmutablePair<Integer, String>(0, "foo"); assertEquals(0, pair.left.intValue()); assertEquals(0, pair.getLeft().intValue()); assertEquals("foo", pair.right); assertEquals("foo", pair.getRight()); final ImmutablePair<Object, String> pair2 = new ImmutablePair<Object, String>(null, "bar"); assertNull(pair2.left); assertNull(pair2.getLeft()); assertEquals("bar", pair2.right); assertEquals("bar", pair2.getRight()); } @Test public void testPairOf() throws Exception { final ImmutablePair<Integer, String> pair = ImmutablePair.of(0, "foo"); assertEquals(0, pair.left.intValue()); assertEquals(0, pair.getLeft().intValue()); assertEquals("foo", pair.right); assertEquals("foo", pair.getRight()); final ImmutablePair<Object, String> pair2 = ImmutablePair.of(null, "bar"); assertNull(pair2.left); assertNull(pair2.getLeft()); assertEquals("bar", pair2.right); assertEquals("bar", pair2.getRight()); } @Test public void testEquals() throws Exception { assertEquals(ImmutablePair.of(null, "foo"), ImmutablePair.of(null, "foo")); assertFalse(ImmutablePair.of("foo", 0).equals(ImmutablePair.of("foo", null))); assertFalse(ImmutablePair.of("foo", "bar").equals(ImmutablePair.of("xyz", "bar"))); final ImmutablePair<String, String> p = ImmutablePair.of("foo", "bar"); assertTrue(p.equals(p)); assertFalse(p.equals(new Object())); } @Test public void testHashCode() throws Exception { assertEquals(ImmutablePair.of(null, "foo").hashCode(), ImmutablePair.of(null, "foo").hashCode()); } @Test public void testToString() throws Exception { assertEquals("(null,null)", ImmutablePair.of(null, null).toString()); assertEquals("(null,two)", ImmutablePair.of(null, "two").toString()); assertEquals("(one,null)", ImmutablePair.of("one", null).toString()); assertEquals("(one,two)", ImmutablePair.of("one", "two").toString()); } @Test @SuppressWarnings("unchecked") public void testSerialization() throws Exception { final ImmutablePair<Integer, String> origPair = ImmutablePair.of(0, "foo"); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(origPair); final ImmutablePair<Integer, String> deserializedPair = (ImmutablePair<Integer, String>) new ObjectInputStream( new ByteArrayInputStream(baos.toByteArray())).readObject(); assertEquals(origPair, deserializedPair); assertEquals(origPair.hashCode(), deserializedPair.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.tuple; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import org.junit.Test; /** * Test the Triple class. * @version $Id$ */ public class ImmutableTripleTest { @Test public void testBasic() throws Exception { final ImmutableTriple<Integer, String, Boolean> triple = new ImmutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); assertEquals(0, triple.left.intValue()); assertEquals(0, triple.getLeft().intValue()); assertEquals("foo", triple.middle); assertEquals("foo", triple.getMiddle()); assertEquals(Boolean.TRUE, triple.right); assertEquals(Boolean.TRUE, triple.getRight()); final ImmutableTriple<Object, String, Integer> triple2 = new ImmutableTriple<Object, String, Integer>(null, "bar", 42); assertNull(triple2.left); assertNull(triple2.getLeft()); assertEquals("bar", triple2.middle); assertEquals("bar", triple2.getMiddle()); assertEquals(new Integer(42), triple2.right); assertEquals(new Integer(42), triple2.getRight()); } @Test public void testTripleOf() throws Exception { final ImmutableTriple<Integer, String, Boolean> triple = ImmutableTriple.of(0, "foo", Boolean.FALSE); assertEquals(0, triple.left.intValue()); assertEquals(0, triple.getLeft().intValue()); assertEquals("foo", triple.middle); assertEquals("foo", triple.getMiddle()); assertEquals(Boolean.FALSE, triple.right); assertEquals(Boolean.FALSE, triple.getRight()); final ImmutableTriple<Object, String, Boolean> triple2 = ImmutableTriple.of(null, "bar", Boolean.TRUE); assertNull(triple2.left); assertNull(triple2.getLeft()); assertEquals("bar", triple2.middle); assertEquals("bar", triple2.getMiddle()); assertEquals(Boolean.TRUE, triple2.right); assertEquals(Boolean.TRUE, triple2.getRight()); } @Test public void testEquals() throws Exception { assertEquals(ImmutableTriple.of(null, "foo", 42), ImmutableTriple.of(null, "foo", 42)); assertFalse(ImmutableTriple.of("foo", 0, Boolean.TRUE).equals(ImmutableTriple.of("foo", null, null))); assertFalse(ImmutableTriple.of("foo", "bar", "baz").equals(ImmutableTriple.of("xyz", "bar", "blo"))); final ImmutableTriple<String, String, String> p = ImmutableTriple.of("foo", "bar", "baz"); assertTrue(p.equals(p)); assertFalse(p.equals(new Object())); } @Test public void testHashCode() throws Exception { assertEquals(ImmutableTriple.of(null, "foo", Boolean.TRUE).hashCode(), ImmutableTriple.of(null, "foo", Boolean.TRUE).hashCode()); } @Test public void testToString() throws Exception { assertEquals("(null,null,null)", ImmutableTriple.of(null, null, null).toString()); assertEquals("(null,two,null)", ImmutableTriple.of(null, "two", null).toString()); assertEquals("(one,null,null)", ImmutableTriple.of("one", null, null).toString()); assertEquals("(one,two,null)", ImmutableTriple.of("one", "two", null).toString()); assertEquals("(null,two,three)", ImmutableTriple.of(null, "two", "three").toString()); assertEquals("(one,null,three)", ImmutableTriple.of("one", null, "three").toString()); assertEquals("(one,two,three)", MutableTriple.of("one", "two", "three").toString()); } @Test @SuppressWarnings("unchecked") public void testSerialization() throws Exception { final ImmutableTriple<Integer, String, Boolean> origTriple = ImmutableTriple.of(0, "foo", Boolean.TRUE); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(origTriple); final ImmutableTriple<Integer, String, Boolean> deserializedTriple = (ImmutableTriple<Integer, String, Boolean>) new ObjectInputStream( new ByteArrayInputStream(baos.toByteArray())).readObject(); assertEquals(origTriple, deserializedTriple); assertEquals(origTriple.hashCode(), deserializedTriple.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.tuple; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import org.junit.Test; /** * Test the MutablePair class. * @version $Id$ */ public class MutablePairTest { @Test public void testBasic() throws Exception { final MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, "foo"); assertEquals(0, pair.getLeft().intValue()); assertEquals("foo", pair.getRight()); final MutablePair<Object, String> pair2 = new MutablePair<Object, String>(null, "bar"); assertNull(pair2.getLeft()); assertEquals("bar", pair2.getRight()); } @Test public void testDefault() throws Exception { final MutablePair<Integer, String> pair = new MutablePair<Integer, String>(); assertNull(pair.getLeft()); assertNull(pair.getRight()); } @Test public void testMutate() throws Exception { final MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, "foo"); pair.setLeft(42); pair.setRight("bar"); assertEquals(42, pair.getLeft().intValue()); assertEquals("bar", pair.getRight()); } @Test public void testPairOf() throws Exception { final MutablePair<Integer, String> pair = MutablePair.of(0, "foo"); assertEquals(0, pair.getLeft().intValue()); assertEquals("foo", pair.getRight()); final MutablePair<Object, String> pair2 = MutablePair.of(null, "bar"); assertNull(pair2.getLeft()); assertEquals("bar", pair2.getRight()); } @Test public void testEquals() throws Exception { assertEquals(MutablePair.of(null, "foo"), MutablePair.of(null, "foo")); assertFalse(MutablePair.of("foo", 0).equals(MutablePair.of("foo", null))); assertFalse(MutablePair.of("foo", "bar").equals(MutablePair.of("xyz", "bar"))); final MutablePair<String, String> p = MutablePair.of("foo", "bar"); assertTrue(p.equals(p)); assertFalse(p.equals(new Object())); } @Test public void testHashCode() throws Exception { assertEquals(MutablePair.of(null, "foo").hashCode(), MutablePair.of(null, "foo").hashCode()); } @Test public void testToString() throws Exception { assertEquals("(null,null)", MutablePair.of(null, null).toString()); assertEquals("(null,two)", MutablePair.of(null, "two").toString()); assertEquals("(one,null)", MutablePair.of("one", null).toString()); assertEquals("(one,two)", MutablePair.of("one", "two").toString()); } @Test @SuppressWarnings("unchecked") public void testSerialization() throws Exception { final MutablePair<Integer, String> origPair = MutablePair.of(0, "foo"); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(origPair); final MutablePair<Integer, String> deserializedPair = (MutablePair<Integer, String>) new ObjectInputStream( new ByteArrayInputStream(baos.toByteArray())).readObject(); assertEquals(origPair, deserializedPair); assertEquals(origPair.hashCode(), deserializedPair.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.tuple; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import org.junit.Test; /** * Test the MutableTriple class. * @version $Id$ */ public class MutableTripleTest { @Test public void testBasic() throws Exception { final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.FALSE); assertEquals(0, triple.getLeft().intValue()); assertEquals("foo", triple.getMiddle()); assertEquals(Boolean.FALSE, triple.getRight()); final MutableTriple<Object, String, String> triple2 = new MutableTriple<Object, String, String>(null, "bar", "hello"); assertNull(triple2.getLeft()); assertEquals("bar", triple2.getMiddle()); assertEquals("hello", triple2.getRight()); } @Test public void testDefault() throws Exception { final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(); assertNull(triple.getLeft()); assertNull(triple.getMiddle()); assertNull(triple.getRight()); } @Test public void testMutate() throws Exception { final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, "foo", Boolean.TRUE); triple.setLeft(42); triple.setMiddle("bar"); triple.setRight(Boolean.FALSE); assertEquals(42, triple.getLeft().intValue()); assertEquals("bar", triple.getMiddle()); assertEquals(Boolean.FALSE, triple.getRight()); } @Test public void testTripleOf() throws Exception { final MutableTriple<Integer, String, Boolean> triple = MutableTriple.of(0, "foo", Boolean.TRUE); assertEquals(0, triple.getLeft().intValue()); assertEquals("foo", triple.getMiddle()); assertEquals(Boolean.TRUE, triple.getRight()); final MutableTriple<Object, String, String> triple2 = MutableTriple.of(null, "bar", "hello"); assertNull(triple2.getLeft()); assertEquals("bar", triple2.getMiddle()); assertEquals("hello", triple2.getRight()); } @Test public void testEquals() throws Exception { assertEquals(MutableTriple.of(null, "foo", "baz"), MutableTriple.of(null, "foo", "baz")); assertFalse(MutableTriple.of("foo", 0, Boolean.TRUE).equals(MutableTriple.of("foo", null, Boolean.TRUE))); assertFalse(MutableTriple.of("foo", "bar", "baz").equals(MutableTriple.of("xyz", "bar", "baz"))); assertFalse(MutableTriple.of("foo", "bar", "baz").equals(MutableTriple.of("foo", "bar", "blo"))); final MutableTriple<String, String, String> p = MutableTriple.of("foo", "bar", "baz"); assertTrue(p.equals(p)); assertFalse(p.equals(new Object())); } @Test public void testHashCode() throws Exception { assertEquals(MutableTriple.of(null, "foo", "baz").hashCode(), MutableTriple.of(null, "foo", "baz").hashCode()); } @Test public void testToString() throws Exception { assertEquals("(null,null,null)", MutableTriple.of(null, null, null).toString()); assertEquals("(null,two,null)", MutableTriple.of(null, "two", null).toString()); assertEquals("(one,null,null)", MutableTriple.of("one", null, null).toString()); assertEquals("(one,two,null)", MutableTriple.of("one", "two", null).toString()); assertEquals("(null,two,three)", MutableTriple.of(null, "two", "three").toString()); assertEquals("(one,null,three)", MutableTriple.of("one", null, "three").toString()); assertEquals("(one,two,three)", MutableTriple.of("one", "two", "three").toString()); } @Test @SuppressWarnings("unchecked") public void testSerialization() throws Exception { final MutableTriple<Integer, String, Boolean> origTriple = MutableTriple.of(0, "foo", Boolean.TRUE); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(origTriple); final MutableTriple<Integer, String, Boolean> deserializedTriple = (MutableTriple<Integer, String, Boolean>) new ObjectInputStream( new ByteArrayInputStream(baos.toByteArray())).readObject(); assertEquals(origTriple, deserializedTriple); assertEquals(origTriple.hashCode(), deserializedTriple.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.tuple; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Calendar; import java.util.HashMap; import java.util.HashSet; import java.util.Map.Entry; import org.junit.Test; /** * Test the Pair class. * * @version $Id$ */ public class PairTest { @Test public void testPairOf() throws Exception { final Pair<Integer, String> pair = Pair.of(0, "foo"); assertTrue(pair instanceof ImmutablePair<?, ?>); assertEquals(0, ((ImmutablePair<Integer, String>) pair).left.intValue()); assertEquals("foo", ((ImmutablePair<Integer, String>) pair).right); final Pair<Object, String> pair2 = Pair.of(null, "bar"); assertTrue(pair2 instanceof ImmutablePair<?, ?>); assertNull(((ImmutablePair<Object, String>) pair2).left); assertEquals("bar", ((ImmutablePair<Object, String>) pair2).right); } @Test public void testCompatibilityBetweenPairs() throws Exception { final Pair<Integer, String> pair = ImmutablePair.of(0, "foo"); final Pair<Integer, String> pair2 = MutablePair.of(0, "foo"); assertEquals(pair, pair2); assertEquals(pair.hashCode(), pair2.hashCode()); final HashSet<Pair<Integer, String>> set = new HashSet<Pair<Integer, String>>(); set.add(pair); assertTrue(set.contains(pair2)); pair2.setValue("bar"); assertFalse(pair.equals(pair2)); assertFalse(pair.hashCode() == pair2.hashCode()); } @Test public void testMapEntry() throws Exception { final Pair<Integer, String> pair = ImmutablePair.of(0, "foo"); final HashMap<Integer, String> map = new HashMap<Integer, String>(); map.put(0, "foo"); final Entry<Integer, String> entry = map.entrySet().iterator().next(); assertEquals(pair, entry); assertEquals(pair.hashCode(), entry.hashCode()); } @Test public void testComparable1() throws Exception { final Pair<String, String> pair1 = Pair.of("A", "D"); final Pair<String, String> pair2 = Pair.of("B", "C"); assertTrue(pair1.compareTo(pair1) == 0); assertTrue(pair1.compareTo(pair2) < 0); assertTrue(pair2.compareTo(pair2) == 0); assertTrue(pair2.compareTo(pair1) > 0); } @Test public void testComparable2() throws Exception { final Pair<String, String> pair1 = Pair.of("A", "C"); final Pair<String, String> pair2 = Pair.of("A", "D"); assertTrue(pair1.compareTo(pair1) == 0); assertTrue(pair1.compareTo(pair2) < 0); assertTrue(pair2.compareTo(pair2) == 0); assertTrue(pair2.compareTo(pair1) > 0); } @Test public void testToString() throws Exception { final Pair<String, String> pair = Pair.of("Key", "Value"); assertEquals("(Key,Value)", pair.toString()); } @Test public void testToStringCustom() throws Exception { final Calendar date = Calendar.getInstance(); date.set(2011, Calendar.APRIL, 25); final Pair<String, Calendar> pair = Pair.of("DOB", date); assertEquals("Test created on " + "04-25-2011", pair.toString("Test created on %2$tm-%2$td-%2$tY")); } @Test public void testFormattable_simple() throws Exception { final Pair<String, String> pair = Pair.of("Key", "Value"); assertEquals("(Key,Value)", String.format("%1$s", pair)); } @Test public void testFormattable_padded() throws Exception { final Pair<String, String> pair = Pair.of("Key", "Value"); assertEquals(" (Key,Value)", String.format("%1$20s", pair)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.lang3.tuple; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import java.util.Calendar; import java.util.HashSet; import org.junit.Test; /** * Test the Triple class. * * @version $Id$ */ public class TripleTest { @Test public void testTripleOf() throws Exception { final Triple<Integer, String, Boolean> triple = Triple.of(0, "foo", Boolean.TRUE); assertTrue(triple instanceof ImmutableTriple<?, ?, ?>); assertEquals(0, ((ImmutableTriple<Integer, String, Boolean>) triple).left.intValue()); assertEquals("foo", ((ImmutableTriple<Integer, String, Boolean>) triple).middle); assertEquals(Boolean.TRUE, ((ImmutableTriple<Integer, String, Boolean>) triple).right); final Triple<Object, String, Long> triple2 = Triple.of(null, "bar", Long.valueOf(200L)); assertTrue(triple2 instanceof ImmutableTriple<?, ?, ?>); assertNull(((ImmutableTriple<Object, String, Long>) triple2).left); assertEquals("bar", ((ImmutableTriple<Object, String, Long>) triple2).middle); assertEquals(new Long(200L), ((ImmutableTriple<Object, String, Long>) triple2).right); } @Test public void testCompatibilityBetweenTriples() throws Exception { final Triple<Integer, String, Boolean> triple = ImmutableTriple.of(0, "foo", Boolean.TRUE); final Triple<Integer, String, Boolean> triple2 = MutableTriple.of(0, "foo", Boolean.TRUE); assertEquals(triple, triple2); assertEquals(triple.hashCode(), triple2.hashCode()); final HashSet<Triple<Integer, String, Boolean>> set = new HashSet<Triple<Integer, String, Boolean>>(); set.add(triple); assertTrue(set.contains(triple2)); } @Test public void testComparable1() throws Exception { final Triple<String, String, String> triple1 = Triple.of("A", "D", "A"); final Triple<String, String, String> triple2 = Triple.of("B", "C", "A"); assertTrue(triple1.compareTo(triple1) == 0); assertTrue(triple1.compareTo(triple2) < 0); assertTrue(triple2.compareTo(triple2) == 0); assertTrue(triple2.compareTo(triple1) > 0); } @Test public void testComparable2() throws Exception { final Triple<String, String, String> triple1 = Triple.of("A", "C", "B"); final Triple<String, String, String> triple2 = Triple.of("A", "D", "B"); assertTrue(triple1.compareTo(triple1) == 0); assertTrue(triple1.compareTo(triple2) < 0); assertTrue(triple2.compareTo(triple2) == 0); assertTrue(triple2.compareTo(triple1) > 0); } @Test public void testComparable3() throws Exception { final Triple<String, String, String> triple1 = Triple.of("A", "A", "D"); final Triple<String, String, String> triple2 = Triple.of("A", "B", "C"); assertTrue(triple1.compareTo(triple1) == 0); assertTrue(triple1.compareTo(triple2) < 0); assertTrue(triple2.compareTo(triple2) == 0); assertTrue(triple2.compareTo(triple1) > 0); } @Test public void testComparable4() throws Exception { final Triple<String, String, String> triple1 = Triple.of("B", "A", "C"); final Triple<String, String, String> triple2 = Triple.of("B", "A", "D"); assertTrue(triple1.compareTo(triple1) == 0); assertTrue(triple1.compareTo(triple2) < 0); assertTrue(triple2.compareTo(triple2) == 0); assertTrue(triple2.compareTo(triple1) > 0); } @Test public void testToString() throws Exception { final Triple<String, String, String> triple = Triple.of("Key", "Something", "Value"); assertEquals("(Key,Something,Value)", triple.toString()); } @Test public void testToStringCustom() throws Exception { final Calendar date = Calendar.getInstance(); date.set(2011, Calendar.APRIL, 25); final Triple<String, String, Calendar> triple = Triple.of("DOB", "string", date); assertEquals("Test created on " + "04-25-2011", triple.toString("Test created on %3$tm-%3$td-%3$tY")); } @Test public void testFormattable_simple() throws Exception { final Triple<String, String, String> triple = Triple.of("Key", "Something", "Value"); assertEquals("(Key,Something,Value)", String.format("%1$s", triple)); } @Test public void testFormattable_padded() throws Exception { final Triple<String, String, String> triple = Triple.of("Key", "Something", "Value"); assertEquals(" (Key,Something,Value)", String.format("%1$30s", triple)); } }
