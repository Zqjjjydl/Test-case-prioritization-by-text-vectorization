b'protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {         final Observer<? super V> observer = downstream;         final SimplePlainQueue<U> q = queue;          if (wip.get() == 0 && wip.compareAndSet(0, 1)) {             if (q.isEmpty()) {                 accept(observer, value);                 if (leave(-1) == 0) {                     return;                 }             } else {                 q.offer(value);             }         } else {             q.offer(value);             if (!enter()) {                 return;             }         }         QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> amb(Iterable<? extends ObservableSource<? extends T>> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new ObservableAmb<T>(null, sources));     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> ambArray(ObservableSource<? extends T>... sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         int len = sources.length;         if (len == 0) {             return empty();         }         if (len == 1) {             return (Observable<T>)wrap(sources[0]);         }         return RxJavaPlugins.onAssembly(new ObservableAmb<T>(sources, null));     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concat(Iterable<? extends ObservableSource<? extends T>> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), bufferSize(), false);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch) {         ObjectHelper.requireNonNull(sources, "sources is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, Functions.identity(), prefetch, ErrorMode.IMMEDIATE));     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatArray(ObservableSource<? extends T>... sources) {         if (sources.length == 0) {             return empty();         } else         if (sources.length == 1) {             return wrap((ObservableSource<T>)sources[0]);         }         return RxJavaPlugins.onAssembly(new ObservableConcatMap(fromArray(sources), Functions.identity(), bufferSize(), ErrorMode.BOUNDARY));     }'
b'@SuppressWarnings({ "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatArrayDelayError(ObservableSource<? extends T>... sources) {         if (sources.length == 0) {             return empty();         } else         if (sources.length == 1) {             return (Observable<T>)wrap(sources[0]);         }         return concatDelayError(fromArray(sources));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatArrayEager(ObservableSource<? extends T>... sources) {         return concatArrayEager(bufferSize(), bufferSize(), sources);     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatArrayEager(int maxConcurrency, int prefetch, ObservableSource<? extends T>... sources) {         return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, false);     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatArrayEagerDelayError(int maxConcurrency, int prefetch, ObservableSource<? extends T>... sources) {         return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources) {         return concatDelayError(sources, bufferSize(), true);     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch, boolean tillTheEnd) {         ObjectHelper.requireNonNull(sources, "sources is null");         ObjectHelper.verifyPositive(prefetch, "prefetch is null");         return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, Functions.identity(), prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatEager(ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int prefetch) {         return wrap(sources).concatMapEager((Function)Functions.identity(), maxConcurrency, prefetch);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> concatEager(Iterable<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int prefetch) {         return fromIterable(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Observable<T> empty() {         return RxJavaPlugins.onAssembly((Observable<T>) ObservableEmpty.INSTANCE);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> error(Callable<? extends Throwable> errorSupplier) {         ObjectHelper.requireNonNull(errorSupplier, "errorSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableError<T>(errorSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @NonNull     public static <T> Observable<T> fromArray(T... items) {         ObjectHelper.requireNonNull(items, "items is null");         if (items.length == 0) {             return empty();         } else         if (items.length == 1) {             return just(items[0]);         }         return RxJavaPlugins.onAssembly(new ObservableFromArray<T>(items));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> fromIterable(Iterable<? extends T> source) {         ObjectHelper.requireNonNull(source, "source is null");         return RxJavaPlugins.onAssembly(new ObservableFromIterable<T>(source));     }'
b'@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> fromPublisher(Publisher<? extends T> publisher) {         ObjectHelper.requireNonNull(publisher, "publisher is null");         return RxJavaPlugins.onAssembly(new ObservableFromPublisher<T>(publisher));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> generate(final Consumer<Emitter<T>> generator) {         ObjectHelper.requireNonNull(generator, "generator is null");         return generate(Functions.<Object>nullSupplier(),         ObservableInternalHelper.simpleGenerator(generator), Functions.<Object>emptyConsumer());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, S> Observable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {         return generate(initialState, generator, Functions.emptyConsumer());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");          return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Observable<Long> interval(long period, TimeUnit unit) {         return interval(period, period, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {         return interval(period, period, unit, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {         return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }          if (count == 0L) {             return Observable.<Long>empty().delay(initialDelay, unit, scheduler);         }          long end = start + (count - 1);         if (start > 0 && end < 0) {             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");         }         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");          return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> just(T item) {         ObjectHelper.requireNonNull(item, "item is null");         return RxJavaPlugins.onAssembly(new ObservableJust<T>(item));     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> merge(Iterable<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize) {         return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> mergeArray(int maxConcurrency, int bufferSize, ObservableSource<? extends T>... sources) {         return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings({ "unchecked", "rawtypes" })     public static <T> Observable<T> merge(ObservableSource<? extends ObservableSource<? extends T>> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new ObservableFlatMap(sources, Functions.identity(), false, Integer.MAX_VALUE, bufferSize()));     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> mergeArray(ObservableSource<? extends T>... sources) {         return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3) {         ObjectHelper.requireNonNull(source1, "source1 is null");         ObjectHelper.requireNonNull(source2, "source2 is null");         ObjectHelper.requireNonNull(source3, "source3 is null");         return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Observable<T> never() {         return RxJavaPlugins.onAssembly((Observable<T>) ObservableNever.INSTANCE);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static Observable<Integer> range(final int start, final int count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }         if (count == 0) {             return empty();         }         if (count == 1) {             return just(start);         }         if ((long)start + (count - 1) > Integer.MAX_VALUE) {             throw new IllegalArgumentException("Integer overflow");         }         return RxJavaPlugins.onAssembly(new ObservableRange(start, count));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static Observable<Long> rangeLong(long start, long count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }          if (count == 0) {             return empty();         }          if (count == 1) {             return just(start);         }          long end = start + (count - 1);         if (start > 0 && end < 0) {             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");         }          return RxJavaPlugins.onAssembly(new ObservableRangeLong(start, count));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,             BiPredicate<? super T, ? super T> isEqual) {         return sequenceEqual(source1, source2, isEqual, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,             BiPredicate<? super T, ? super T> isEqual, int bufferSize) {         ObjectHelper.requireNonNull(source1, "source1 is null");         ObjectHelper.requireNonNull(source2, "source2 is null");         ObjectHelper.requireNonNull(isEqual, "isEqual is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableSequenceEqualSingle<T>(source1, source2, isEqual, bufferSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,             int bufferSize) {         return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> switchOnNext(ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize) {         ObjectHelper.requireNonNull(sources, "sources is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableSwitchMap(sources, Functions.identity(), bufferSize, false));     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> switchOnNextDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch) {         ObjectHelper.requireNonNull(sources, "sources is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableSwitchMap(sources, Functions.identity(), prefetch, true));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> unsafeCreate(ObservableSource<T> onSubscribe) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         if (onSubscribe instanceof Observable) {             throw new IllegalArgumentException("unsafeCreate(Observable) should be upgraded");         }         return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(onSubscribe));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, D> Observable<T> using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, Consumer<? super D> disposer) {         return using(resourceSupplier, sourceSupplier, disposer, true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, D> Observable<T> using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager) {         ObjectHelper.requireNonNull(resourceSupplier, "resourceSupplier is null");         ObjectHelper.requireNonNull(sourceSupplier, "sourceSupplier is null");         ObjectHelper.requireNonNull(disposer, "disposer is null");         return RxJavaPlugins.onAssembly(new ObservableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Observable<T> wrap(ObservableSource<T> source) {         ObjectHelper.requireNonNull(source, "source is null");         if (source instanceof Observable) {             return RxJavaPlugins.onAssembly((Observable<T>)source);         }         return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Observable<R> zip(Iterable<? extends ObservableSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {         ObjectHelper.requireNonNull(zipper, "zipper is null");         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(null, sources, zipper, bufferSize(), false));     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Observable<R> zip(ObservableSource<? extends ObservableSource<? extends T>> sources, final Function<? super Object[], ? extends R> zipper) {         ObjectHelper.requireNonNull(zipper, "zipper is null");         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new ObservableToList(sources, 16)                 .flatMap(ObservableInternalHelper.zipIterable(zipper)));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Observable<R> zipArray(Function<? super Object[], ? extends R> zipper,             boolean delayError, int bufferSize, ObservableSource<? extends T>... sources) {         if (sources.length == 0) {             return empty();         }         ObjectHelper.requireNonNull(zipper, "zipper is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> all(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new ObservableAllSingle<T>(this, predicate));     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> ambWith(ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return ambArray(this, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> any(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new ObservableAnySingle<T>(this, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingFirst() {         BlockingFirstObserver<T> observer = new BlockingFirstObserver<T>();         subscribe(observer);         T v = observer.blockingGet();         if (v != null) {             return v;         }         throw new NoSuchElementException();     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final void blockingForEach(Consumer<? super T> onNext) {         Iterator<T> it = blockingIterable().iterator();         while (it.hasNext()) {             try {                 onNext.accept(it.next());             } catch (Throwable e) {                 Exceptions.throwIfFatal(e);                 ((Disposable)it).dispose();                 throw ExceptionHelper.wrapOrThrow(e);             }         }     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Iterable<T> blockingIterable(int bufferSize) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return new BlockingObservableIterable<T>(this, bufferSize);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingLast() {         BlockingLastObserver<T> observer = new BlockingLastObserver<T>();         subscribe(observer);         T v = observer.blockingGet();         if (v != null) {             return v;         }         throw new NoSuchElementException();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Iterable<T> blockingMostRecent(T initialValue) {         return new BlockingObservableMostRecent<T>(this, initialValue);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingSingle() {         T v = singleElement().blockingGet();         if (v == null) {             throw new NoSuchElementException();         }         return v;     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingSingle(T defaultItem) {         return single(defaultItem).blockingGet();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Future<T> toFuture() {         return subscribeWith(new FutureObserver<T>());     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Consumer<? super T> onNext) {         ObservableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {         ObservableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {         ObservableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Observer<? super T> observer) {         ObservableBlockingSubscribe.subscribe(this, observer);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<List<T>> buffer(int count) {         return buffer(count, count);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<List<T>> buffer(int count, int skip) {         return buffer(count, skip, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Observable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {         ObjectHelper.verifyPositive(count, "count");         ObjectHelper.verifyPositive(skip, "skip");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableBuffer<T, U>(this, count, skip, bufferSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Observable<U> buffer(int count, Callable<U> bufferSupplier) {         return buffer(count, count, bufferSupplier);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {         return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final <U extends Collection<? super T>> Observable<U> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable<U> bufferSupplier) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<List<T>> buffer(long timespan, TimeUnit unit, int count) {         return buffer(timespan, unit, Schedulers.computation(), count);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {         return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final <U extends Collection<? super T>> Observable<U> buffer(             long timespan, TimeUnit unit,             Scheduler scheduler, int count,             Callable<U> bufferSupplier,             boolean restartTimerOnMaxSize) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         ObjectHelper.verifyPositive(count, "count");         return RxJavaPlugins.onAssembly(new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <TOpening, TClosing> Observable<List<T>> buffer(             ObservableSource<? extends TOpening> openingIndicator,             Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> closingIndicator) {         return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <TOpening, TClosing, U extends Collection<? super T>> Observable<U> buffer(             ObservableSource<? extends TOpening> openingIndicator,             Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> closingIndicator,             Callable<U> bufferSupplier) {         ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");         ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Observable<List<T>> buffer(ObservableSource<B> boundary) {         return buffer(boundary, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Observable<List<T>> buffer(ObservableSource<B> boundary, final int initialCapacity) {         ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");         return buffer(boundary, Functions.<T>createArrayList(initialCapacity));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <B, U extends Collection<? super T>> Observable<U> buffer(ObservableSource<B> boundary, Callable<U> bufferSupplier) {         ObjectHelper.requireNonNull(boundary, "boundary is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Observable<List<T>> buffer(Callable<? extends ObservableSource<B>> boundarySupplier) {         return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> cacheWithInitialCapacity(int initialCapacity) {         ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");         return RxJavaPlugins.onAssembly(new ObservableCache<T>(this, initialCapacity));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Single<U> collect(Callable<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {         ObjectHelper.requireNonNull(initialValueSupplier, "initialValueSupplier is null");         ObjectHelper.requireNonNull(collector, "collector is null");         return RxJavaPlugins.onAssembly(new ObservableCollectSingle<T, U>(this, initialValueSupplier, collector));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Single<U> collectInto(final U initialValue, BiConsumer<? super U, ? super T> collector) {         ObjectHelper.requireNonNull(initialValue, "initialValue is null");         return collect(Functions.justCallable(initialValue), collector);     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> compose(ObservableTransformer<? super T, ? extends R> composer) {         return wrap(((ObservableTransformer<T, R>) ObjectHelper.requireNonNull(composer, "composer is null")).apply(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {         return concatMap(mapper, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         if (this instanceof ScalarCallable) {             @SuppressWarnings("unchecked")             T v = ((ScalarCallable<T>)this).call();             if (v == null) {                 return empty();             }             return ObservableScalarXMap.scalarXMap(v, mapper);         }         return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {         return concatMapDelayError(mapper, bufferSize(), true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapEager(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {         return concatMapEager(mapper, Integer.MAX_VALUE, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapEager(Function<? super T, ? extends ObservableSource<? extends R>> mapper,             int maxConcurrency, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapEager<T, R>(this, mapper, ErrorMode.IMMEDIATE, maxConcurrency, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapEagerDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper,             int maxConcurrency, int prefetch, boolean tillTheEnd) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapEager<T, R>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, maxConcurrency, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable concatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {         return concatMapCompletable(mapper, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable concatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, int capacityHint) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(capacityHint, "capacityHint");         return RxJavaPlugins.onAssembly(new ObservableConcatMapCompletable<T>(this, mapper, ErrorMode.IMMEDIATE, capacityHint));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper) {         return concatMapCompletableDelayError(mapper, true, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper, boolean tillTheEnd, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapCompletable<T>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<T, U>(this, mapper));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return concatMap(ObservableInternalHelper.flatMapIntoIterable(mapper), prefetch);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         return concatMapMaybe(mapper, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapMaybe<T, R>(this, mapper, ErrorMode.IMMEDIATE, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapMaybeDelayError(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         return concatMapMaybeDelayError(mapper, true, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapMaybeDelayError(Function<? super T, ? extends MaybeSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapMaybe<T, R>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper) {         return concatMapSingle(mapper, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapSingle<T, R>(this, mapper, ErrorMode.IMMEDIATE, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapSingleDelayError(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean tillTheEnd) {         return concatMapSingleDelayError(mapper, tillTheEnd, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> concatMapSingleDelayError(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ObservableConcatMapSingle<T, R>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> concatWith(ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return concat(this, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> concatWith(@NonNull SingleSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableConcatWithSingle<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> concatWith(@NonNull MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableConcatWithMaybe<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> concatWith(@NonNull CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableConcatWithCompletable<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> contains(final Object element) {         ObjectHelper.requireNonNull(element, "element is null");         return any(Functions.equalsWith(element));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<T> debounce(Function<? super T, ? extends ObservableSource<U>> debounceSelector) {         ObjectHelper.requireNonNull(debounceSelector, "debounceSelector is null");         return RxJavaPlugins.onAssembly(new ObservableDebounce<T, U>(this, debounceSelector));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> debounce(long timeout, TimeUnit unit) {         return debounce(timeout, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableDebounceTimed<T>(this, timeout, unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> defaultIfEmpty(T defaultItem) {         ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");         return switchIfEmpty(just(defaultItem));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<T> delay(final Function<? super T, ? extends ObservableSource<U>> itemDelay) {         ObjectHelper.requireNonNull(itemDelay, "itemDelay is null");         return flatMap(ObservableInternalHelper.itemDelay(itemDelay));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {         return delay(delay, unit, scheduler, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");          return RxJavaPlugins.onAssembly(new ObservableDelay<T>(this, delay, unit, scheduler, delayError));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Observable<T> delay(ObservableSource<U> subscriptionDelay,             Function<? super T, ? extends ObservableSource<V>> itemDelay) {         return delaySubscription(subscriptionDelay).delay(itemDelay);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<T> delaySubscription(ObservableSource<U> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableDelaySubscriptionOther<T, U>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {         return delaySubscription(timer(delay, unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @Deprecated     @SuppressWarnings({ "unchecked", "rawtypes" })     public final <T2> Observable<T2> dematerialize() {         return RxJavaPlugins.onAssembly(new ObservableDematerialize(this, Functions.identity()));     }'
b'@Experimental     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> dematerialize(Function<? super T, Notification<R>> selector) {         ObjectHelper.requireNonNull(selector, "selector is null");         return RxJavaPlugins.onAssembly(new ObservableDematerialize<T, R>(this, selector));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> distinct() {         return distinct(Functions.identity(), Functions.createHashSet());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Observable<T> distinct(Function<? super T, K> keySelector) {         return distinct(keySelector, Functions.createHashSet());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Observable<T> distinct(Function<? super T, K> keySelector, Callable<? extends Collection<? super K>> collectionSupplier) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableDistinct<T, K>(this, keySelector, collectionSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> distinctUntilChanged() {         return distinctUntilChanged(Functions.identity());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySelector) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {         ObjectHelper.requireNonNull(comparer, "comparer is null");         return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doAfterNext(Consumer<? super T> onAfterNext) {         ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");         return RxJavaPlugins.onAssembly(new ObservableDoAfterNext<T>(this, onAfterNext));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doAfterTerminate(Action onFinally) {         ObjectHelper.requireNonNull(onFinally, "onFinally is null");         return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.EMPTY_ACTION, onFinally);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doFinally(Action onFinally) {         ObjectHelper.requireNonNull(onFinally, "onFinally is null");         return RxJavaPlugins.onAssembly(new ObservableDoFinally<T>(this, onFinally));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnDispose(Action onDispose) {         return doOnLifecycle(Functions.emptyConsumer(), onDispose);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnComplete(Action onComplete) {         return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), onComplete, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");         return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {         ObjectHelper.requireNonNull(onNotification, "onNotification is null");         return doOnEach(                 Functions.notificationOnNext(onNotification),                 Functions.notificationOnError(onNotification),                 Functions.notificationOnComplete(onNotification),                 Functions.EMPTY_ACTION             );     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnEach(final Observer<? super T> observer) {         ObjectHelper.requireNonNull(observer, "observer is null");         return doOnEach(                 ObservableInternalHelper.observerOnNext(observer),                 ObservableInternalHelper.observerOnError(observer),                 ObservableInternalHelper.observerOnComplete(observer),                 Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnError(Consumer<? super Throwable> onError) {         return doOnEach(Functions.emptyConsumer(), onError, Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnLifecycle(final Consumer<? super Disposable> onSubscribe, final Action onDispose) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         ObjectHelper.requireNonNull(onDispose, "onDispose is null");         return RxJavaPlugins.onAssembly(new ObservableDoOnLifecycle<T>(this, onSubscribe, onDispose));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnNext(Consumer<? super T> onNext) {         return doOnEach(onNext, Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnSubscribe(Consumer<? super Disposable> onSubscribe) {         return doOnLifecycle(onSubscribe, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> doOnTerminate(final Action onTerminate) {         ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");         return doOnEach(Functions.emptyConsumer(),                 Functions.actionConsumer(onTerminate), onTerminate,                 Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> elementAt(long index) {         if (index < 0) {             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);         }         return RxJavaPlugins.onAssembly(new ObservableElementAtMaybe<T>(this, index));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> elementAt(long index, T defaultItem) {         if (index < 0) {             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);         }         ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");         return RxJavaPlugins.onAssembly(new ObservableElementAtSingle<T>(this, index, defaultItem));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> elementAtOrError(long index) {         if (index < 0) {             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);         }         return RxJavaPlugins.onAssembly(new ObservableElementAtSingle<T>(this, index, null));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> filter(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new ObservableFilter<T>(this, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> first(T defaultItem) {         return elementAt(0L, defaultItem);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors) {         return flatMap(mapper, delayErrors, Integer.MAX_VALUE);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper,             boolean delayErrors, int maxConcurrency, int bufferSize) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         if (this instanceof ScalarCallable) {             @SuppressWarnings("unchecked")             T v = ((ScalarCallable<T>)this).call();             if (v == null) {                 return empty();             }             return ObservableScalarXMap.scalarXMap(v, mapper);         }         return RxJavaPlugins.onAssembly(new ObservableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMap(             Function<? super T, ? extends ObservableSource<? extends R>> onNextMapper,             Function<? super Throwable, ? extends ObservableSource<? extends R>> onErrorMapper,             Callable<? extends ObservableSource<? extends R>> onCompleteSupplier) {         ObjectHelper.requireNonNull(onNextMapper, "onNextMapper is null");         ObjectHelper.requireNonNull(onErrorMapper, "onErrorMapper is null");         ObjectHelper.requireNonNull(onCompleteSupplier, "onCompleteSupplier is null");         return merge(new ObservableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends U>> mapper,             BiFunction<? super T, ? super U, ? extends R> resultSelector) {         return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {         return flatMapCompletable(mapper, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Observable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,             BiFunction<? super T, ? super U, ? extends V> resultSelector) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.requireNonNull(resultSelector, "resultSelector is null");         return flatMap(ObservableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         return flatMapMaybe(mapper, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper, boolean delayErrors) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableFlatMapMaybe<T, R>(this, mapper, delayErrors));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper) {         return flatMapSingle(mapper, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean delayErrors) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableFlatMapSingle<T, R>(this, mapper, delayErrors));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer<? super Throwable> onError,             final Action onComplete) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");          ForEachWhileObserver<T> o = new ForEachWhileObserver<T>(onNext, onError, onComplete);         subscribe(o);         return o;     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {         return groupBy(keySelector, (Function)Functions.identity(), false, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,             Function<? super T, ? extends V> valueSelector) {         return groupBy(keySelector, valueSelector, false, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,             Function<? super T, ? extends V> valueSelector,             boolean delayError, int bufferSize) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         ObjectHelper.requireNonNull(valueSelector, "valueSelector is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");          return RxJavaPlugins.onAssembly(new ObservableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> hide() {         return RxJavaPlugins.onAssembly(new ObservableHide<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable ignoreElements() {         return RxJavaPlugins.onAssembly(new ObservableIgnoreElementsCompletable<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> isEmpty() {         return all(Functions.alwaysFalse());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> join(             ObservableSource<? extends TRight> other,             Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd,             Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd,             BiFunction<? super T, ? super TRight, ? extends R> resultSelector                     ) {         ObjectHelper.requireNonNull(other, "other is null");         ObjectHelper.requireNonNull(leftEnd, "leftEnd is null");         ObjectHelper.requireNonNull(rightEnd, "rightEnd is null");         ObjectHelper.requireNonNull(resultSelector, "resultSelector is null");         return RxJavaPlugins.onAssembly(new ObservableJoin<T, TRight, TLeftEnd, TRightEnd, R>(                 this, other, leftEnd, rightEnd, resultSelector));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> lastElement() {         return RxJavaPlugins.onAssembly(new ObservableLastMaybe<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> last(T defaultItem) {         ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");         return RxJavaPlugins.onAssembly(new ObservableLastSingle<T>(this, defaultItem));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> lastOrError() {         return RxJavaPlugins.onAssembly(new ObservableLastSingle<T>(this, null));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableMap<T, R>(this, mapper));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<Notification<T>> materialize() {         return RxJavaPlugins.onAssembly(new ObservableMaterialize<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> mergeWith(ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return merge(this, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> mergeWith(@NonNull SingleSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableMergeWithSingle<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> mergeWith(@NonNull MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableMergeWithMaybe<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> mergeWith(@NonNull CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableMergeWithCompletable<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> observeOn(Scheduler scheduler) {         return observeOn(scheduler, false, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableObserveOn<T>(this, scheduler, delayError, bufferSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> onErrorResumeNext(Function<? super Throwable, ? extends ObservableSource<? extends T>> resumeFunction) {         ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");         return RxJavaPlugins.onAssembly(new ObservableOnErrorNext<T>(this, resumeFunction, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> onErrorResumeNext(final ObservableSource<? extends T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return onErrorResumeNext(Functions.justFunction(next));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {         ObjectHelper.requireNonNull(valueSupplier, "valueSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableOnErrorReturn<T>(this, valueSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> onExceptionResumeNext(final ObservableSource<? extends T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return RxJavaPlugins.onAssembly(new ObservableOnErrorNext<T>(this, Functions.justFunction(next), true));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> onTerminateDetach() {         return RxJavaPlugins.onAssembly(new ObservableDetach<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends ObservableSource<R>> selector) {         ObjectHelper.requireNonNull(selector, "selector is null");         return RxJavaPlugins.onAssembly(new ObservablePublishSelector<T, R>(this, selector));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {         ObjectHelper.requireNonNull(reducer, "reducer is null");         return RxJavaPlugins.onAssembly(new ObservableReduceMaybe<T>(this, reducer));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {         ObjectHelper.requireNonNull(seed, "seed is null");         ObjectHelper.requireNonNull(reducer, "reducer is null");         return RxJavaPlugins.onAssembly(new ObservableReduceSeedSingle<T, R>(this, seed, reducer));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {         ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");         ObjectHelper.requireNonNull(reducer, "reducer is null");         return RxJavaPlugins.onAssembly(new ObservableReduceWithSingle<T, R>(this, seedSupplier, reducer));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> repeat() {         return repeat(Long.MAX_VALUE);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> repeat(long times) {         if (times < 0) {             throw new IllegalArgumentException("times >= 0 required but it was " + times);         }         if (times == 0) {             return empty();         }         return RxJavaPlugins.onAssembly(new ObservableRepeat<T>(this, times));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> repeatUntil(BooleanSupplier stop) {         ObjectHelper.requireNonNull(stop, "stop is null");         return RxJavaPlugins.onAssembly(new ObservableRepeatUntil<T>(this, stop));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) {         ObjectHelper.requireNonNull(handler, "handler is null");         return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends ObservableSource<R>> selector) {         ObjectHelper.requireNonNull(selector, "selector is null");         return ObservableReplay.multicastSelector(ObservableInternalHelper.replayCallable(this), selector);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends ObservableSource<R>> selector, int bufferSize, long time, TimeUnit unit) {         return replay(selector, bufferSize, time, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final <R> Observable<R> replay(final Function<? super Observable<T>, ? extends ObservableSource<R>> selector, final Scheduler scheduler) {         ObjectHelper.requireNonNull(selector, "selector is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return ObservableReplay.multicastSelector(ObservableInternalHelper.replayCallable(this),                 ObservableInternalHelper.replayFunction(selector, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final ConnectableObservable<T> replay(final int bufferSize) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return ObservableReplay.create(this, bufferSize);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit) {         return replay(bufferSize, time, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final ConnectableObservable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return ObservableReplay.create(this, time, unit, scheduler, bufferSize);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final ConnectableObservable<T> replay(final int bufferSize, final Scheduler scheduler) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return ObservableReplay.observeOn(replay(bufferSize), scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final ConnectableObservable<T> replay(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return ObservableReplay.observeOn(replay(), scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> retry() {         return retry(Long.MAX_VALUE, Functions.alwaysTrue());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");          return RxJavaPlugins.onAssembly(new ObservableRetryBiPredicate<T>(this, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> retry(long times) {         return retry(times, Functions.alwaysTrue());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> retry(long times, Predicate<? super Throwable> predicate) {         if (times < 0) {             throw new IllegalArgumentException("times >= 0 required but it was " + times);         }         ObjectHelper.requireNonNull(predicate, "predicate is null");          return RxJavaPlugins.onAssembly(new ObservableRetryPredicate<T>(this, times, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> retry(Predicate<? super Throwable> predicate) {         return retry(Long.MAX_VALUE, predicate);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> retryWhen(             final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {         ObjectHelper.requireNonNull(handler, "handler is null");         return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> sample(long period, TimeUnit unit) {         return sample(period, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableSampleTimed<T>(this, period, unit, scheduler, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<T> sample(ObservableSource<U> sampler) {         ObjectHelper.requireNonNull(sampler, "sampler is null");         return RxJavaPlugins.onAssembly(new ObservableSampleWithObservable<T>(this, sampler, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> scan(BiFunction<T, T, T> accumulator) {         ObjectHelper.requireNonNull(accumulator, "accumulator is null");         return RxJavaPlugins.onAssembly(new ObservableScan<T>(this, accumulator));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> scan(final R initialValue, BiFunction<R, ? super T, R> accumulator) {         ObjectHelper.requireNonNull(initialValue, "initialValue is null");         return scanWith(Functions.justCallable(initialValue), accumulator);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {         ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");         ObjectHelper.requireNonNull(accumulator, "accumulator is null");         return RxJavaPlugins.onAssembly(new ObservableScanSeed<T, R>(this, seedSupplier, accumulator));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> serialize() {         return RxJavaPlugins.onAssembly(new ObservableSerialized<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> singleElement() {         return RxJavaPlugins.onAssembly(new ObservableSingleMaybe<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> single(T defaultItem) {         ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");         return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(this, defaultItem));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> singleOrError() {         return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(this, null));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> skip(long count) {         if (count <= 0) {             return RxJavaPlugins.onAssembly(this);         }         return RxJavaPlugins.onAssembly(new ObservableSkip<T>(this, count));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> skip(long time, TimeUnit unit) {         return skipUntil(timer(time, unit));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {         return skipUntil(timer(time, unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> skipLast(int count) {         if (count < 0) {             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);         }         if (count == 0) {             return RxJavaPlugins.onAssembly(this);         }         return RxJavaPlugins.onAssembly(new ObservableSkipLast<T>(this, count));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.TRAMPOLINE)     public final Observable<T> skipLast(long time, TimeUnit unit) {         return skipLast(time, unit, Schedulers.trampoline(), false, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {         return skipLast(time, unit, scheduler, false, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         // the internal buffer holds pairs of (timestamp, value) so double the default buffer size         int s = bufferSize << 1;         return RxJavaPlugins.onAssembly(new ObservableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<T> skipUntil(ObservableSource<U> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableSkipUntil<T, U>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> skipWhile(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new ObservableSkipWhile<T>(this, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> sorted() {         return toList().toObservable().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> sorted(Comparator<? super T> sortFunction) {         ObjectHelper.requireNonNull(sortFunction, "sortFunction is null");         return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> startWith(Iterable<? extends T> items) {         return concatArray(fromIterable(items), this);     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> startWith(ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return concatArray(other, this);     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> startWith(T item) {         ObjectHelper.requireNonNull(item, "item is null");         return concatArray(just(item), this);     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> startWithArray(T... items) {         Observable<T> fromArray = fromArray(items);         if (fromArray == empty()) {             return RxJavaPlugins.onAssembly(this);         }         return concatArray(fromArray, this);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(Consumer<? super T> onNext) {         return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {         return subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,             Action onComplete, Consumer<? super Disposable> onSubscribe) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");          LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);          subscribe(ls);          return ls;     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> subscribeOn(Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableSubscribeOn<T>(this, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> switchIfEmpty(ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchIfEmpty<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> switchMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         if (this instanceof ScalarCallable) {             @SuppressWarnings("unchecked")             T v = ((ScalarCallable<T>)this).call();             if (v == null) {                 return empty();             }             return ObservableScalarXMap.scalarXMap(v, mapper);         }         return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable switchMapCompletable(@NonNull Function<? super T, ? extends CompletableSource> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchMapCompletable<T>(this, mapper, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable switchMapCompletableDelayError(@NonNull Function<? super T, ? extends CompletableSource> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchMapCompletable<T>(this, mapper, true));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> switchMapMaybe(@NonNull Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchMapMaybe<T, R>(this, mapper, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> switchMapMaybeDelayError(@NonNull Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchMapMaybe<T, R>(this, mapper, true));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @NonNull     public final <R> Observable<R> switchMapSingle(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchMapSingle<T, R>(this, mapper, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @NonNull     public final <R> Observable<R> switchMapSingleDelayError(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new ObservableSwitchMapSingle<T, R>(this, mapper, true));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> switchMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {         return switchMapDelayError(mapper, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> take(long count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }         return RxJavaPlugins.onAssembly(new ObservableTake<T>(this, count));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> take(long time, TimeUnit unit) {         return takeUntil(timer(time, unit));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) {         return takeUntil(timer(time, unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> takeLast(int count) {         if (count < 0) {             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);         } else         if (count == 0) {             return RxJavaPlugins.onAssembly(new ObservableIgnoreElements<T>(this));         } else         if (count == 1) {             return RxJavaPlugins.onAssembly(new ObservableTakeLastOne<T>(this));         }         return RxJavaPlugins.onAssembly(new ObservableTakeLast<T>(this, count));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         if (count < 0) {             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);         }         return RxJavaPlugins.onAssembly(new ObservableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Observable<T> takeUntil(ObservableSource<U> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new ObservableTakeUntil<T, U>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> takeWhile(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new ObservableTakeWhile<T>(this, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> throttleFirst(long windowDuration, TimeUnit unit) {         return throttleFirst(windowDuration, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit) {         return sample(intervalDuration, unit);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {         return sample(intervalDuration, unit, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {         return debounce(timeout, unit);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {         return debounce(timeout, unit, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<Timed<T>> timeInterval() {         return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.     public final Observable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableTimeInterval<T>(this, unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <V> Observable<T> timeout(Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator) {         return timeout0(null, itemTimeoutIndicator, null);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <V> Observable<T> timeout(Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator,             ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return timeout0(null, itemTimeoutIndicator, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> timeout(long timeout, TimeUnit timeUnit) {         return timeout0(timeout, timeUnit, null, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<T> timeout(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return timeout0(timeout, timeUnit, other, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, ObservableSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return timeout0(timeout, timeUnit, other, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {         return timeout0(timeout, timeUnit, null, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.     public final Observable<Timed<T>> timestamp(Scheduler scheduler) {         return timestamp(TimeUnit.MILLISECONDS, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.     public final Observable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return map(Functions.<T>timestampWith(unit, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<List<T>> toList(final int capacityHint) {         ObjectHelper.verifyPositive(capacityHint, "capacityHint");         return RxJavaPlugins.onAssembly(new ObservableToListSingle<T, List<T>>(this, capacityHint));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Single<U> toList(Callable<U> collectionSupplier) {         ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");         return RxJavaPlugins.onAssembly(new ObservableToListSingle<T, U>(this, collectionSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Single<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {         @SuppressWarnings({ "rawtypes", "unchecked" })         Function<? super T, ? extends T> valueSelector = (Function)Functions.identity();         Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();         Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();         return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);     }'
b'@BackpressureSupport(BackpressureKind.SPECIAL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> toFlowable(BackpressureStrategy strategy) {         Flowable<T> f = new FlowableFromObservable<T>(this);          switch (strategy) {             case DROP:                 return f.onBackpressureDrop();             case LATEST:                 return f.onBackpressureLatest();             case MISSING:                 return f;             case ERROR:                 return RxJavaPlugins.onAssembly(new FlowableOnBackpressureError<T>(f));             default:                 return f.onBackpressureBuffer();         }     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<List<T>> toSortedList() {         return toSortedList(Functions.naturalOrder());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> unsubscribeOn(Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableUnsubscribeOn<T>(this, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<Observable<T>> window(long count) {         return window(count, count, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<Observable<T>> window(long count, long skip, int bufferSize) {         ObjectHelper.verifyPositive(count, "count");         ObjectHelper.verifyPositive(skip, "skip");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableWindow<T>(this, count, skip, bufferSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit) {         return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {         ObjectHelper.verifyPositive(timespan, "timespan");         ObjectHelper.verifyPositive(timeskip, "timeskip");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.requireNonNull(unit, "unit is null");         return RxJavaPlugins.onAssembly(new ObservableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Observable<Observable<T>> window(long timespan, TimeUnit unit) {         return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<Observable<T>> window(long timespan, TimeUnit unit,             Scheduler scheduler, long count) {         return window(timespan, unit, scheduler, count, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<Observable<T>> window(             long timespan, TimeUnit unit, Scheduler scheduler,             long count, boolean restart, int bufferSize) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.verifyPositive(count, "count");         return RxJavaPlugins.onAssembly(new ObservableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Observable<Observable<T>> window(ObservableSource<B> boundary) {         return window(boundary, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Observable<Observable<T>> window(             ObservableSource<U> openingIndicator,             Function<? super U, ? extends ObservableSource<V>> closingIndicator) {         return window(openingIndicator, closingIndicator, bufferSize());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Observable<Observable<T>> window(             ObservableSource<U> openingIndicator,             Function<? super U, ? extends ObservableSource<V>> closingIndicator, int bufferSize) {         ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");         ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Observable<Observable<T>> window(Callable<? extends ObservableSource<B>> boundary, int bufferSize) {         ObjectHelper.requireNonNull(boundary, "boundary is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new ObservableWindowBoundarySupplier<T, B>(this, boundary, bufferSize));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Observable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {         ObjectHelper.requireNonNull(other, "other is null");         ObjectHelper.requireNonNull(zipper, "zipper is null");         return RxJavaPlugins.onAssembly(new ObservableZipIterable<T, U, R>(this, other, zipper));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Observable<R> zipWith(ObservableSource<? extends U> other,             BiFunction<? super T, ? super U, ? extends R> zipper) {         ObjectHelper.requireNonNull(other, "other is null");         return zip(this, other, zipper);     }'
b'@Override     protected void subscribeActual(MaybeObserver<? super T> observer) {         source.subscribe(new LastObserver<T>(observer));     }'
b'@NonNull     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public Observable<T> refCount() {         return RxJavaPlugins.onAssembly(new ObservableRefCount<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> refCount(int subscriberCount) {         return refCount(subscriberCount, 0, TimeUnit.NANOSECONDS, Schedulers.trampoline());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> refCount(long timeout, TimeUnit unit, Scheduler scheduler) {         return refCount(1, timeout, unit, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Observable<T> refCount(int subscriberCount, long timeout, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.verifyPositive(subscriberCount, "subscriberCount");         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new ObservableRefCount<T>(this, subscriberCount, timeout, unit, scheduler));     }'
b'@NonNull     public Observable<T> autoConnect(int numberOfSubscribers, @NonNull Consumer<? super Disposable> connection) {         if (numberOfSubscribers <= 0) {             this.connect(connection);             return RxJavaPlugins.onAssembly(this);         }         return RxJavaPlugins.onAssembly(new ObservableAutoConnect<T>(this, numberOfSubscribers, connection));     }'
b'protected final boolean validate(@NonNull Subscriber<?>[] subscribers) {         int p = parallelism();         if (subscribers.length != p) {             Throwable iae = new IllegalArgumentException("parallelism = " + p + ", subscribers = " + subscribers.length);             for (Subscriber<?> s : subscribers) {                 EmptySubscription.error(iae, s);             }             return false;         }         return true;     }'
b'@CheckReturnValue     public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source) {         return from(source, Runtime.getRuntime().availableProcessors(), Flowable.bufferSize());     }'
b'@CheckReturnValue     public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source, int parallelism) {         return from(source, parallelism, Flowable.bufferSize());     }'
b'@CheckReturnValue     @NonNull     public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source,             int parallelism, int prefetch) {         ObjectHelper.requireNonNull(source, "source");         ObjectHelper.verifyPositive(parallelism, "parallelism");         ObjectHelper.verifyPositive(prefetch, "prefetch");          return RxJavaPlugins.onAssembly(new ParallelFromPublisher<T>(source, parallelism, prefetch));     }'
b'@CheckReturnValue     @NonNull     public final <R> R as(@NonNull ParallelFlowableConverter<T, R> converter) {         return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> map(@NonNull Function<? super T, ? extends R> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper");         return RxJavaPlugins.onAssembly(new ParallelMap<T, R>(this, mapper));     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> map(@NonNull Function<? super T, ? extends R> mapper, @NonNull ParallelFailureHandling errorHandler) {         ObjectHelper.requireNonNull(mapper, "mapper");         ObjectHelper.requireNonNull(errorHandler, "errorHandler is null");         return RxJavaPlugins.onAssembly(new ParallelMapTry<T, R>(this, mapper, errorHandler));     }'
b'@CheckReturnValue     public final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate");         return RxJavaPlugins.onAssembly(new ParallelFilter<T>(this, predicate));     }'
b'@CheckReturnValue     public final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate, @NonNull ParallelFailureHandling errorHandler) {         ObjectHelper.requireNonNull(predicate, "predicate");         ObjectHelper.requireNonNull(errorHandler, "errorHandler is null");         return RxJavaPlugins.onAssembly(new ParallelFilterTry<T>(this, predicate, errorHandler));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> runOn(@NonNull Scheduler scheduler) {         return runOn(scheduler, Flowable.bufferSize());     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> runOn(@NonNull Scheduler scheduler, int prefetch) {         ObjectHelper.requireNonNull(scheduler, "scheduler");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ParallelRunOn<T>(this, scheduler, prefetch));     }'
b'@CheckReturnValue     @NonNull     public final Flowable<T> reduce(@NonNull BiFunction<T, T, T> reducer) {         ObjectHelper.requireNonNull(reducer, "reducer");         return RxJavaPlugins.onAssembly(new ParallelReduceFull<T>(this, reducer));     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> reduce(@NonNull Callable<R> initialSupplier, @NonNull BiFunction<R, ? super T, R> reducer) {         ObjectHelper.requireNonNull(initialSupplier, "initialSupplier");         ObjectHelper.requireNonNull(reducer, "reducer");         return RxJavaPlugins.onAssembly(new ParallelReduce<T, R>(this, initialSupplier, reducer));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     public final Flowable<T> sequential() {         return sequential(Flowable.bufferSize());     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     @NonNull     public final Flowable<T> sequential(int prefetch) {         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ParallelJoin<T>(this, prefetch, false));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     @NonNull     public final Flowable<T> sequentialDelayError() {         return sequentialDelayError(Flowable.bufferSize());     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     @NonNull     public final Flowable<T> sequentialDelayError(int prefetch) {         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ParallelJoin<T>(this, prefetch, true));     }'
b'@CheckReturnValue     @NonNull     public final Flowable<T> sorted(@NonNull Comparator<? super T> comparator) {         return sorted(comparator, 16);     }'
b'@CheckReturnValue     @NonNull     public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator) {         return toSortedList(comparator, 16);     }'
b'@CheckReturnValue     @NonNull     public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) {         ObjectHelper.requireNonNull(comparator, "comparator is null");         ObjectHelper.verifyPositive(capacityHint, "capacityHint");          int ch = capacityHint / parallelism() + 1;         ParallelFlowable<List<T>> railReduced = reduce(Functions.<T>createArrayList(ch), ListAddBiConsumer.<T>instance());         ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<T>(comparator));          Flowable<List<T>> merged = railSorted.reduce(new MergerBiFunction<T>(comparator));          return RxJavaPlugins.onAssembly(merged);     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 onNext,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 Functions.emptyConsumer(),                 Functions.EMPTY_LONG_CONSUMER,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext, @NonNull ParallelFailureHandling errorHandler) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(errorHandler, "errorHandler is null");         return RxJavaPlugins.onAssembly(new ParallelDoOnNextTry<T>(this, onNext, errorHandler));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doAfterNext(@NonNull Consumer<? super T> onAfterNext) {         ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 onAfterNext,                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 Functions.emptyConsumer(),                 Functions.EMPTY_LONG_CONSUMER,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) {         ObjectHelper.requireNonNull(onError, "onError is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 onError,                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 Functions.emptyConsumer(),                 Functions.EMPTY_LONG_CONSUMER,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnComplete(@NonNull Action onComplete) {         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 onComplete,                 Functions.EMPTY_ACTION,                 Functions.emptyConsumer(),                 Functions.EMPTY_LONG_CONSUMER,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doAfterTerminated(@NonNull Action onAfterTerminate) {         ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 onAfterTerminate,                 Functions.emptyConsumer(),                 Functions.EMPTY_LONG_CONSUMER,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnSubscribe(@NonNull Consumer<? super Subscription> onSubscribe) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 onSubscribe,                 Functions.EMPTY_LONG_CONSUMER,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) {         ObjectHelper.requireNonNull(onRequest, "onRequest is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 Functions.emptyConsumer(),                 onRequest,                 Functions.EMPTY_ACTION                 ));     }'
b'@CheckReturnValue     @NonNull     public final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) {         ObjectHelper.requireNonNull(onCancel, "onCancel is null");         return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 Functions.emptyConsumer(),                 Functions.EMPTY_LONG_CONSUMER,                 onCancel                 ));     }'
b'@CheckReturnValue     @NonNull     public final <C> ParallelFlowable<C> collect(@NonNull Callable<? extends C> collectionSupplier, @NonNull BiConsumer<? super C, ? super T> collector) {         ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");         ObjectHelper.requireNonNull(collector, "collector is null");         return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));     }'
b'@CheckReturnValue     @NonNull     public static <T> ParallelFlowable<T> fromArray(@NonNull Publisher<T>... publishers) {         if (publishers.length == 0) {             throw new IllegalArgumentException("Zero publishers not supported");         }         return RxJavaPlugins.onAssembly(new ParallelFromArray<T>(publishers));     }'
b'@CheckReturnValue     @NonNull     public final <U> U to(@NonNull Function<? super ParallelFlowable<T>, U> converter) {         try {             return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);         } catch (Throwable ex) {             Exceptions.throwIfFatal(ex);             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@CheckReturnValue     @NonNull     public final <U> ParallelFlowable<U> compose(@NonNull ParallelTransformer<T, U> composer) {         return RxJavaPlugins.onAssembly(ObjectHelper.requireNonNull(composer, "composer is null").apply(this));     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> flatMap(             @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayError) {         return flatMap(mapper, delayError, Integer.MAX_VALUE, Flowable.bufferSize());     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> flatMap(             @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,             boolean delayError, int maxConcurrency, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ParallelFlatMap<T, R>(this, mapper, delayError, maxConcurrency, prefetch));     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> concatMap(             @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper) {         return concatMap(mapper, 2);     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> concatMap(             @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,                     int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> concatMapDelayError(             @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,                     boolean tillTheEnd) {         return concatMapDelayError(mapper, 2, tillTheEnd);     }'
b'@CheckReturnValue     @NonNull     public final <R> ParallelFlowable<R> concatMapDelayError(             @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,                     int prefetch, boolean tillTheEnd) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(                 this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));     }'
b'public static <U, R> Observable<R> multicastSelector(             final Callable<? extends ConnectableObservable<U>> connectableFactory,             final Function<? super Observable<U>, ? extends ObservableSource<R>> selector) {         return RxJavaPlugins.onAssembly(new MulticastReplay<R, U>(connectableFactory, selector));     }'
b'public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {         final Observable<T> observable = co.observeOn(scheduler);         return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));     }'
b'@SuppressWarnings("unchecked")     public static <T> ConnectableObservable<T> createFrom(ObservableSource<? extends T> source) {         return create(source, DEFAULT_UNBOUNDED_FACTORY);     }'
b'public static <T> ConnectableObservable<T> create(ObservableSource<T> source,             final int bufferSize) {         if (bufferSize == Integer.MAX_VALUE) {             return createFrom(source);         }         return create(source, new ReplayBufferSupplier<T>(bufferSize));     }'
b'public static <T> ConnectableObservable<T> create(ObservableSource<T> source,             long maxAge, TimeUnit unit, Scheduler scheduler) {         return create(source, maxAge, unit, scheduler, Integer.MAX_VALUE);     }'
b'public static <T> ConnectableObservable<T> create(ObservableSource<T> source,             final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {         return create(source, new ScheduledReplaySupplier<T>(bufferSize, maxAge, unit, scheduler));     }'
b'static <T> ConnectableObservable<T> create(ObservableSource<T> source,             final BufferSupplier<T> bufferFactory) {         // the current connection to source needs to be shared between the operator and its onSubscribe call         final AtomicReference<ReplayObserver<T>> curr = new AtomicReference<ReplayObserver<T>>();         ObservableSource<T> onSubscribe = new ReplaySource<T>(curr, bufferFactory);         return RxJavaPlugins.onAssembly(new ObservableReplay<T>(onSubscribe, source, curr, bufferFactory));     }'
b'public boolean setResource(int index, Subscription resource) {         for (;;) {             Subscription o = get(index);             if (o == SubscriptionHelper.CANCELLED) {                 if (resource != null) {                     resource.cancel();                 }                 return false;             }             if (compareAndSet(index, o, resource)) {                 if (o != null) {                     o.cancel();                 }                 return true;             }         }     }'
b'public Subscription replaceResource(int index, Subscription resource) {         for (;;) {             Subscription o = get(index);             if (o == SubscriptionHelper.CANCELLED) {                 if (resource != null) {                     resource.cancel();                 }                 return null;             }             if (compareAndSet(index, o, resource)) {                 return o;             }         }     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastProcessor<T> create(int capacityHint) {         return new UnicastProcessor<T>(capacityHint);     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastProcessor<T> create(boolean delayError) {         return new UnicastProcessor<T>(bufferSize(), null, delayError);     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {         ObjectHelper.requireNonNull(onCancelled, "onTerminate");         return new UnicastProcessor<T>(capacityHint, onCancelled);     }'
b'@SuppressWarnings("unchecked")     public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,             Subscriber<? super R> subscriber,             Function<? super T, ? extends Publisher<? extends R>> mapper) {         if (source instanceof Callable) {             T t;              try {                 t = ((Callable<T>)source).call();             } catch (Throwable ex) {                 Exceptions.throwIfFatal(ex);                 EmptySubscription.error(ex, subscriber);                 return true;             }              if (t == null) {                 EmptySubscription.complete(subscriber);                 return true;             }              Publisher<? extends R> r;              try {                 r = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null Publisher");             } catch (Throwable ex) {                 Exceptions.throwIfFatal(ex);                 EmptySubscription.error(ex, subscriber);                 return true;             }              if (r instanceof Callable) {                 R u;                  try {                     u = ((Callable<R>)r).call();                 } catch (Throwable ex) {                     Exceptions.throwIfFatal(ex);                     EmptySubscription.error(ex, subscriber);                     return true;                 }                  if (u == null) {                     EmptySubscription.complete(subscriber);                     return true;                 }                 subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));             } else {                 r.subscribe(subscriber);             }              return true;         }         return false;     }'
b'public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {         return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));     }'
b'@NonNull     public static Disposable fromRunnable(@NonNull Runnable run) {         ObjectHelper.requireNonNull(run, "run is null");         return new RunnableDisposable(run);     }'
b'@NonNull     public static Disposable fromAction(@NonNull Action run) {         ObjectHelper.requireNonNull(run, "run is null");         return new ActionDisposable(run);     }'
b'@NonNull     public static Disposable fromFuture(@NonNull Future<?> future) {         ObjectHelper.requireNonNull(future, "future is null");         return fromFuture(future, true);     }'
b'@NonNull     public static Disposable fromFuture(@NonNull Future<?> future, boolean allowInterrupt) {         ObjectHelper.requireNonNull(future, "future is null");         return new FutureDisposable(future, allowInterrupt);     }'
b'@NonNull     public static Disposable fromSubscription(@NonNull Subscription subscription) {         ObjectHelper.requireNonNull(subscription, "subscription is null");         return new SubscriptionDisposable(subscription);     }'
b'public final T blockingGet() {         if (getCount() != 0) {             try {                 BlockingHelper.verifyNonBlocking();                 await();             } catch (InterruptedException ex) {                 dispose();                 throw ExceptionHelper.wrapOrThrow(ex);             }         }          Throwable e = error;         if (e != null) {             throw ExceptionHelper.wrapOrThrow(e);         }         return value;     }'
b'@NonNull     public static Scheduler initComputationScheduler(@NonNull Callable<Scheduler> defaultScheduler) {         ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can\'t be null");         Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitComputationHandler;         if (f == null) {             return callRequireNonNull(defaultScheduler);         }         return applyRequireNonNull(f, defaultScheduler); // JIT will skip this     }'
b'@NonNull     public static Scheduler initIoScheduler(@NonNull Callable<Scheduler> defaultScheduler) {         ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can\'t be null");         Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitIoHandler;         if (f == null) {             return callRequireNonNull(defaultScheduler);         }         return applyRequireNonNull(f, defaultScheduler);     }'
b'@NonNull     public static Scheduler initNewThreadScheduler(@NonNull Callable<Scheduler> defaultScheduler) {         ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can\'t be null");         Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitNewThreadHandler;         if (f == null) {             return callRequireNonNull(defaultScheduler);         }         return applyRequireNonNull(f, defaultScheduler);     }'
b'@NonNull     public static Scheduler initSingleScheduler(@NonNull Callable<Scheduler> defaultScheduler) {         ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can\'t be null");         Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitSingleHandler;         if (f == null) {             return callRequireNonNull(defaultScheduler);         }         return applyRequireNonNull(f, defaultScheduler);     }'
b'@NonNull     public static Scheduler onComputationScheduler(@NonNull Scheduler defaultScheduler) {         Function<? super Scheduler, ? extends Scheduler> f = onComputationHandler;         if (f == null) {             return defaultScheduler;         }         return apply(f, defaultScheduler);     }'
b'public static void onError(@NonNull Throwable error) {         Consumer<? super Throwable> f = errorHandler;          if (error == null) {             error = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");         } else {             if (!isBug(error)) {                 error = new UndeliverableException(error);             }         }          if (f != null) {             try {                 f.accept(error);                 return;             } catch (Throwable e) {                 // Exceptions.throwIfFatal(e); TODO decide                 e.printStackTrace(); // NOPMD                 uncaught(e);             }         }          error.printStackTrace(); // NOPMD         uncaught(error);     }'
b'@NonNull     public static Scheduler onIoScheduler(@NonNull Scheduler defaultScheduler) {         Function<? super Scheduler, ? extends Scheduler> f = onIoHandler;         if (f == null) {             return defaultScheduler;         }         return apply(f, defaultScheduler);     }'
b'@NonNull     public static Scheduler onNewThreadScheduler(@NonNull Scheduler defaultScheduler) {         Function<? super Scheduler, ? extends Scheduler> f = onNewThreadHandler;         if (f == null) {             return defaultScheduler;         }         return apply(f, defaultScheduler);     }'
b'@NonNull     public static Runnable onSchedule(@NonNull Runnable run) {         ObjectHelper.requireNonNull(run, "run is null");          Function<? super Runnable, ? extends Runnable> f = onScheduleHandler;         if (f == null) {             return run;         }         return apply(f, run);     }'
b'@NonNull     public static Scheduler onSingleScheduler(@NonNull Scheduler defaultScheduler) {         Function<? super Scheduler, ? extends Scheduler> f = onSingleHandler;         if (f == null) {             return defaultScheduler;         }         return apply(f, defaultScheduler);     }'
b'public static void reset() {         setErrorHandler(null);         setScheduleHandler(null);          setComputationSchedulerHandler(null);         setInitComputationSchedulerHandler(null);          setIoSchedulerHandler(null);         setInitIoSchedulerHandler(null);          setSingleSchedulerHandler(null);         setInitSingleSchedulerHandler(null);          setNewThreadSchedulerHandler(null);         setInitNewThreadSchedulerHandler(null);          setOnFlowableAssembly(null);         setOnFlowableSubscribe(null);          setOnObservableAssembly(null);         setOnObservableSubscribe(null);          setOnSingleAssembly(null);         setOnSingleSubscribe(null);          setOnCompletableAssembly(null);         setOnCompletableSubscribe(null);          setOnConnectableFlowableAssembly(null);         setOnConnectableObservableAssembly(null);          setOnMaybeAssembly(null);         setOnMaybeSubscribe(null);          setOnParallelAssembly(null);          setFailOnNonBlockingScheduler(false);         setOnBeforeBlocking(null);     }'
b'public static void setComputationSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onComputationHandler = handler;     }'
b'public static void setInitComputationSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onInitComputationHandler = handler;     }'
b'public static void setInitIoSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onInitIoHandler = handler;     }'
b'public static void setInitNewThreadSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onInitNewThreadHandler = handler;     }'
b'public static void setInitSingleSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onInitSingleHandler = handler;     }'
b'public static void setIoSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onIoHandler = handler;     }'
b'public static void setNewThreadSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onNewThreadHandler = handler;     }'
b'public static void setScheduleHandler(@Nullable Function<? super Runnable, ? extends Runnable> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onScheduleHandler = handler;     }'
b'public static void setSingleSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onSingleHandler = handler;     }'
b'public static void setOnCompletableAssembly(@Nullable Function<? super Completable, ? extends Completable> onCompletableAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onCompletableAssembly = onCompletableAssembly;     }'
b'public static void setOnCompletableSubscribe(             @Nullable BiFunction<? super Completable, ? super CompletableObserver, ? extends CompletableObserver> onCompletableSubscribe) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onCompletableSubscribe = onCompletableSubscribe;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnFlowableAssembly(@Nullable Function<? super Flowable, ? extends Flowable> onFlowableAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onFlowableAssembly = onFlowableAssembly;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnMaybeAssembly(@Nullable Function<? super Maybe, ? extends Maybe> onMaybeAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onMaybeAssembly = onMaybeAssembly;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnConnectableFlowableAssembly(@Nullable Function<? super ConnectableFlowable, ? extends ConnectableFlowable> onConnectableFlowableAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onConnectableFlowableAssembly = onConnectableFlowableAssembly;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnFlowableSubscribe(@Nullable BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> onFlowableSubscribe) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onFlowableSubscribe = onFlowableSubscribe;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnMaybeSubscribe(@Nullable BiFunction<? super Maybe, MaybeObserver, ? extends MaybeObserver> onMaybeSubscribe) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onMaybeSubscribe = onMaybeSubscribe;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnObservableAssembly(@Nullable Function<? super Observable, ? extends Observable> onObservableAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onObservableAssembly = onObservableAssembly;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnConnectableObservableAssembly(@Nullable Function<? super ConnectableObservable, ? extends ConnectableObservable> onConnectableObservableAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onConnectableObservableAssembly = onConnectableObservableAssembly;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnObservableSubscribe(             @Nullable BiFunction<? super Observable, ? super Observer, ? extends Observer> onObservableSubscribe) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onObservableSubscribe = onObservableSubscribe;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnSingleAssembly(@Nullable Function<? super Single, ? extends Single> onSingleAssembly) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onSingleAssembly = onSingleAssembly;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnSingleSubscribe(@Nullable BiFunction<? super Single, ? super SingleObserver, ? extends SingleObserver> onSingleSubscribe) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         RxJavaPlugins.onSingleSubscribe = onSingleSubscribe;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> Subscriber<? super T> onSubscribe(@NonNull Flowable<T> source, @NonNull Subscriber<? super T> subscriber) {         BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> f = onFlowableSubscribe;         if (f != null) {             return apply(f, source, subscriber);         }         return subscriber;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> Observer<? super T> onSubscribe(@NonNull Observable<T> source, @NonNull Observer<? super T> observer) {         BiFunction<? super Observable, ? super Observer, ? extends Observer> f = onObservableSubscribe;         if (f != null) {             return apply(f, source, observer);         }         return observer;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> SingleObserver<? super T> onSubscribe(@NonNull Single<T> source, @NonNull SingleObserver<? super T> observer) {         BiFunction<? super Single, ? super SingleObserver, ? extends SingleObserver> f = onSingleSubscribe;         if (f != null) {             return apply(f, source, observer);         }         return observer;     }'
b'@NonNull     public static CompletableObserver onSubscribe(@NonNull Completable source, @NonNull CompletableObserver observer) {         BiFunction<? super Completable, ? super CompletableObserver, ? extends CompletableObserver> f = onCompletableSubscribe;         if (f != null) {             return apply(f, source, observer);         }         return observer;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> MaybeObserver<? super T> onSubscribe(@NonNull Maybe<T> source, @NonNull MaybeObserver<? super T> observer) {         BiFunction<? super Maybe, ? super MaybeObserver, ? extends MaybeObserver> f = onMaybeSubscribe;         if (f != null) {             return apply(f, source, observer);         }         return observer;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> Maybe<T> onAssembly(@NonNull Maybe<T> source) {         Function<? super Maybe, ? extends Maybe> f = onMaybeAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> Flowable<T> onAssembly(@NonNull Flowable<T> source) {         Function<? super Flowable, ? extends Flowable> f = onFlowableAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> ConnectableFlowable<T> onAssembly(@NonNull ConnectableFlowable<T> source) {         Function<? super ConnectableFlowable, ? extends ConnectableFlowable> f = onConnectableFlowableAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {         Function<? super Observable, ? extends Observable> f = onObservableAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> ConnectableObservable<T> onAssembly(@NonNull ConnectableObservable<T> source) {         Function<? super ConnectableObservable, ? extends ConnectableObservable> f = onConnectableObservableAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> Single<T> onAssembly(@NonNull Single<T> source) {         Function<? super Single, ? extends Single> f = onSingleAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@NonNull     public static Completable onAssembly(@NonNull Completable source) {         Function<? super Completable, ? extends Completable> f = onCompletableAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'@SuppressWarnings("rawtypes")     public static void setOnParallelAssembly(@Nullable Function<? super ParallelFlowable, ? extends ParallelFlowable> handler) {         if (lockdown) {             throw new IllegalStateException("Plugins can\'t be changed anymore");         }         onParallelAssembly = handler;     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @NonNull     public static <T> ParallelFlowable<T> onAssembly(@NonNull ParallelFlowable<T> source) {         Function<? super ParallelFlowable, ? extends ParallelFlowable> f = onParallelAssembly;         if (f != null) {             return apply(f, source);         }         return source;     }'
b'public static boolean onBeforeBlocking() {         BooleanSupplier f = onBeforeBlocking;         if (f != null) {             try {                 return f.getAsBoolean();             } catch (Throwable ex) {                 throw ExceptionHelper.wrapOrThrow(ex);             }         }         return false;     }'
b'@NonNull     public static Scheduler createComputationScheduler(@NonNull ThreadFactory threadFactory) {         return new ComputationScheduler(ObjectHelper.requireNonNull(threadFactory, "threadFactory is null"));     }'
b'@NonNull     static <T, R> R apply(@NonNull Function<T, R> f, @NonNull T t) {         try {             return f.apply(t);         } catch (Throwable ex) {             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@NonNull     static <T, U, R> R apply(@NonNull BiFunction<T, U, R> f, @NonNull T t, @NonNull U u) {         try {             return f.apply(t, u);         } catch (Throwable ex) {             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@NonNull     static Scheduler callRequireNonNull(@NonNull Callable<Scheduler> s) {         try {             return ObjectHelper.requireNonNull(s.call(), "Scheduler Callable result can\'t be null");         } catch (Throwable ex) {             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@NonNull     static Scheduler applyRequireNonNull(@NonNull Function<? super Callable<Scheduler>, ? extends Scheduler> f, Callable<Scheduler> s) {         return ObjectHelper.requireNonNull(apply(f, s), "Scheduler Callable result can\'t be null");     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> amb(final Iterable<? extends MaybeSource<? extends T>> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new MaybeAmb<T>(null, sources));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Maybe<T> ambArray(final MaybeSource<? extends T>... sources) {         if (sources.length == 0) {             return empty();         }         if (sources.length == 1) {             return wrap((MaybeSource<T>)sources[0]);         }         return RxJavaPlugins.onAssembly(new MaybeAmb<T>(sources, null));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concat(Publisher<? extends MaybeSource<? extends T>> sources) {         return concat(sources, 2);     }'
b'@SuppressWarnings("unchecked")     @BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatArrayDelayError(MaybeSource<? extends T>... sources) {         if (sources.length == 0) {             return Flowable.empty();         } else         if (sources.length == 1) {             return RxJavaPlugins.onAssembly(new MaybeToFlowable<T>((MaybeSource<T>)sources[0]));         }         return RxJavaPlugins.onAssembly(new MaybeConcatArrayDelayError<T>(sources));     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatArrayEager(MaybeSource<? extends T>... sources) {         return Flowable.fromArray(sources).concatMapEager((Function)MaybeToPublisher.instance());     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatEager(Iterable<? extends MaybeSource<? extends T>> sources) {         return Flowable.fromIterable(sources).concatMapEager((Function)MaybeToPublisher.instance());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> create(MaybeOnSubscribe<T> onSubscribe) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         return RxJavaPlugins.onAssembly(new MaybeCreate<T>(onSubscribe));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> defer(final Callable<? extends MaybeSource<? extends T>> maybeSupplier) {         ObjectHelper.requireNonNull(maybeSupplier, "maybeSupplier is null");         return RxJavaPlugins.onAssembly(new MaybeDefer<T>(maybeSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Maybe<T> empty() {         return RxJavaPlugins.onAssembly((Maybe<T>)MaybeEmpty.INSTANCE);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> error(Throwable exception) {         ObjectHelper.requireNonNull(exception, "exception is null");         return RxJavaPlugins.onAssembly(new MaybeError<T>(exception));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> error(Callable<? extends Throwable> supplier) {         ObjectHelper.requireNonNull(supplier, "errorSupplier is null");         return RxJavaPlugins.onAssembly(new MaybeErrorCallable<T>(supplier));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) {         ObjectHelper.requireNonNull(completableSource, "completableSource is null");         return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {         ObjectHelper.requireNonNull(singleSource, "singleSource is null");         return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> fromCallable(@NonNull final Callable<? extends T> callable) {         ObjectHelper.requireNonNull(callable, "callable is null");         return RxJavaPlugins.onAssembly(new MaybeFromCallable<T>(callable));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> fromFuture(Future<? extends T> future) {         ObjectHelper.requireNonNull(future, "future is null");         return RxJavaPlugins.onAssembly(new MaybeFromFuture<T>(future, 0L, null));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {         ObjectHelper.requireNonNull(future, "future is null");         ObjectHelper.requireNonNull(unit, "unit is null");         return RxJavaPlugins.onAssembly(new MaybeFromFuture<T>(future, timeout, unit));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> fromRunnable(final Runnable run) {         ObjectHelper.requireNonNull(run, "run is null");         return RxJavaPlugins.onAssembly(new MaybeFromRunnable<T>(run));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> just(T item) {         ObjectHelper.requireNonNull(item, "item is null");         return RxJavaPlugins.onAssembly(new MaybeJust<T>(item));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> merge(Publisher<? extends MaybeSource<? extends T>> sources) {         return merge(sources, Integer.MAX_VALUE);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> mergeArrayDelayError(MaybeSource<? extends T>... sources) {         if (sources.length == 0) {             return Flowable.empty();         }         return Flowable.fromArray(sources).flatMap((Function)MaybeToPublisher.instance(), true, sources.length);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> mergeDelayError(Iterable<? extends MaybeSource<? extends T>> sources) {         return Flowable.fromIterable(sources).flatMap((Function)MaybeToPublisher.instance(), true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Maybe<T> never() {         return RxJavaPlugins.onAssembly((Maybe<T>)MaybeNever.INSTANCE);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(MaybeSource<? extends T> source1, MaybeSource<? extends T> source2) {         return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(MaybeSource<? extends T> source1, MaybeSource<? extends T> source2,             BiPredicate<? super T, ? super T> isEqual) {         ObjectHelper.requireNonNull(source1, "source1 is null");         ObjectHelper.requireNonNull(source2, "source2 is null");         ObjectHelper.requireNonNull(isEqual, "isEqual is null");         return RxJavaPlugins.onAssembly(new MaybeEqualSingle<T>(source1, source2, isEqual));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Maybe<Long> timer(long delay, TimeUnit unit) {         return timer(delay, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Maybe<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");          return RxJavaPlugins.onAssembly(new MaybeTimer(Math.max(0L, delay), unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> unsafeCreate(MaybeSource<T> onSubscribe) {         if (onSubscribe instanceof Maybe) {             throw new IllegalArgumentException("unsafeCreate(Maybe) should be upgraded");         }         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         return RxJavaPlugins.onAssembly(new MaybeUnsafeCreate<T>(onSubscribe));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, D> Maybe<T> using(Callable<? extends D> resourceSupplier,             Function<? super D, ? extends MaybeSource<? extends T>> sourceSupplier,                     Consumer<? super D> resourceDisposer) {         return using(resourceSupplier, sourceSupplier, resourceDisposer, true);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, D> Maybe<T> using(Callable<? extends D> resourceSupplier,             Function<? super D, ? extends MaybeSource<? extends T>> sourceSupplier,                     Consumer<? super D> resourceDisposer, boolean eager) {         ObjectHelper.requireNonNull(resourceSupplier, "resourceSupplier is null");         ObjectHelper.requireNonNull(sourceSupplier, "sourceSupplier is null");         ObjectHelper.requireNonNull(resourceDisposer, "disposer is null");         return RxJavaPlugins.onAssembly(new MaybeUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Maybe<T> wrap(MaybeSource<T> source) {         if (source instanceof Maybe) {             return RxJavaPlugins.onAssembly((Maybe<T>)source);         }         ObjectHelper.requireNonNull(source, "onSubscribe is null");         return RxJavaPlugins.onAssembly(new MaybeUnsafeCreate<T>(source));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Maybe<R> zip(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {         ObjectHelper.requireNonNull(zipper, "zipper is null");         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new MaybeZipIterable<T, R>(sources, zipper));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Maybe<R> zipArray(Function<? super Object[], ? extends R> zipper,             MaybeSource<? extends T>... sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         if (sources.length == 0) {             return empty();         }         ObjectHelper.requireNonNull(zipper, "zipper is null");         return RxJavaPlugins.onAssembly(new MaybeZipArray<T, R>(sources, zipper));     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> ambWith(MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return ambArray(this, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingGet() {         BlockingMultiObserver<T> observer = new BlockingMultiObserver<T>();         subscribe(observer);         return observer.blockingGet();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingGet(T defaultValue) {         ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");         BlockingMultiObserver<T> observer = new BlockingMultiObserver<T>();         subscribe(observer);         return observer.blockingGet(defaultValue);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> cache() {         return RxJavaPlugins.onAssembly(new MaybeCache<T>(this));     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Maybe<R> compose(MaybeTransformer<? super T, ? extends R> transformer) {         return wrap(((MaybeTransformer<T, R>) ObjectHelper.requireNonNull(transformer, "transformer is null")).apply(this));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Maybe<R> concatMap(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new MaybeFlatten<T, R>(this, mapper));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> concatWith(MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return concat(this, other);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> contains(final Object item) {         ObjectHelper.requireNonNull(item, "item is null");         return RxJavaPlugins.onAssembly(new MaybeContains<T>(this, item));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Long> count() {         return RxJavaPlugins.onAssembly(new MaybeCount<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Maybe<T> delay(long delay, TimeUnit unit) {         return delay(delay, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Maybe<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new MaybeDelay<T>(this, Math.max(0L, delay), unit, scheduler));     }'
b'@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Maybe<T> delaySubscription(Publisher<U> subscriptionIndicator) {         ObjectHelper.requireNonNull(subscriptionIndicator, "subscriptionIndicator is null");         return RxJavaPlugins.onAssembly(new MaybeDelaySubscriptionOtherPublisher<T, U>(this, subscriptionIndicator));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Maybe<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {         return delaySubscription(Flowable.timer(delay, unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> doOnError(Consumer<? super Throwable> onError) {         return RxJavaPlugins.onAssembly(new MaybePeek<T>(this,                 Functions.emptyConsumer(), // onSubscribe                 Functions.emptyConsumer(), // onSuccess                 ObjectHelper.requireNonNull(onError, "onError is null"),                 Functions.EMPTY_ACTION,    // onComplete                 Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)                 Functions.EMPTY_ACTION     // dispose         ));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> doOnEvent(BiConsumer<? super T, ? super Throwable> onEvent) {         ObjectHelper.requireNonNull(onEvent, "onEvent is null");         return RxJavaPlugins.onAssembly(new MaybeDoOnEvent<T>(this, onEvent));     }'
b'@Experimental     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> doOnTerminate(final Action onTerminate) {         ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");         return RxJavaPlugins.onAssembly(new MaybeDoOnTerminate<T>(this, onTerminate));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Maybe<R> flatMap(Function<? super T, ? extends MaybeSource<? extends U>> mapper,             BiFunction<? super T, ? super U, ? extends R> resultSelector) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.requireNonNull(resultSelector, "resultSelector is null");         return RxJavaPlugins.onAssembly(new MaybeFlatMapBiSelector<T, U, R>(this, mapper, resultSelector));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Flowable<U> flattenAsFlowable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableFlowable<T, U>(this, mapper));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> hide() {         return RxJavaPlugins.onAssembly(new MaybeHide<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable ignoreElement() {         return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> isEmpty() {         return RxJavaPlugins.onAssembly(new MaybeIsEmptySingle<T>(this));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Maybe<R> lift(final MaybeOperator<? extends R, ? super T> lift) {         ObjectHelper.requireNonNull(lift, "lift is null");         return RxJavaPlugins.onAssembly(new MaybeLift<T, R>(this, lift));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Maybe<R> map(Function<? super T, ? extends R> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new MaybeMap<T, R>(this, mapper));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Maybe<U> ofType(final Class<U> clazz) {         ObjectHelper.requireNonNull(clazz, "clazz is null");         return filter(Functions.isInstanceOf(clazz)).cast(clazz);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> R to(Function<? super Maybe<T>, R> convert) {         try {             return ObjectHelper.requireNonNull(convert, "convert is null").apply(this);         } catch (Throwable ex) {             Exceptions.throwIfFatal(ex);             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> toObservable() {         if (this instanceof FuseToObservable) {             return ((FuseToObservable<T>)this).fuseToObservable();         }         return RxJavaPlugins.onAssembly(new MaybeToObservable<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> toSingle() {         return RxJavaPlugins.onAssembly(new MaybeToSingle<T>(this, null));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> onErrorComplete() {         return onErrorComplete(Functions.alwaysTrue());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> onErrorResumeNext(final MaybeSource<? extends T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return onErrorResumeNext(Functions.justFunction(next));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> onErrorResumeNext(Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) {         ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");         return RxJavaPlugins.onAssembly(new MaybeOnErrorNext<T>(this, resumeFunction, true));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {         ObjectHelper.requireNonNull(valueSupplier, "valueSupplier is null");         return RxJavaPlugins.onAssembly(new MaybeOnErrorReturn<T>(this, valueSupplier));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> onTerminateDetach() {         return RxJavaPlugins.onAssembly(new MaybeDetach<T>(this));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> repeatUntil(BooleanSupplier stop) {         return toFlowable().repeatUntil(stop);     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {         return toFlowable().repeatWhen(handler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {         return toFlowable().retry(predicate).singleElement();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> retry(long count) {         return retry(count, Functions.alwaysTrue());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) {         return toFlowable().retry(times, predicate).singleElement();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> retryWhen(             final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {         return toFlowable().retryWhen(handler).singleElement();     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe() {         return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? super Throwable> onError) {         return subscribe(onSuccess, onError, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> switchIfEmpty(MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new MaybeSwitchIfEmpty<T>(this, other));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> switchIfEmpty(SingleSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new MaybeSwitchIfEmptySingle<T>(this, other));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Maybe<T> takeUntil(MaybeSource<U> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new MaybeTakeUntilMaybe<T, U>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Maybe<T> timeout(long timeout, TimeUnit timeUnit) {         return timeout(timeout, timeUnit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Maybe<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {         return timeout(timer(timeout, timeUnit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Maybe<T> timeout(MaybeSource<U> timeoutIndicator) {         ObjectHelper.requireNonNull(timeoutIndicator, "timeoutIndicator is null");         return RxJavaPlugins.onAssembly(new MaybeTimeoutMaybe<T, U>(this, timeoutIndicator, null));     }'
b'@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Maybe<T> timeout(Publisher<U> timeoutIndicator) {         ObjectHelper.requireNonNull(timeoutIndicator, "timeoutIndicator is null");         return RxJavaPlugins.onAssembly(new MaybeTimeoutPublisher<T, U>(this, timeoutIndicator, null));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Maybe<T> unsubscribeOn(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new MaybeUnsubscribeOn<T>(this, scheduler));     }'
b'public static <T> ConnectableFlowable<T> create(Flowable<T> source, final int bufferSize) {         // the current connection to source needs to be shared between the operator and its onSubscribe call         final AtomicReference<PublishSubscriber<T>> curr = new AtomicReference<PublishSubscriber<T>>();         Publisher<T> onSubscribe = new FlowablePublisher<T>(curr, bufferSize);         return RxJavaPlugins.onAssembly(new FlowablePublish<T>(onSubscribe, source, curr, bufferSize));     }'
b'public static <T> SingleObserver<T> create(Observer<? super T> downstream) {         return new SingleToObservableObserver<T>(downstream);     }'
b'public static <T> T requireNonNull(T object, String message) {         if (object == null) {             throw new NullPointerException(message);         }         return object;     }'
b'@SuppressWarnings("unchecked")     public static <T> BiPredicate<T, T> equalsPredicate() {         return (BiPredicate<T, T>)EQUALS;     }'
b'public static void onError(Subscriber<?> subscriber, Throwable ex,             AtomicInteger wip, AtomicThrowable error) {         if (error.addThrowable(ex)) {             if (wip.getAndIncrement() == 0) {                 subscriber.onError(error.terminate());             }         } else {             RxJavaPlugins.onError(ex);         }     }'
b'public static void onComplete(Subscriber<?> subscriber, AtomicInteger wip, AtomicThrowable error) {         if (wip.getAndIncrement() == 0) {             Throwable ex = error.terminate();             if (ex != null) {                 subscriber.onError(ex);             } else {                 subscriber.onComplete();             }         }     }'
b'public static void onError(Observer<?> observer, Throwable ex,             AtomicInteger wip, AtomicThrowable error) {         if (error.addThrowable(ex)) {             if (wip.getAndIncrement() == 0) {                 observer.onError(error.terminate());             }         } else {             RxJavaPlugins.onError(ex);         }     }'
b'public static void onComplete(Observer<?> observer, AtomicInteger wip, AtomicThrowable error) {         if (wip.getAndIncrement() == 0) {             Throwable ex = error.terminate();             if (ex != null) {                 observer.onError(ex);             } else {                 observer.onComplete();             }         }     }'
b'@SuppressWarnings("unchecked")     public static <T> Function<T, T> identity() {         return (Function<T, T>)IDENTITY;     }'
b'public static <T> Callable<T> justCallable(T value) {         return new JustValue<Object, T>(value);     }'
b'public static <T, U> Function<T, U> justFunction(U value) {         return new JustValue<T, U>(value);     }'
b'public static <T, U> Function<T, U> castFunction(Class<U> target) {         return new CastToClass<T, U>(target);     }'
b'private void printStackTrace(PrintStreamOrWriter s) {         StringBuilder b = new StringBuilder(128);         b.append(this).append(\'\\n\');         for (StackTraceElement myStackElement : getStackTrace()) {             b.append("\\tat ").append(myStackElement).append(\'\\n\');         }         int i = 1;         for (Throwable ex : exceptions) {             b.append("  ComposedException ").append(i).append(" :\\n");             appendStackTrace(b, ex, "\\t");             i++;         }         s.println(b.toString());     }'
b'Throwable getRootCause(Throwable e) {         Throwable root = e.getCause();         if (root == null || e == root) {             return e;         }         while (true) {             Throwable cause = root.getCause();             if (cause == null || cause == root) {                 return root;             }             root = cause;         }     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastSubject<T> create() {         return new UnicastSubject<T>(bufferSize(), true);     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastSubject<T> create(int capacityHint) {         return new UnicastSubject<T>(capacityHint, true);     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) {         return new UnicastSubject<T>(capacityHint, onTerminate, true);     }'
b'@CheckReturnValue     @NonNull     public static <T> UnicastSubject<T> create(boolean delayError) {         return new UnicastSubject<T>(bufferSize(), delayError);     }'
b'public boolean offer(T t) {         if (t == null) {             onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));             return true;         }         PublishSubscription<T>[] array = subscribers.get();          for (PublishSubscription<T> s : array) {             if (s.isFull()) {                 return false;             }         }          for (PublishSubscription<T> s : array) {             s.onNext(t);         }         return true;     }'
b'@SuppressWarnings("unchecked")     @Override     public final void onSubscribe(Disposable d) {         if (DisposableHelper.validate(this.upstream, d)) {              this.upstream = d;             if (d instanceof QueueDisposable) {                 this.qd = (QueueDisposable<T>)d;             }              if (beforeDownstream()) {                  downstream.onSubscribe(this);                  afterDownstream();             }          }     }'
b'@Override     public void onError(Throwable t) {         if (done) {             RxJavaPlugins.onError(t);             return;         }         done = true;         downstream.onError(t);     }'
b'protected final void fail(Throwable t) {         Exceptions.throwIfFatal(t);         upstream.dispose();         onError(t);     }'
b'protected final int transitiveBoundaryFusion(int mode) {         QueueDisposable<T> qd = this.qd;         if (qd != null) {             if ((mode & BOUNDARY) == 0) {                 int m = qd.requestFusion(mode);                 if (m != NONE) {                     sourceMode = m;                 }                 return m;             }         }         return NONE;     }'
b'public Throwable blockingGetError() {         if (getCount() != 0) {             try {                 BlockingHelper.verifyNonBlocking();                 await();             } catch (InterruptedException ex) {                 dispose();                 return ex;             }         }         return error;     }'
b'public Throwable blockingGetError(long timeout, TimeUnit unit) {         if (getCount() != 0) {             try {                 BlockingHelper.verifyNonBlocking();                 if (!await(timeout, unit)) {                     dispose();                     throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));                 }             } catch (InterruptedException ex) {                 dispose();                 throw ExceptionHelper.wrapOrThrow(ex);             }         }         return error;     }'
b'public boolean blockingAwait(long timeout, TimeUnit unit) {         if (getCount() != 0) {             try {                 BlockingHelper.verifyNonBlocking();                 if (!await(timeout, unit)) {                     dispose();                     return false;                 }             } catch (InterruptedException ex) {                 dispose();                 throw ExceptionHelper.wrapOrThrow(ex);             }         }         Throwable ex = error;         if (ex != null) {             throw ExceptionHelper.wrapOrThrow(ex);         }         return true;     }'
b'@CheckReturnValue     @NonNull     public static <T> ReplayProcessor<T> create(int capacityHint) {         return new ReplayProcessor<T>(new UnboundedReplayBuffer<T>(capacityHint));     }'
b'@CheckReturnValue     @NonNull     public static <T> ReplayProcessor<T> createWithSize(int maxSize) {         return new ReplayProcessor<T>(new SizeBoundReplayBuffer<T>(maxSize));     }'
b'static <T> ReplayProcessor<T> createUnbounded() {         return new ReplayProcessor<T>(new SizeBoundReplayBuffer<T>(Integer.MAX_VALUE));     }'
b'@CheckReturnValue     @NonNull     public static <T> ReplayProcessor<T> createWithTime(long maxAge, TimeUnit unit, Scheduler scheduler) {         return new ReplayProcessor<T>(new SizeAndTimeBoundReplayBuffer<T>(Integer.MAX_VALUE, maxAge, unit, scheduler));     }'
b'@SuppressWarnings("unchecked")     @Override     public final void onSubscribe(Subscription s) {         if (SubscriptionHelper.validate(this.upstream, s)) {              this.upstream = s;             if (s instanceof QueueSubscription) {                 this.qs = (QueueSubscription<T>)s;             }              if (beforeDownstream()) {                  downstream.onSubscribe(this);                  afterDownstream();             }          }     }'
b'protected final void fail(Throwable t) {         Exceptions.throwIfFatal(t);         upstream.cancel();         onError(t);     }'
b'protected final int transitiveBoundaryFusion(int mode) {         QueueSubscription<T> qs = this.qs;         if (qs != null) {             if ((mode & BOUNDARY) == 0) {                 int m = qs.requestFusion(mode);                 if (m != NONE) {                     sourceMode = m;                 }                 return m;             }         }         return NONE;     }'
b'@CheckReturnValue     @NonNull     public static <T> BehaviorSubject<T> createDefault(T defaultValue) {         return new BehaviorSubject<T>(defaultValue);     }'
b'@Nullable     public T getValue() {         Object o = value.get();         if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {             return null;         }         return NotificationLite.getValue(o);     }'
b'@Deprecated     public Object[] getValues() {         @SuppressWarnings("unchecked")         T[] a = (T[])EMPTY_ARRAY;         T[] b = getValues(a);         if (b == EMPTY_ARRAY) {             return new Object[0];         }         return b;      }'
b'@Deprecated     @SuppressWarnings("unchecked")     public T[] getValues(T[] array) {         Object o = value.get();         if (o == null || NotificationLite.isComplete(o) || NotificationLite.isError(o)) {             if (array.length != 0) {                 array[0] = null;             }             return array;         }         T v = NotificationLite.getValue(o);         if (array.length != 0) {             array[0] = v;             if (array.length != 1) {                 array[1] = null;             }         } else {             array = (T[])Array.newInstance(array.getClass().getComponentType(), 1);             array[0] = v;         }         return array;     }'
b'public boolean hasValue() {         Object o = value.get();         return o != null && !NotificationLite.isComplete(o) && !NotificationLite.isError(o);     }'
b'public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,             Disposable dispose, QueueDrain<T, U> qd) {         int missed = 1;          for (;;) {             for (;;) {                 boolean d = qd.done();                  T v = q.poll();                  boolean empty = v == null;                  if (checkTerminated(d, empty, a, delayError, q, qd)) {                     if (dispose != null) {                         dispose.dispose();                     }                     return;                 }                  if (empty) {                     break;                 }                  long r = qd.requested();                 if (r != 0L) {                     if (qd.accept(a, v)) {                         if (r != Long.MAX_VALUE) {                             qd.produced(1);                         }                     }                 } else {                     q.clear();                     if (dispose != null) {                         dispose.dispose();                     }                     a.onError(new MissingBackpressureException("Could not emit value due to lack of requests."));                     return;                 }             }              missed = qd.leave(-missed);             if (missed == 0) {                 break;             }         }     }'
b'public static <T> SimpleQueue<T> createQueue(int capacityHint) {         if (capacityHint < 0) {             return new SpscLinkedArrayQueue<T>(-capacityHint);         }         return new SpscArrayQueue<T>(capacityHint);     }'
b'public static void request(Subscription s, int prefetch) {         s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch);     }'
b'public static <T> boolean postCompleteRequest(long n,                                                   Subscriber<? super T> actual,                                                   Queue<T> queue,                                                   AtomicLong state,                                                   BooleanSupplier isCancelled) {         for (; ; ) {             long r = state.get();              // extract the current request amount             long r0 = r & REQUESTED_MASK;              // preserve COMPLETED_MASK and calculate new requested amount             long u = (r & COMPLETED_MASK) | BackpressureHelper.addCap(r0, n);              if (state.compareAndSet(r, u)) {                 // (complete, 0) -> (complete, n) transition then replay                 if (r == COMPLETED_MASK) {                      postCompleteDrain(n | COMPLETED_MASK, actual, queue, state, isCancelled);                      return true;                 }                 // (active, r) -> (active, r + n) transition then continue with requesting from upstream                 return false;             }         }      }'
b'static <T> boolean postCompleteDrain(long n,                                          Subscriber<? super T> actual,                                          Queue<T> queue,                                          AtomicLong state,                                          BooleanSupplier isCancelled) {  // TODO enable fast-path //        if (n == -1 || n == Long.MAX_VALUE) { //            for (;;) { //                if (isCancelled.getAsBoolean()) { //                    break; //                } // //                T v = queue.poll(); // //                if (v == null) { //                    actual.onComplete(); //                    break; //                } // //                actual.onNext(v); //            } // //            return true; //        }          long e = n & COMPLETED_MASK;          for (; ; ) {              while (e != n) {                 if (isCancelled(isCancelled)) {                     return true;                 }                  T t = queue.poll();                  if (t == null) {                     actual.onComplete();                     return true;                 }                  actual.onNext(t);                 e++;             }              if (isCancelled(isCancelled)) {                 return true;             }              if (queue.isEmpty()) {                 actual.onComplete();                 return true;             }              n = state.get();              if (n == e) {                  n = state.addAndGet(-(e & REQUESTED_MASK));                  if ((n & REQUESTED_MASK) == 0L) {                     return false;                 }                  e = n & COMPLETED_MASK;             }         }      }'
b'public static <T> void postComplete(Subscriber<? super T> actual,                                         Queue<T> queue,                                         AtomicLong state,                                         BooleanSupplier isCancelled) {          if (queue.isEmpty()) {             actual.onComplete();             return;         }          if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) {             return;         }          for (; ; ) {             long r = state.get();              if ((r & COMPLETED_MASK) != 0L) {                 return;             }              long u = r | COMPLETED_MASK;             // (active, r) -> (complete, r) transition             if (state.compareAndSet(r, u)) {                 // if the requested amount was non-zero, drain the queue                 if (r != 0L) {                     postCompleteDrain(u, actual, queue, state, isCancelled);                 }                  return;             }         }      }'
b'@CheckReturnValue     @NonNull     public static <T> ReplaySubject<T> create() {         return new ReplaySubject<T>(new UnboundedReplayBuffer<T>(16));     }'
b'@CheckReturnValue     @NonNull     public static <T> ReplaySubject<T> createWithSize(int maxSize) {         return new ReplaySubject<T>(new SizeBoundReplayBuffer<T>(maxSize));     }'
b'static <T> ReplaySubject<T> createUnbounded() {         return new ReplaySubject<T>(new SizeBoundReplayBuffer<T>(Integer.MAX_VALUE));     }'
b'protected final void complete(R n) {         long p = produced;         if (p != 0) {             BackpressureHelper.produced(this, p);         }          for (;;) {             long r = get();             if ((r & COMPLETE_MASK) != 0) {                 onDrop(n);                 return;             }             if ((r & REQUEST_MASK) != 0) {                 lazySet(COMPLETE_MASK + 1);                 downstream.onNext(n);                 downstream.onComplete();                 return;             }             value = n;             if (compareAndSet(0, COMPLETE_MASK)) {                 return;             }             value = null;         }     }'
b'@Deprecated     public Object[] getValues() {         T v = getValue();         return v != null ? new Object[] { v } : new Object[0];     }'
b'@Deprecated     public T[] getValues(T[] array) {         T v = getValue();         if (v == null) {             if (array.length != 0) {                 array[0] = null;             }             return array;         }         if (array.length == 0) {             array = Arrays.copyOf(array, 1);         }         array[0] = v;         if (array.length != 1) {             array[1] = null;         }         return array;     }'
b'@SuppressWarnings("unchecked")     @Nullable     public T getValue() {         Object o = value;         if (o != null && !NotificationLite.isError(o)) {             return (T)value;         }         return null;     }'
b'@Nullable     public Throwable getError() {         Object o = value;         if (NotificationLite.isError(o)) {             return NotificationLite.getError(o);         }         return null;     }'
b'@NonNull     public static <T> Notification<T> createOnNext(@NonNull T value) {         ObjectHelper.requireNonNull(value, "value is null");         return new Notification<T>(value);     }'
b'@NonNull     public static <T> Notification<T> createOnError(@NonNull Throwable error) {         ObjectHelper.requireNonNull(error, "error is null");         return new Notification<T>(NotificationLite.error(error));     }'
b'public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) {         ObjectHelper.requireNonNull(next, "next is null");         if (upstream != null) {             next.dispose();             if (upstream != DisposableHelper.DISPOSED) {                 reportDoubleSubscription(observer);             }             return false;         }         return true;     }'
b'public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) {         ObjectHelper.requireNonNull(next, "next is null");         if (!upstream.compareAndSet(null, next)) {             next.dispose();             if (upstream.get() != DisposableHelper.DISPOSED) {                 reportDoubleSubscription(observer);             }             return false;         }         return true;     }'
b'public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) {         ObjectHelper.requireNonNull(next, "next is null");         if (upstream != null) {             next.cancel();             if (upstream != SubscriptionHelper.CANCELLED) {                 reportDoubleSubscription(subscriber);             }             return false;         }         return true;     }'
b'public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) {         ObjectHelper.requireNonNull(next, "next is null");         if (!upstream.compareAndSet(null, next)) {             next.cancel();             if (upstream.get() != SubscriptionHelper.CANCELLED) {                 reportDoubleSubscription(subscriber);             }             return false;         }         return true;     }'
b'void add(CacheSubscription<T> consumer) {         for (;;) {             CacheSubscription<T>[] current = subscribers.get();             if (current == TERMINATED) {                 return;             }             int n = current.length;              @SuppressWarnings("unchecked")             CacheSubscription<T>[] next = new CacheSubscription[n + 1];             System.arraycopy(current, 0, next, 0, n);             next[n] = consumer;              if (subscribers.compareAndSet(current, next)) {                 return;             }         }     }'
b'@SuppressWarnings("unchecked")     void remove(CacheSubscription<T> consumer) {         for (;;) {             CacheSubscription<T>[] current = subscribers.get();             int n = current.length;             if (n == 0) {                 return;             }              int j = -1;             for (int i = 0; i < n; i++) {                 if (current[i] == consumer) {                     j = i;                     break;                 }             }              if (j < 0) {                 return;             }             CacheSubscription<T>[] next;              if (n == 1) {                 next = EMPTY;             } else {                 next = new CacheSubscription[n - 1];                 System.arraycopy(current, 0, next, 0, j);                 System.arraycopy(current, j + 1, next, j, n - j - 1);             }              if (subscribers.compareAndSet(current, next)) {                 return;             }         }     }'
b'void replay(CacheSubscription<T> consumer) {         // make sure there is only one replay going on at a time         if (consumer.getAndIncrement() != 0) {             return;         }          // see if there were more replay request in the meantime         int missed = 1;         // read out state into locals upfront to avoid being re-read due to volatile reads         long index = consumer.index;         int offset = consumer.offset;         Node<T> node = consumer.node;         AtomicLong requested = consumer.requested;         Subscriber<? super T> downstream = consumer.downstream;         int capacity = capacityHint;          for (;;) {             // first see if the source has terminated, read order matters!             boolean sourceDone = done;             // and if the number of items is the same as this consumer has received             boolean empty = size == index;              // if the source is done and we have all items so far, terminate the consumer             if (sourceDone && empty) {                 // release the node object to avoid leaks through retained consumers                 consumer.node = null;                 // if error is not null then the source failed                 Throwable ex = error;                 if (ex != null) {                     downstream.onError(ex);                 } else {                     downstream.onComplete();                 }                 return;             }              // there are still items not sent to the consumer             if (!empty) {                 // see how many items the consumer has requested in total so far                 long consumerRequested = requested.get();                 // MIN_VALUE indicates a cancelled consumer, we stop replaying                 if (consumerRequested == Long.MIN_VALUE) {                     // release the node object to avoid leaks through retained consumers                     consumer.node = null;                     return;                 }                 // if the consumer has requested more and there is more, we will emit an item                 if (consumerRequested != index) {                      // if the offset in the current node has reached the node capacity                     if (offset == capacity) {                         // switch to the subsequent node                         node = node.next;                         // reset the in-node offset                         offset = 0;                     }                      // emit the cached item                     downstream.onNext(node.values[offset]);                      // move the node offset forward                     offset++;                     // move the total consumed item count forward                     index++;                      // retry for the next item/terminal event if any                     continue;                 }             }              // commit the changed references back             consumer.index = index;             consumer.offset = offset;             consumer.node = node;             // release the changes and see if there were more replay request in the meantime             missed = consumer.addAndGet(-missed);             if (missed == 0) {                 break;             }         }     }'
b'public static long addCap(long a, long b) {         long u = a + b;         if (u < 0L) {             return Long.MAX_VALUE;         }         return u;     }'
b'public static long multiplyCap(long a, long b) {         long u = a * b;         if (((a | b) >>> 31) != 0) {             if (u / a != b) {                 return Long.MAX_VALUE;             }         }         return u;     }'
b'public static long add(AtomicLong requested, long n) {         for (;;) {             long r = requested.get();             if (r == Long.MAX_VALUE) {                 return Long.MAX_VALUE;             }             long u = addCap(r, n);             if (requested.compareAndSet(r, u)) {                 return r;             }         }     }'
b'public static long addCancel(AtomicLong requested, long n) {         for (;;) {             long r = requested.get();             if (r == Long.MIN_VALUE) {                 return Long.MIN_VALUE;             }             if (r == Long.MAX_VALUE) {                 return Long.MAX_VALUE;             }             long u = addCap(r, n);             if (requested.compareAndSet(r, u)) {                 return r;             }         }     }'
b'public static long produced(AtomicLong requested, long n) {         for (;;) {             long current = requested.get();             if (current == Long.MAX_VALUE) {                 return Long.MAX_VALUE;             }             long update = current - n;             if (update < 0L) {                 RxJavaPlugins.onError(new IllegalStateException("More produced than requested: " + update));                 update = 0L;             }             if (requested.compareAndSet(current, update)) {                 return update;             }         }     }'
b'public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {         final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();          BlockingObserver<T> bs = new BlockingObserver<T>(queue);         observer.onSubscribe(bs);          o.subscribe(bs);         for (;;) {             if (bs.isDisposed()) {                 break;             }             Object v = queue.poll();             if (v == null) {                 try {                     v = queue.take();                 } catch (InterruptedException ex) {                     bs.dispose();                     observer.onError(ex);                     return;                 }             }             if (bs.isDisposed()                     || o == BlockingObserver.TERMINATED                     || NotificationLite.acceptFull(v, observer)) {                 break;             }         }     }'
b'public static <T> void subscribe(ObservableSource<? extends T> o) {         BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();         LambdaObserver<T> ls = new LambdaObserver<T>(Functions.emptyConsumer(),         callback, callback, Functions.emptyConsumer());          o.subscribe(ls);          BlockingHelper.awaitForComplete(callback, ls);         Throwable e = callback.error;         if (e != null) {             throw ExceptionHelper.wrapOrThrow(e);         }     }'
b'public static <T> void subscribe(ObservableSource<? extends T> o, final Consumer<? super T> onNext,             final Consumer<? super Throwable> onError, final Action onComplete) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         subscribe(o, new LambdaObserver<T>(onNext, onError, onComplete, Functions.emptyConsumer()));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable concatArray(CompletableSource... sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         if (sources.length == 0) {             return complete();         } else         if (sources.length == 1) {             return wrap(sources[0]);         }         return RxJavaPlugins.onAssembly(new CompletableConcatArray(sources));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable concat(Iterable<? extends CompletableSource> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");          return RxJavaPlugins.onAssembly(new CompletableConcatIterable(sources));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public static Completable concat(Publisher<? extends CompletableSource> sources) {         return concat(sources, 2);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public static Completable concat(Publisher<? extends CompletableSource> sources, int prefetch) {         ObjectHelper.requireNonNull(sources, "sources is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new CompletableConcat(sources, prefetch));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable create(CompletableOnSubscribe source) {         ObjectHelper.requireNonNull(source, "source is null");         return RxJavaPlugins.onAssembly(new CompletableCreate(source));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable error(final Throwable error) {         ObjectHelper.requireNonNull(error, "error is null");         return RxJavaPlugins.onAssembly(new CompletableError(error));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable fromAction(final Action run) {         ObjectHelper.requireNonNull(run, "run is null");         return RxJavaPlugins.onAssembly(new CompletableFromAction(run));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable fromCallable(final Callable<?> callable) {         ObjectHelper.requireNonNull(callable, "callable is null");         return RxJavaPlugins.onAssembly(new CompletableFromCallable(callable));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable fromFuture(final Future<?> future) {         ObjectHelper.requireNonNull(future, "future is null");         return fromAction(Functions.futureAction(future));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Completable fromMaybe(final MaybeSource<T> maybe) {         ObjectHelper.requireNonNull(maybe, "maybe is null");         return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(maybe));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable fromRunnable(final Runnable run) {         ObjectHelper.requireNonNull(run, "run is null");         return RxJavaPlugins.onAssembly(new CompletableFromRunnable(run));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Completable fromSingle(final SingleSource<T> single) {         ObjectHelper.requireNonNull(single, "single is null");         return RxJavaPlugins.onAssembly(new CompletableFromSingle<T>(single));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable mergeArray(CompletableSource... sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         if (sources.length == 0) {             return complete();         } else         if (sources.length == 1) {             return wrap(sources[0]);         }         return RxJavaPlugins.onAssembly(new CompletableMergeArray(sources));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable merge(Iterable<? extends CompletableSource> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new CompletableMergeIterable(sources));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     public static Completable merge(Publisher<? extends CompletableSource> sources) {         return merge0(sources, Integer.MAX_VALUE, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public static Completable merge(Publisher<? extends CompletableSource> sources, int maxConcurrency) {         return merge0(sources, maxConcurrency, false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     public static Completable mergeDelayError(Publisher<? extends CompletableSource> sources) {         return merge0(sources, Integer.MAX_VALUE, true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public static Completable mergeDelayError(Publisher<? extends CompletableSource> sources, int maxConcurrency) {         return merge0(sources, maxConcurrency, true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable never() {         return RxJavaPlugins.onAssembly(CompletableNever.INSTANCE);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Completable timer(long delay, TimeUnit unit) {         return timer(delay, unit, Schedulers.computation());     }'
b'private static NullPointerException toNpe(Throwable ex) {         NullPointerException npe = new NullPointerException("Actually not, but can\'t pass out an exception otherwise...");         npe.initCause(ex);         return npe;     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <R> Completable using(Callable<R> resourceSupplier,             Function<? super R, ? extends CompletableSource> completableFunction,             Consumer<? super R> disposer) {         return using(resourceSupplier, completableFunction, disposer, true);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static Completable wrap(CompletableSource source) {         ObjectHelper.requireNonNull(source, "source is null");         if (source instanceof Completable) {             return RxJavaPlugins.onAssembly((Completable)source);         }         return RxJavaPlugins.onAssembly(new CompletableFromUnsafeSource(source));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable ambWith(CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return ambArray(this, other);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Observable<T> andThen(ObservableSource<T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return RxJavaPlugins.onAssembly(new CompletableAndThenObservable<T>(this, next));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Flowable<T> andThen(Publisher<T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return RxJavaPlugins.onAssembly(new CompletableAndThenPublisher<T>(this, next));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Single<T> andThen(SingleSource<T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable<T>(next, this));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Maybe<T> andThen(MaybeSource<T> next) {         ObjectHelper.requireNonNull(next, "next is null");         return RxJavaPlugins.onAssembly(new MaybeDelayWithCompletable<T>(next, this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable andThen(CompletableSource next) {         ObjectHelper.requireNonNull(next, "next is null");         return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, next));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> R as(@NonNull CompletableConverter<? extends R> converter) {         return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final void blockingAwait() {         BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();         subscribe(observer);         observer.blockingGet();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable compose(CompletableTransformer transformer) {         return wrap(ObjectHelper.requireNonNull(transformer, "transformer is null").apply(this));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable concatWith(CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable delay(long delay, TimeUnit unit, Scheduler scheduler) {         return delay(delay, unit, scheduler, false);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable delay(final long delay, final TimeUnit unit, final Scheduler scheduler, final boolean delayError) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new CompletableDelay(this, delay, unit, scheduler, delayError));     }'
b'@CheckReturnValue     @Experimental     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Completable delaySubscription(long delay, TimeUnit unit) {         return delaySubscription(delay, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @Experimental     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {         return Completable.timer(delay, unit, scheduler).andThen(this);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable doOnComplete(Action onComplete) {         return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),                 onComplete, Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable doOnDispose(Action onDispose) {         return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION, onDispose);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable doOnError(Consumer<? super Throwable> onError) {         return doOnLifecycle(Functions.emptyConsumer(), onError,                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     private Completable doOnLifecycle(             final Consumer<? super Disposable> onSubscribe,             final Consumer<? super Throwable> onError,             final Action onComplete,             final Action onTerminate,             final Action onAfterTerminate,             final Action onDispose) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");         ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");         ObjectHelper.requireNonNull(onDispose, "onDispose is null");         return RxJavaPlugins.onAssembly(new CompletablePeek(this, onSubscribe, onError, onComplete, onTerminate, onAfterTerminate, onDispose));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable doOnSubscribe(Consumer<? super Disposable> onSubscribe) {         return doOnLifecycle(onSubscribe, Functions.emptyConsumer(),                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable doOnTerminate(final Action onTerminate) {         return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),                 Functions.EMPTY_ACTION, onTerminate,                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable doAfterTerminate(final Action onAfterTerminate) {         return doOnLifecycle(                 Functions.emptyConsumer(),                 Functions.emptyConsumer(),                 Functions.EMPTY_ACTION,                 Functions.EMPTY_ACTION,                 onAfterTerminate,                 Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable observeOn(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new CompletableObserveOn(this, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable onErrorComplete(final Predicate<? super Throwable> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");          return RxJavaPlugins.onAssembly(new CompletableOnErrorComplete(this, predicate));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable onErrorResumeNext(final Function<? super Throwable, ? extends CompletableSource> errorMapper) {         ObjectHelper.requireNonNull(errorMapper, "errorMapper is null");         return RxJavaPlugins.onAssembly(new CompletableResumeNext(this, errorMapper));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable repeat(long times) {         return fromPublisher(toFlowable().repeat(times));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable repeatUntil(BooleanSupplier stop) {         return fromPublisher(toFlowable().repeatUntil(stop));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {         return fromPublisher(toFlowable().repeatWhen(handler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable retry(BiPredicate<? super Integer, ? super Throwable> predicate) {         return fromPublisher(toFlowable().retry(predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable retry(long times) {         return fromPublisher(toFlowable().retry(times));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable retry(long times, Predicate<? super Throwable> predicate) {         return fromPublisher(toFlowable().retry(times, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {         return fromPublisher(toFlowable().retryWhen(handler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Observable<T> startWith(Observable<T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return other.concatWith(this.<T>toObservable());     }'
b'@SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe() {         EmptyCompletableObserver observer = new EmptyCompletableObserver();         subscribe(observer);         return observer;     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <E extends CompletableObserver> E subscribeWith(E observer) {         subscribe(observer);         return observer;     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable subscribeOn(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");          return RxJavaPlugins.onAssembly(new CompletableSubscribeOn(this, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable takeUntil(CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");          return RxJavaPlugins.onAssembly(new CompletableTakeUntilCompletable(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Completable timeout(long timeout, TimeUnit unit) {         return timeout0(timeout, unit, Schedulers.computation(), null);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Completable timeout(long timeout, TimeUnit unit, CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return timeout0(timeout, unit, Schedulers.computation(), other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler) {         return timeout0(timeout, unit, scheduler, null);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return timeout0(timeout, unit, scheduler, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> U to(Function<? super Completable, U> converter) {         try {             return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);         } catch (Throwable ex) {             Exceptions.throwIfFatal(ex);             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@CheckReturnValue     @SuppressWarnings("unchecked")     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Flowable<T> toFlowable() {         if (this instanceof FuseToFlowable) {             return ((FuseToFlowable<T>)this).fuseToFlowable();         }         return RxJavaPlugins.onAssembly(new CompletableToFlowable<T>(this));     }'
b'@CheckReturnValue     @SuppressWarnings("unchecked")     @SchedulerSupport(SchedulerSupport.NONE)     public final <T> Maybe<T> toMaybe() {         if (this instanceof FuseToMaybe) {             return ((FuseToMaybe<T>)this).fuseToMaybe();         }         return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(this));     }'
b'static <T> boolean tryAsCompletable(Object source,             Function<? super T, ? extends CompletableSource> mapper,             CompletableObserver observer) {         if (source instanceof Callable) {             @SuppressWarnings("unchecked")             Callable<T> call = (Callable<T>) source;             CompletableSource cs = null;             try {                 T item = call.call();                 if (item != null) {                     cs = ObjectHelper.requireNonNull(mapper.apply(item), "The mapper returned a null CompletableSource");                 }             } catch (Throwable ex) {                 Exceptions.throwIfFatal(ex);                 EmptyDisposable.error(ex, observer);                 return true;             }              if (cs == null) {                 EmptyDisposable.complete(observer);             } else {                 cs.subscribe(observer);             }             return true;         }         return false;     }'
b'static <T, R> boolean tryAsMaybe(Object source,             Function<? super T, ? extends MaybeSource<? extends R>> mapper,             Observer<? super R> observer) {         if (source instanceof Callable) {             @SuppressWarnings("unchecked")             Callable<T> call = (Callable<T>) source;             MaybeSource<? extends R> cs = null;             try {                 T item = call.call();                 if (item != null) {                     cs = ObjectHelper.requireNonNull(mapper.apply(item), "The mapper returned a null MaybeSource");                 }             } catch (Throwable ex) {                 Exceptions.throwIfFatal(ex);                 EmptyDisposable.error(ex, observer);                 return true;             }              if (cs == null) {                 EmptyDisposable.complete(observer);             } else {                 cs.subscribe(MaybeToObservable.create(observer));             }             return true;         }         return false;     }'
b'public void add(Object o) {         // if no value yet, create the first array         if (size == 0) {             head = new Object[capacityHint + 1];             tail = head;             head[0] = o;             indexInTail = 1;             size = 1;         } else         // if the tail is full, create a new tail and link         if (indexInTail == capacityHint) {             Object[] t = new Object[capacityHint + 1];             t[0] = o;             tail[capacityHint] = t;             tail = t;             indexInTail = 1;             size++;         } else {             tail[indexInTail] = o;             indexInTail++;             size++;         }     }'
b'public static void shutdown() {         ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null);         if (exec != null) {             exec.shutdownNow();         }         POOLS.clear();     }'
b'public static ScheduledExecutorService create(ThreadFactory factory) {         final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);         tryPutIntoPool(PURGE_ENABLED, exec);         return exec;     }'
b'public final void setSubscription(Subscription s) {         if (cancelled) {             s.cancel();             return;         }          ObjectHelper.requireNonNull(s, "s is null");          if (get() == 0 && compareAndSet(0, 1)) {             Subscription a = actual;              if (a != null && cancelOnReplace) {                 a.cancel();             }              actual = s;              long r = requested;              if (decrementAndGet() != 0) {                 drainLoop();             }              if (r != 0L) {                 s.request(r);             }              return;         }          Subscription a = missedSubscription.getAndSet(s);         if (a != null && cancelOnReplace) {             a.cancel();         }         drain();     }'
b'void emitLoop() {         for (;;) {             AppendOnlyLinkedArrayList<Object> q;             synchronized (this) {                 q = queue;                 if (q == null) {                     emitting = false;                     return;                 }                 queue = null;             }             q.forEachWhile(this);         }     }'
b'@Override     protected void subscribeActual(SingleObserver<? super T> observer) {         source.subscribe(new LastSubscriber<T>(observer, defaultItem));     }'
b'public static void throwIfFatal(@NonNull Throwable t) {         // values here derived from https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495         if (t instanceof VirtualMachineError) {             throw (VirtualMachineError) t;         } else if (t instanceof ThreadDeath) {             throw (ThreadDeath) t;         } else if (t instanceof LinkageError) {             throw (LinkageError) t;         }     }'
b'public static RuntimeException wrapOrThrow(Throwable error) {         if (error instanceof Error) {             throw (Error)error;         }         if (error instanceof RuntimeException) {             return (RuntimeException)error;         }         return new RuntimeException(error);     }'
b'public static List<Throwable> flatten(Throwable t) {         List<Throwable> list = new ArrayList<Throwable>();         ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>();         deque.offer(t);          while (!deque.isEmpty()) {             Throwable e = deque.removeFirst();             if (e instanceof CompositeException) {                 CompositeException ce = (CompositeException) e;                 List<Throwable> exceptions = ce.getExceptions();                 for (int i = exceptions.size() - 1; i >= 0; i--) {                     deque.offerFirst(exceptions.get(i));                 }             } else {                 list.add(e);             }         }          return list;     }'
b'@SuppressWarnings("unchecked")     public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E {         if (e instanceof Exception) {             return (Exception)e;         }         throw (E)e;     }'
b'void add(CacheDisposable<T> consumer) {         for (;;) {             CacheDisposable<T>[] current = observers.get();             if (current == TERMINATED) {                 return;             }             int n = current.length;              @SuppressWarnings("unchecked")             CacheDisposable<T>[] next = new CacheDisposable[n + 1];             System.arraycopy(current, 0, next, 0, n);             next[n] = consumer;              if (observers.compareAndSet(current, next)) {                 return;             }         }     }'
b'@SuppressWarnings("unchecked")     void remove(CacheDisposable<T> consumer) {         for (;;) {             CacheDisposable<T>[] current = observers.get();             int n = current.length;             if (n == 0) {                 return;             }              int j = -1;             for (int i = 0; i < n; i++) {                 if (current[i] == consumer) {                     j = i;                     break;                 }             }              if (j < 0) {                 return;             }             CacheDisposable<T>[] next;              if (n == 1) {                 next = EMPTY;             } else {                 next = new CacheDisposable[n - 1];                 System.arraycopy(current, 0, next, 0, j);                 System.arraycopy(current, j + 1, next, j, n - j - 1);             }              if (observers.compareAndSet(current, next)) {                 return;             }         }     }'
b'void replay(CacheDisposable<T> consumer) {         // make sure there is only one replay going on at a time         if (consumer.getAndIncrement() != 0) {             return;         }          // see if there were more replay request in the meantime         int missed = 1;         // read out state into locals upfront to avoid being re-read due to volatile reads         long index = consumer.index;         int offset = consumer.offset;         Node<T> node = consumer.node;         Observer<? super T> downstream = consumer.downstream;         int capacity = capacityHint;          for (;;) {             // if the consumer got disposed, clear the node and quit             if (consumer.disposed) {                 consumer.node = null;                 return;             }              // first see if the source has terminated, read order matters!             boolean sourceDone = done;             // and if the number of items is the same as this consumer has received             boolean empty = size == index;              // if the source is done and we have all items so far, terminate the consumer             if (sourceDone && empty) {                 // release the node object to avoid leaks through retained consumers                 consumer.node = null;                 // if error is not null then the source failed                 Throwable ex = error;                 if (ex != null) {                     downstream.onError(ex);                 } else {                     downstream.onComplete();                 }                 return;             }              // there are still items not sent to the consumer             if (!empty) {              // if the offset in the current node has reached the node capacity                 if (offset == capacity) {                     // switch to the subsequent node                     node = node.next;                     // reset the in-node offset                     offset = 0;                 }                  // emit the cached item                 downstream.onNext(node.values[offset]);                  // move the node offset forward                 offset++;                 // move the total consumed item count forward                 index++;                  // retry for the next item/terminal event if any                 continue;             }              // commit the changed references back             consumer.index = index;             consumer.offset = offset;             consumer.node = node;             // release the changes and see if there were more replay request in the meantime             missed = consumer.addAndGet(-missed);             if (missed == 0) {                 break;             }         }     }'
b'@Benchmark     public void oneStreamOfNthatMergesIn1(final InputMillion input) throws InterruptedException {         Flowable<Flowable<Integer>> os = Flowable.range(1, input.size)                 .map(new Function<Integer, Flowable<Integer>>() {                     @Override                     public Flowable<Integer> apply(Integer v) {                         return Flowable.just(v);                     }                 });         PerfSubscriber o = input.newLatchedObserver();         Flowable.merge(os).subscribe(o);          if (input.size == 1) {             while (o.latch.getCount() != 0) { }         } else {             o.latch.await();         }     }'
b'@Override     public boolean add(@NonNull Disposable disposable) {         ObjectHelper.requireNonNull(disposable, "disposable is null");         if (!disposed) {             synchronized (this) {                 if (!disposed) {                     OpenHashSet<Disposable> set = resources;                     if (set == null) {                         set = new OpenHashSet<Disposable>();                         resources = set;                     }                     set.add(disposable);                     return true;                 }             }         }         disposable.dispose();         return false;     }'
b'public boolean addAll(@NonNull Disposable... disposables) {         ObjectHelper.requireNonNull(disposables, "disposables is null");         if (!disposed) {             synchronized (this) {                 if (!disposed) {                     OpenHashSet<Disposable> set = resources;                     if (set == null) {                         set = new OpenHashSet<Disposable>(disposables.length + 1);                         resources = set;                     }                     for (Disposable d : disposables) {                         ObjectHelper.requireNonNull(d, "A Disposable in the disposables array is null");                         set.add(d);                     }                     return true;                 }             }         }         for (Disposable d : disposables) {             d.dispose();         }         return false;     }'
b'@Override     public boolean remove(@NonNull Disposable disposable) {         if (delete(disposable)) {             disposable.dispose();             return true;         }         return false;     }'
b'@Override     public boolean delete(@NonNull Disposable disposable) {         ObjectHelper.requireNonNull(disposable, "disposables is null");         if (disposed) {             return false;         }         synchronized (this) {             if (disposed) {                 return false;             }              OpenHashSet<Disposable> set = resources;             if (set == null || !set.remove(disposable)) {                 return false;             }         }         return true;     }'
b'public void clear() {         if (disposed) {             return;         }         OpenHashSet<Disposable> set;         synchronized (this) {             if (disposed) {                 return;             }              set = resources;             resources = null;         }          dispose(set);     }'
b'public int size() {         if (disposed) {             return 0;         }         synchronized (this) {             if (disposed) {                 return 0;             }             OpenHashSet<Disposable> set = resources;             return set != null ? set.size() : 0;         }     }'
b'public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T> subscriber) {         final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();          BlockingSubscriber<T> bs = new BlockingSubscriber<T>(queue);          o.subscribe(bs);          try {             for (;;) {                 if (bs.isCancelled()) {                     break;                 }                 Object v = queue.poll();                 if (v == null) {                     if (bs.isCancelled()) {                         break;                     }                     BlockingHelper.verifyNonBlocking();                     v = queue.take();                 }                 if (bs.isCancelled()) {                     break;                 }                 if (v == BlockingSubscriber.TERMINATED                         || NotificationLite.acceptFull(v, subscriber)) {                     break;                 }             }         } catch (InterruptedException e) {             bs.cancel();             subscriber.onError(e);         }     }'
b'public static <T> void subscribe(Publisher<? extends T> o) {         BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();         LambdaSubscriber<T> ls = new LambdaSubscriber<T>(Functions.emptyConsumer(),         callback, callback, Functions.REQUEST_MAX);          o.subscribe(ls);          BlockingHelper.awaitForComplete(callback, ls);         Throwable e = callback.error;         if (e != null) {             throw ExceptionHelper.wrapOrThrow(e);         }     }'
b'public static <T> void subscribe(Publisher<? extends T> o, final Consumer<? super T> onNext,             final Consumer<? super Throwable> onError, final Action onComplete) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         subscribe(o, new LambdaSubscriber<T>(onNext, onError, onComplete, Functions.REQUEST_MAX));     }'
b'public static <T> void subscribe(Publisher<? extends T> o, final Consumer<? super T> onNext,         final Consumer<? super Throwable> onError, final Action onComplete, int bufferSize) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         ObjectHelper.verifyPositive(bufferSize, "number > 0 required");         subscribe(o, new BoundedSubscriber<T>(onNext, onError, onComplete, Functions.boundedConsumer(bufferSize),                 bufferSize));     }'
b'public final void add(@NonNull Disposable resource) {         ObjectHelper.requireNonNull(resource, "resource is null");         resources.add(resource);     }'
b'@SuppressWarnings("unchecked")     public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source,             Observer<? super R> observer,             Function<? super T, ? extends ObservableSource<? extends R>> mapper) {         if (source instanceof Callable) {             T t;              try {                 t = ((Callable<T>)source).call();             } catch (Throwable ex) {                 Exceptions.throwIfFatal(ex);                 EmptyDisposable.error(ex, observer);                 return true;             }              if (t == null) {                 EmptyDisposable.complete(observer);                 return true;             }              ObservableSource<? extends R> r;              try {                 r = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null ObservableSource");             } catch (Throwable ex) {                 Exceptions.throwIfFatal(ex);                 EmptyDisposable.error(ex, observer);                 return true;             }              if (r instanceof Callable) {                 R u;                  try {                     u = ((Callable<R>)r).call();                 } catch (Throwable ex) {                     Exceptions.throwIfFatal(ex);                     EmptyDisposable.error(ex, observer);                     return true;                 }                  if (u == null) {                     EmptyDisposable.complete(observer);                     return true;                 }                 ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u);                 observer.onSubscribe(sd);                 sd.run();             } else {                 r.subscribe(observer);             }              return true;         }         return false;     }'
b'public static <T, U> Observable<U> scalarXMap(T value,             Function<? super T, ? extends ObservableSource<? extends U>> mapper) {         return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper));     }'
b'public static <T> MaybeObserver<T> create(Observer<? super T> downstream) {         return new MaybeToObservableObserver<T>(downstream);     }'
b'@NonNull     @Experimental     public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker) {         return new ExecutorScheduler(executor, interruptibleWorker);     }'
b'public static void shutdown() {         computation().shutdown();         io().shutdown();         newThread().shutdown();         single().shutdown();         trampoline().shutdown();         SchedulerPoolFactory.shutdown();     }'
b'public void add(T value) {         final int c = capacity;         int o = offset;         if (o == c) {             Object[] next = new Object[c + 1];             tail[c] = next;             tail = next;             o = 0;         }         tail[o] = value;         offset = o + 1;     }'
b'@SuppressWarnings("unchecked")     public void forEachWhile(NonThrowingPredicate<? super T> consumer) {         Object[] a = head;         final int c = capacity;         while (a != null) {             for (int i = 0; i < c; i++) {                 Object o = a[i];                 if (o == null) {                     break;                 }                 if (consumer.test((T)o)) {                     return;                 }             }             a = (Object[])a[c];         }     }'
b'public <U> boolean accept(Subscriber<? super U> subscriber) {         Object[] a = head;         final int c = capacity;         while (a != null) {             for (int i = 0; i < c; i++) {                 Object o = a[i];                 if (o == null) {                     break;                 }                  if (NotificationLite.acceptFull(o, subscriber)) {                     return true;                 }             }             a = (Object[])a[c];         }         return false;     }'
b'public <U> boolean accept(Observer<? super U> observer) {         Object[] a = head;         final int c = capacity;         while (a != null) {             for (int i = 0; i < c; i++) {                 Object o = a[i];                 if (o == null) {                     break;                 }                  if (NotificationLite.acceptFull(o, observer)) {                     return true;                 }             }             a = (Object[])a[c];         }         return false;     }'
b'@SuppressWarnings("unchecked")     public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Exception {         Object[] a = head;         final int c = capacity;         for (;;) {             for (int i = 0; i < c; i++) {                 Object o = a[i];                 if (o == null) {                     return;                 }                 if (consumer.test(state, (T)o)) {                     return;                 }             }             a = (Object[])a[c];         }     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> amb(final Iterable<? extends SingleSource<? extends T>> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new SingleAmb<T>(null, sources));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Single<T> ambArray(final SingleSource<? extends T>... sources) {         if (sources.length == 0) {             return error(SingleInternalHelper.<T>emptyThrower());         }         if (sources.length == 1) {             return wrap((SingleSource<T>)sources[0]);         }         return RxJavaPlugins.onAssembly(new SingleAmb<T>(sources, null));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings({ "unchecked", "rawtypes" })     public static <T> Flowable<T> concatArray(SingleSource<? extends T>... sources) {         return RxJavaPlugins.onAssembly(new FlowableConcatMap(Flowable.fromArray(sources), SingleInternalHelper.toFlowable(), 2, ErrorMode.BOUNDARY));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> defer(final Callable<? extends SingleSource<? extends T>> singleSupplier) {         ObjectHelper.requireNonNull(singleSupplier, "singleSupplier is null");         return RxJavaPlugins.onAssembly(new SingleDefer<T>(singleSupplier));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> error(final Callable<? extends Throwable> errorSupplier) {         ObjectHelper.requireNonNull(errorSupplier, "errorSupplier is null");         return RxJavaPlugins.onAssembly(new SingleError<T>(errorSupplier));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> fromCallable(final Callable<? extends T> callable) {         ObjectHelper.requireNonNull(callable, "callable is null");         return RxJavaPlugins.onAssembly(new SingleFromCallable<T>(callable));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> fromFuture(Future<? extends T> future) {         return toSingle(Flowable.<T>fromFuture(future));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {         return toSingle(Flowable.<T>fromFuture(future, timeout, unit));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static <T> Single<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {         return toSingle(Flowable.<T>fromFuture(future, timeout, unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings({ "unchecked", "rawtypes" })     public static <T> Single<T> merge(SingleSource<? extends SingleSource<? extends T>> source) {         ObjectHelper.requireNonNull(source, "source is null");         return RxJavaPlugins.onAssembly(new SingleFlatMap<SingleSource<? extends T>, T>(source, (Function)Functions.identity()));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings({ "unchecked", "rawtypes" })     public static <T> Flowable<T> mergeDelayError(Publisher<? extends SingleSource<? extends T>> sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, SingleInternalHelper.toFlowable(), true, Integer.MAX_VALUE, Flowable.bufferSize()));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Single<T> never() {         return RxJavaPlugins.onAssembly((Single<T>) SingleNever.INSTANCE);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Single<Long> timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new SingleTimer(delay, unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<T> unsafeCreate(SingleSource<T> onSubscribe) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         if (onSubscribe instanceof Single) {             throw new IllegalArgumentException("unsafeCreate(Single) should be upgraded");         }         return RxJavaPlugins.onAssembly(new SingleFromUnsafeSource<T>(onSubscribe));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, U> Single<T> using(Callable<U> resourceSupplier,                                          Function<? super U, ? extends SingleSource<? extends T>> singleFunction,                                          Consumer<? super U> disposer) {         return using(resourceSupplier, singleFunction, disposer, true);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> R as(@NonNull SingleConverter<T, ? extends R> converter) {         return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> hide() {         return RxJavaPlugins.onAssembly(new SingleHide<T>(this));     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> compose(SingleTransformer<? super T, ? extends R> transformer) {         return wrap(((SingleTransformer<T, R>) ObjectHelper.requireNonNull(transformer, "transformer is null")).apply(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> cache() {         return RxJavaPlugins.onAssembly(new SingleCache<T>(this));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> concatWith(SingleSource<? extends T> other) {         return concat(this, other);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Single<T> delay(long time, TimeUnit unit) {         return delay(time, unit, Schedulers.computation(), false);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler) {         return delay(time, unit, scheduler, false);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler, boolean delayError) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new SingleDelay<T>(this, time, unit, scheduler, delayError));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> delaySubscription(CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable<T>(this, other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Single<T> delaySubscription(long time, TimeUnit unit) {         return delaySubscription(time, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> delaySubscription(long time, TimeUnit unit, Scheduler scheduler) {         return delaySubscription(Observable.timer(time, unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     @Experimental     public final <R> Maybe<R> dematerialize(Function<? super T, Notification<R>> selector) {         ObjectHelper.requireNonNull(selector, "selector is null");         return RxJavaPlugins.onAssembly(new SingleDematerialize<T, R>(this, selector));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) {         ObjectHelper.requireNonNull(onAfterSuccess, "onAfterSuccess is null");         return RxJavaPlugins.onAssembly(new SingleDoAfterSuccess<T>(this, onAfterSuccess));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doAfterTerminate(Action onAfterTerminate) {         ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");         return RxJavaPlugins.onAssembly(new SingleDoAfterTerminate<T>(this, onAfterTerminate));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doFinally(Action onFinally) {         ObjectHelper.requireNonNull(onFinally, "onFinally is null");         return RxJavaPlugins.onAssembly(new SingleDoFinally<T>(this, onFinally));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doOnSubscribe(final Consumer<? super Disposable> onSubscribe) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         return RxJavaPlugins.onAssembly(new SingleDoOnSubscribe<T>(this, onSubscribe));     }'
b'@Experimental     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doOnTerminate(final Action onTerminate) {         ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");         return RxJavaPlugins.onAssembly(new SingleDoOnTerminate<T>(this, onTerminate));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doOnSuccess(final Consumer<? super T> onSuccess) {         ObjectHelper.requireNonNull(onSuccess, "onSuccess is null");         return RxJavaPlugins.onAssembly(new SingleDoOnSuccess<T>(this, onSuccess));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doOnError(final Consumer<? super Throwable> onError) {         ObjectHelper.requireNonNull(onError, "onError is null");         return RxJavaPlugins.onAssembly(new SingleDoOnError<T>(this, onError));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> doOnDispose(final Action onDispose) {         ObjectHelper.requireNonNull(onDispose, "onDispose is null");         return RxJavaPlugins.onAssembly(new SingleDoOnDispose<T>(this, onDispose));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> flatMap(Function<? super T, ? extends SingleSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new SingleFlatMap<T, R>(this, mapper));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Maybe<R> flatMapMaybe(final Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new SingleFlatMapMaybe<T, R>(this, mapper));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Observable<R> flatMapObservable(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new SingleFlatMapObservable<T, R>(this, mapper));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> lift(final SingleOperator<? extends R, ? super T> lift) {         ObjectHelper.requireNonNull(lift, "lift is null");         return RxJavaPlugins.onAssembly(new SingleLift<T, R>(this, lift));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> map(Function<? super T, ? extends R> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new SingleMap<T, R>(this, mapper));     }'
b'@Experimental     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Notification<T>> materialize() {         return RxJavaPlugins.onAssembly(new SingleMaterialize<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> contains(Object value) {         return contains(value, ObjectHelper.equalsPredicate());     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> mergeWith(SingleSource<? extends T> other) {         return merge(this, other);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> observeOn(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new SingleObserveOn<T>(this, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> onErrorReturn(final Function<Throwable, ? extends T> resumeFunction) {         ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");         return RxJavaPlugins.onAssembly(new SingleOnErrorReturn<T>(this, resumeFunction, null));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> onTerminateDetach() {         return RxJavaPlugins.onAssembly(new SingleDetach<T>(this));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> repeat() {         return toFlowable().repeat();     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> retry() {         return toSingle(toFlowable().retry());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {         return toSingle(toFlowable().retry(predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> retry(long times, Predicate<? super Throwable> predicate) {         return toSingle(toFlowable().retry(times, predicate));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {         return toSingle(toFlowable().retryWhen(handler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(Consumer<? super T> onSuccess) {         return subscribe(onSuccess, Functions.ON_ERROR_MISSING);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(final Consumer<? super T> onSuccess, final Consumer<? super Throwable> onError) {         ObjectHelper.requireNonNull(onSuccess, "onSuccess is null");         ObjectHelper.requireNonNull(onError, "onError is null");          ConsumerSingleObserver<T> observer = new ConsumerSingleObserver<T>(onSuccess, onError);         subscribe(observer);         return observer;     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <E extends SingleObserver<? super T>> E subscribeWith(E observer) {         subscribe(observer);         return observer;     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> subscribeOn(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new SingleSubscribeOn<T>(this, scheduler));     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> takeUntil(final CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return takeUntil(new CompletableToFlowable<T>(other));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Single<T> timeout(long timeout, TimeUnit unit) {         return timeout0(timeout, unit, Schedulers.computation(), null);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> timeout(long timeout, TimeUnit unit, Scheduler scheduler) {         return timeout0(timeout, unit, scheduler, null);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @Deprecated     public final Completable toCompletable() {         return RxJavaPlugins.onAssembly(new CompletableFromSingle<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final Future<T> toFuture() {         return subscribeWith(new FutureSingleObserver<T>());     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Single<T> unsubscribeOn(final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new SingleUnsubscribeOn<T>(this, scheduler));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Single<R> zipWith(SingleSource<U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {         return zip(this, other, zipper);     }'
b'@CheckReturnValue     @NonNull     public static <T> MulticastProcessor<T> create() {         return new MulticastProcessor<T>(bufferSize(), false);     }'
b'@CheckReturnValue     @NonNull     public static <T> MulticastProcessor<T> create(boolean refCount) {         return new MulticastProcessor<T>(bufferSize(), refCount);     }'
b'public void start() {         if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {             queue = new SpscArrayQueue<T>(bufferSize);         }     }'
b'public void startUnbounded() {         if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {             queue = new SpscLinkedArrayQueue<T>(bufferSize);         }     }'
b'public boolean offer(T t) {         if (once.get()) {             return false;         }         ObjectHelper.requireNonNull(t, "offer called with null. Null values are generally not allowed in 2.x operators and sources.");         if (fusionMode == QueueSubscription.NONE) {             if (queue.offer(t)) {                 drain();                 return true;             }         }         return false;     }'
b'@Override     public boolean offer(final T e) {         if (null == e) {             throw new NullPointerException("Null is not a valid element");         }         // local load of field to avoid repeated loads after volatile reads         final AtomicReferenceArray<Object> buffer = producerBuffer;         final long index = lpProducerIndex();         final int mask = producerMask;         final int offset = calcWrappedOffset(index, mask);         if (index < producerLookAhead) {             return writeToQueue(buffer, e, index, offset);         } else {             final int lookAheadStep = producerLookAheadStep;             // go around the buffer or resize if full (unless we hit max capacity)             int lookAheadElementOffset = calcWrappedOffset(index + lookAheadStep, mask);             if (null == lvElement(buffer, lookAheadElementOffset)) { // LoadLoad                 producerLookAhead = index + lookAheadStep - 1; // joy, there\'s plenty of room                 return writeToQueue(buffer, e, index, offset);             } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full                 return writeToQueue(buffer, e, index, offset);             } else {                 resize(buffer, index, offset, e, mask); // add a buffer and link old to new                 return true;             }         }     }'
b'@Nullable     @SuppressWarnings("unchecked")     @Override     public T poll() {         // local load of field to avoid repeated loads after volatile reads         final AtomicReferenceArray<Object> buffer = consumerBuffer;         final long index = lpConsumerIndex();         final int mask = consumerMask;         final int offset = calcWrappedOffset(index, mask);         final Object e = lvElement(buffer, offset); // LoadLoad         boolean isNextBuffer = e == HAS_NEXT;         if (null != e && !isNextBuffer) {             soElement(buffer, offset, null); // StoreStore             soConsumerIndex(index + 1); // this ensures correctness on 32bit platforms             return (T) e;         } else if (isNextBuffer) {             return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);         }          return null;     }'
b'@Override     public boolean offer(T first, T second) {         final AtomicReferenceArray<Object> buffer = producerBuffer;         final long p = lvProducerIndex();         final int m = producerMask;          int pi = calcWrappedOffset(p + 2, m);          if (null == lvElement(buffer, pi)) {             pi = calcWrappedOffset(p, m);             soElement(buffer, pi + 1, second);             soElement(buffer, pi, first);             soProducerIndex(p + 2);         } else {             final int capacity = buffer.length();             final AtomicReferenceArray<Object> newBuffer = new AtomicReferenceArray<Object>(capacity);             producerBuffer = newBuffer;              pi = calcWrappedOffset(p, m);             soElement(newBuffer, pi + 1, second); // StoreStore             soElement(newBuffer, pi, first);             soNext(buffer, newBuffer);              soElement(buffer, pi, HAS_NEXT); // new buffer is visible after element is              soProducerIndex(p + 2); // this ensures correctness on 32bit platforms         }          return true;     }'
b'@Nullable     public Disposable get() {         Disposable d = resource.get();         if (d == DisposableHelper.DISPOSED) {             return Disposables.disposed();         }         return d;     }'
b'public static <T> ConnectableObservable<T> create(ObservableSource<T> source) {         // the current connection to source needs to be shared between the operator and its onSubscribe call         final AtomicReference<PublishObserver<T>> curr = new AtomicReference<PublishObserver<T>>();         ObservableSource<T> onSubscribe = new PublishSource<T>(curr);         return RxJavaPlugins.onAssembly(new ObservablePublish<T>(onSubscribe, source, curr));     }'
b'public final void complete(T value) {         int state = get();         if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {             return;         }         Observer<? super T> a = downstream;         if (state == FUSED_EMPTY) {             this.value = value;             lazySet(FUSED_READY);             a.onNext(null);         } else {             lazySet(TERMINATED);             a.onNext(value);         }         if (get() != DISPOSED) {             a.onComplete();         }     }'
b'public final void error(Throwable t) {         int state = get();         if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {             RxJavaPlugins.onError(t);             return;         }         lazySet(TERMINATED);         downstream.onError(t);     }'
b'public final void complete() {         int state = get();         if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {             return;         }         lazySet(TERMINATED);         downstream.onComplete();     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {         return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {         if (sources.length == 0) {             return empty();         } else         if (sources.length == 1) {             return fromPublisher(sources[0]);         }         return RxJavaPlugins.onAssembly(new FlowableConcatArray<T>(sources, false));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings({ "rawtypes", "unchecked" })     public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {         ObjectHelper.requireNonNull(sources, "sources is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public static <T> Flowable<T> concatArrayEagerDelayError(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {         return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, true);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {         return concatDelayError(sources, bufferSize(), true);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {         return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, BackpressureStrategy mode) {         ObjectHelper.requireNonNull(source, "source is null");         ObjectHelper.requireNonNull(mode, "mode is null");         return RxJavaPlugins.onAssembly(new FlowableCreate<T>(source, mode));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Flowable<T> empty() {         return RxJavaPlugins.onAssembly((Flowable<T>) FlowableEmpty.INSTANCE);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {         ObjectHelper.requireNonNull(supplier, "supplier is null");         return RxJavaPlugins.onAssembly(new FlowableError<T>(supplier));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {         ObjectHelper.requireNonNull(source, "source is null");         return RxJavaPlugins.onAssembly(new FlowableFromIterable<T>(source));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {         return generate(initialState, generator, Functions.emptyConsumer());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Flowable<Long> interval(long period, TimeUnit unit) {         return interval(period, period, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {         return interval(period, period, unit, scheduler);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {         return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {         if (count < 0L) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }         if (count == 0L) {             return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);         }          long end = start + (count - 1);         if (start > 0 && end < 0) {             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");         }         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");          return RxJavaPlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> just(T item) {         ObjectHelper.requireNonNull(item, "item is null");         return RxJavaPlugins.onAssembly(new FlowableJust<T>(item));     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {         return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> merge(             Publisher<? extends T> source1, Publisher<? extends T> source2,             Publisher<? extends T> source3, Publisher<? extends T> source4) {         ObjectHelper.requireNonNull(source1, "source1 is null");         ObjectHelper.requireNonNull(source2, "source2 is null");         ObjectHelper.requireNonNull(source3, "source3 is null");         ObjectHelper.requireNonNull(source4, "source4 is null");         return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {         return fromIterable(sources).flatMap((Function)Functions.identity(), true);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     @SuppressWarnings("unchecked")     public static <T> Flowable<T> never() {         return RxJavaPlugins.onAssembly((Flowable<T>) FlowableNever.INSTANCE);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static Flowable<Integer> range(int start, int count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         } else         if (count == 0) {             return empty();         } else         if (count == 1) {             return just(start);         } else         if ((long)start + (count - 1) > Integer.MAX_VALUE) {             throw new IllegalArgumentException("Integer overflow");         }         return RxJavaPlugins.onAssembly(new FlowableRange(start, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static Flowable<Long> rangeLong(long start, long count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }          if (count == 0) {             return empty();         }          if (count == 1) {             return just(start);         }          long end = start + (count - 1);         if (start > 0 && end < 0) {             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");         }          return RxJavaPlugins.onAssembly(new FlowableRangeLong(start, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,             BiPredicate<? super T, ? super T> isEqual) {         return sequenceEqual(source1, source2, isEqual, bufferSize());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,             BiPredicate<? super T, ? super T> isEqual, int bufferSize) {         ObjectHelper.requireNonNull(source1, "source1 is null");         ObjectHelper.requireNonNull(source2, "source2 is null");         ObjectHelper.requireNonNull(isEqual, "isEqual is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new FlowableSequenceEqualSingle<T>(source1, source2, isEqual, bufferSize));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {         return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);     }'
b'@SuppressWarnings({ "unchecked", "rawtypes" })     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {         return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {         return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public static Flowable<Long> timer(long delay, TimeUnit unit) {         return timer(delay, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.NONE)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> unsafeCreate(Publisher<T> onSubscribe) {         ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");         if (onSubscribe instanceof Flowable) {             throw new IllegalArgumentException("unsafeCreate(Flowable) should be upgraded");         }         return RxJavaPlugins.onAssembly(new FlowableFromPublisher<T>(onSubscribe));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,             Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {         return using(resourceSupplier, sourceSupplier, resourceDisposer, true);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {         ObjectHelper.requireNonNull(zipper, "zipper is null");         ObjectHelper.requireNonNull(sources, "sources is null");         return RxJavaPlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false));     }'
b'@SuppressWarnings({ "rawtypes", "unchecked", "cast" })     @CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,             final Function<? super Object[], ? extends R> zipper) {         ObjectHelper.requireNonNull(zipper, "zipper is null");         return fromPublisher(sources).toList().flatMapPublisher((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> R as(@NonNull FlowableConverter<T, ? extends R> converter) {         return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingFirst() {         BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();         subscribe(s);         T v = s.blockingGet();         if (v != null) {             return v;         }         throw new NoSuchElementException();     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Iterable<T> blockingIterable() {         return blockingIterable(bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Iterable<T> blockingIterable(int bufferSize) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return new BlockingFlowableIterable<T>(this, bufferSize);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingLast() {         BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();         subscribe(s);         T v = s.blockingGet();         if (v != null) {             return v;         }         throw new NoSuchElementException();     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Iterable<T> blockingMostRecent(T initialItem) {         return new BlockingFlowableMostRecent<T>(this, initialItem);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Iterable<T> blockingNext() {         return new BlockingFlowableNext<T>(this);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingSingle() {         return singleOrError().blockingGet();     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final T blockingSingle(T defaultItem) {         return single(defaultItem).blockingGet();     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Future<T> toFuture() {         return subscribeWith(new FutureSubscriber<T>());     }'
b'@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Consumer<? super T> onNext) {         FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete,         int bufferSize) {         FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete, bufferSize);     }'
b'@BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public final void blockingSubscribe(Subscriber<? super T> subscriber) {         FlowableBlockingSubscribe.subscribe(this, subscriber);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<List<T>> buffer(int count) {         return buffer(count, count);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<List<T>> buffer(int count, int skip) {         return buffer(count, skip, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {         ObjectHelper.verifyPositive(count, "count");         ObjectHelper.verifyPositive(skip, "skip");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new FlowableBuffer<T, U>(this, count, skip, bufferSupplier));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {         return buffer(count, count, bufferSupplier);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {         return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit,             Scheduler scheduler, Callable<U> bufferSupplier) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {         return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {         return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final <U extends Collection<? super T>> Flowable<U> buffer(             long timespan, TimeUnit unit,             Scheduler scheduler, int count,             Callable<U> bufferSupplier,             boolean restartTimerOnMaxSize) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         ObjectHelper.verifyPositive(count, "count");         return RxJavaPlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <TOpening, TClosing> Flowable<List<T>> buffer(             Flowable<? extends TOpening> openingIndicator,             Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {         return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(             Flowable<? extends TOpening> openingIndicator,             Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,             Callable<U> bufferSupplier) {         ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");         ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {         return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {         ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");         return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {         ObjectHelper.requireNonNull(boundaryIndicator, "boundaryIndicator is null");         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");         return RxJavaPlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> cache() {         return cacheWithInitialCapacity(16);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> cacheWithInitialCapacity(int initialCapacity) {         ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");         return RxJavaPlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Single<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {         ObjectHelper.requireNonNull(initialItemSupplier, "initialItemSupplier is null");         ObjectHelper.requireNonNull(collector, "collector is null");         return RxJavaPlugins.onAssembly(new FlowableCollectSingle<T, U>(this, initialItemSupplier, collector));     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {         return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, "composer is null")).apply(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public final Completable concatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {         return concatMapCompletable(mapper, 2);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper, boolean tillTheEnd) {         return concatMapCompletableDelayError(mapper, tillTheEnd, 2);     }'
b'@CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.FULL)     public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper, boolean tillTheEnd, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new FlowableConcatMapCompletable<T>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {         return concatMapDelayError(mapper, 2, true);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper,             int maxConcurrency, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {         return concatMapIterable(mapper, 2);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> concatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         return concatMapMaybe(mapper, 2);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> concatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, int prefetch) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(prefetch, "prefetch");         return RxJavaPlugins.onAssembly(new FlowableConcatMapSingle<T, R>(this, mapper, ErrorMode.IMMEDIATE, prefetch));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> concatMapSingleDelayError(Function<? super T, ? extends SingleSource<? extends R>> mapper) {         return concatMapSingleDelayError(mapper, true, 2);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> concatWith(@NonNull SingleSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableConcatWithSingle<T>(this, other));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> concatWith(@NonNull MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableConcatWithMaybe<T>(this, other));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> concatWith(@NonNull CompletableSource other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableConcatWithCompletable<T>(this, other));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> contains(final Object item) {         ObjectHelper.requireNonNull(item, "item is null");         return any(Functions.equalsWith(item));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Long> count() {         return RxJavaPlugins.onAssembly(new FlowableCountSingle<T>(this));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {         ObjectHelper.requireNonNull(debounceIndicator, "debounceIndicator is null");         return RxJavaPlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {         return delay(delay, unit, Schedulers.computation(), delayError);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {         return delay(delay, unit, scheduler, false);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,             Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {         return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @Deprecated     @SuppressWarnings({ "unchecked", "rawtypes" })     public final <T2> Flowable<T2> dematerialize() {         return RxJavaPlugins.onAssembly(new FlowableDematerialize(this, Functions.identity()));     }'
b'@Experimental     @CheckReturnValue     @NonNull     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     public final <R> Flowable<R> dematerialize(Function<? super T, Notification<R>> selector) {         ObjectHelper.requireNonNull(selector, "selector is null");         return RxJavaPlugins.onAssembly(new FlowableDematerialize<T, R>(this, selector));     }'
b'@SuppressWarnings({ "rawtypes", "unchecked" })     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> distinct() {         return distinct((Function)Functions.identity(), Functions.<T>createHashSet());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {         return distinct(keySelector, Functions.<K>createHashSet());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,             Callable<? extends Collection<? super K>> collectionSupplier) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");         return RxJavaPlugins.onAssembly(new FlowableDistinct<T, K>(this, keySelector, collectionSupplier));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> distinctUntilChanged() {         return distinctUntilChanged(Functions.identity());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {         ObjectHelper.requireNonNull(comparer, "comparer is null");         return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doFinally(Action onFinally) {         ObjectHelper.requireNonNull(onFinally, "onFinally is null");         return RxJavaPlugins.onAssembly(new FlowableDoFinally<T>(this, onFinally));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) {         ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");         return RxJavaPlugins.onAssembly(new FlowableDoAfterNext<T>(this, onAfterNext));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {         return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),                 Functions.EMPTY_ACTION, onAfterTerminate);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnCancel(Action onCancel) {         return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnComplete(Action onComplete) {         return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),                 onComplete, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,             Action onComplete, Action onAfterTerminate) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");         ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");         return RxJavaPlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {         ObjectHelper.requireNonNull(onNotification, "onNotification is null");         return doOnEach(                 Functions.notificationOnNext(onNotification),                 Functions.notificationOnError(onNotification),                 Functions.notificationOnComplete(onNotification),                 Functions.EMPTY_ACTION             );     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {         ObjectHelper.requireNonNull(subscriber, "subscriber is null");         return doOnEach(                 FlowableInternalHelper.subscriberOnNext(subscriber),                 FlowableInternalHelper.subscriberOnError(subscriber),                 FlowableInternalHelper.subscriberOnComplete(subscriber),                 Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {         return doOnEach(Functions.emptyConsumer(), onError,                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnNext(Consumer<? super T> onNext) {         return doOnEach(onNext, Functions.emptyConsumer(),                 Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnRequest(LongConsumer onRequest) {         return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {         return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> doOnTerminate(final Action onTerminate) {         return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),                 onTerminate, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> elementAt(long index) {         if (index < 0) {             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);         }         return RxJavaPlugins.onAssembly(new FlowableElementAtMaybe<T>(this, index));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> elementAtOrError(long index) {         if (index < 0) {             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);         }         return RxJavaPlugins.onAssembly(new FlowableElementAtSingle<T>(this, index, null));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> filter(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new FlowableFilter<T>(this, predicate));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> firstElement() {         return elementAt(0);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> first(T defaultItem) {         return elementAt(0, defaultItem);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> firstOrError() {         return elementAtOrError(0);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,             boolean delayErrors, int maxConcurrency, int bufferSize) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         if (this instanceof ScalarCallable) {             @SuppressWarnings("unchecked")             T v = ((ScalarCallable<T>)this).call();             if (v == null) {                 return empty();             }             return FlowableScalarXMap.scalarXMap(v, mapper);         }         return RxJavaPlugins.onAssembly(new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> flatMap(             Function<? super T, ? extends Publisher<? extends R>> onNextMapper,             Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,             Callable<? extends Publisher<? extends R>> onCompleteSupplier) {         ObjectHelper.requireNonNull(onNextMapper, "onNextMapper is null");         ObjectHelper.requireNonNull(onErrorMapper, "onErrorMapper is null");         ObjectHelper.requireNonNull(onCompleteSupplier, "onCompleteSupplier is null");         return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper,             final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.requireNonNull(combiner, "combiner is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {         return flatMapCompletable(mapper, false, Integer.MAX_VALUE);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors, int maxConcurrency) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         return RxJavaPlugins.onAssembly(new FlowableFlatMapCompletableCompletable<T>(this, mapper, delayErrors, maxConcurrency));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {         return flatMapMaybe(mapper, false, Integer.MAX_VALUE);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper) {         return flatMapSingle(mapper, false, Integer.MAX_VALUE);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");         return RxJavaPlugins.onAssembly(new FlowableFlatMapSingle<T, R>(this, mapper, delayErrors, maxConcurrency));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.NONE)     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable forEach(Consumer<? super T> onNext) {         return subscribe(onNext);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.NONE)     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable forEachWhile(Predicate<? super T> onNext) {         return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.NONE)     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {         return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.NONE)     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,             final Action onComplete) {         ObjectHelper.requireNonNull(onNext, "onNext is null");         ObjectHelper.requireNonNull(onError, "onError is null");         ObjectHelper.requireNonNull(onComplete, "onComplete is null");          ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);         subscribe(s);         return s;     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {         return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,             Function<? super T, ? extends V> valueSelector) {         return groupBy(keySelector, valueSelector, false, bufferSize());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,             Function<? super T, ? extends V> valueSelector,             boolean delayError, int bufferSize) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         ObjectHelper.requireNonNull(valueSelector, "valueSelector is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");          return RxJavaPlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError, null));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> hide() {         return RxJavaPlugins.onAssembly(new FlowableHide<T>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable ignoreElements() {         return RxJavaPlugins.onAssembly(new FlowableIgnoreElementsCompletable<T>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<Boolean> isEmpty() {         return all(Functions.alwaysFalse());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> lastElement() {         return RxJavaPlugins.onAssembly(new FlowableLastMaybe<T>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> lastOrError() {         return RxJavaPlugins.onAssembly(new FlowableLastSingle<T>(this, null));     }'
b'@BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     public final Flowable<T> limit(long count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }         return RxJavaPlugins.onAssembly(new FlowableLimit<T>(this, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<Notification<T>> materialize() {         return RxJavaPlugins.onAssembly(new FlowableMaterialize<T>(this));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> mergeWith(Publisher<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return merge(this, other);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> mergeWith(@NonNull SingleSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableMergeWithSingle<T>(this, other));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> mergeWith(@NonNull MaybeSource<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableMergeWithMaybe<T>(this, other));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> observeOn(Scheduler scheduler) {         return observeOn(scheduler, false, bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> onBackpressureBuffer() {         return onBackpressureBuffer(bufferSize(), false, true);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> onBackpressureBuffer(int capacity) {         return onBackpressureBuffer(capacity, false, false);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> onBackpressureDrop() {         return RxJavaPlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {         ObjectHelper.requireNonNull(onDrop, "onDrop is null");         return RxJavaPlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this, onDrop));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {         ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");         return RxJavaPlugins.onAssembly(new FlowableOnErrorNext<T>(this, resumeFunction, false));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> onTerminateDetach() {         return RxJavaPlugins.onAssembly(new FlowableDetach<T>(this));     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     public final ParallelFlowable<T> parallel() {         return ParallelFlowable.from(this);     }'
b'@BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     @CheckReturnValue     public final ParallelFlowable<T> parallel(int parallelism) {         ObjectHelper.verifyPositive(parallelism, "parallelism");         return ParallelFlowable.from(this, parallelism);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final ConnectableFlowable<T> publish() {         return publish(bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {         return publish(selector, bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final ConnectableFlowable<T> publish(int bufferSize) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return FlowablePublish.create(this, bufferSize);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> rebatchRequests(int n) {         return observeOn(ImmediateThinScheduler.INSTANCE, true, n);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {         ObjectHelper.requireNonNull(reducer, "reducer is null");         return RxJavaPlugins.onAssembly(new FlowableReduceMaybe<T>(this, reducer));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {         ObjectHelper.requireNonNull(seed, "seed is null");         ObjectHelper.requireNonNull(reducer, "reducer is null");         return RxJavaPlugins.onAssembly(new FlowableReduceSeedSingle<T, R>(this, seed, reducer));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {         ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");         ObjectHelper.requireNonNull(reducer, "reducer is null");         return RxJavaPlugins.onAssembly(new FlowableReduceWithSingle<T, R>(this, seedSupplier, reducer));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> repeat() {         return repeat(Long.MAX_VALUE);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> repeat(long times) {         if (times < 0) {             throw new IllegalArgumentException("times >= 0 required but it was " + times);         }         if (times == 0) {             return empty();         }         return RxJavaPlugins.onAssembly(new FlowableRepeat<T>(this, times));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final ConnectableFlowable<T> replay() {         return FlowableReplay.createFrom(this);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {         return replay(selector, bufferSize, time, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {         ObjectHelper.requireNonNull(selector, "selector is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),                 FlowableInternalHelper.replayFunction(selector, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final ConnectableFlowable<T> replay(final int bufferSize) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return FlowableReplay.create(this, bufferSize);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {         return replay(bufferSize, time, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return FlowableReplay.create(this, time, unit, scheduler, bufferSize);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return FlowableReplay.observeOn(replay(bufferSize), scheduler);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> retry() {         return retry(Long.MAX_VALUE, Functions.alwaysTrue());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> retry(long count) {         return retry(count, Functions.alwaysTrue());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> retry(Predicate<? super Throwable> predicate) {         return retry(Long.MAX_VALUE, predicate);     }'
b'@BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final void safeSubscribe(Subscriber<? super T> s) {         ObjectHelper.requireNonNull(s, "s is null");         if (s instanceof SafeSubscriber) {             subscribe((SafeSubscriber<? super T>)s);         } else {             subscribe(new SafeSubscriber<T>(s));         }     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<T> sample(long period, TimeUnit unit) {         return sample(period, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, false));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Flowable<T> sample(Publisher<U> sampler) {         ObjectHelper.requireNonNull(sampler, "sampler is null");         return RxJavaPlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, false));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {         ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");         ObjectHelper.requireNonNull(accumulator, "accumulator is null");         return RxJavaPlugins.onAssembly(new FlowableScanSeed<T, R>(this, seedSupplier, accumulator));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> serialize() {         return RxJavaPlugins.onAssembly(new FlowableSerialized<T>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> share() {         return publish().refCount();     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Maybe<T> singleElement() {         return RxJavaPlugins.onAssembly(new FlowableSingleMaybe<T>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<T> singleOrError() {         return RxJavaPlugins.onAssembly(new FlowableSingleSingle<T>(this, null));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> skip(long count) {         if (count <= 0L) {             return RxJavaPlugins.onAssembly(this);         }         return RxJavaPlugins.onAssembly(new FlowableSkip<T>(this, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> skip(long time, TimeUnit unit) {         return skipUntil(timer(time, unit));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {         return skipUntil(timer(time, unit, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> skipLast(int count) {         if (count < 0) {             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);         }         if (count == 0) {             return RxJavaPlugins.onAssembly(this);         }         return RxJavaPlugins.onAssembly(new FlowableSkipLast<T>(this, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> skipLast(long time, TimeUnit unit) {         return skipLast(time, unit, Schedulers.computation(), false, bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {         return skipLast(time, unit, scheduler, false, bufferSize());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> skipWhile(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new FlowableSkipWhile<T>(this, predicate));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> sorted() {         return toList().toFlowable().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> sorted(Comparator<? super T> sortFunction) {         ObjectHelper.requireNonNull(sortFunction, "sortFunction");         return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> startWith(Iterable<? extends T> items) {         return concatArray(fromIterable(items), this);     }'
b'@SuppressWarnings("unchecked")     @CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> startWithArray(T... items) {         Flowable<T> fromArray = fromArray(items);         if (fromArray == empty()) {             return RxJavaPlugins.onAssembly(this);         }         return concatArray(fromArray, this);     }'
b'@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe() {         return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,                 Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Disposable subscribe(Consumer<? super T> onNext) {         return subscribe(onNext, Functions.ON_ERROR_MISSING,                 Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);     }'
b'@BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public final void subscribe(FlowableSubscriber<? super T> s) {         ObjectHelper.requireNonNull(s, "s is null");         try {             Subscriber<? super T> z = RxJavaPlugins.onSubscribe(this, s);              ObjectHelper.requireNonNull(z, "The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");              subscribeActual(z);         } catch (NullPointerException e) { // NOPMD             throw e;         } catch (Throwable e) {             Exceptions.throwIfFatal(e);             // can\'t call onError because no way to know if a Subscription has been set or not             // can\'t call onSubscribe because the call might have set a Subscription already             RxJavaPlugins.onError(e);              NullPointerException npe = new NullPointerException("Actually not, but can\'t throw other exceptions due to RS");             npe.initCause(e);             throw npe;         }     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {         subscribe(subscriber);         return subscriber;     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, requestOn));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableSwitchIfEmpty<T>(this, other));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Completable switchMapCompletable(@NonNull Function<? super T, ? extends CompletableSource> mapper) {         ObjectHelper.requireNonNull(mapper, "mapper is null");         return RxJavaPlugins.onAssembly(new FlowableSwitchMapCompletable<T>(this, mapper, false));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {         return switchMapDelayError(mapper, bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> take(long count) {         if (count < 0) {             throw new IllegalArgumentException("count >= 0 required but it was " + count);         }         return RxJavaPlugins.onAssembly(new FlowableTake<T>(this, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<T> take(long time, TimeUnit unit) {         return takeUntil(timer(time, unit));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {         return takeUntil(timer(time, unit, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> takeLast(int count) {         if (count < 0) {             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);         } else         if (count == 0) {             return RxJavaPlugins.onAssembly(new FlowableIgnoreElements<T>(this));         } else         if (count == 1) {             return RxJavaPlugins.onAssembly(new FlowableTakeLastOne<T>(this));         }         return RxJavaPlugins.onAssembly(new FlowableTakeLast<T>(this, count));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {         return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         if (count < 0) {             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);         }         return RxJavaPlugins.onAssembly(new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {         return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) {         ObjectHelper.requireNonNull(stopPredicate, "stopPredicate is null");         return RxJavaPlugins.onAssembly(new FlowableTakeUntilPredicate<T>(this, stopPredicate));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U> Flowable<T> takeUntil(Publisher<U> other) {         ObjectHelper.requireNonNull(other, "other is null");         return RxJavaPlugins.onAssembly(new FlowableTakeUntil<T, U>(this, other));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<T> takeWhile(Predicate<? super T> predicate) {         ObjectHelper.requireNonNull(predicate, "predicate is null");         return RxJavaPlugins.onAssembly(new FlowableTakeWhile<T>(this, predicate));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {         return throttleFirst(windowDuration, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {         return sample(intervalDuration, unit);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {         return sample(intervalDuration, unit, scheduler);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {         return debounce(timeout, unit, scheduler);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {         return timeInterval(unit, Schedulers.computation());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.     public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableTimeInterval<T>(this, unit, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {         return timeout0(null, itemTimeoutIndicator, null);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {         return timeout0(timeout, timeUnit, null, Schedulers.computation());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {         return timeout0(timeout, timeUnit, null, scheduler);     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,             Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {         ObjectHelper.requireNonNull(firstTimeoutIndicator, "firstTimeoutIndicator is null");         return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.     public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {         return timestamp(TimeUnit.MILLISECONDS, scheduler);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.SPECIAL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <R> R to(Function<? super Flowable<T>, R> converter) {         try {             return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);         } catch (Throwable ex) {             Exceptions.throwIfFatal(ex);             throw ExceptionHelper.wrapOrThrow(ex);         }     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<List<T>> toList() {         return RxJavaPlugins.onAssembly(new FlowableToListSingle<T, List<T>>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<List<T>> toList(final int capacityHint) {         ObjectHelper.verifyPositive(capacityHint, "capacityHint");         return RxJavaPlugins.onAssembly(new FlowableToListSingle<T, List<T>>(this, Functions.<T>createArrayList(capacityHint)));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U extends Collection<? super T>> Single<U> toList(Callable<U> collectionSupplier) {         ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");         return RxJavaPlugins.onAssembly(new FlowableToListSingle<T, U>(this, collectionSupplier));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final <K, V> Single<Map<K, Collection<V>>> toMultimap(             final Function<? super T, ? extends K> keySelector,             final Function<? super T, ? extends V> valueSelector,             final Callable<? extends Map<K, Collection<V>>> mapSupplier,             final Function<? super K, ? extends Collection<? super V>> collectionFactory) {         ObjectHelper.requireNonNull(keySelector, "keySelector is null");         ObjectHelper.requireNonNull(valueSelector, "valueSelector is null");         ObjectHelper.requireNonNull(mapSupplier, "mapSupplier is null");         ObjectHelper.requireNonNull(collectionFactory, "collectionFactory is null");         return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Observable<T> toObservable() {         return RxJavaPlugins.onAssembly(new ObservableFromPublisher<T>(this));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)     @SchedulerSupport(SchedulerSupport.NONE)     public final Single<List<T>> toSortedList() {         return toSortedList(Functions.naturalComparator());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<T> unsubscribeOn(Scheduler scheduler) {         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableUnsubscribeOn<T>(this, scheduler));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<Flowable<T>> window(long count) {         return window(count, count, bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {         ObjectHelper.verifyPositive(skip, "skip");         ObjectHelper.verifyPositive(count, "count");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new FlowableWindow<T>(this, count, skip, bufferSize));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {         return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.COMPUTATION)     public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,             long count) {         return window(timespan, unit, Schedulers.computation(), count, false);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.CUSTOM)     public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,             Scheduler scheduler) {         return window(timespan, unit, scheduler, Long.MAX_VALUE, false);     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Flowable<Flowable<T>> window(             Publisher<U> openingIndicator,             Function<? super U, ? extends Publisher<V>> closingIndicator) {         return window(openingIndicator, closingIndicator, bufferSize());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, V> Flowable<Flowable<T>> window(             Publisher<U> openingIndicator,             Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {         ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");         ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {         return window(boundaryIndicatorSupplier, bufferSize());     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.ERROR)     @SchedulerSupport(SchedulerSupport.NONE)     public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {         ObjectHelper.requireNonNull(boundaryIndicatorSupplier, "boundaryIndicatorSupplier is null");         ObjectHelper.verifyPositive(bufferSize, "bufferSize");         return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));     }'
b'@CheckReturnValue     @NonNull     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {         ObjectHelper.requireNonNull(other, "other is null");         ObjectHelper.requireNonNull(zipper, "zipper is null");         return RxJavaPlugins.onAssembly(new FlowableZipIterable<T, U, R>(this, other, zipper));     }'
b'@CheckReturnValue     @BackpressureSupport(BackpressureKind.FULL)     @SchedulerSupport(SchedulerSupport.NONE)     public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,             BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {         return zip(this, other, zipper, delayError);     }'
b'@Override     public boolean offer(final T e) {         if (null == e) {             throw new NullPointerException("Null is not a valid element");         }         final LinkedQueueNode<T> nextNode = new LinkedQueueNode<T>(e);         final LinkedQueueNode<T> prevProducerNode = xchgProducerNode(nextNode);         // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed         // and completes the store in prev.next.         prevProducerNode.soNext(nextNode); // StoreStore         return true;     }'
b"@Nullable     @Override     public T poll() {         LinkedQueueNode<T> currConsumerNode = lpConsumerNode(); // don't load twice, it's alright         LinkedQueueNode<T> nextNode = currConsumerNode.lvNext();         if (nextNode != null) {             // we have to null out the value because we are going to hang on to the node             final T nextValue = nextNode.getAndNullValue();             spConsumerNode(nextNode);             return nextValue;         }         else if (currConsumerNode != lvProducerNode()) {             // spin, we are no longer wait free             while ((nextNode = currConsumerNode.lvNext()) == null) { } // NOPMD             // got the next node...              // we have to null out the value because we are going to hang on to the node             final T nextValue = nextNode.getAndNullValue();             spConsumerNode(nextNode);             return nextValue;         }         return null;     }"
b'@NonNull     public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);          ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);          if (parent != null) {             if (!parent.add(sr)) {                 return sr;             }         }          Future<?> f;         try {             if (delayTime <= 0) {                 f = executor.submit((Callable<Object>)sr);             } else {                 f = executor.schedule((Callable<Object>)sr, delayTime, unit);             }             sr.setFuture(f);         } catch (RejectedExecutionException ex) {             if (parent != null) {                 parent.remove(sr);             }             RxJavaPlugins.onError(ex);         }          return sr;     }'
b'public PerfAsyncConsumer await(int count) {         if (count <= 1000) {             while (getCount() != 0) { }         } else {             try {                 await();             } catch (InterruptedException ex) {                 throw new RuntimeException(ex);             }         }         return this;     }'
b'public final void complete(T v) {         int state = get();         for (;;) {             if (state == FUSED_EMPTY) {                 value = v;                 lazySet(FUSED_READY);                  Subscriber<? super T> a = downstream;                 a.onNext(v);                 if (get() != CANCELLED) {                     a.onComplete();                 }                 return;             }              // if state is >= CANCELLED or bit zero is set (*_HAS_VALUE) case, return             if ((state & ~HAS_REQUEST_NO_VALUE) != 0) {                 return;             }              if (state == HAS_REQUEST_NO_VALUE) {                 lazySet(HAS_REQUEST_HAS_VALUE);                 Subscriber<? super T> a = downstream;                 a.onNext(v);                 if (get() != CANCELLED) {                     a.onComplete();                 }                 return;             }             value = v;             if (compareAndSet(NO_REQUEST_NO_VALUE, NO_REQUEST_HAS_VALUE)) {                 return;             }             state = get();             if (state == CANCELLED) {                 value = null;                 return;             }         }     }'
b'@CheckReturnValue     @NonNull     public static <T> BehaviorProcessor<T> createDefault(T defaultValue) {         ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");         return new BehaviorProcessor<T>(defaultValue);     }'
b'public boolean offer(T t) {         if (t == null) {             onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));             return true;         }         BehaviorSubscription<T>[] array = subscribers.get();          for (BehaviorSubscription<T> s : array) {             if (s.isFull()) {                 return false;             }         }          Object o = NotificationLite.next(t);         setCurrent(o);         for (BehaviorSubscription<T> bs : array) {             bs.emitNext(o, index);         }         return true;     }'
b'@Override     protected void subscribeActual(MaybeObserver<? super T> observer) {         source.subscribe(new LastSubscriber<T>(observer));     }'
b'public static void verifyNonBlocking() {         if (RxJavaPlugins.isFailOnNonBlockingScheduler()                 && (Thread.currentThread() instanceof NonBlockingThread                         || RxJavaPlugins.onBeforeBlocking())) {             throw new IllegalStateException("Attempt to block on a Scheduler " + Thread.currentThread().getName() + " that doesn\'t support blocking operators as they may lead to deadlock");         }     }'
b'@NonNull     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     public Flowable<T> refCount() {         return RxJavaPlugins.onAssembly(new FlowableRefCount<T>(this));     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     public final Flowable<T> refCount(int subscriberCount) {         return refCount(subscriberCount, 0, TimeUnit.NANOSECONDS, Schedulers.trampoline());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.COMPUTATION)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     public final Flowable<T> refCount(long timeout, TimeUnit unit) {         return refCount(1, timeout, unit, Schedulers.computation());     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     public final Flowable<T> refCount(long timeout, TimeUnit unit, Scheduler scheduler) {         return refCount(1, timeout, unit, scheduler);     }'
b'@CheckReturnValue     @SchedulerSupport(SchedulerSupport.CUSTOM)     @BackpressureSupport(BackpressureKind.PASS_THROUGH)     public final Flowable<T> refCount(int subscriberCount, long timeout, TimeUnit unit, Scheduler scheduler) {         ObjectHelper.verifyPositive(subscriberCount, "subscriberCount");         ObjectHelper.requireNonNull(unit, "unit is null");         ObjectHelper.requireNonNull(scheduler, "scheduler is null");         return RxJavaPlugins.onAssembly(new FlowableRefCount<T>(this, subscriberCount, timeout, unit, scheduler));     }'
b'@NonNull     public Flowable<T> autoConnect(int numberOfSubscribers, @NonNull Consumer<? super Disposable> connection) {         if (numberOfSubscribers <= 0) {             this.connect(connection);             return RxJavaPlugins.onAssembly(this);         }         return RxJavaPlugins.onAssembly(new FlowableAutoConnect<T>(this, numberOfSubscribers, connection));     }'
b'protected final void request(long n) {         Subscription s = this.upstream;         if (s != null) {             s.request(n);         }     }'
b'public boolean setResource(int index, Disposable resource) {         for (;;) {             Disposable o = get(index);             if (o == DisposableHelper.DISPOSED) {                 resource.dispose();                 return false;             }             if (compareAndSet(index, o, resource)) {                 if (o != null) {                     o.dispose();                 }                 return true;             }         }     }'
b'public Disposable replaceResource(int index, Disposable resource) {         for (;;) {             Disposable o = get(index);             if (o == DisposableHelper.DISPOSED) {                 resource.dispose();                 return null;             }             if (compareAndSet(index, o, resource)) {                 return o;             }         }     }'
b'public final T blockingGet() {         if (getCount() != 0) {             try {                 BlockingHelper.verifyNonBlocking();                 await();             } catch (InterruptedException ex) {                 Subscription s = this.upstream;                 this.upstream = SubscriptionHelper.CANCELLED;                 if (s != null) {                     s.cancel();                 }                 throw ExceptionHelper.wrapOrThrow(ex);             }         }          Throwable e = error;         if (e != null) {             throw ExceptionHelper.wrapOrThrow(e);         }         return value;     }'
b'boolean add(PublishDisposable<T> ps) {         for (;;) {             PublishDisposable<T>[] a = subscribers.get();             if (a == TERMINATED) {                 return false;             }              int n = a.length;             @SuppressWarnings("unchecked")             PublishDisposable<T>[] b = new PublishDisposable[n + 1];             System.arraycopy(a, 0, b, 0, n);             b[n] = ps;              if (subscribers.compareAndSet(a, b)) {                 return true;             }         }     }'
b'@SuppressWarnings("unchecked")     void remove(PublishDisposable<T> ps) {         for (;;) {             PublishDisposable<T>[] a = subscribers.get();             if (a == TERMINATED || a == EMPTY) {                 return;             }              int n = a.length;             int j = -1;             for (int i = 0; i < n; i++) {                 if (a[i] == ps) {                     j = i;                     break;                 }             }              if (j < 0) {                 return;             }              PublishDisposable<T>[] b;              if (n == 1) {                 b = EMPTY;             } else {                 b = new PublishDisposable[n - 1];                 System.arraycopy(a, 0, b, 0, j);                 System.arraycopy(a, j + 1, b, j, n - j - 1);             }             if (subscribers.compareAndSet(a, b)) {                 return;             }         }     }'
b'public static <U, R> Flowable<R> multicastSelector(             final Callable<? extends ConnectableFlowable<U>> connectableFactory,             final Function<? super Flowable<U>, ? extends Publisher<R>> selector) {         return new MulticastFlowable<R, U>(connectableFactory, selector);     }'
b'public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) {         final Flowable<T> flowable = cf.observeOn(scheduler);         return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable));     }'
b'@SuppressWarnings("unchecked")     public static <T> ConnectableFlowable<T> createFrom(Flowable<? extends T> source) {         return create(source, DEFAULT_UNBOUNDED_FACTORY);     }'
b'public static <T> ConnectableFlowable<T> create(Flowable<T> source,             final int bufferSize) {         if (bufferSize == Integer.MAX_VALUE) {             return createFrom(source);         }         return create(source, new ReplayBufferTask<T>(bufferSize));     }'
b'public static <T> ConnectableFlowable<T> create(Flowable<T> source,             long maxAge, TimeUnit unit, Scheduler scheduler) {         return create(source, maxAge, unit, scheduler, Integer.MAX_VALUE);     }'
b'public static <T> ConnectableFlowable<T> create(Flowable<T> source,             final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {         return create(source, new ScheduledReplayBufferTask<T>(bufferSize, maxAge, unit, scheduler));     }'
b'static <T> ConnectableFlowable<T> create(Flowable<T> source,             final Callable<? extends ReplayBuffer<T>> bufferFactory) {         // the current connection to source needs to be shared between the operator and its onSubscribe call         final AtomicReference<ReplaySubscriber<T>> curr = new AtomicReference<ReplaySubscriber<T>>();         Publisher<T> onSubscribe = new ReplayPublisher<T>(curr, bufferFactory);         return RxJavaPlugins.onAssembly(new FlowableReplay<T>(onSubscribe, source, curr, bufferFactory));     }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static MoshiConverterFactory create(Moshi moshi) {     if (moshi == null) throw new NullPointerException("moshi == null");     return new MoshiConverterFactory(moshi, false, false, false);   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {     if (scheduler == null) throw new NullPointerException("scheduler == null");     return new RxJava2CallAdapterFactory(scheduler, false);   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {     if (serializer == null) throw new NullPointerException("serializer == null");     return new SimpleXmlConverterFactory(serializer, false);   }'
b"static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {     if (toResolve == rawType) return context;      // We skip searching through interfaces if unknown is an interface.     if (toResolve.isInterface()) {       Class<?>[] interfaces = rawType.getInterfaces();       for (int i = 0, length = interfaces.length; i < length; i++) {         if (interfaces[i] == toResolve) {           return rawType.getGenericInterfaces()[i];         } else if (toResolve.isAssignableFrom(interfaces[i])) {           return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);         }       }     }      // Check our supertypes.     if (!rawType.isInterface()) {       while (rawType != Object.class) {         Class<?> rawSupertype = rawType.getSuperclass();         if (rawSupertype == toResolve) {           return rawType.getGenericSuperclass();         } else if (toResolve.isAssignableFrom(rawSupertype)) {           return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);         }         rawType = rawSupertype;       }     }      // We can't resolve this further.     return toResolve;   }"
b'public static <T> Call<T> defer(Callable<Call<T>> callable) {     return new DeferredCall<>(callable);   }'
b'@SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.   public <T> T create(final Class<T> service) {     Utils.validateServiceInterface(service);     if (validateEagerly) {       eagerlyValidateMethods(service);     }     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },         new InvocationHandler() {           private final Platform platform = Platform.get();           private final Object[] emptyArgs = new Object[0];            @Override public @Nullable Object invoke(Object proxy, Method method,               @Nullable Object[] args) throws Throwable {             // If the method is a method from Object then defer to normal invocation.             if (method.getDeclaringClass() == Object.class) {               return method.invoke(this, args);             }             if (platform.isDefaultMethod(method)) {               return platform.invokeDefaultMethod(method, service, proxy, args);             }             return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);           }         });   }'
b'public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {     return nextCallAdapter(null, returnType, annotations);   }'
b'public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,       Annotation[] annotations) {     checkNotNull(returnType, "returnType == null");     checkNotNull(annotations, "annotations == null");      int start = callAdapterFactories.indexOf(skipPast) + 1;     for (int i = start, count = callAdapterFactories.size(); i < count; i++) {       CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);       if (adapter != null) {         return adapter;       }     }      StringBuilder builder = new StringBuilder("Could not locate call adapter for ")         .append(returnType)         .append(".\\n");     if (skipPast != null) {       builder.append("  Skipped:");       for (int i = 0; i < start; i++) {         builder.append("\\n   * ").append(callAdapterFactories.get(i).getClass().getName());       }       builder.append(\'\\n\');     }     builder.append("  Tried:");     for (int i = start, count = callAdapterFactories.size(); i < count; i++) {       builder.append("\\n   * ").append(callAdapterFactories.get(i).getClass().getName());     }     throw new IllegalArgumentException(builder.toString());   }'
b'public <T> Converter<T, RequestBody> requestBodyConverter(Type type,       Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {     return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);   }'
b'public <T> Converter<T, RequestBody> nextRequestBodyConverter(       @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,       Annotation[] methodAnnotations) {     checkNotNull(type, "type == null");     checkNotNull(parameterAnnotations, "parameterAnnotations == null");     checkNotNull(methodAnnotations, "methodAnnotations == null");      int start = converterFactories.indexOf(skipPast) + 1;     for (int i = start, count = converterFactories.size(); i < count; i++) {       Converter.Factory factory = converterFactories.get(i);       Converter<?, RequestBody> converter =           factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);       if (converter != null) {         //noinspection unchecked         return (Converter<T, RequestBody>) converter;       }     }      StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")         .append(type)         .append(".\\n");     if (skipPast != null) {       builder.append("  Skipped:");       for (int i = 0; i < start; i++) {         builder.append("\\n   * ").append(converterFactories.get(i).getClass().getName());       }       builder.append(\'\\n\');     }     builder.append("  Tried:");     for (int i = start, count = converterFactories.size(); i < count; i++) {       builder.append("\\n   * ").append(converterFactories.get(i).getClass().getName());     }     throw new IllegalArgumentException(builder.toString());   }'
b'public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {     return nextResponseBodyConverter(null, type, annotations);   }'
b'public <T> Converter<ResponseBody, T> nextResponseBodyConverter(       @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {     checkNotNull(type, "type == null");     checkNotNull(annotations, "annotations == null");      int start = converterFactories.indexOf(skipPast) + 1;     for (int i = start, count = converterFactories.size(); i < count; i++) {       Converter<ResponseBody, ?> converter =           converterFactories.get(i).responseBodyConverter(type, annotations, this);       if (converter != null) {         //noinspection unchecked         return (Converter<ResponseBody, T>) converter;       }     }      StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")         .append(type)         .append(".\\n");     if (skipPast != null) {       builder.append("  Skipped:");       for (int i = 0; i < start; i++) {         builder.append("\\n   * ").append(converterFactories.get(i).getClass().getName());       }       builder.append(\'\\n\');     }     builder.append("  Tried:");     for (int i = start, count = converterFactories.size(); i < count; i++) {       builder.append("\\n   * ").append(converterFactories.get(i).getClass().getName());     }     throw new IllegalArgumentException(builder.toString());   }'
b'public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {     checkNotNull(type, "type == null");     checkNotNull(annotations, "annotations == null");      for (int i = 0, count = converterFactories.size(); i < count; i++) {       Converter<?, String> converter =           converterFactories.get(i).stringConverter(type, annotations, this);       if (converter != null) {         //noinspection unchecked         return (Converter<T, String>) converter;       }     }      // Nothing matched. Resort to default converter which just calls toString().     //noinspection unchecked     return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static JaxbConverterFactory create(JAXBContext context) {     if (context == null) throw new NullPointerException("context == null");     return new JaxbConverterFactory(context);   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static GsonConverterFactory create(Gson gson) {     if (gson == null) throw new NullPointerException("gson == null");     return new GsonConverterFactory(gson);   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {     if (scheduler == null) throw new NullPointerException("scheduler == null");     return new RxJavaCallAdapterFactory(scheduler, false);   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static JacksonConverterFactory create(ObjectMapper mapper) {     if (mapper == null) throw new NullPointerException("mapper == null");     return new JacksonConverterFactory(mapper);   }'
b'static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(       Retrofit retrofit, Method method, RequestFactory requestFactory) {     boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;     boolean continuationWantsResponse = false;     boolean continuationBodyNullable = false;      Annotation[] annotations = method.getAnnotations();     Type adapterType;     if (isKotlinSuspendFunction) {       Type[] parameterTypes = method.getGenericParameterTypes();       Type responseType = Utils.getParameterLowerBound(0,           (ParameterizedType) parameterTypes[parameterTypes.length - 1]);       if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {         // Unwrap the actual body type from Response<T>.         responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);         continuationWantsResponse = true;       } else {         // TODO figure out if type is nullable or not         // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)         // Find the entry for method         // Determine if return type is nullable or not       }        adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);       annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);     } else {       adapterType = method.getGenericReturnType();     }      CallAdapter<ResponseT, ReturnT> callAdapter =         createCallAdapter(retrofit, method, adapterType, annotations);     Type responseType = callAdapter.responseType();     if (responseType == okhttp3.Response.class) {       throw methodError(method, "\'"           + getRawType(responseType).getName()           + "\' is not a valid response body type. Did you mean ResponseBody?");     }     if (responseType == Response.class) {       throw methodError(method, "Response must include generic type (e.g., Response<String>)");     }     // TODO support Unit for Kotlin?     if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {       throw methodError(method, "HEAD method must use Void as response type.");     }      Converter<ResponseBody, ResponseT> responseConverter =         createResponseConverter(retrofit, method, responseType);      okhttp3.Call.Factory callFactory = retrofit.callFactory;     if (!isKotlinSuspendFunction) {       return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);     } else if (continuationWantsResponse) {       //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.       return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,           callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);     } else {       //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.       return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,           callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,           continuationBodyNullable);     }   }'
b'@SuppressWarnings("ConstantConditions") // Guarding public API nullability.   public static NetworkBehavior create(Random random) {     if (random == null) throw new NullPointerException("random == null");     return new NetworkBehavior(random);   }'
